<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<script type="text/javascript">var BOOTSTRAP_VERSION ="lumen";
	var BOOTSTRAP_JS_HEAD =1;
	var BOOTSTRAP_CDN_ENABLE =0; var BOOTSTRAP_NAVBAR_TYPE =0; var BOOTSTRAP_LOGO_OPTION =0; var BOOTSTRAP_NAVBAR =1; var BootstrapInputFix =true;var BootstrapNavbarLineHeightFix =true;var BOOTSTRAP_EDT= 0; </script>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<title>Virus Bulletin :: Dylib hijacking on OS X</title>
<meta name="description" content="DLL hijacking is a well known class of attack which, until now, was believed only to affect Windows. However, in this paper, Patrick Wardle shows that OS X is similarly vulnerable to dynamic library hijack attacks." />
<meta name="generator" content="concrete5 - 5.6.3.5" />
<script type="text/javascript">
var CCM_DISPATCHER_FILENAME = '/index.php';var CCM_CID = 1579;var CCM_EDIT_MODE = false;var CCM_ARRANGE_MODE = false;var CCM_IMAGE_PATH = "/concrete/images";
var CCM_TOOLS_PATH = "/index.php/tools/required";
var CCM_BASE_URL = "https://www.virusbulletin.com";
var CCM_REL = "";

</script>
<link rel="shortcut icon" href="/files/8914/5459/9485/VBIcon.png" type="image/x-icon" />
<link rel="icon" href="/files/8914/5459/9485/VBIcon.png" type="image/x-icon" />
<link rel="stylesheet" type="text/css" href="/concrete/css/ccm.base.css" />
<script type="text/javascript" src="/concrete/js/jquery.js"></script>
<script type="text/javascript" src="/concrete/js/ccm.base.js"></script>
<script type="text/javascript">
var COOKIES_ALLOWED=false;
</script>
<link rel="stylesheet" type="text/css" href="/packages/free_cookies_disclosure/css/cookies_disclosure.css" />
<!--[if lte IE 8]><link rel="stylesheet" type="text/css" href="/packages/free_cookies_disclosure/css/cookies_disclosure_ie.css" /><![endif]-->
<script type="text/javascript">
var COOKIES_DISCLOSURE_HIDE_INTERVAL=10;
</script>
<script type="text/javascript" src="/packages/free_cookies_disclosure/js/disclosure_hide.js"></script>
<link rel="stylesheet" type="text/css" href="/packages/bootstrap/css/lumen/bootstrap.css" />
<link rel="stylesheet" type="text/css" href="/packages/bootstrap/css/lumen/bootstrap-overwrites.css" />
<link rel="stylesheet" type="text/css" href="/packages/bootstrap/css/members.css" />
<script type="text/javascript" src="/packages/bootstrap/js/common/prettify.js"></script>
<script type="text/javascript" src="/packages/bootstrap/js/common/jquery.easing.1.3.js"></script>
<script type="text/javascript" src="/packages/bootstrap/js/common/bootstrap.min.js"></script>
<link rel="stylesheet" type="text/css" href="/libraries/css/jquery.fancybox.css" />
<script type="text/javascript" src="/libraries/js/jquery.fancybox.pack.js"></script>
<link rel="stylesheet" media="screen" type="text/css" href="/files/cache/css/bootstrap/typography.css" />
<script type="text/javascript" src="/index.php/tools/packages/free_cookies_disclosure/disclosure_i18n_js"></script>
<script type="text/javascript" src="/packages/free_cookies_disclosure/js/disclosure_ajax_form.js"></script>
<link rel="stylesheet" type="text/css" href="/concrete/blocks/page_list/view.css" />
<link rel="stylesheet" type="text/css" href="/packages/remo_expand/blocks/remo_expand/templates/vbexpand/view.css" />
<script type="text/javascript" src="/packages/remo_expand/js/jquery.color.js"></script>
<script type="text/javascript" src="/packages/remo_expand/js/jquery.ba-hashchange.js"></script>
<script type="text/javascript" src="/packages/remo_expand/js/remo.expand.js"></script>
<link rel="stylesheet" type="text/css" href="/packages/bootstrap/blocks/search/templates/VB_global_search/view.css" />
<link rel="stylesheet" type="text/css" href="/packages/travisn_spacer/css/ccm.tnspacer.css" />

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">

<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/run_prettify.js" integrity="sha256-1SFdTXlsw0RkQ+iO0E91LDshGiIbPiTYqJto0px4wds=" crossorigin="anonymous"></script>
<!--[if gte IE 9]>
<script src="/packages/bootstrap/js/common/modernizr.js"></script>
<![endif]-->

<!--[if lt IE 9]>	
	
	<script src="/packages/bootstrap/js/common/html5shiv.js"></script>
	<script src="/packages/bootstrap/js/common/respond.min.js"></script>
	
<![endif]-->
</head>
<body data-spy="scroll" data-target=".bs-sidebar">

<div class="navbar  navbar-fixed-top navbar-default  bs-docs-nav">
<div class="navbar-inner">
<div class="container"><div class="row"><div class="col-sm-4 col-md-4 logo-position-1 col-logo">
<div class="navbar-header">
<button type="button" class="navbar-toggle btn_navbar_custom">
<span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</button><div class="mobile-clearfix"></div><div class="navbar-brand navbar-brand-area"><a href="/"><img border="0" class="ccm-image-block" alt="" src="/files/4614/4535/7515/logo-big.png" width="339" height="92" /></a></div> </div>
</div><div class="col-sm-8 col-md-8 logo-position-1 col-nav"> <div class="nav-collapse collapse nav_collapse_custom navbar-collapse"> <div style="clear:both"></div>
<div class="vb-global-search-div">
<form action="/index.php/global-search-results/" method="get">
<fieldset>
<input name="search_paths[]" type="hidden" value="" />
<input name="query" type="text" class="vb-global-search" placeholder="Search site..." />
<input name="submit" type="submit" value="Search!" style="display:none" />
</fieldset>
</form>
</div>
<div class="tnSpacer" style="height:48px"></div>
<ul class="nav nav-pills"><li class=" nav-first nav-item-6299"><a href="/newsletter/" target="_self" class=" nav-first nav-item-6299 ">Newsletter</a></li><li class=" nav-item-260"><a href="/conference/" target="_self" class=" nav-item-260 ">VB Conference</a></li><li class=" nav-item-166"><a href="/testing/" target="_self" class=" nav-item-166 ">VB Testing</a></li><li class=" nav-path-selected active nav-item-160"><a href="/virusbulletin/" target="_self" class=" nav-path-selected active nav-item-160 ">Bulletin</a></li><li class=" nav-last nav-item-130"><a href="/blog/" target="_self" class=" nav-last nav-item-130 ">Blog</a></li></ul> </div>
</div>
</div><div class="clearfix"></div>
</div>
</div>
</div>
<div class="navbar-top-fixed-space "><div class="clearfix"></div></div>

<div class="container m-top-20">
<div class="row">
<div class="col-md-9 col-sm-9 col-lg-9">
<div class="titlepage" xmlns=""><div><div><h1 class="title" xmlns="http://www.w3.org/1999/xhtml"><a id="vb201503-dylib-hijacking"></a>Dylib hijacking on OS X</h1></div><div><p class="pubdate" xmlns="http://www.w3.org/1999/xhtml">2015-03-19</p></div><div><div class="authorgroup" xmlns="http://www.w3.org/1999/xhtml"><div class="author titlepage"><h3 class="author"><span class="firstname">Patrick</span> <span class="surname">Wardle</span></h3><span class="orgname">Synack</span>, <span class="orgdiv">USA</span></div><b class="editedby">Editor: </b><span class="editor"><span class="firstname">Martijn</span> <span class="surname">Grooten</span></span></div></div><div><div class="abstract" xmlns="http://www.w3.org/1999/xhtml"><p class="title"><b>Abstract</b></p><p>DLL hijacking is a well known class of attack which, until now, was believed only to affect Windows. However, in this paper, Patrick Wardle shows that OS X is similarly vulnerable to dynamic library hijack attacks.</p></div></div><div><p class="copyright" xmlns="http://www.w3.org/1999/xhtml"><i>Copyright &copy; 2015 Virus Bulletin</i></p></div></div><hr /></div>
<div class="ccm-remo-expand">
<div id="ccm-remo-expand-title-2175" class="ccm-remo-expand-title ccm-remo-expand-closed" data-expander-speed="200">Table of contents</div><div id="ccm-remo-expand-content-2175" class="ccm-remo-expand-content"><div class="toc"><dl><dt><span class="sect1"><a href="#id3233174"></a></span></dt><dt><span class="sect1"><a href="#id4402343">Background</a></span></dt><dt><span class="sect1"><a href="#id3989575">Dylib hijacking on OS X</a></span></dt><dt><span class="sect1"><a href="#id4577869">Attacks</a></span></dt><dt><span class="sect1"><a href="#id3328549">Defences</a></span></dt><dt><span class="sect1"><a href="#id2621989">Conclusion</a></span></dt></dl></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a class="chapter" id="id3233174"></a></h2></div></div></div><p><span class="emphasis"><em>(This paper was presented at CanSecWest 2015.)</em></span></p><p>DLL hijacking is a well known class of attack which was always believed only to affect the <span class="emphasis"><em>Windows</em></span> OS. However, this paper will show that <span class="emphasis"><em>OS X</em></span> is similarly vulnerable to dynamic library hijacks. By abusing various features and undocumented aspects of <span class="emphasis"><em>OS X</em></span>&rsquo;s dynamic loader, attackers need only to &lsquo;plant&rsquo; specially crafted dynamic libraries to have malicious code automatically loaded into vulnerable applications. Using this method, such attackers can perform a wide range of malicious and subversive actions, including stealthy persistence, load-time process injection, security software circumvention, and a <span class="emphasis"><em>Gatekeeper</em></span> bypass (affording opportunities for remote infection). Since this attack abuses legitimate functionality of the OS, it is challenging to prevent and unlikely to be patched. However, this paper will present techniques and tools that can uncover vulnerable binaries as well as detect if a hijacking has occurred.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a class="chapter" id="id4402343"></a>Background</h2></div></div></div><p>Before detailing the dynamic library (dylib) hijacking attack on <span class="emphasis"><em>OS X</em></span>, dynamic link library (DLL) hijacking on <span class="emphasis"><em>Windows</em></span> will briefly be reviewed. As the two attacks are conceptually quite similar, examining the well-understood <span class="emphasis"><em>Windows</em></span> attack can help in gaining an understanding of the former.</p><p>DLL hijacking on <span class="emphasis"><em>Windows</em></span> is best explained by <span class="emphasis"><em>Microsoft</em></span>:</p><p>&lsquo;When an application dynamically loads a dynamic link library (DLL) without specifying a fully qualified path name, <span class="emphasis"><em>Windows</em></span> tries to locate the DLL by searching a well-defined set of directories. If an attacker gains control of one of the directories, they can force the application to load a malicious copy of the DLL instead of the DLL that it was expecting.&rsquo; [<span class="citation"><a href="#citation.1">1</a></span>]</p><p>To reiterate, the default search behaviour of the <span class="emphasis"><em>Windows</em></span> loader is to search various directories (such as the application&rsquo;s directory or the current working directory) before the <span class="emphasis"><em>Windows</em></span> system directory. This can be problematic if an application attempts to load a system library via an insufficiently qualified path (i.e. just by its name). In such a scenario, an attacker may &lsquo;plant&rsquo; a malicious DLL (the name of which matches that of the legitimate system DLL) in one of the primary search directories. With this malicious DLL in place, the <span class="emphasis"><em>Windows</em></span> loader will find the attacker&rsquo;s library before the legitimate DLL and blindly load it into the context of the vulnerable application.</p><p>This is illustrated in <a href="#figure.1">Figure 1</a> and <a href="#figure.2">Figure 2</a>, where a vulnerable application (<a href="#figure.1">Figure 1</a>) is hijacked by a malicious DLL that has been planted in the primary search directory (<a href="#figure.2">Figure 2</a>).</p><div class="figure"><a id="figure.1"></a><div class="mediaobject"><img alt="Loading the legitimate system DLL." src="/uploads/images/figures/2015/03/Dylib-1.jpg" /></div><p class="title"><b>Figure&nbsp;1.&nbsp;Loading the legitimate system DLL.</b></p></div><div class="figure"><a id="figure.2"></a><div class="mediaobject"><img alt="Loading the attacker&rsquo;s malicious DLL." src="/uploads/images/figures/2015/03/Dylib-2.jpg" /></div><p class="title"><b>Figure&nbsp;2.&nbsp;Loading the attacker&rsquo;s malicious DLL.</b></p></div><p>DLL hijacking attacks initially gained notoriety in 2010 and quickly grabbed the attention of both the media and malicious attackers. Also known as &lsquo;binary planting&rsquo;, &lsquo;insecure library loading&rsquo; or &lsquo;DLL preloading&rsquo;, the discovery of this vulnerability is often attributed to H.D. Moore [<span class="citation"><a href="#citation.2">2</a></span>], [<span class="citation"><a href="#citation.3">3</a></span>]. However, the NSA was actually the first to note this flaw, 12 years prior to Moore, in 1998. In the NSA&rsquo;s unclassified &lsquo;Windows NT Security Guidelines&rsquo;, the organization both describes and warns of DLL hijacking:</p><p>&lsquo;It is important that penetrators can&rsquo;t insert a &ldquo;fake&rdquo; DLL in one of these directories where the search finds it before a legitimate DLL of the same name.&rsquo; [<span class="citation"><a href="#citation.4">4</a></span>]</p><p>To an attacker, DLL hijacking affords many useful scenarios. For example, such attacks can allow a malicious library to stealthily be persisted (without modifying the registry or other components of the OS), privileges to be escalated, and even provides the means for remote infection.</p><p>Malware authors were fairly quick to realize the benefits of DLL hijacking. In a blog post entitled &lsquo;What the fxsst?&rsquo; [<span class="citation"><a href="#citation.5">5</a></span>] , <span class="emphasis"><em>Mandiant</em></span> researchers described how they had uncovered various unrelated malware samples all named &lsquo;fxsst.dll&rsquo;. Upon closer inspection, they found that the samples were all exploiting a DLL hijacking vulnerability in the <span class="emphasis"><em>Windows</em></span> shell (Explorer.exe), that provided a stealthy method of persistence. Specifically, as Explorer.exe was installed in C: \Windows, planting a library named fxsst.dll in the same directory would result in the persistence of the malicious DLL as the loader searched the application&rsquo;s directory before the system directory where the legitimate fxsst.dll lived.</p><p>Another example of malware using a DLL hijack can be found within the leaked source code for the banking trojan &lsquo;Carberp&rsquo; [<span class="citation"><a href="#citation.6">6</a></span>]. The source code shows the malware bypassing User Account Control (UAC) via a DLL hijack of sysprep.exe (see <a href="#figure.3">Figure 3</a>). This binary is an auto-elevated process, meaning that it requires no UAC prompt to gain elevated status. Unfortunately, it was found to be vulnerable to a DLL hijacking attack and would load a maliciously planted DLL (named cryptbase.dll) into its elevated process context [<span class="citation"><a href="#citation.7">7</a></span>].</p><div class="figure"><a id="figure.3"></a><div class="mediaobject"><img alt="Carberp abusing a DLL hijack to bypass UAC." src="/uploads/images/figures/2015/03/Dylib-3.jpg" /></div><p class="title"><b>Figure&nbsp;3.&nbsp;Carberp abusing a DLL hijack to bypass UAC.</b></p></div><p>These days, DLL hijacking on <span class="emphasis"><em>Windows</em></span> is somewhat uncommon. <span class="emphasis"><em>Microsoft</em></span> was swift to respond to attacks, patching vulnerable applications and detailing how others could avoid this issue (i.e. simply by specifying an absolute, or fully qualified path for imported DLLs) [<span class="citation"><a href="#citation.8">8</a></span>]. Moreover, OS level mitigations were introduced, which if enabled via the SafeDllSearchMode and/or CWDIllegalInDllSearch registry keys, stop the majority of DLL hijackings generically.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a class="chapter" id="id3989575"></a>Dylib hijacking on OS X</h2></div></div></div><p>It has always been assumed that dynamic library hijacking was a <span class="emphasis"><em>Windows</em></span>-only problem. However, as one astute <span class="emphasis"><em>StackOverflow</em></span> user pointed out in 2010, &lsquo;any OS which allows for dynamic linking of external libraries is theoretically vulnerable to this&rsquo; [<span class="citation"><a href="#citation.9">9</a></span>]. It took until 2015 for him to be proved correct &ndash; this paper will reveal an equally devastating dynamic library hijack attack affecting <span class="emphasis"><em>OS X</em></span>.</p><p>The goal of the research presented here was to determine whether <span class="emphasis"><em>OS X</em></span> was vulnerable to a dynamic library attack. Specifically, the research sought to answer the question: could an attacker plant a malicious <span class="emphasis"><em>OS X</em></span> dynamic library (dylib) such that the OS&rsquo;s dynamic loader would load it automatically into a vulnerable application? It was hypothesized that, much like DLL hijacking on <span class="emphasis"><em>Windows</em></span>, such an attack on <span class="emphasis"><em>OS X</em></span> would provide an attacker with a myriad of subversive capabilities. For example, stealthy persistence, load-time process injection, security software circumvention, and perhaps even &lsquo;remote&rsquo; infection.</p><p>It should be noted that several constraints were placed upon this undertaking. First, success was constrained by disallowing any modification to the system &ndash; except for the creation of files (and if necessary folders). In other words, the research ignored attack scenarios that required the subverting of existing binaries (e.g. patching) or modifications to existing OS configuration files (e.g. &lsquo;auto-run&rsquo; plists, etc.). As such attacks are well known and trivial both to prevent and to detect, they were ignored. The research also sought a method of hijack that was completely independent of the user&rsquo;s environment. <span class="emphasis"><em>OS X </em></span>provides various legitimate means to control the environment in a manner that could coerce the loader to load malicious libraries automatically into a target process. These methods, such as setting the DYLD_INSERT_LIBRARIES environment variable, are user-specific and, again, well known and easy to detect. As such, they were of little interest and were ignored.</p><p>The research began with an analysis of the <span class="emphasis"><em>OS X </em></span>dynamic linker and loader, dyld. This binary, found within /usr/bin, provides standard loader and linker functionality including finding, loading and linking dynamic libraries.</p><p>As <span class="emphasis"><em>Apple</em></span> has made dyld open source [<span class="citation"><a href="#citation.10">10</a></span>], analysis was fairly straightforward. For example, reading the source code provided a decent understanding of dyld&rsquo;s actions as an executable is loaded and its dependent libraries are loaded and linked in. The following briefly summarizes the initial steps taken by dyld (focusing on those that are relevant to the attack described in this paper):</p><div class="orderedlist"><ol type="1"><li><p>As any new process is started, the kernel sets the user-mode entry point to __dyld_start (dyldStartup.s). This function simply sets up the stack then jumps to dyldbootstrap::start(), which in turn calls the loader&#39;s _main().</p></li><li><p>Dyld&rsquo;s _main() function (dyld.cpp) invokes link(), which then calls an ImageLoader object&rsquo;s link() method to kick off the linking process for the main executable.</p></li><li><p>The ImageLoader class (ImageLoader.cpp) exposes many functions that dyld calls in order to perform various binary image loading logic. For example, the class contains a link() method. When called, this invokes the object&rsquo;s recursiveLoadLibraries() method to perform the loading of all dependent dynamic libraries.</p></li><li><p>The ImageLoader&rsquo;s recursiveLoadLibraries() method determines all required libraries and invokes the context.loadLibrary() function on each. The context object is simply a structure of function pointers that is passed around between methods and functions. The loadLibrary member of this structure is initialized with the libraryLocator() function (dyld.cpp), which simply calls the load() function.</p></li><li><p>The load() function (dyld.cpp) calls various helper functions within the same file, named loadPhase0() through to loadPhase5(). Each function is responsible for handling a specific task of the load process, such as resolving paths or dealing with environment variables that can affect the load process.</p></li><li><p>After loadPhase5(), the loadPhase6() function finally loads (maps) the required dylibs from the file system into memory. It then calls into an instance of the ImageLoaderMachO class in order to perform Mach O specific loading and linking logic on each dylib.</p></li></ol></div><p>With a basic understanding of dyld&rsquo;s initial loading logic, the research turned to hunting for logic that could be abused to perform a dylib hijack. Specifically, the research was interested in code in the loader that didn&rsquo;t error out if a dylib wasn&rsquo;t found, or code that looked for dylibs in multiple locations. If either of these scenarios was realized within the loader, it was hoped that an <span class="emphasis"><em>OS X</em></span> dylib hijack could be performed.</p><p>The initial scenario was investigated first. In this case, it was hypothesized that if the loader could handle situations where a dylib was not found, an attacker (who could identify such situations) could place a malicious dylib in this presumed location. From then on, the loader would now &lsquo;find&rsquo; the planted dylib and blindly load the attacker&rsquo;s malicious code.</p><p>Recall that the loader calls the ImageLoader class&rsquo;s recursiveLoadLibraries() method to both find and load all required libraries. As shown in <a href="#figure.4">Figure 4</a>, the loading code is wrapped in a try/catch block to detect dylibs that fail to load.</p><div class="figure"><a id="figure.4"></a><div class="mediaobject"><img alt="Error logic for dylib load failures." src="/uploads/images/figures/2015/03/Dylib-4.jpg" /></div><p class="title"><b>Figure&nbsp;4.&nbsp;Error logic for dylib load failures.</b></p></div><p>Unsurprisingly, there is logic to throw an exception (with a message) if a library fails to load. Interestingly though, this exception is only thrown if a variable named &lsquo;required&rsquo; is set to true. Moreover, the comment in the source code indicates that failure to load &lsquo;weak&rsquo; libraries is OK. This seems to indicate that some scenario exists where the loader is OK with missing libraries &ndash; perfect!</p><p>Digging deeper into the loader&rsquo;s source code revealed where this &lsquo;required&rsquo; variable is set. Specifically, the doGetDependentLibraries() method of the ImageLoaderMacho class parses the load commands (described below) and sets the variable based on whether or not the load command is of type LC_LOAD_WEAK_DYLIB.</p><div class="figure"><a id="figure.5"></a><div class="mediaobject"><img alt="Setting the &lsquo;required&rsquo; variable (src file?)." src="/uploads/images/figures/2015/03/Dylib-5.jpg" /></div><p class="title"><b>Figure&nbsp;5.&nbsp;Setting the &lsquo;required&rsquo; variable (src file?).</b></p></div><p>Load commands are an integral component of the Mach-O file format (<span class="emphasis"><em>OS X</em></span>&rsquo;s native binary file format). Embedded immediately following the Mach-O header, they provide various commands to the loader. For example, there are load commands to specify the memory layout of the binary, the initial execution state of the main thread, and information about the dependent dynamic libraries for the binary. To view the load commands of a compiled binary, a tool such as MachOView [<span class="citation"><a href="#citation.11">11</a></span>] or /usr/bin/otool (with the -l command-line flag) can be used (see <a href="#figure.6">Figure 6</a>).</p><div class="figure"><a id="figure.6"></a><div class="mediaobject"><img alt="Dumping Calculator.app&rsquo;s load commands with MachOView." src="/uploads/images/figures/2015/03/Dylib-6.jpg" /></div><p class="title"><b>Figure&nbsp;6.&nbsp;Dumping Calculator.app&rsquo;s load commands with MachOView.</b></p></div><p>(Click <a href="/uploads/images/figures/2015/03/Dylib-6-large.jpg" target="_top">here</a> to view a larger version of Figure 6.)</p><p>The code in <a href="#figure.5">Figure 5</a> shows the loader iterating over all the load commands within a binary, looking for those that specify a dylib import. The format of such load commands (e.g. LC_LOAD_DYLIB, LC_LOAD_WEAK_DYLIB, etc.) can be found in the mach-o/loader.h file.</p><div class="figure"><a id="figure.7"></a><div class="mediaobject"><img alt="The format of the LC_LOAD_* load commands." src="/uploads/images/figures/2015/03/Dylib-7.jpg" /></div><p class="title"><b>Figure&nbsp;7.&nbsp;The format of the LC_LOAD_* load commands.</b></p></div><p>For each dylib that an executable was dynamically linked against, it will contain an LC_LOAD_* (LC_LOAD_DYLIB, LC_LOAD_WEAK_DYLIB, etc.) load command. As the loader code in <a href="#figure.4">Figure 4</a> and <a href="#figure.5">Figure 5</a> illustrates, LC_LOAD_DYLIB load commands specify a required dylib, while libraries imported via LC_LOAD_WEAK_DYLIB are optional (i.e. &lsquo;weak&rsquo;). In the case of the former (LC_LOAD_DYLIB), an exception will be thrown if the required dylib is not found, causing the loader to abort and terminate the process. However, in the latter case (LC_LOAD_WEAK_DYLIB), the dylib is optional. If such a &lsquo;weak&rsquo; dylib is not found, no harm is done, and the main binary will still be able to execute.</p><div class="figure"><a id="figure.8"></a><div class="mediaobject"><img alt="Attempting to load a &lsquo;weak&rsquo; dylib (LC_LOAD_WEAK_DYLIB)." src="/uploads/images/figures/2015/03/Dylib-8.jpg" /></div><p class="title"><b>Figure&nbsp;8.&nbsp;Attempting to load a &lsquo;weak&rsquo; dylib (LC_LOAD_WEAK_DYLIB).</b></p></div><p>This loader logic fulfilled the first hypothetical hijack scenario, and as such, provided a dylib hijack attack on <span class="emphasis"><em>OS X</em></span>. Namely, as illustrated in Figure 9, if a binary specifies a weak import that is not found, an attacker can place a malicious dylib in this presumed location. From then on, the loader will &lsquo;find&rsquo; the attacker&rsquo;s dylib and blindly load this malicious code into the process space of the vulnerable binary.</p><div class="figure"><a id="figure.9"></a><div class="mediaobject"><img alt="Hijacking an application via a malicious &lsquo;weak&rsquo; dylib." src="/uploads/images/figures/2015/03/Dylib-9.jpg" /></div><p class="title"><b>Figure&nbsp;9.&nbsp;Hijacking an application via a malicious &lsquo;weak&rsquo; dylib.</b></p></div><p>Recall that another hijack attack was hypothesized if a scenario existed where the loader searched for dynamic libraries in multiple locations. In this case, it was thought that an attacker would be able to place a malicious dylib in one of the primary search directories (if the legitimate dylib was found elsewhere). It was hoped that the loader would then find the attacker&rsquo;s malicious dylib first (before the legitimate one), and thus naively load the attacker&rsquo;s malicious library.</p><p>On <span class="emphasis"><em>OS X</em></span>, load commands such as LC_LOAD_DYLIB always specify a path to the dynamic library (as opposed to <span class="emphasis"><em>Windows</em></span>, where just the name of the library may be provided). Because a path is provided, dyld generally does not need to search various directories to find the dynamic library. Instead, it can simply go directly to the specified directory and load the dylib. However, analysis of dyld&rsquo;s source code uncovered a scenario in which this generality did not hold.</p><p>Looking at the loadPhase3() function in dyld.cpp revealed some interesting logic, as shown in <a href="#figure.10">Figure 10</a>.</p><div class="figure"><a id="figure.10"></a><div class="mediaobject"><img alt="Loading &lsquo;rpath&rsquo;-dependent libraries." src="/uploads/images/figures/2015/03/Dylib-10.jpg" /></div><p class="title"><b>Figure&nbsp;10.&nbsp;Loading &lsquo;rpath&rsquo;-dependent libraries.</b></p></div><p>Dyld will iterate over an rp-&gt;paths vector, dynamically building paths (held within the &lsquo;newPath&rsquo; variable) which are then loaded via the loadPhase4() function. While this does seem to fulfil the requirement of the second hijack scenario (i.e. dyld looking in multiple locations for the same dylib), a closer examination was required.</p><p>The comment on the first line of dyld&rsquo;s source in <a href="#figure.10">Figure 10</a> mentions the term &lsquo;@rpath.&rsquo; According to <span class="emphasis"><em>Apple</em></span> documentation, this is a special loader keyword (introduced in <span class="emphasis"><em>OS X 10.5</em></span>, <span class="emphasis"><em>Leopard</em></span>) that identifies a dynamic library as a &lsquo;run-path-dependent library&rsquo; [<span class="citation"><a href="#citation.12">12</a></span>]. <span class="emphasis"><em>Apple</em></span> explains that a run-path-dependent library &lsquo;is a dependent library whose complete install name (path) is not known when the library is created&rsquo; [<span class="citation"><a href="#citation.12">12</a></span>]. Other online documentation such as [<span class="citation"><a href="#citation.13">13</a></span>] and [<span class="citation"><a href="#citation.14">14</a></span>] provides more detail, describing the role of these libraries and explaining how the @rpath keyword enables: &lsquo;frameworks and dynamic libraries to finally be built only once and be used for both system-wide installation and embedding without changes to their install names, and allowing applications to provide alternate locations for a given library, or even override the location specified for a deeply embedded library&rsquo; [<span class="citation"><a href="#citation.14">14</a></span>].</p><p>While this feature allows software developers to deploy complex applications more easily, it can also be abused to perform a dylib hijack. This is true since in order to make use of run-path-dependent libraries, &lsquo;an executable provides a list of run-path search paths, which the dynamic loader traverses at load time to find the libraries&rsquo; [<span class="citation"><a href="#citation.12">12</a></span>]. This is realized in code in various places within dyld, including the code snippet that was presented in <a href="#figure.10">Figure 10</a>.</p><p>Since run-path-dependent libraries are relatively novel and somewhat unknown, it seemed prudent to provide an example of building both a legitimate run-path-dependent library and a sample application that links against it.</p><p>A run-path-dependent library is a normal dylib whose install name is prefixed with &lsquo;@rpath&rsquo;. To create such a library in Xcode one can simply set the dylib&rsquo;s installation directory to &lsquo;@rpath&rsquo;, as shown in <a href="#figure.11">Figure 11</a>.</p><div class="figure"><a id="figure.11"></a><div class="mediaobject"><img alt="Building a run-path-dependent library." src="/uploads/images/figures/2015/03/Dylib-11.jpg" /></div><p class="title"><b>Figure&nbsp;11.&nbsp;Building a run-path-dependent library.</b></p></div><p>Once the run-path-dependent library was compiled, examination of the LC_ID_DYLIB load command (which contains identifying information about the dylib) showed the run-path of the dylib. Specifically, the &lsquo;name&rsquo; (path) within the LC_ID_DYLIB load command contained the dylib&rsquo;s bundle (rpathLib.framework/ Versions/A/rpathLib), prefixed with the &lsquo;@rpath&rsquo; keyword (see <a href="#figure.12">Figure 12</a>).</p><div class="figure"><a id="figure.12"></a><div class="mediaobject"><img alt="&lsquo;@rpath&rsquo; embedded in the dylib&rsquo;s &lsquo;install name&rsquo; (path)." src="/uploads/images/figures/2015/03/Dylib-12.jpg" /></div><p class="title"><b>Figure&nbsp;12.&nbsp;&lsquo;@rpath&rsquo; embedded in the dylib&rsquo;s &lsquo;install name&rsquo; (path).</b></p></div><p>Building an application that linked against a run-path-dependent library was fairly straightforward as well. First, the run-path-dependent library was added to the &lsquo;Link Binary With Libraries&rsquo; list in Xcode. Then a list of run-path search directories was added to the &lsquo;Runpath Search Paths&rsquo; list. As will be shown, these search directories are traversed by the dynamic loader at load time in order to locate the run path-dependent libraries.</p><div class="figure"><a id="figure.13"></a><div class="mediaobject"><img alt="Linking in a @rpath&rsquo;d dylib and specifying the run path search paths." src="/uploads/images/figures/2015/03/Dylib-13.jpg" /></div><p class="title"><b>Figure&nbsp;13.&nbsp;Linking in a @rpath&rsquo;d dylib and specifying the run path search paths.</b></p></div><p>Once the application was built, dumping its load commands revealed various commands associated with the run-path library dependency. A standard LC_LOAD_DYLIB load command was present for the dependency on the run-path-dependent dylib, as shown in <a href="#figure.14">Figure 14</a>.</p><div class="figure"><a id="figure.14"></a><div class="mediaobject"><img alt="The dependency on the @rpath&rsquo;d dylib." src="/uploads/images/figures/2015/03/Dylib-14.jpg" /></div><p class="title"><b>Figure&nbsp;14.&nbsp;The dependency on the @rpath&rsquo;d dylib.</b></p></div><p>In <a href="#figure.14">Figure 14</a>, note that the install name (i.e. path) to the run path-dependent dylib is prefixed with &lsquo;@rpath&rsquo; and matches the name value from the LC_ID_DYLIB load command of the run-path-dependent dylib (see <a href="#figure.12">Figure 12</a>). This application&rsquo;s embedded LC_LOAD_DYLIB load command with the run-path-dependent dylib tells the loader, &lsquo;I depend on the rpathLib dylib, but when built, I didn&rsquo;t know exactly where it would be installed. Please use my embedded run-path search paths to find it and load it!&rsquo;</p><p>The run-path search paths that were entered into the &lsquo;Runpath Search Paths&rsquo; list in Xcode generated LC_RPATH load commands &ndash; one for each search directory. Dumping the load commands of the compiled application revealed the embedded LC_RPATH load commands, as shown in <a href="#figure.15">Figure 15</a>.</p><div class="figure"><a id="figure.15"></a><div class="mediaobject"><img alt="The embedded run-path search paths (directories)." src="/uploads/images/figures/2015/03/Dylib-15.jpg" /></div><p class="title"><b>Figure&nbsp;15.&nbsp;The embedded run-path search paths (directories).</b></p></div><p>With a practical understanding of run-path-dependent dylibs and an application that linked against one, it was easy to understand dyld&rsquo;s source code which was responsible for handling this scenario at load time.</p><p>When an application is launched, dyld will parse the application&rsquo;s LC_LOAD_* load commands in order to load and link all dependent dylibs. To handle run-path-dependent libraries, dyld performs two distinct steps: it extracts all embedded run-path search paths and then uses this list to find and load all run-path-dependent libraries.</p><p>In order to extract all embedded run-path search paths, dyld invokes the getRPaths() method of the ImageLoader class. This method (invoked by the recursiveLoadLibraries() method) simply parses the application for all LC_RPATH load commands. For each such load command, it extracts the run-path search path and appends it to a vector (i.e. a list), as shown in <a href="#figure.16">Figure 16</a>.</p><div class="figure"><a id="figure.16"></a><div class="mediaobject"><img alt="Extracting and saving all embedded run-path search paths." src="/uploads/images/figures/2015/03/Dylib-16.jpg" /></div><p class="title"><b>Figure&nbsp;16.&nbsp;Extracting and saving all embedded run-path search paths.</b></p></div><p>With a list of all embedded run-path search paths, dyld can now &lsquo;resolve&rsquo; all dependent run-path-dependent libraries. This logic is performed in the loadPhase3() function in dyld.cpp. Specifically, the code (shown in <a href="#figure.17">Figure 17</a>) checks to see if a dependent library&rsquo;s name (path) is prefixed with the &lsquo;@rpath&rsquo; keyword. If so, it iterates over the list of extracted run-path search paths, replacing the &lsquo;@rpath&rsquo; keyword in the import with the current search path. Then it attempts to load the dylib from this newly resolved directory.</p><div class="figure"><a id="figure.17"></a><div class="mediaobject"><img alt="Searching run-path search directories for @rpath&rsquo;d dylibs." src="/uploads/images/figures/2015/03/Dylib-17.jpg" /></div><p class="title"><b>Figure&nbsp;17.&nbsp;Searching run-path search directories for @rpath&rsquo;d dylibs.</b></p></div><p>It is important to note that the order of the directories that dyld searches is deterministic and matches the order of the embedded LC_RPATH load commands. Also, as is shown in the code snippet in <a href="#figure.17">Figure 17</a>, the search continues until the dependent dylib is found or all paths have been exhausted.</p><p><a href="#figure.18">Figure 18</a> illustrates this search conceptually. The loader (dyld) can been seen searching the various embedded run-path search paths in order to find the required run-path-dependent dylib. Note that in this example scenario, the dylib is found in the second (i.e. non-primary) search directory (see <a href="#figure.18">Figure 18</a>).</p><div class="figure"><a id="figure.18"></a><div class="mediaobject"><img alt="Dyld searching multiple run-path search directories." src="/uploads/images/figures/2015/03/Dylib-18.jpg" /></div><p class="title"><b>Figure&nbsp;18.&nbsp;Dyld searching multiple run-path search directories.</b></p></div><p>The astute reader will recognize that this loader logic opens up yet another avenue for a dylib hijack attack. Specifically, if an application is linked against a run-path-dependent library, has multiple embedded run-path search paths, and the run-path-dependent library is not found in a primary search path, an attacker can perform a hijack. Such a hijack may be accomplished simply by &lsquo;planting&rsquo; a malicious dylib into any of the primary run-path search paths. With the malicious dylib in place, any time the application is subsequently run, the loader will find the malicious dylib first, and load it blindly (see <a href="#figure.19">Figure 19</a>).</p><div class="figure"><a id="figure.19"></a><div class="mediaobject"><img alt="Hijacking an application via a malicious &lsquo;@rpath&rsquo; dylib." src="/uploads/images/figures/2015/03/Dylib-19.jpg" /></div><p class="title"><b>Figure&nbsp;19.&nbsp;Hijacking an application via a malicious &lsquo;@rpath&rsquo; dylib.</b></p></div><p>To summarize the findings so far: an <span class="emphasis"><em>OS X</em></span> system is vulnerable to a hijacking attack given the presence of any application that either:</p><div class="itemizedlist"><ul type="disc"><li><p>Contains an LC_LOAD_WEAK_DYLIB load command that references a non-existent dylib.</p></li></ul></div><p>or</p><div class="itemizedlist"><ul type="disc"><li><p>Contains both an LC_LOAD*_DYLIB load command that references a run-path-dependent library (&lsquo;@rpath&rsquo;) and multiple LC_RPATH load commands, with the run-path-dependent library not found in a primary run-path search path.</p></li></ul></div><p>The remainder of this paper will first walk through a complete dylib hijack attack, then present various attack scenarios (persistence, load-time process injection, &lsquo;remote&rsquo; infection etc.), before concluding with some possible defences to counter such an attack.</p><p>In order to assist the reader in gaining a deeper understanding of dylib hijacking, it seems prudent to detail the trials, errors, and ultimate success of a hijack attack. Armed with this knowledge it will be trivial to understand attack automation, attack scenarios, and practical defences.</p><p>Recall the previously described sample application (&lsquo;rPathApp.app&rsquo;) that was created in order to illustrate linking against a run-path-dependent dylib. This application will be the target of the hijack.</p><p>A dylib hijack is only possible against a vulnerable application (that is to say, one that fulfils either of the two previously described hijack conditions). Since the example application (rPathApp.app) links against a run-path-dependent dylib, it may be vulnerable to the second hijack scenario. The simplest way to detect such a vulnerability is to enable debug logging in the loader, then simply run the application from the command line. To enable such logging, set the DYLD_PRINT_RPATHS environment variable. This will cause dyld to log its @rpath expansions and dylib loading attempts. Viewing this output should quickly reveal any vulnerable expansions (i.e. a primary expansion that points to a non-existent dylib), as shown in <a href="#figure.20">Figure 20</a>.</p><div class="figure"><a id="figure.20"></a><div class="mediaobject"><img alt="The vulnerable (test) application, rPathApp." src="/uploads/images/figures/2015/03/Dylib-20.jpg" /></div><p class="title"><b>Figure&nbsp;20.&nbsp;The vulnerable (test) application, rPathApp.</b></p></div><p><a href="#figure.20">Figure 20</a> shows the loader first looking for a required dylib (rpathLib) in a location where it does not exist. As was shown in <a href="#figure.19">Figure 19</a>, in this scenario, an attacker could plant a malicious dylib in this primary run-path search path and the loader will then load it blindly.</p><p>A simple dylib was created to act as a malicious hijacker library. In order to gain automatic execution when loaded, the dylib implemented a constructor function. Such a constructor is executed automatically by the operating system when the dylib is loaded successfully. This is a nice feature to make use of, since generally code within a dylib isn&rsquo;t executed until the main application calls into it via some exported function.</p><div class="figure"><a id="figure.21"></a><div class="mediaobject"><img alt="A dylib&rsquo;s constructor will automatically be executed." src="/uploads/images/figures/2015/03/Dylib-21.jpg" /></div><p class="title"><b>Figure&nbsp;21.&nbsp;A dylib&rsquo;s constructor will automatically be executed.</b></p></div><p>Once compiled, this dylib was renamed to match the target (i.e. legitimate) library: rpathlib. Following this, the necessary directory structure (Library/One/rpathLib.framework/Versions/A/) was created and the &lsquo;malicious&rsquo; dylib was copied in. This ensured that whenever the application was launched, dyld would now find (and load) the hijacker dylib during the search for the run-path-dependent dylib.</p><div class="figure"><a id="figure.22"></a><div class="mediaobject"><img alt="The &lsquo;malicious&rsquo; dylib placed in the primary run-path search path." src="/uploads/images/figures/2015/03/Dylib-22.jpg" /></div><p class="title"><b>Figure&nbsp;22.&nbsp;The &lsquo;malicious&rsquo; dylib placed in the primary run-path search path.</b></p></div><p>Unfortunately, this initial hijack attempt failed and the application crashed miserably, as shown in <a href="#figure.23">Figure 23</a>.</p><div class="figure"><a id="figure.23"></a><div class="mediaobject"><img alt="Success! Then crash and burning." src="/uploads/images/figures/2015/03/Dylib-23.jpg" /></div><p class="title"><b>Figure&nbsp;23.&nbsp;Success! Then crash and burning.</b></p></div><p>The good news, though, was that the loader found and attempted to load the hijacker dylib (see the &lsquo;RPATH successful expansion&hellip;&rsquo; log message in <a href="#figure.23">Figure 23</a>). And although the application crashed, this was preceded by an informative and verbose exception, thrown by dyld. The exception seemed self explanatory: the version of the hijacker dylib was not compatible with the required (or expected) version. Digging into the loader&rsquo;s source code revealed the code that triggered this exception, as shown in <a href="#figure.24">Figure 24</a>.</p><div class="figure"><a id="figure.24"></a><div class="mediaobject"><img alt="Dyld extracting and comparing compatibility version numbers." src="/uploads/images/figures/2015/03/Dylib-24.jpg" /></div><p class="title"><b>Figure&nbsp;24.&nbsp;Dyld extracting and comparing compatibility version numbers.</b></p></div><p>As can be seen, the loader invokes the doGetLibraryInfo() method to extract compatibility and current version numbers from the LC_ID_DYLIB load command of the library that is being loaded. This extracted compatibility version number (&lsquo;minVersion&rsquo;) is then checked against the version that the application requires. If it is too low, an incompatibility exception is thrown.</p><p>It was quite trivial to fix the compatibility issue (and thus prevent the exception) by updating the version numbers in Xcode, and then recompiling, as shown in <a href="#figure.25">Figure 25</a>.</p><div class="figure"><a id="figure.25"></a><div class="mediaobject"><img alt="Setting the compatibility and current version numbers." src="/uploads/images/figures/2015/03/Dylib-25.jpg" /></div><p class="title"><b>Figure&nbsp;25.&nbsp;Setting the compatibility and current version numbers.</b></p></div><p>Dumping the LC_ID_DYLIB load command of the recompiled hijacker dylib confirmed the updated (and now compatible) version numbers, as shown in <a href="#figure.26">Figure 26</a>.</p><div class="figure"><a id="figure.26"></a><div class="mediaobject"><img alt="Embedded compatibility and current version numbers." src="/uploads/images/figures/2015/03/Dylib-26.jpg" /></div><p class="title"><b>Figure&nbsp;26.&nbsp;Embedded compatibility and current version numbers.</b></p></div><p>The updated hijacker dylib was re-copied into the application&rsquo;s primary run-path search directory. Relaunching the vulnerable application again showed the loader &lsquo;finding&rsquo; the hijacker dylib and attempting to load it. Alas, although the dylib was now seen as compatible (i.e. the version number checks passed), a new exception was thrown and the application crashed once again, as shown in <a href="#figure.27">Figure 27</a>.</p><div class="figure"><a id="figure.27"></a><div class="mediaobject"><img alt="&lsquo;Symbol not found&rsquo; exception." src="/uploads/images/figures/2015/03/Dylib-27.jpg" /></div><p class="title"><b>Figure&nbsp;27.&nbsp;&lsquo;Symbol not found&rsquo; exception.</b></p></div><p>Once again, the exception was quite verbose, explaining exactly why the loader threw it, and thus killed the application. Applications link against dependent libraries in order to access functionality (such as functions, objects, etc.) that are exported by the library. Once a required dylib is loaded into memory, the loader will attempt to resolve (via exported symbols) the required functionality that the dependent library is expected to export. If this functionality is not found, linking fails and the loading and linking process is aborted, thus crashing the process.</p><p>There were various ways to ensure that the hijacker dylib exported the correct symbols, such that it would be fully linked in. One naive approach would have been to implement and export code directly within the hijacker dylib to mimic all the exports of the target (legitimate) dylib. While this would probably have succeeded, it seemed complex and dylib specific (i.e. targeting another dylib would have required other exports). A more elegant approach was simply to instruct the linker to look elsewhere for the symbols it required. Of course, that elsewhere was the legitimate dylib. In this scenario, the hijacker dylib would simply acts as a proxy or &lsquo;re-exporter&rsquo; dylib, and as the loader would follow its re-exporting directives, no linker errors would be thrown.</p><div class="figure"><a id="figure.28"></a><div class="mediaobject"><img alt="Re-exporting to the legitimate dylib." src="/uploads/images/figures/2015/03/Dylib-28.jpg" /></div><p class="title"><b>Figure&nbsp;28.&nbsp;Re-exporting to the legitimate dylib.</b></p></div><p>It took some effort to get the re-exportation working seamlessly. The first step was to return to Xcode and add several linker flags to the hijacker dylib project. These flags included &lsquo;-Xlinker&rsquo;, &lsquo;reexport_library&rsquo;, and then the path to the target library which contained the actual exports that the vulnerable application was dependent upon.</p><div class="figure"><a id="figure.29"></a><div class="mediaobject"><img alt="Required linker flags to enable re-exporting." src="/uploads/images/figures/2015/03/Dylib-29.jpg" /></div><p class="title"><b>Figure&nbsp;29.&nbsp;Required linker flags to enable re-exporting.</b></p></div><p>These linker flags generated an embedded LC_REEXPORT_DYLIB load command that contained the path to the target (legitimate) library, as shown in <a href="#figure.30">Figure 30</a>.</p><div class="figure"><a id="figure.30"></a><div class="mediaobject"><img alt="Embedded LC_REEXPORT_DYLIB load command." src="/uploads/images/figures/2015/03/Dylib-30.jpg" /></div><p class="title"><b>Figure&nbsp;30.&nbsp;Embedded LC_REEXPORT_DYLIB load command.</b></p></div><p>However, all was not well. Since the re-export target of the hijacker dylib was a run-path-dependent library, the name field in the embedded LC_REEXPORT_DYLIB (extracted from the legitimate dylib&rsquo;s LC_ID_DYLIB load command) began with &lsquo;@rpath&rsquo;. This was problematic since, unlike LC_LOAD*_DYLIB load commands, dyld does not resolve run-path-dependent paths in LC_REEXPORT_DYLIB load commands. In other words, the loader will try to load &lsquo;@rpath/rpathLib.framework/Versions/A/rpathLib&rsquo; directly from the file system. This, of course, would clearly fail.</p><p>The solution was to resolve the embedded &lsquo;@rpath&rsquo; path, providing the full path of the target library in the LC_REEXPORT_DYLIB load command. This was accomplished with one of Apple&rsquo;s developer tools: install_name_tool. To update the embedded install name (path) in the LC_REEXPORT_DYLIB load command, the tool was executed with the -change flag, the existing name (within the LC_REEXPORT_DYLIB), the new name, and finally the path to the hijacker dylib, as shown in <a href="#figure.31">Figure 31</a>.</p><div class="figure"><a id="figure.31"></a><div class="mediaobject"><img alt="Using install_tool_name to update the embedded name (path)." src="/uploads/images/figures/2015/03/Dylib-31.jpg" /></div><p class="title"><b>Figure&nbsp;31.&nbsp;Using install_tool_name to update the embedded name (path).</b></p></div><p>With the path in the LC_REEXPORT_DYLIB load command updated correctly, the hijacked dylib was re-copied into the application&rsquo;s primary run-path search directory, and then the application was re-executed. As shown in <a href="#figure.32">Figure 32</a>, this finally resulted in success.</p><div class="figure"><a id="figure.32"></a><div class="mediaobject"><img alt="Successfully dylib hijacking a vulnerable application." src="/uploads/images/figures/2015/03/Dylib-32.jpg" /></div><p class="title"><b>Figure&nbsp;32.&nbsp;Successfully dylib hijacking a vulnerable application.</b></p></div><p>To summarize: since the rPathApp application linked against a run-path-dependent library which was not found in the initial run-path search directory, it was vulnerable to a dylib hijack attack. Planting a specially compatible malicious dylib in the initial search path directory caused the loader to load the hijacker dylib blindly each time the application was executed. Since the malicious dylib contained the correct versioning information as well as re-exporting all symbols to the legitimate dylib, all the required symbols were resolved, thus ensuring no functionality within the application was lost or broken.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a class="chapter" id="id4577869"></a>Attacks</h2></div></div></div><p>With a solid understanding of dylib hijacking on <span class="emphasis"><em>OS X </em></span>behind us, it is now time to illustrate some real-life attack scenarios and provide some practical defences.</p><p>Advanced adversaries understand the importance of automating as many components of an attack as possible. Such automation increases scale and efficiency, freeing the attacker to focus on more demanding or complex aspects of the attack.</p><p>The first component of the hijack attack that was automated was the discovery of vulnerable applications. A Python script, dylibHijackScanner.py (available for download at [<span class="citation"><a href="#citation.15">15</a></span>]), was created to accomplish this task. After gathering either a list of running processes or all executables on the file system, the script intelligently parses the binaries&rsquo; Mach-O headers and load commands. To detect binaries that may be hijacked via weak dylibs, the script looks for LC_LOAD_WEAK_DYLIB load commands that reference non-existent dylibs. Automatically detecting binaries that may be hijacked due to non-existent @rpath&rsquo;d imports was a little more complex. First, the script looks for a binary with at least one LC_LOAD*_DYLIB load command that references a run-path-dependent dylib. If such a load command is found, the script continues parsing the binary&rsquo;s load commands looking for multiple LC_RPATHs. In the case that both these prerequisites hold true, the script checks to see whether the run-path-dependent library import is found in a primary run-path search path. If the library does not exist, the script alerts the user that the binary is vulnerable. Executing the scanner script revealed a surprising number of vulnerable applications, including (as expected) the vulnerable test application, rPathApp.app.</p><div class="figure"><a id="figure.33"></a><div class="mediaobject"><img alt="Automatically detecting vulnerable applications." src="/uploads/images/figures/2015/03/Dylib-33.jpg" /></div><p class="title"><b>Figure&nbsp;33.&nbsp;Automatically detecting vulnerable applications.</b></p></div><p>As can be seen in <a href="#figure.33">Figure 33</a>, the scanner script found nearly 150 vulnerable binaries just on the author&rsquo;s work laptop! Interestingly, the majority of vulnerable applications fell into the more complex (from a prerequisite standpoint) &lsquo;multiple rpath&rsquo; category. Due to space constraints, the full list of vulnerable applications cannot be shown here. However, <a href="#table.1">Table 1</a> lists several of the more widespread or well-recognized applications that were found by the scanner script to be vulnerable to a dylib hijack.</p><div class="table"><a id="table.1"></a><table border="1" summary="Common vulnerable applications."><colgroup><col /><col /><col /></colgroup><thead><tr><th align="center">Application</th><th align="center">Company</th><th align="center">Vulnerability</th></tr></thead><tbody><tr><td>iCloud Photos</td><td>Apple</td><td>rpath import</td></tr><tr><td>Xcode</td><td>Apple</td><td>rpath import</td></tr><tr><td>Word</td><td>Microsoft</td><td>rpath &amp; weak import</td></tr><tr><td>Excel</td><td>Microsoft</td><td>rpath &amp; weak import</td></tr><tr><td>Google Drive</td><td>Google</td><td>rpath import</td></tr><tr><td>Java</td><td>Oracle</td><td>rpath import</td></tr><tr><td>GPG Keychain</td><td>GPG Tools</td><td>rpath import</td></tr><tr><td>Dropbox (garcon)</td><td>Dropbox</td><td>rpath import</td></tr></tbody></table><p class="title"><b>Table&nbsp;1.&nbsp;Common vulnerable applications.</b></p></div><p>With an automated capability to uncover vulnerable applications, the next logical step was to automate the creation of compatible hijacker dylibs. Recall that two components of the hijacker dylib had to be customized in order to perform a hijack successfully. First, the hijacker dylib&rsquo;s versioning numbers had to be compatible with the legitimate dylib. Second (in the case of the rpath hijack), the hijacker dylib also had to contain a re-export (LC_REEXPORT_DYLIB) load command that pointed to the legitimate dylib, ensuring that all required symbols were resolvable.</p><p>It was fairly straightforward to automate the customization of a generic dylib to fulfil these two prerequisites. A second Python script, createHijacker.py (also available for download at [<span class="citation"><a href="#citation.15">15</a></span>]), was created to perform this customization. First, the script finds and parses the relevant LC_ID_DYLIB load command within the target dylib (the legitimate dylib which the vulnerable application loads). This allows the necessary compatibility information to be extracted. Armed with this information, the hijacker dylib is similarly parsed, until its LC_ID_DYLIB load command is found. The script then updates the hijacker&rsquo;s LC_ID_DYLIB load command with the extracted compatibility information, thus ensuring a precise compatibility versioning match. Following this, the re-export issue is addressed by updating the hijacker dylib&rsquo;s LC_REEXPORT_DYLIB load command to point to the target dylib. While this could have been achieved by updating the LC_REEXPORT_DYLIB load command manually, it proved far easier simply to execute the install_name_tool command.</p><p><a href="#figure.34">Figure 34</a> shows the Python script automatically configuring a generic hijacker dylib in order to exploit the vulnerable example application, rpathApp.app.</p><div class="figure"><a id="figure.34"></a><div class="mediaobject"><img alt="Automated hijacker creation." src="/uploads/images/figures/2015/03/Dylib-34.jpg" /></div><p class="title"><b>Figure&nbsp;34.&nbsp;Automated hijacker creation.</b></p></div><p>Dylib hijacking can be used to perform a wide range of nefarious actions. This paper covers several of these, including persistence, load-time process injection, bypassing security products, and even a <span class="emphasis"><em>Gatekeeper</em></span> bypass. These attacks, though highly damaging, are all realized simply by planting a malicious dylib which abuses legitimate functionality provided by the OS loader. As such, they are trivial to accomplish yet unlikely to be &lsquo;patched out&rsquo; or even detected by personal security products.</p><p>Using dylib hijacking to achieve stealthy persistence is one of the most advantageous uses of the attack. If a vulnerable application is started automatically whenever the system is rebooted or the user logs in, a local attacker can perform a persistent dylib hijack to gain automatic execution of malicious code. Besides a novel persistence mechanism, this scenario affords the attacker a fairly high level of stealth. First, it simply requires the planting of a single file &ndash; no OS components (e.g. startup configuration files or signed system binaries) are modified. This is important since such components are often monitored by security software or are trivial to verify. Second, the attacker&rsquo;s dylib will be hosted within the context of an existing trusted process, making it difficult to detect as nothing will obviously appear amiss.</p><p>Of course, gaining such stealthy and elegant persistence requires a vulnerable application that is automatically started by the OS. <span class="emphasis"><em>Apple</em></span>&rsquo;s iCloud Photo Stream Agent (/Applications/iPhoto.app/Contents/Library/LoginItems/ PhotoStreamAgent.app) is started automatically whenever a user logs in, in order to sync local content with the cloud. As luck would have it, the application contains multiple run-path search directories and several @rpath imports that are not found in the primary run-path search directory. In other words, it is vulnerable to a dylib hijack attack.</p><div class="figure"><a id="figure.35"></a><div class="mediaobject"><img alt="Apple&rsquo;s vulnerable Photo Stream Agent." src="/uploads/images/figures/2015/03/Dylib-35.jpg" /></div><p class="title"><b>Figure&nbsp;35.&nbsp;Apple&rsquo;s vulnerable Photo Stream Agent.</b></p></div><p>Using the createHijacker.py script, it was trivial to configure a malicious hijacker dylib to ensure compatibility with the target dylib and application. It should be noted that in this case, since the vulnerable import (&lsquo;PhotoFoundation&rsquo;) was found within a framework bundle, the same bundle structure was recreated in the primary run-path search directory (/ Applications/iPhoto.app/Contents/Library/LoginItems/). With the correct bundle layout and malicious hijacker dylib (renamed as &lsquo;PhotoFoundation&rsquo;) placed within the primary run-path search directory, the loader found and loaded the malicious dylib whenever the iCloud Photo Stream Agent was started. Since this application was executed by the OS, the hijacker dylib was stealthily and surreptitiously persisted across reboots.</p><div class="figure"><a id="figure.36"></a><div class="mediaobject"><img alt="Hijacking Apple&rsquo;s Photo Stream Agent for persistence." src="/uploads/images/figures/2015/03/Dylib-36.jpg" /></div><p class="title"><b>Figure&nbsp;36.&nbsp;Hijacking Apple&rsquo;s Photo Stream Agent for persistence.</b></p></div><p>As a final note on persistence, if no vulnerable applications are found to be started automatically by the OS, any vulnerable application commonly started by the user (such as a browser, or mail client) may be targeted as well. Alternatively, a legitimate vulnerable application could easily be made persistent in a variety of ways (for example registering it as a Login Item, etc.), then persistently exploited. Although this latter scenario increases the visibility of the attack, the attacker dylib would, of course, prevent any UI from being displayed. Thus, it&rsquo;s unlikely that the majority of users would notice a legitimate (<span class="emphasis"><em>Apple</em></span>) binary automatically being started (and exploited) in the background.</p><p>Process injection, or coercing an external process into loading a dynamic library, is another useful attack scenario of dylib hijacking. In the context of this paper, &lsquo;injection&rsquo; refers to load-time injection (i.e. whenever the process is started) as opposed to run-time injection. While the latter is arguably more powerful, the former is far simpler and often achieves the same level of damage.</p><p>Using dylib hijacking to coerce an external process into persistently loading a malicious dylib is a powerful and stealthy technique. As with the other dylib hijack attack scenarios, it does not require any modifications to OS components or binaries (e.g. patching the target process&rsquo;s on-disk binary image). Moreover, since the planted dylib will persistently and automatically be loaded into the target process space each time the process is started, an attack no longer needs a separate monitoring component (to detect when the target process is started, then inject a malicious dylib). Also, since the attacker simply requires a malicious hijacker dylib to be planted, it neatly side-steps the complexities of run-time process injection. Finally, as this injection technique abuses legitimate functionality provided by the OS loader, it is unlikely to be detected by personal security products (which often attempt to prevent remote process injection by monitoring &lsquo;inter-process&rsquo; APIs).</p><p>Xcode is <span class="emphasis"><em>Apple</em></span>&#39;s &lsquo;Integrated Development Environment&rsquo; (IDE) application. It is used by developers to write both <span class="emphasis"><em>OS X </em></span>and <span class="emphasis"><em>iOS</em></span> applications. As such, it is a juicy target for an advanced adversary who may wish to inject code into its address space to surreptitiously infect the developer&rsquo;s products (i.e. as a creative autonomous malware propagation mechanism). Xcode and several of its various helper tools and utilities are vulnerable to dylib hijack attacks. Specifically, run-path-dependent dylibs, such as DVTFoundation are not found in Xcode&rsquo;s primary run-path search directories (see <a href="#figure.37">Figure 37</a>).</p><div class="figure"><a id="figure.37"></a><div class="mediaobject"><img alt="Apple&rsquo;s vulnerable IDE, Xcode." src="/uploads/images/figures/2015/03/Dylib-37.jpg" /></div><p class="title"><b>Figure&nbsp;37.&nbsp;Apple&rsquo;s vulnerable IDE, Xcode.</b></p></div><p>The process injection hijack against Xcode was fairly straightforward to complete. First, a hijacker dylib was configured, such that its versioning information was compatible and it re-exported all symbols to the legitimate DVTFoundation. Then, the configured hijacker dylib was copied to /Applications/Xcode.app/Contents/Frameworks/DVTFoundation.framework/Versions/A/ (Frameworks/ being the primary run-path search directory). Now, whenever Xcode was started, the malicious code was automatically loaded as well. Here, it was free to perform actions such as intercepting compile requests and surreptitiously injecting malicious source or binary code into the final products.</p><p>As Ken Thompson noted in his seminal work &lsquo;Reflections on Trusting Trust&rsquo; [<span class="citation"><a href="#citation.16">16</a></span>], when you can&rsquo;t trust the build process or compiler, you can&rsquo;t even trust the code that you create.</p><div class="figure"><a id="figure.38"></a><div class="mediaobject"><img alt="Process &lsquo;injection&rsquo; via dylib hijacking." src="/uploads/images/figures/2015/03/Dylib-38.jpg" /></div><p class="title"><b>Figure&nbsp;38.&nbsp;Process &lsquo;injection&rsquo; via dylib hijacking.</b></p></div><p>Besides persistence and load-time process injection, dylib hijacking can be used to bypass personal security products. Specifically, by leveraging a dylib hijack attack, an attacker can coerce a trusted process into automatically loading malicious code, then perform some previous blocked or &lsquo;alertable&rsquo; action, now without detection.</p><p>Personal security products (PSPs) seek to detect malicious code via signatures, heuristic behavioural analysis, or simply by alerting the user whenever some event occurs. Since dylib hijacking is a novel technique that abuses legitimate functionality, both signature-based and heuristic-based products are trivial to bypass completely. However, security products, such as firewalls, that alert the user about any outgoing connections from an unknown process, pose more of a challenge to an attacker. Dylib hijacking can trivially thwart such products as well.</p><p>Personal firewalls are popular with <span class="emphasis"><em>OS X</em></span> users. They often take a somewhat binary approach, fully trusting outgoing network connections from known processes, while alerting the user to any network activity originating from unknown or untrusted processes. While this is an effective method for detecting basic malware, advanced attackers can trivially bypass these products by exploiting their Achilles heel: trust. As mentioned, generally these products contain default rules, or allow the user to create blanket rules for known, trusted processes (e.g. &lsquo;allow any outgoing connection from process X&rsquo;). While this ensures that legitimate functionality is not broken, if an attacker can introduce malicious code into the context of a trusted process, the code will inherit the process&rsquo;s trust, and thus the fire-wall will allow its outgoing connections.</p><p><span class="emphasis"><em>GPG Tools</em></span> [<span class="citation"><a href="#citation.17">17</a></span>] is a message encryption suite for <span class="emphasis"><em>OS X</em></span> that provides the ability to manage keys, send encrypted mail, or, via plug-ins, enable cryptographic services to arbitrary applications. Unfortunately, its products are susceptible to dylib hijacking.</p><div class="figure"><a id="figure.39"></a><div class="mediaobject"><img alt="GPG Tools&rsquo; vulnerable keychain app." src="/uploads/images/figures/2015/03/Dylib-39.jpg" /></div><p class="title"><b>Figure&nbsp;39.&nbsp;GPG Tools&rsquo; vulnerable keychain app.</b></p></div><p>As <span class="emphasis"><em>GPG Keychain</em></span> requires various Internet functionality (e.g. to look up keys on keyservers), it&rsquo;s likely to have an &lsquo;allow any outgoing connection&rsquo; rule, as shown in <a href="#figure.40">Figure 40</a>.</p><div class="figure"><a id="figure.40"></a><div class="mediaobject"><img alt="Access rule for GPG Keychain." src="/uploads/images/figures/2015/03/Dylib-40.jpg" /></div><p class="title"><b>Figure&nbsp;40.&nbsp;Access rule for GPG Keychain.</b></p></div><p>Using a dylib hijack, an attacker can target the <span class="emphasis"><em>GPG Keychain </em></span>application to load a malicious dylib into its address space. Here, the dylib will inherit the same level of trust as the process, and thus should be able to create outgoing connections without generating an alert. Testing this confirmed that the hijacker dylib was able to access the Internet in an uninhibited manner (see <a href="#figure.41">Figure 41</a>).</p><div class="figure"><a id="figure.41"></a><div class="mediaobject"><img alt="Bypassing a personal firewall (LittleSnitch) via dylib hijacking." src="/uploads/images/figures/2015/03/Dylib-41.jpg" /></div><p class="title"><b>Figure&nbsp;41.&nbsp;Bypassing a personal firewall (LittleSnitch) via dylib hijacking.</b></p></div><p>(Click <a href="/uploads/images/figures/2015/03/Dylib-41-large.jpg" target="_top">here</a> to view a larger version of Figure 41.)</p><p>Defensive-minded individuals may correctly point out that, in this scenario, <span class="emphasis"><em>GPG Keychain</em></span>&rsquo;s firewall rule could be tightened to mitigate this attack, by only allowing outgoing connections to specific remote endpoints (e.g. known key servers). However, there are a myriad of other vulnerable applications that may be hijacked to access the network in a similarly uninhibited manner. Or, in the case of the <span class="emphasis"><em>Little Snitch</em></span> firewall, the inclusion of a system-level undeletable firewall rule allowing any connection from any process to talk to iCloud.com endpoints is more than enough for a full bypass (i.e. using a remote <span class="emphasis"><em>iCloud iDrive</em></span> as a C&amp;C server).</p><p>So far, the dylib attack scenarios described here have all been local. While they are powerful, elegant and stealthy, they all require existing access to a user&rsquo;s computer. However, dylib hijacking can also be abused by a remote attacker in order to facilitate gaining initial access to a remote computer.</p><p>There are a variety of ways to infect <span class="emphasis"><em>Mac</em></span> computers, but the simplest and most reliable is to deliver malicious content directly to end target(s). The &lsquo;low-tech&rsquo; way is to coerce the user into downloading and installing the malicious content manually. Attackers creatively employ a range of techniques to accomplish this, such as providing &lsquo;required&rsquo; plug-ins (to view content), fake updates or patches, fake security tools (&lsquo;rogue&rsquo; AV products), or even infected torrents.</p><div class="figure"><a id="figure.42"></a><div class="mediaobject"><img alt="Masked malicious content." src="/uploads/images/figures/2015/03/Dylib-42.jpg" /></div><p class="title"><b>Figure&nbsp;42.&nbsp;Masked malicious content.</b></p></div><p>If the user is tricked into downloading and running any of this malicious content, they could become infected. While &lsquo;low tech&rsquo;, the success of such techniques should not be underestimated. In fact, when a rogue security program (Mac Defender) was distributed by such means, hundreds of thousands of <span class="emphasis"><em>OS X </em></span>users were infected, with over 60,000 alone contacting <span class="emphasis"><em>AppleCare</em></span> in order to resolve the issue [<span class="citation"><a href="#citation.18">18</a></span>].</p><p>Relying on trickery to infect a remote target will probably not work against more computer-savvy individuals. A more reliable (though far more advanced) technique relies on man-in-the-middling users&rsquo; connections as they download legitimate software. Due to the constraints of the <span class="emphasis"><em>Mac App Store</em></span>, most software is still delivered via developer or company websites. If such software is downloaded via insecure connections (e.g. over HTTP), an attacker with the necessary level of network access may be able to infect the download in transit. When the user then runs the software, they will become infected, as shown in <a href="#figure.43">Figure 43</a>.</p><div class="figure"><a id="figure.43"></a><div class="mediaobject"><img alt="Man-in-the-middling a software download." src="/uploads/images/figures/2015/03/Dylib-43.jpg" /></div><p class="title"><b>Figure&nbsp;43.&nbsp;Man-in-the-middling a software download.</b></p></div><p>Readers may be thinking, &lsquo;hey, it&rsquo;s 2015, most software should be downloaded via secure channels, right?&rsquo; Unfortunately, even today, the majority of third-party <span class="emphasis"><em>OS X</em></span> software is distributed insecurely. For example, of the software found installed in the author&rsquo;s dock, 66% was distributed insecurely.</p><div class="figure"><a id="figure.44"></a><div class="mediaobject"><img alt="Software (in the author&rsquo;s dock) that was distributed over HTTP." src="/uploads/images/figures/2015/03/Dylib-44.jpg" /></div><p class="title"><b>Figure&nbsp;44.&nbsp;Software (in the author&rsquo;s dock) that was distributed over HTTP.</b></p></div><p>Moreover, further research uncovered that all major third-party <span class="emphasis"><em>OS X </em></span>security products were similarly distributed insecurely (see <a href="#figure.45">Figure 45</a>).</p><div class="figure"><a id="figure.45"></a><div class="mediaobject"><img alt="Insecure downloads of major OS X security products." src="/uploads/images/figures/2015/03/Dylib-45.jpg" /></div><p class="title"><b>Figure&nbsp;45.&nbsp;Insecure downloads of major OS X security products.</b></p></div><p><span class="emphasis"><em>Apple</em></span> is well aware of these risks, and since version <span class="emphasis"><em>OS X Lion </em></span>(10.7.5), <span class="emphasis"><em>Mac</em></span> computers have shipped with a built-in security product, named <span class="emphasis"><em>Gatekeeper</em></span>, that is designed to counter these attack vectors directly.</p><p>The concept of <span class="emphasis"><em>Gatekeeper</em></span> is simple, yet highly effective: block any untrusted software from executing. Behind the scenes, things are a little more complex, but for the purposes of this discussion, a higher-level overview suffices. When any executable content is downloaded, it is tagged with a &lsquo;quarantined&rsquo; attribute. The first time such content is set to run, <span class="emphasis"><em>Gatekeeper</em></span> verifies the software. Depending on the user&rsquo;s settings, if the software is not signed with a known <span class="emphasis"><em>Apple</em></span> developer ID (default), or from the <span class="emphasis"><em>Mac App Store</em></span>, <span class="emphasis"><em>Gatekeeper</em></span> will disallow the application from executing.</p><div class="figure"><a id="figure.46"></a><div class="mediaobject"><img alt="Gatekeeper in action." src="/uploads/images/figures/2015/03/Dylib-46.jpg" /></div><p class="title"><b>Figure&nbsp;46.&nbsp;Gatekeeper in action.</b></p></div><p>With <span class="emphasis"><em>Gatekeeper</em></span> automatically installed and enabled on all modern versions of <span class="emphasis"><em>OS X</em></span>, tricking users into installing malicious software or infecting insecure downloads (which will break digital signatures) is essentially fully mitigated. (Of course, an attacker could attempt to obtain a valid <span class="emphasis"><em>Apple</em></span> developer certificate, then sign their malicious software. However, <span class="emphasis"><em>Apple</em></span> is fairly cautious about handing out such certificates, and moreover, has an effective certificate revocation process that can block certificates if any abuse is discovered. Also, if <span class="emphasis"><em>Gatekeeper</em></span> is set to only allow software from the <span class="emphasis"><em>Mac App Store</em></span>, this abuse scenario is impossible.)</p><p>Unfortunately, by abusing a dylib hijack, an attacker can bypass <span class="emphasis"><em>Gatekeeper</em></span> to run unsigned malicious code &ndash; even if the user&rsquo;s settings only allow <span class="emphasis"><em>Apple</em></span>-signed code from the <span class="emphasis"><em>Mac App Store</em></span>. This (re)opens the previously discussed attack vectors and puts <span class="emphasis"><em>OS X</em></span> users at risk once again.</p><p>Conceptually, bypassing <span class="emphasis"><em>Gatekeeper</em></span> via dylib hijacking is straightforward. While <span class="emphasis"><em>Gatekeeper</em></span> fully validates the contents of software packages that are being executed (e.g. everything in an application bundle), it does not verify &lsquo;external&rsquo; components.</p><div class="figure"><a id="figure.47"></a><div class="mediaobject"><img alt="Theoretical dmg/zip that would bypass Gatekeeper." src="/uploads/images/figures/2015/03/Dylib-47.jpg" /></div><p class="title"><b>Figure&nbsp;47.&nbsp;Theoretical dmg/zip that would bypass Gatekeeper.</b></p></div><p>Normally this isn&rsquo;t a problem &ndash; why would a downloaded (legitimate) application ever load relatively external code? (Hint: relative, yet external content.)</p><p>As <span class="emphasis"><em>Gatekeeper</em></span> only verifies internal content, if an <span class="emphasis"><em>Apple</em></span>-signed or <span class="emphasis"><em>Mac App Store</em></span> application contains a relative external reference to a hijackable dylib, an attacker can bypass <span class="emphasis"><em>Gatekeeper</em></span>. Specifically, the attacker can create (or infect in transit) a .dmg or .zip file with the necessary folder structure to contain the malicious dylib in the externally referenced relative location. When the legitimate application is executed by the unsuspecting user, <span class="emphasis"><em>Gatekeeper</em></span> will verify the application bundle then (as it is trusted, and unmodified) allow it to execute. During the loading process, the dylib hijack will be triggered and the externally referenced malicious dylib will be loaded &ndash; even if <span class="emphasis"><em>Gatekeeper</em></span> is set to only allow code from the <span class="emphasis"><em>Mac App Store</em></span>!</p><p>Finding a vulnerable application that fulfils the necessary prerequisites was fairly easy. Instruments.app is an <span class="emphasis"><em>Apple</em></span>-signed &lsquo;<span class="emphasis"><em>Gatekeeper</em></span> approved&rsquo; application that expects to be installed within a sub-directory of Xcode.app. As such, it contains relative references to dylibs outside of its application bundle; dylibs that can be hijacked.</p><div class="figure"><a id="figure.48"></a><div class="mediaobject"><img alt="Apple&rsquo;s vulnerable Instruments app." src="/uploads/images/figures/2015/03/Dylib-48.jpg" /></div><p class="title"><b>Figure&nbsp;48.&nbsp;Apple&rsquo;s vulnerable Instruments app.</b></p></div><p>With a vulnerable trusted application, a malicious .dmg image was created that would trigger the Gatekeeper bypass. First, the Instruments.app was placed into the image. Then an external directory structure was created that contained the malicious dylib (CoreSimulator.framework/Versions/A/CoreSimulator).</p><div class="figure"><a id="figure.49"></a><div class="mediaobject"><img alt="Malicious .dmg image." src="/uploads/images/figures/2015/03/Dylib-49.jpg" /></div><p class="title"><b>Figure&nbsp;49.&nbsp;Malicious .dmg image.</b></p></div><p>To make the malicious .dmg more &lsquo;believable&rsquo;, the external files were set to hidden, a top level alias (with a custom icon) was created to point to Instruments.app, the background was changed, and the entire image was made read-only (so that it would automatically be displayed when double-clicked). The final product is shown in <a href="#figure.50">Figure 50</a>.</p><div class="figure"><a id="figure.50"></a><div class="mediaobject"><img alt="The finalized malicious .dmg image." src="/uploads/images/figures/2015/03/Dylib-50.jpg" /></div><p class="title"><b>Figure&nbsp;50.&nbsp;The finalized malicious .dmg image.</b></p></div><p>This malicious (though seemingly benign) .dmg file was then &lsquo;deployed&rsquo; (uploaded to a public URL) for testing purposes. When downloaded via <span class="emphasis"><em>Safari</em></span> and then executed, <span class="emphasis"><em>Gatekeeper</em></span>&rsquo;s standard &lsquo;this is downloaded from the Internet&rsquo; message window was initially shown. It is important to note that this alert is shown for any content downloaded from the Internet, and thus is not unusual.</p><p>Once this message window was dismissed, the malicious code was surreptitiously loaded along with the legitimate application. This, of course, should not have been allowed as <span class="emphasis"><em>Gatekeeper</em></span>&rsquo;s settings were at the maximum (only allow apps from the <span class="emphasis"><em>Mac App Store</em></span>) (see <a href="#figure.51">Figure 51</a>).</p><div class="figure"><a id="figure.51"></a><div class="mediaobject"><img alt="Bypassing Gatekeeper via a dylib hijack." src="/uploads/images/figures/2015/03/Dylib-51.jpg" /></div><p class="title"><b>Figure&nbsp;51.&nbsp;Bypassing Gatekeeper via a dylib hijack.</b></p></div><p>(Click <a href="/uploads/images/figures/2015/03/Dylib-51-large.jpg" target="_top">here</a> to view a larger version of Figure 51.)</p><p>As the malicious dylib was loaded and executed before the application&rsquo;s main method, the dylib could ensure that nothing appeared out of the ordinary. For example, in this case where the malicious .dmg masquerades as a Flash installer, the dylib can suppress Instruments.app&rsquo;s UI, and instead spawn a legitimate Flash installer.</p><p>With the ability to bypass <span class="emphasis"><em>Gatekeeper</em></span> and load unsigned malicious code, attackers can return to their old habits of tricking users into installing fake patches, updates or installers, fake AV products, or executing infected pirated applications. Worse yet, advanced adversaries with networking-level capabilities (who can intercept insecure connections) can now arbitrarily infect legitimate software downloads. Neither have to worry <span class="emphasis"><em>Gatekeeper</em></span> any more.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a class="chapter" id="id3328549"></a>Defences</h2></div></div></div><p>Dylib hijacking is a powerful new attack class against <span class="emphasis"><em>OS X</em></span>, that affords both local and remote attackers a wide range of malicious attack scenarios. Unfortunately, despite being contacted multiple times, <span class="emphasis"><em>Apple</em></span> has shown no interest in addressing any of the issues described in this paper. Granted, there appears to be no easy fix for the core issue of dylib hijacking as it abuses the legitimate functionality of the OS. However, it is the opinion of the author that <span class="emphasis"><em>Gatekeeper</em></span> should certainly be fixed in order to prevent unsigned malicious code from executing.</p><p>Users may wonder what they can do to protect themselves. First, until <span class="emphasis"><em>Gatekeeper</em></span> is fixed, downloading untrusted, or even legitimate software via insecure channels (e.g. via the Internet over HTTP) is not advised. Refraining from this will ensure that remote attackers will be unable to gain initial access to one&rsquo;s computer via the attack vector described in this paper. Due to the novelty of dylib hijacking on <span class="emphasis"><em>OS X</em></span>, it is unlikely (though not impossible) that attackers or <span class="emphasis"><em>OS X</em></span> malware are currently abusing such attacks locally. However, it can&rsquo;t hurt to be sure!</p><p>To detect local hijacks, as well as to reveal vulnerable applications, the author created a new application named <span class="emphasis"><em>Dynamic Hijack Scanner</em></span> (or <span class="emphasis"><em>DHS</em></span>). <span class="emphasis"><em>DHS</em></span> attempts to uncover hijackers and vulnerable targets by scanning all running processes of the entire file-system. The application can be downloaded from objective-see.com.</p><div class="figure"><a id="figure.52"></a><div class="mediaobject"><img alt="Objective-see&rsquo;s DHS scanner." src="/uploads/images/figures/2015/03/Dylib-52.jpg" /></div><p class="title"><b>Figure&nbsp;52.&nbsp;Objective-see&rsquo;s DHS scanner.</b></p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a class="chapter" id="id2621989"></a>Conclusion</h2></div></div></div><p>DLL hijacking is a well known attack class that affects the <span class="emphasis"><em>Windows</em></span> OS. Until now, <span class="emphasis"><em>OS X </em></span>was assumed to be immune to such attacks. This paper countered that assumption, illustrating a similar <span class="emphasis"><em>OS X </em></span>attack, dubbed &lsquo;dylib hijacking&rsquo;. By abusing weak or run-path-dependent imports, found within countless <span class="emphasis"><em>Apple</em></span> and third-party applications, this attack class opens up a multitude of attack scenarios to both local and remote attackers. From stealthy local persistence to a <span class="emphasis"><em>Gatekeeper</em></span> bypass that provides avenues for remote infections, dylib hijacking is likely to become a powerful weapon in the arsenal of <span class="emphasis"><em>OS X</em></span> attackers. And while <span class="emphasis"><em>Apple</em></span> appears apathetic toward this novel attack, secure software downloads and tools such as <span class="emphasis"><em>DHS</em></span> can ensure that OS X users remain secure... for now.</p><div class="bibliography"><div class="titlepage"><div><div><h3 class="title"><a class="chapter" id="id2208341"></a>Bibliography</h3></div></div></div><div class="bibliomixed"><a id="citation.1"></a><p class="bibliomixed">[1] Secure loading of libraries to prevent DLL preloading attacks. <span class="bibliosource"><a href="http://blogs.technet.com/cfs-file.ashx/__key/CommunityServer-Components-PostAttachments/00-03-35-14-21/Secure-loading-of-libraries-to-prevent-DLL-Preloading.docx" target="_blank">http://blogs.technet.com/cfs-file.ashx/__key/CommunityServer-Components-PostAttachments/00-03-35-14-21/Secure-loading-of-libraries-to-prevent-DLL-Preloading.docx</a></span>.</p></div><div class="bibliomixed"><a id="citation.2"></a><p class="bibliomixed">[2] DLL hijacking. <span class="bibliosource"><a href="https://en.wikipedia.org/wiki/Dynamic-link_library#DLL_hijacking" target="_blank">http://en.wikipedia.org/wiki/Dynamic-link_library#DLL_hijacking</a></span>.</p></div><div class="bibliomixed"><a id="citation.3"></a><p class="bibliomixed">[3] Dynamic-Link Library Hijacking. <span class="bibliosource"><a href="https://www.exploit-db.com/wp-content/themes/exploit/docs/31687.pdf" target="_blank">http://www.exploit-db.com/wp-content/themes/exploit/docs/31687.pdf</a></span>.</p></div><div class="bibliomixed"><a id="citation.4"></a><p class="bibliomixed">[4] Windows NT Security Guidelines. <span class="bibliosource"><a href="https://www.autistici.org/loa/pasky/NSAGuideV2.PDF" target="_blank">http://www.autistici.org/loa/pasky/NSAGuideV2.PDF</a></span>.</p></div><div class="bibliomixed"><a id="citation.5"></a><p class="bibliomixed">[5] What the fxsst? <span class="bibliosource"><a href="https://www.mandiant.com/blog/fxsst/" target="_blank">https://www.mandiant.com/blog/fxsst/</a></span>.</p></div><div class="bibliomixed"><a id="citation.6"></a><p class="bibliomixed">[6] Leaked Carberp source code. <span class="bibliosource"><a href="https://github.com/hzeroo/Carberp" target="_blank">https://github.com/hzeroo/Carberp</a></span>.</p></div><div class="bibliomixed"><a id="citation.7"></a><p class="bibliomixed">[7] Windows 7 UAC whitelist: Proof-of-concept source code. <span class="bibliosource"><a href="http://www.pretentiousname.com/misc/W7E_Source/win7_uac_poc_details.html" target="_blank">http://www.pretentiousname.com/misc/W7E_Source/win7_uac_poc_details.html</a></span>.</p></div><div class="bibliomixed"><a id="citation.8"></a><p class="bibliomixed">[8] Microsoft Security Advisory 2269637; Insecure Library Loading Could Allow Remote Code Execution. <span class="bibliosource"><a href="https://technet.microsoft.com/en-us/library/security/2269637.aspx" target="_blank">https://technet.microsoft.com/en-us/library/security/2269637.aspx</a></span>.</p></div><div class="bibliomixed"><a id="citation.9"></a><p class="bibliomixed">[9] What is dll hijacking? <span class="bibliosource"><a href="https://stackoverflow.com/a/3623571/3854841" target="_blank">http://stackoverflow.com/a/3623571/3854841</a></span>.</p></div><div class="bibliomixed"><a id="citation.10"></a><p class="bibliomixed">[10] OS X loader (dyld) source code. <span class="bibliosource"><a href="https://www.opensource.apple.com/source/dyld" target="_blank">http://www.opensource.apple.com/source/dyld</a></span>.</p></div><div class="bibliomixed"><a id="citation.11"></a><p class="bibliomixed">[11] MachOView. <span class="bibliosource"><a href="https://sourceforge.net/projects/machoview/" target="_blank">http://sourceforge.net/projects/machoview/</a></span>.</p></div><div class="bibliomixed"><a id="citation.12"></a><p class="bibliomixed">[12] Run-Path Dependent Libraries. <span class="bibliosource"><a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/RunpathDependentLibraries.html" target="_blank">https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/RunpathDependentLibraries.html</a></span>.</p></div><div class="bibliomixed"><a id="citation.13"></a><p class="bibliomixed">[13] Using @rpath: Why and How. <span class="bibliosource"><a href="http://www.dribin.org/dave/blog/archives/2009/11/15/rpath/" target="_blank">http://www.dribin.org/dave/blog/archives/2009/11/15/rpath/</a></span>.</p></div><div class="bibliomixed"><a id="citation.14"></a><p class="bibliomixed">[14] Friday Q&amp;A 2012-11-09: dyld: Dynamic Linking On OS X. <span class="bibliosource"><a href="https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html" target="_blank">https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html</a></span>.</p></div><div class="bibliomixed"><a id="citation.15"></a><p class="bibliomixed">[15] dylibHijackScanner.py &amp; createHijacker.py. <span class="bibliosource"><a href="https://github.com/synack/" target="_blank">https://github.com/synack/</a></span>.</p></div><div class="bibliomixed"><a id="citation.16"></a><p class="bibliomixed">[16] Reflections on Trusting Trust. <span class="bibliosource"><a href="http://cm.bell-labs.com/who/ken/trust.html" target="_blank">http://cm.bell-labs.com/who/ken/trust.html</a></span>.</p></div><div class="bibliomixed"><a id="citation.17"></a><p class="bibliomixed">[17] GPG Tools. <span class="bibliosource"><a href="https://gpgtools.org/" target="_blank">https://gpgtools.org/</a></span>.</p></div><div class="bibliomixed"><a id="citation.18"></a><p class="bibliomixed">[18] Apple support to infected Mac users: &lsquo;You cannot show the customer how to stop the process&rsquo;. <span class="bibliosource"><a href="https://nakedsecurity.sophos.com/2011/05/24/apple-support-to-infected-mac-users-you-cannot-show-the-customer-how-to-stop-the-process" target="_blank">https://nakedsecurity.sophos.com/2011/05/24/apple-support-to-infected-mac-users-you-cannot-show-the-customer-how-to-stop-the-process</a></span>.</p></div></div></div> </div>
<div class="col-md-3 col-sm-3 col-lg-3">
<p><a href="/uploads/pdf/magazine/2015/vb201503-dylib-hijacking.pdf" target="_blank"><img class="ccm-image-block responsive" alt="" src="/uploads/images/buttons/pdf-download-button.jpg" onmouseover="this.src = '/uploads/images/buttons/pdf-download-button-hover.jpg'" onmouseout="this.src = '/uploads/images/buttons/pdf-download-button.jpg'" border="0" height="45" width="262"></a></p>
<div id="NDPHPBlock13359" class="NDPHPBlock">
<div style="width: 100%;"><div style='float: left; width: 20%; margin-left: auto; margin-right: auto; text-align: center;'><center><a target='_blank' title='Tweet this!' href="https://twitter.com/share?text=Dylib hijacking on OS X&url=https://www.virusbulletin.com/virusbulletin/2015/03/dylib-hijacking-os-x"><img src='/uploads/images/buttons/twitter.png' alt='twitter.png' width='45' height='45' class='responsive' /></a></center></div><div style='float: left; width: 20%; margin-left: auto; margin-right: auto; text-align: center;'><center><a target='_blank' title='Share on Facebook' href='https://www.facebook.com/sharer.php?u=https://www.virusbulletin.com/virusbulletin/2015/03/dylib-hijacking-os-x'><img src='/uploads/images/buttons/fb.png' alt='fb.png' width='45' height='45' class='responsive' /></a></center></div><div style='float: left; width: 20%; margin-left: auto; margin-right: auto; text-align: center;'><center><a target='_blank' title='Share on LinkedIn' href="https://www.linkedin.com/shareArticle?mini=true&url=https://www.virusbulletin.com/virusbulletin/2015/03/dylib-hijacking-os-x&title=Dylib hijacking on OS X"><img src='/uploads/images/buttons/linkedin.png' alt='linkedin.png' width='45' height='45' class='responsive' /></a></center></div><div style='float: left; width: 20%; margin-left: auto; margin-right: auto; text-align: center;'><center><a target='_blank' title='Share on Hacker News' href="https://news.ycombinator.com/submitlink?u=https://www.virusbulletin.com/virusbulletin/2015/03/dylib-hijacking-os-x&t=Dylib hijacking on OS X"><img src='/uploads/images/buttons/hackernews.png' alt='hackernews.png' width='45' height='45' class='responsive' /></a></center></div><div style='float: left; width: 20%; margin-left: auto; margin-right: auto; text-align: center;'><center><a target='_blank' title='reddit this!' href="https://www.reddit.com/submit?url=https://www.virusbulletin.com/virusbulletin/2015/03/dylib-hijacking-os-x"><img src='/uploads/images/buttons/reddit.png' alt='reddit.png' width='45' height='45' class='responsive' /></a></center></div></div></div><p> </p>
<h2>Latest articles:</h2>
<div class="ccm-page-list">
<h3 class="ccm-page-list-title">
<a href="/virusbulletin/2022/04/cryptojacking-fly-teamtnt-using-nvidia-drivers-mine-cryptocurrency/" target="_self">Cryptojacking on the fly: TeamTNT using NVIDIA drivers to mine cryptocurrency</a>
</h3>
<div class="ccm-page-list-description">
TeamTNT is known for attacking insecure and vulnerable Kubernetes deployments in order to infiltrate organizations&rsquo; dedicated environments and transform them into attack launchpads. In this article Aditya Sood presents a new module introduced by&hellip; </div>
<h3 class="ccm-page-list-title">
<a href="/virusbulletin/2021/12/collector-stealer-russian-origin-credential-and-information-extractor/" target="_self">Collector-stealer: a Russian origin credential and information extractor</a>
</h3>
<div class="ccm-page-list-description">
Collector-stealer, a piece of malware of Russian origin, is heavily used on the Internet to exfiltrate sensitive data from end-user systems and store it in its C&amp;C panels. In this article, researchers Aditya K Sood and Rohit Chaturvedi present a 360&hellip; </div>
<h3 class="ccm-page-list-title">
<a href="/virusbulletin/2021/06/fighting-fire-fire/" target="_self">Fighting Fire with Fire</a>
</h3>
<div class="ccm-page-list-description">
In 1989, Joe Wells encountered his first virus: Jerusalem. He disassembled the virus, and from that moment onward, was intrigued by the properties of these small pieces of self-replicating code. Joe Wells was an expert on computer viruses, was partly&hellip; </div>
<h3 class="ccm-page-list-title">
<a href="/virusbulletin/2021/04/run-your-malicious-vba-macros-anywhere/" target="_self">Run your malicious VBA macros anywhere!</a>
</h3>
<div class="ccm-page-list-description">
Kurt Natvig wanted to understand whether it&rsquo;s possible to recompile VBA macros to another language, which could then easily be &lsquo;run&rsquo; on any gateway, thus revealing a sample&rsquo;s true nature in a safe manner. In this article he explains how he recompiled&hellip; </div>
<h3 class="ccm-page-list-title">
<a href="/virusbulletin/2021/04/dissecting-design-and-vulnerabilities-azorultccpanels/" target="_self">Dissecting the design and vulnerabilities in AZORult&nbsp;C&amp;C&nbsp;panels</a>
</h3>
<div class="ccm-page-list-description">
Aditya K Sood looks at the command-and-control (C&amp;C) design of the AZORult malware, discussing his team's findings related to the C&amp;C design and some security issues they identified during the research. </div>
</div>
<p><br /><a class="btn btn-block btn-warning" href="/virusbulletin/archive">Bulletin Archive</a></p> </div>
</div>
</div>

<footer class="bs-footer" role="contentinfo">
<div class="container">
<div class="bs-social">
<div class="row ">
<div class="col-md-3">
<p><a title="About Us" href="/about-vb/about-us/">About us</a></p>
<p><a title="Contact Us" href="/about-vb/contact-us/">Contact us</a></p>
<p><a title="Advisory Board" href="/about-vb/advisory-board/">Advisory board</a></p>
<p><a title="Press" href="/about-vb/press/">Press information</a></p>
<p><a title="Security Events Calendar" href="/resources/calendar/">Security events calendar</a></p>
<p><a title="Newsletter" href="/newsletter/">Virus Bulletin newsletter</a></p> </div>
<div class="col-md-3">
<p><a title="VB Testing" href="/testing/">Testing</a></p>
<p><a title="VB100" href="/testing/vb1001/">VB100</a></p>
<p><a title="VBSpam" href="/testing/vbspam/">VBSpam</a></p>
<p><a title="VBWeb" href="/testing/vbweb/">VBWeb</a></p>
<p><a title="Consultancy Services" href="/testing/consultancy-services/">Consultancy services</a></p>
<p><a title="The Spammers' Compendium" href="/resources/spammerscompendium/">Spammers' Compendium</a></p> </div>
<div class="col-md-3">
<p><a title="VB2021 localhost" href="/conference/vb2021/">VB2021 localhost</a></p>
<p><a title="VB2020 localhost" href="/conference/vb2020/">VB2020 localhost</a></p>
<p><a title="VB2019" href="/conference/vb2019/">VB2019 (London)</a></p>
<p><a title="VB2018" href="/conference/vb2018">VB2018 (Montreal)</a></p>
<p><a title="VB2017" href="/conference/vb2017">VB2017 (Madrid)</a></p>
<p><a title="Conference Archive" href="/conference/vb-conference-archive/">Older conferences</a></p> </div>
<div class="col-md-3">
<div class="row">
<table style="float: right;" border="0">
<tbody>
<tr>
<td align="center"><a href="/rss" target="_blank"><img title="Get our blog updates" src="/uploads/images/buttons/rss-square-gray.png" alt="rss.png" width="35" height="35" /></a></td>
<td> </td>
<td align="center"><a href="https://twitter.com/virusbtn" target="_blank"><img class="bhtmbxoyxwpzahwcvxnw" title="Visit us on Twitter" src="/uploads/images/buttons/twitter-square-gray.png" alt="twitter.png" width="35" height="35" /></a></td>
<td> </td>
<td align="center"><a href="https://www.linkedin.com/company/virus-bulletin" target="_blank"><img class="bhtmbxoyxwpzahwcvxnw" title="Visit us on LinkedIn" src="/uploads/images/buttons/linkedin-square-gray.png" alt="linkedin.png" width="35" height="35" /></a></td>
<td> </td>
<td align="center"><a href="https://www.facebook.com/virusbulletin" target="_blank"><img title="Visit us on Facebook" src="/uploads/images/buttons/fb-square-gray.png" alt="twitter.png" width="35" height="35" /></a></td>
<td> </td>
<td align="center"><a href="https://www.youtube.com/user/virusbtn" target="_blank"><img title="Visit us on Youtube" src="/uploads/images/buttons/youtube-square-gray.png" alt="youtube.png" width="35" height="35" /></a></td>
</tr>
</tbody>
</table>
</div> </div>
</div>
<div class="row ">
<div class="col-md-12">
</div>
</div>
</div>
</div>
</footer>

<footer class="bs-footer2" role="contentinfo">
<div class="container">
<div class="bs-social2">
<div class="row ">
<div class="col-md-3">
</div>
<div class="col-md-3">
</div>
<div class="col-md-3">
</div>
<div class="col-md-3">
</div>
</div>
<div class="row ">
<div class="col-md-12">
<p style="text-align: left;">©1989-2022 Virus Bulletin.        <a title="Privacy Policy" href="/about-vb/privacy-policy/">Privacy policy</a>        <a title="Cookies" href="/about-vb/privacy-policy/cookies/">Cookies</a>        <a title="Terms and Conditions" href="/about-vb/terms-and-conditions/">Terms and Conditions</a></p> </div>
</div>
</div>
</div>
</footer>

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-21876594-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-21876594-2', { 'anonymize_ip': true });
</script><script type="text/javascript" src="/libraries/js/fancybox.load.js"></script>
<script type="text/javascript" src="/packages/bootstrap/js/common/app.js"></script>
<div id="ccm-cookiesDisclosure" class="disclosure-bottom">
<div class="disclosure-container">
<div class="disclosure-content">
<p> We have placed cookies on your device in order to improve the functionality of this site, as outlined in our <a href="/about-vb/privacy-policy/cookies" target="_blank">cookies policy</a>. However, you may delete and block all cookies from this site and your use of the site will be unaffected. By continuing to browse this site, you are agreeing to Virus Bulletin's use of data as outlined in our <a href="/about-vb/privacy-policy/" target="_blank">privacy policy</a>.</p>
</div>
<div class="disclosure-form">
<form action="/index.php/cookies_disclosure/" method="POST">
<input type="hidden" name="allowCookies" value="1" />
<div class="button">
<input class="btn btn-info btn-sm" type="submit" name="submit" value="I understand. Don't show this message again!" />
</div>
</form>
</div>
<div class="ccm-spacer">&nbsp;</div>
</div>
</div>
</body>
</html>