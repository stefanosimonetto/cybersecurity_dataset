IDAPython â€“ making strings decompiler-friendly
December 21, 2015 in IDA/Hex-Rays, Malware Analysis, Reversing, Software Releases

Update
As pointed out by 0stracon there is an option in Hexrays that actually enables it to print all strings. Go to Hex-Rays Decompiler Analysis Options and untick â€˜Print only constant string literalsâ€™.
To make it permanent, enable it in hexrays.cfg:
#define HO_CONST_STRINGSÂ Â  0x0040Â Â  // Only print string literals if they reside
// in read-only memory (e.g. .rodata segment).
// When off, all strings are printed as literals.
// You can override decompiler's decision by
// adding 'const' or 'volatile' to the
// string variable's type declaration
HEXOPTIONS               = 0x....   // Combination of HO_... bits
I was not aware of this option and reinvented the wheel ğŸ™‚
Old post
One of the features of IDA is its ability to recognize strings. This is a great feature, especially useful when you combine it with a power of HexRays decompiler â€“ together they can produce a very nice pseudocode.
There is only one annoying bit there: if strings are recognized and defined inside a writable segment, they will not be presented by the decompiler as strings, but as variable names referring to strings.
Letâ€™s have a look at the example.
In the below example (Dexter sample) IDA recognizes the string â€œUpdateMutex:â€
When we now switch to the decompiler view, we will see that the decompiler changes it to s__Updatemutex:

(the â€˜s__â€™ prefix comes from the string prefix I typically use i.e. â€˜s->â€™ which decompiler â€˜flattensâ€™ to â€˜s__â€™). The s__Updatemutex refers to a string as shown below i.e. â€œUpdateMutex:â€ :
Obviously, aÂ  decompiled code that refers to the actual string is much more readable â€“ see the same piece of code as shown above where data is referred to by actual strings:
In order to make the decompiler use these actual strings (not the reference) we have two options:

Make the segment where the string is recognized read-only (by disabling â€˜Writeâ€™ in segment properties):

Unfortunately, this will confuse the decompiler and will make the output not trustworthy (it is often truncated). You will also receive a friendly reminder that you are doing something stupid ğŸ˜‰ a.k.a. a red card from the decompilerâ€™s authors:

The second option is to use a â€˜properâ€™ method of fixing the issue by telling the IDA that the string is a read-only a.k.a. constant i.e. you can change the type of the string from existing one to the one prefixed with a keyword â€˜constâ€™:

Since most of the time strings are static it is handy to convert all the strings in IDA to read-only i.e. retyping all of them using the â€˜constâ€™ trick.
This is exactly what the strings_to_const.py script is intended to do.
It enumerates all segments, finds all strings recognized by IDA (note the comment about the prefix I use, you may need to adapt it to your needs), and then converts them to read-only.
The result?
See below â€“ before and after:

Comments Off on IDAPython â€“ making strings decompiler-friendly

Comments are closed.
