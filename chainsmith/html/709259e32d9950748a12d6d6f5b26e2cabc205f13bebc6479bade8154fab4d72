<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<script type="text/javascript">var BOOTSTRAP_VERSION ="lumen";
	var BOOTSTRAP_JS_HEAD =1;
	var BOOTSTRAP_CDN_ENABLE =0; var BOOTSTRAP_NAVBAR_TYPE =0; var BOOTSTRAP_LOGO_OPTION =0; var BOOTSTRAP_NAVBAR =1; var BootstrapInputFix =true;var BootstrapNavbarLineHeightFix =true;var BOOTSTRAP_EDT= 0; </script>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<title>Virus Bulletin :: Shellcoding ARM: part 2</title>
<meta name="description" content="In the first part of this series Aleksander Czarnowski covered the background information needed to understand the principles of ARM shellcoding. In this follow-up article he moves on to dissect some previously crafted shellcode." />
<meta name="generator" content="concrete5 - 5.6.3.5" />
<script type="text/javascript">
var CCM_DISPATCHER_FILENAME = '/index.php';var CCM_CID = 1790;var CCM_EDIT_MODE = false;var CCM_ARRANGE_MODE = false;var CCM_IMAGE_PATH = "/concrete/images";
var CCM_TOOLS_PATH = "/index.php/tools/required";
var CCM_BASE_URL = "https://www.virusbulletin.com";
var CCM_REL = "";

</script>
<link rel="shortcut icon" href="/files/8914/5459/9485/VBIcon.png" type="image/x-icon" />
<link rel="icon" href="/files/8914/5459/9485/VBIcon.png" type="image/x-icon" />
<link rel="stylesheet" type="text/css" href="/concrete/css/ccm.base.css" />
<script type="text/javascript" src="/concrete/js/jquery.js"></script>
<script type="text/javascript" src="/concrete/js/ccm.base.js"></script>
<script type="text/javascript">
var COOKIES_ALLOWED=false;
</script>
<link rel="stylesheet" type="text/css" href="/packages/free_cookies_disclosure/css/cookies_disclosure.css" />
<!--[if lte IE 8]><link rel="stylesheet" type="text/css" href="/packages/free_cookies_disclosure/css/cookies_disclosure_ie.css" /><![endif]-->
<script type="text/javascript">
var COOKIES_DISCLOSURE_HIDE_INTERVAL=10;
</script>
<script type="text/javascript" src="/packages/free_cookies_disclosure/js/disclosure_hide.js"></script>
<link rel="stylesheet" type="text/css" href="/packages/bootstrap/css/lumen/bootstrap.css" />
<link rel="stylesheet" type="text/css" href="/packages/bootstrap/css/lumen/bootstrap-overwrites.css" />
<link rel="stylesheet" type="text/css" href="/packages/bootstrap/css/members.css" />
<script type="text/javascript" src="/packages/bootstrap/js/common/prettify.js"></script>
<script type="text/javascript" src="/packages/bootstrap/js/common/jquery.easing.1.3.js"></script>
<script type="text/javascript" src="/packages/bootstrap/js/common/bootstrap.min.js"></script>
<link rel="stylesheet" type="text/css" href="/libraries/css/jquery.fancybox.css" />
<script type="text/javascript" src="/libraries/js/jquery.fancybox.pack.js"></script>
<link rel="stylesheet" media="screen" type="text/css" href="/files/cache/css/bootstrap/typography.css" />
<script type="text/javascript" src="/index.php/tools/packages/free_cookies_disclosure/disclosure_i18n_js"></script>
<script type="text/javascript" src="/packages/free_cookies_disclosure/js/disclosure_ajax_form.js"></script>
<link rel="stylesheet" type="text/css" href="/concrete/blocks/page_list/view.css" />
<link rel="stylesheet" type="text/css" href="/packages/remo_expand/blocks/remo_expand/templates/vbexpand/view.css" />
<script type="text/javascript" src="/packages/remo_expand/js/jquery.color.js"></script>
<script type="text/javascript" src="/packages/remo_expand/js/jquery.ba-hashchange.js"></script>
<script type="text/javascript" src="/packages/remo_expand/js/remo.expand.js"></script>
<link rel="stylesheet" type="text/css" href="/packages/bootstrap/blocks/search/templates/VB_global_search/view.css" />
<link rel="stylesheet" type="text/css" href="/packages/travisn_spacer/css/ccm.tnspacer.css" />

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">

<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/run_prettify.js" integrity="sha256-1SFdTXlsw0RkQ+iO0E91LDshGiIbPiTYqJto0px4wds=" crossorigin="anonymous"></script>
<!--[if gte IE 9]>
<script src="/packages/bootstrap/js/common/modernizr.js"></script>
<![endif]-->

<!--[if lt IE 9]>	
	
	<script src="/packages/bootstrap/js/common/html5shiv.js"></script>
	<script src="/packages/bootstrap/js/common/respond.min.js"></script>
	
<![endif]-->
</head>
<body data-spy="scroll" data-target=".bs-sidebar">

<div class="navbar  navbar-fixed-top navbar-default  bs-docs-nav">
<div class="navbar-inner">
<div class="container"><div class="row"><div class="col-sm-4 col-md-4 logo-position-1 col-logo">
<div class="navbar-header">
<button type="button" class="navbar-toggle btn_navbar_custom">
<span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</button><div class="mobile-clearfix"></div><div class="navbar-brand navbar-brand-area"><a href="/"><img border="0" class="ccm-image-block" alt="" src="/files/4614/4535/7515/logo-big.png" width="339" height="92" /></a></div> </div>
</div><div class="col-sm-8 col-md-8 logo-position-1 col-nav"> <div class="nav-collapse collapse nav_collapse_custom navbar-collapse"> <div style="clear:both"></div>
<div class="vb-global-search-div">
<form action="/index.php/global-search-results/" method="get">
<fieldset>
<input name="search_paths[]" type="hidden" value="" />
<input name="query" type="text" class="vb-global-search" placeholder="Search site..." />
<input name="submit" type="submit" value="Search!" style="display:none" />
</fieldset>
</form>
</div>
<div class="tnSpacer" style="height:48px"></div>
<ul class="nav nav-pills"><li class=" nav-first nav-item-6299"><a href="/newsletter/" target="_self" class=" nav-first nav-item-6299 ">Newsletter</a></li><li class=" nav-item-260"><a href="/conference/" target="_self" class=" nav-item-260 ">VB Conference</a></li><li class=" nav-item-166"><a href="/testing/" target="_self" class=" nav-item-166 ">VB Testing</a></li><li class=" nav-path-selected active nav-item-160"><a href="/virusbulletin/" target="_self" class=" nav-path-selected active nav-item-160 ">Bulletin</a></li><li class=" nav-last nav-item-130"><a href="/blog/" target="_self" class=" nav-last nav-item-130 ">Blog</a></li></ul> </div>
</div>
</div><div class="clearfix"></div>
</div>
</div>
</div>
<div class="navbar-top-fixed-space "><div class="clearfix"></div></div>

<div class="container m-top-20">
<div class="row">
<div class="col-md-9 col-sm-9 col-lg-9">
<div class="titlepage" xmlns=""><div><div><h1 class="title" xmlns="http://www.w3.org/1999/xhtml"><a id="vb201303-shellcoding-ARM"></a>Shellcoding ARM: part 2</h1></div><div><p class="pubdate" xmlns="http://www.w3.org/1999/xhtml">2013-03-04</p></div><div><div class="authorgroup" xmlns="http://www.w3.org/1999/xhtml"><div class="author titlepage"><h3 class="author"><span class="surname">Aleksander P. Czarnowski</span></h3><span class="orgname">AVET Information and Network Security</span>, <span class="orgdiv">Poland</span></div><b class="editedby">Editor: </b><span class="editor"><span class="firstname">Helen</span> <span class="surname">Martin</span></span></div></div><div><div class="abstract" xmlns="http://www.w3.org/1999/xhtml"><p class="title"><b>Abstract</b></p><p>In the first part of this series Aleksander Czarnowski covered the background information needed to understand the principles of ARM shellcoding. In this follow-up article he moves on to dissect some previously crafted shellcode.</p></div></div><div><p class="copyright" xmlns="http://www.w3.org/1999/xhtml"><i>Copyright &copy; 2013 Virus Bulletin</i></p></div></div><hr /></div>
<div class="ccm-remo-expand">
<div id="ccm-remo-expand-title-2819" class="ccm-remo-expand-title ccm-remo-expand-closed" data-expander-speed="200">Table of contents</div><div id="ccm-remo-expand-content-2819" class="ccm-remo-expand-content"><div class="toc"><dl><dt><span class="sect1"><a href="#id4936660"></a></span></dt><dt><span class="sect1"><a href="#id4394117">The GetPC problem</a></span></dt><dt><span class="sect1"><a href="#id3859184">API calling conventions</a></span></dt><dt><span class="sect1"><a href="#id2802455">A simple construction to avoid NULL bytes</a></span></dt><dt><span class="sect1"><a href="#id2857240">Testing our shellcode on a real target</a></span></dt><dt><span class="sect1"><a href="#id2615637">Analysing shellcode with IDA Pro</a></span></dt><dt><span class="sect1"><a href="#id2802280">Dumping the shellcode from the executable</a></span></dt><dt><span class="sect1"><a href="#id4884151">Summary</a></span></dt></dl></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a class="chapter" id="id4936660"></a></h2></div></div></div><p>In the first part of this series [<span class="citation"><a href="#citation.1">1</a></span>] we discussed the basic background information needed to understand the principles of ARM shellcoding. In this follow-up article we will dissect some previously crafted shellcode.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a class="chapter" id="id4394117"></a>The GetPC problem</h2></div></div></div><p>The shellcode techniques we&rsquo;ve discussed so far have a couple of requirements:</p><div class="itemizedlist"><ul type="disc"><li><p>The code must be position independent (PIC).</p></li><li><p>The shellcode data (such as parameters for syscalls) must be positioned at the end of the code section.</p></li></ul></div><p>This raises the issue of how to determine the Program Counter (PC) value. This value can be used to calculate the offset to the shellcode data and other crucial areas such as encrypted code (this will be discussed in more detail in the next article). </p><p><a href="#figure.1">Figure 1</a> shows the most basic shellcode layouts: </p><div class="figure"><a id="figure.1"></a><div class="mediaobject"><img alt="Basic shellcode layouts." src="/uploads/images/figures/2013/03/shellcoding-1.jpg" /></div><p class="title"><b>Figure&nbsp;1.&nbsp;Basic shellcode layouts.</b></p></div><p>What is missing from <a href="#figure.1">Figure 1</a> is a return address, but since this section is random in the sense that it changes from vulnerability to vulnerability (and even between system revisions), we can&rsquo;t predict it, and it is outside the scope of this article. </p><p>To better illustrate the GetPC problem, let&rsquo;s compare x86 shellcode techniques with ARM ones. </p><p>In x86 architecture, the two most popular &lsquo;GetPC&rsquo; constructions are: </p><div class="itemizedlist"><ul type="disc"><li><p>JMP/CALL/POP reg trampoline code</p></li><li><p>Use of FSTENV</p></li></ul></div><p>As shown in <a href="#table.1">Table 1</a>, the trampoline code is quite simple. The POP ECX instruction returns the EIP value, which is a pointer to the shellcode data section since the address pushed onto the stack by the CALL instruction points to the next instruction after the CALL opcode. However, in our case there is no valid code there, just data.</p><div class="table"><a id="table.1"></a><table border="1" summary="Trampoline code."><colgroup><col /><col /></colgroup><tbody><tr><td><span class="bold"><strong>Address</strong></span></td><td><span class="bold"><strong>Instructions</strong></span></td></tr><tr><td>0</td><td>JMP start</td></tr><tr><td>+5 (rstart)</td><td>POP ECX</td></tr><tr><td>[&hellip;]</td><td>Rest of the shellcode</td></tr><tr><td>Start</td><td>CALL rstart (+5)</td></tr><tr><td>start+5</td><td>Shellcode data section</td></tr></tbody></table><p class="title"><b>Table&nbsp;1.&nbsp;Trampoline code.</b></p></div><p>One might wonder why, besides the pointer to the shellcode data section, we need the first JMP instruction. The reason is bad bytes. Consider the following code:</p><pre class="programlisting">CALL $+4
POP  ECX
</pre><p>The call instruction will be assembled as:</p><pre class="programlisting">E8<span class="bold"><strong>00000000</strong></span></pre><p>There are clearly too many bad bytes to deal with such opcode in the case of shellcode. </p><p>The second trick is based on the FPU instruction FSTENV, which saves the FPU and part of the CPU state in memory. In protected mode, 28 bytes of memory are needed to store the saved state: </p><div class="table"><a id="table.2"></a><table border="1" summary="The FPU instruction FSTENV saves the FPU and part of the CPU
      state in memory."><colgroup><col /><col /></colgroup><tbody><tr><td><span class="bold"><strong>Address</strong></span></td><td><span class="bold"><strong>Instructions</strong></span></td></tr><tr><td>0</td><td>FLDZ </td></tr><tr><td>+2</td><td>FSTENV SS:[ESP-0xC] </td></tr><tr><td>+6</td><td>POP ECX</td></tr></tbody></table><p class="title"><b>Table&nbsp;2.&nbsp;The FPU instruction FSTENV saves the FPU and part of the CPU state in memory.</b></p></div><p>After the code shown above has been executed, the ECX register contains the address of the FLDZ instruction. </p><p>It is worth mentioning that both methods are system independent, unlike methods based on Structured Exception Handling (SEH) which only work under <span class="emphasis"><em>Windows</em></span>, for example. It should not come as a surprise, therefore, that ARM shellcode can also be written in such a way that enables execution under different operating systems. Obviously the API calling convention changes from platform to platform, but the shellcode framework can be reused in such cases. </p><p>So how is it done on the ARM platform? There are a number of features of ARM architecture that particularly appeal to shellcode authors &ndash; one of which is the ability to switch between ARM and Thumb modes and the fact that this process does not require any special preparation (unlike switching between real and protected mode on x86 CPU, for example). Why is this feature so important to shellcode authors? Since the Thumb/Thumb2 instruction set is 16 bits long, the instruction encodings are not only shorter (shorter shellcode means more flexible and more reliable shellcode), but as a side effect, many bad bytes are eliminated. We will discuss this in more detail later in the article. </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a class="chapter" id="id3859184"></a>API calling conventions</h2></div></div></div><p>To understand all the shellcode presented here we first need to understand the <span class="emphasis"><em>Linux</em></span> API calling convention, which is a reflection of the ARM calling convention. </p><p>Let&rsquo;s start with the <span class="emphasis"><em>Linux</em></span> execve() calling structure:</p><div class="itemizedlist"><ul type="disc"><li><p>R0 must point to the &lsquo;//bin/sh&rsquo; string</p></li><li><p>R1 must point to the &lsquo;//bin/sh&rsquo; string</p></li><li><p>R2 must be set to 0</p></li><li><p>R7 must contain the SYSCALL number, which is 0x0b (11) for <span class="emphasis"><em>Linux</em></span> execve().</p></li></ul></div><p>Now if you take a look at the shellcode in <a href="#table.3">Table 3</a>, you will see that most parts of it are preparations for the syscall.</p><div class="table"><a id="table.3"></a><table border="1" summary="Shellcode instructions."><colgroup><col /><col /><col /><col /></colgroup><tbody><tr><td><span class="bold"><strong>Address</strong></span></td><td><span class="bold"><strong>Bytes</strong></span></td><td><span class="bold"><strong>Instructions</strong></span></td><td><span class="bold"><strong>Comment</strong></span></td></tr><tr><td>0</td><td>e28f6001</td><td>add r6, pc, #1</td><td>This is an ARM-type GetPC construction based on jump.</td></tr><tr><td>+4</td><td>e12fff16</td><td>bx r6</td><td>The BX instruction not only sets PC to the R6 value, but also switches ARM into Thumb mode.</td></tr><tr><td>+8</td><td>4678 </td><td>mov r0, pc</td><td>This is the second part of the GetPC construction &ndash; now R0 contains the current offset of the shellcode. Note that from this point on, the shellcode is executing in Thumb mode.</td></tr><tr><td>+A</td><td>300a</td><td>adds r0, #10</td><td>The R0 register value is adjusted to point to the data section (R0 points to the +16 address) &ndash; points to //bin/sh string.</td></tr><tr><td>+C</td><td>9001</td><td>str r0, [sp, #4]</td><td>The section data pointer is placed on the stack. </td></tr><tr><td>+E</td><td>a901</td><td>add r1, sp, #4</td><td>R1 = SP+4 &ndash; points to the //bin/sh string.</td></tr><tr><td>+10</td><td>1a92</td><td>subs r2, r2, r2</td><td>The R2 register is zeroed out (R2 = 0). Subs r2, r2, r2 is used in order to avoid bad bytes.</td></tr><tr><td>+12</td><td>270b</td><td>movs r7, #11</td><td>R7 contains the <span class="emphasis"><em>Linux</em></span> SYSCALL number (0x0B = execve).</td></tr><tr><td>+14</td><td>df01 </td><td>svc 1</td><td><span class="emphasis"><em>Linux</em></span> SYSCALL.</td></tr><tr><td>+16</td><td>&nbsp;</td><td>//bin/sh</td><td>Data section for execve SYSCALL.</td></tr></tbody></table><p class="title"><b>Table&nbsp;3.&nbsp;Shellcode instructions.</b></p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a class="chapter" id="id2802455"></a>A simple construction to avoid NULL bytes</h2></div></div></div><p>As described in [<span class="citation"><a href="#citation.1">1</a></span>], NULL bytes are bad bytes because they terminate C-string-based functions. When exploiting even the most basic buffer overflow vulnerability using the insecure strcpy() function, the attacker does not want his shellcode to be partially copied into memory because it will crash the target process during execution (setting aside safeguards such as a non-executable stack and ASLR). This means that the final shellcode must not contain any NULL bytes. However, as noted earlier, NULL bytes are C string delimiters, and in the case of <span class="emphasis"><em>Linux</em></span> they are used to mark the end of strings passed to glibc and kernel functions, for example. One solution to the problem is to patch bytes that are C string delimiters during runtime so that their value turns to 0 only after the shellcode has gained control over the currently executing context. However, simply loading a 0 value directly into the register will not work:</p><pre class="programlisting">mov r7, #0</pre><p>and</p><pre class="programlisting">ldr r5, #0</pre><p>result in bad bytes. Shellcoders use a couple of tricks to eliminate this problem. We&rsquo;ve already seen one such trick at offset +10 of our shellcode &ndash; to load 0 into the R2 register the following instruction is used:</p><pre class="programlisting">subs r2, r2, r2</pre><p>Sometimes, instead of the subs rx, rx, rx stream of instructions, a different construction is used to zero out registers:</p><pre class="programlisting">subs rx, rx, rx
mov ry, rx
mov rz, rx
</pre><p>where x, y and z are register numbers. However, this trick might not work with the R0 register in ARM mode, since such instructions can be encoded with bad bytes. </p><p>The result of this subtraction operation is stored in the R2 register and the R2 register value is subtracted from the R2 register value. The result is the required zero. </p><p>Another obvious trick is to employ the exclusive-or (eor) operation on the same register: </p><pre class="programlisting">eor r2, r2</pre><p>You might also be wondering why our shellcode uses the BX instruction to make a branch in the shellcode. After all, the PC register is accessible and its value can be stored in any other general-purpose register using a simple mov instruction (as happens at the +8 offset). The reason lies in the additional functionality of the BX instruction. It not only jumps to a given location (setting PC to an appropriate value), but it also switches from the ARM instruction set to the Thumb instruction set, which happens to be shorter. This allows the SVC instruction to be two bytes long instead of the longer, 32 bit ARM version, which in turn can contain bad bytes. We will return to this discussion later.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a class="chapter" id="id2857240"></a>Testing our shellcode on a real target</h2></div></div></div><p>In order to make our simple shellcode work within the C wrapper presented in [<span class="citation"><a href="#citation.1">1</a></span>] we need to get rid of the non executable stack. In order to do that we use the z execstack switch (without the -z execstack option the application could shut down with a &lsquo;segmentation fault&rsquo; error):</p><pre class="programlisting">gcc -z execstack -o 21253-raspi-execve.exe 21253-raspi-execve.c</pre><p>Now we will be able to execute the shellcode. Note that if you do not plan to run the shellcode but just get a compiled byte stream for further analysis, you can safely skip this step. In fact, the non-executable stack has no direct impact on debugging when using <span class="emphasis"><em>I</em></span><span class="emphasis"><em>DA Pro</em></span> with <span class="emphasis"><em>qemu</em></span>. However, if you plan to debug/analyse shellcode directly with on target architecture, the non executable stack should be disabled. </p><p>You might be surprised to learn that when trying to debug our example code with <span class="emphasis"><em>gdb</em></span> it fails after the BX instruction. The reason is that <span class="emphasis"><em>gdb</em></span> does not currently support Thumb2 instructions out of the box [<span class="citation"><a href="#citation.2">2</a></span>]. <span class="emphasis"><em>Gdb</em></span>&rsquo;s lack of support for Thumb2 is a good reason to switch to<span class="emphasis"><em> IDA Pro</em></span>. However, <span class="emphasis"><em>gdb</em></span> will be sufficient just to examine the resulting ELF binary and to find out how parameters are passed and how the shellcode is called at an assembly level. In order to do this we must:</p><div class="orderedlist"><ol type="1"><li><p>Load the program binary into memory and set a breakpoint at the main() function (break main).</p></li><li><p>Run the program to catch the first breakpoint (run).</p></li><li><p>Disassemble the main function (disassemble).</p></li><li><p>Set a breakpoint at the call to our shellcode (break *0x0846c).</p></li><li><p>Continue program execution (cont).</p></li><li><p>Execute a single instruction (si) to enter our shellcode.</p></li><li><p>Get the CPU status (info registers).</p></li></ol></div><p>Listing 1 shows a simple <span class="emphasis"><em>gdb</em></span> session. As you can see, we are able to locate our shellcode in memory and to determine how it is called. The reason we have discussed <span class="emphasis"><em>gdb</em></span> in detail is because it is available on all <span class="emphasis"><em>Linux</em></span> systems on different platforms. However, the rest of our work will be done with <span class="emphasis"><em>IDA Pro</em></span>. </p><pre class="programlisting">gdb &ndash;q ./nostack-21253-raspi-execve.exe
Reading symbols from /tmp/nostack-21253-raspi-execve.exe...(no debugging symbols found)...done.
(gdb) break main
Breakpoint 1 at 0x8428
(gdb) run
Starting program: /tmp/nostack-21253-raspi-execve.exe

Breakpoint 1, 0x00008428 in main ()
(gdb) disassemble
Dump of assembler code for function main:
=&gt; 0x00008428 &lt;+0&gt;:   push {r4, r5, r11, lr}
   0x0000842c &lt;+4&gt;:   add  r11, sp, #12
   0x00008430 &lt;+8&gt;:   ldr  r3, [pc, #68] ; 0x847c &lt;main+84&gt;
   0x00008434 &lt;+12&gt;:  ldr  r3, [r3]
   0x00008438 &lt;+16&gt;:  mov  r5, r3
   0x0000843c &lt;+20&gt;:  ldr  r4, [pc, #60] ; 0x8480 &lt;main+88&gt;
   0x00008440 &lt;+24&gt;:  ldr  r3, [pc, #60] ; 0x8484 &lt;main+92&gt;
   0x00008444 &lt;+28&gt;:  ldr  r3, [r3]
   0x00008448 &lt;+32&gt;:  mov  r0, r3
   0x0000844c &lt;+36&gt;:  bl   0x8358 &lt;strlen&gt;
   0x00008450 &lt;+40&gt;:  mov  r3, r0
   0x00008454 &lt;+44&gt;:  mov  r0, r5
   0x00008458 &lt;+48&gt;:  mov  r1, r4
   0x0000845c &lt;+52&gt;:  mov  r2, r3
   0x00008460 &lt;+56&gt;:  bl   0x8364 &lt;fprintf&gt;
   0x00008464 &lt;+60&gt;:  ldr  r3, [pc, #24] ; 0x8484 &lt;main+92&gt;
   0x00008468 &lt;+64&gt;   ldr  r3, [r3]
<span class="bold"><strong>   0x0000846c &lt;+68&gt;:  blx  r3  &lt;= this is a call to our shellcode from the C wrapper</strong></span>
   0x00008470 &lt;+72&gt;:  mov  r3, #0
   0x00008474 &lt;+76&gt;:  mov  r0, r3
   0x00008478 &lt;+80&gt;:  pop  {r4, r5, r11, pc}
   0x0000847c &lt;+84&gt;:  andeq r0, r1, r0, ror #12
   0x00008480 &lt;+88&gt;:  andeq r8, r0, r12, lsl r5
   0x00008484 &lt;+92&gt;:  andeq r0, r1, r12, asr r6
End of assembler dump.
(gdb) break *0x0846c
Breakpoint 2 at 0x846c
(gdb) cont
Continuing.
Length: 30

Breakpoint 2, 0x0000846c in main ()
(gdb) si
0x000084f8 in ?? ()
(gdb) info registers
r0  0xb  11
r1  0x1  1
r2  0x0  0
r3  0x84f8  34040
r4  0x851c  34076
r5  0x401685e0 1075217888
r6  0x837c  33660
r7  0x0  0
r8  0x0  0
r9  0x0  0
r10 0x40026000 1073897472
r11 0xbefff6a4 3204445860
r12 0x40168030 1075216432
sp  0xbefff698 0xbefff698
lr  0x8470  33904
<span class="bold"><strong>pc  0x84f8  0x84f8 &lt;= our shellcode address</strong></span>
cpsr 0x60000010 1610612752

<span class="bold"><strong>Listing 1: Simple gdb session.</strong></span>
</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a class="chapter" id="id2615637"></a>Analysing shellcode with IDA Pro</h2></div></div></div><p><span class="emphasis"><em>IDA Pro</em></span> has several great features that target ARM architecture, and when these are combined with <span class="emphasis"><em>IDAPython</em></span> and other neat functionality, it makes an excellent tool for analysis. </p><p>Let&rsquo;s start by loading our binary with shellcode into <span class="emphasis"><em>IDA</em></span>. Select the file and choose ARM as the target CPU. When <span class="emphasis"><em>IDA</em></span> loads the file it displays the warning shown in <a href="#figure.2">Figure 2</a> about the ARM and Thumb instruction sets. Since <span class="emphasis"><em>IDA</em></span> might not automatically be able to distinguish which instruction set is being used, and to provide the user with the ability to switch manually between modes, it provides a virtual register, T (<a href="#figure.3">Figure 3</a>), which when set to 1 defines Thumb opcode (16 bit) and when set to 0 signifies ARM (32-bit) mode. Thanks to this feature you can switch back and forth from Thumb to ARM during disassembly of your code. Of course, when <span class="emphasis"><em>IDA</em></span> is able to detect the mode switch (by tracing the BX instruction target, for example), it adjusts the T register value accordingly. </p><div class="figure"><a id="figure.2"></a><div class="mediaobject"><img alt="Warning about the Thumb and ARM instruction sets." src="/uploads/images/figures/2013/03/shellcoding-2.jpg" /></div><p class="title"><b>Figure&nbsp;2.&nbsp;Warning about the Thumb and ARM instruction sets.</b></p></div><div class="figure"><a id="figure.3"></a><div class="mediaobject"><img alt="Virtual segment register T value definition &ndash; it should reflect the T bit of the processor state register (CPSR)." src="/uploads/images/figures/2013/03/shellcoding-3.jpg" /></div><p class="title"><b>Figure&nbsp;3.&nbsp;Virtual segment register T value definition &ndash; it should reflect the T bit of the processor state register (CPSR).</b></p></div><p>Next let&rsquo;s try to locate our shellcode. We&rsquo;ve already got an address from the <span class="emphasis"><em>gdb</em></span> session: 0x084F8. However, the exact address displayed in<span class="emphasis"><em> IDA Pro</em></span> will be: .rodata:000084F8 (for the &lsquo;Jump to address&rsquo; command we can still pass the 0x084F8 value without knowing which ELF section we are looking for). If we hadn&rsquo;t got the address from the <span class="emphasis"><em>gdb</em></span> experiment, we could use <span class="emphasis"><em>IDA</em></span> to help us locate our byte stream. Since we&rsquo;ve used GCC, <span class="emphasis"><em>IDA</em></span> is able to identify functions, and the main() function is displayed in the &lsquo;Function name&rsquo; window. Click on &lsquo;main&rsquo; to jump to it. Next, scroll down and look for a branch with link instruction, since our C wrapper is using the call &lsquo;(*(void(*)()) SC)();&rsquo; to transfer execution to the SC table. <a href="#figure.4">Figure 4</a> shows a disassembly provided by <span class="emphasis"><em>IDA</em></span>.</p><div class="figure"><a id="figure.4"></a><div class="mediaobject"><img alt="Shellcode call from C wrapper." src="/uploads/images/figures/2013/03/shellcoding-4.jpg" /></div><p class="title"><b>Figure&nbsp;4.&nbsp;Shellcode call from C wrapper.</b></p></div><p>If you jump to the SC symbol (by clicking on it) you will not find our shellcode yet, but the data shown in <a href="#figure.5">Figure 5</a>.</p><div class="figure"><a id="figure.5"></a><div class="mediaobject"><img alt="SC symbol definition." src="/uploads/images/figures/2013/03/shellcoding-5.jpg" /></div><p class="title"><b>Figure&nbsp;5.&nbsp;SC symbol definition.</b></p></div><p>Obviously the disassembly is wrong, since this is data rather than code. However, if you convert it to data (using the D key) you will get: DCD 0x84F8. This is a more reasonable interpretation. The process should not come as a surprise since in C code we were using pointers, so the SC variable contains the address to our shellcode rather than the shellcode itself. </p><p>When we have the address of the shellcode we can jump to it &ndash; see <a href="#figure.6">Figure 6</a>. </p><div class="figure"><a id="figure.6"></a><div class="mediaobject"><img alt="Our execve shellcode disassembly in IDA Pro." src="/uploads/images/figures/2013/03/shellcoding-6.jpg" /></div><p class="title"><b>Figure&nbsp;6.&nbsp;Our execve shellcode disassembly in IDA Pro.</b></p></div><p>As you can see, the shellcode starts at 0x84F8 and the shellcode data section starts from 0x850E &ndash; this contains the string for the execve() call. The call to the execve() function is at 0x850C. Note how the SVC 1 instruction is encoded so there are no bad bytes. </p><p>As a side note, when I&rsquo;m disassembling and analysing shellcode within <span class="emphasis"><em>IDA</em></span> I always mark its start and end by renaming those locations (using the &lsquo;N&rsquo; key in disassembly view). I always use the names &lsquo;SHELLCODE_START&rsquo; and &lsquo;SHELLCODE_END&rsquo;, but the names can be anything as long as you can memorize them &ndash; such marks may be helpful later during analysis. Keep in mind that calculating the start and end of shellcode can be quite tricky &ndash; here, we are using a C wrapper to test the shellcode, but in a real life scenario you may have a malware sample that sends packets over the network and there will be no hints such as symbols or even BLX instructions. </p><p>If you take a look at our shellcode entry point once more you will notice another important thing: it starts with ARM instructions and switches to Thumb2 mode using BX. Note how the ARM and Thumb/Thumb2 instructions are encoded: </p><div class="itemizedlist"><ul type="disc"><li><p>All ARM opcodes (32-bit) occupy exactly four bytes </p></li><li><p>All Thumb/Thumb2 opcodes (12-bit) occupy exactly two bytes.</p></li></ul></div><p>This explains why shellcode written in Thumb mode is shorter. Besides the previously mentioned SVC instruction coding issue in ARM mode there is another construction that causes problems due to the generation of bad bytes: the R0 register. Take a look at the following instruction samples and their encodings:</p><pre class="programlisting">06 <span class="bold"><strong>00</strong></span> A0 E1   MOV R0, R6
<span class="bold"><strong>00</strong></span> 60 A0 E1   MOV R6, R0
03 <span class="bold"><strong>00</strong></span> A0 E1   MOV R0, R3
05 <span class="bold"><strong>00</strong></span> A0 E1   MOV R0, R5
<span class="bold"><strong>00</strong></span> 30 90 E5   LDR R3, [R0]
0C <span class="bold"><strong>00</strong></span> 9F E5   LDR R0, =main
04 <span class="bold"><strong>00</strong></span> 2D E5   STR R0, [SP,#-4]!
</pre><p>As you can see, in most cases use of the R0 register in ARM mode ends with a NULL byte. Why don&rsquo;t the MOV R0, PC instructions from our shellcode contain any bad bytes? The reason is that there is a difference in encoding between the 32 bit and 16 bit instruction sets. In our case the MOV R0, PC instruction is for Thumb2 mode and therefore it occupies only two bytes instead of ARM&rsquo;s four bytes as in the examples above, and the resulting encoding does not use a zero byte value. When constructing shellcode you have to remember that other instructions might also generate bad bytes, even without referencing the R0 register &ndash; for example:</p><pre class="programlisting"><span class="bold"><strong>00</strong></span> 30 93 E5  LDR R3, [R3]</pre><p>If you have problems calculating the correct shellcode end address, in most cases you can dump memory up to the first occurrence of a NULL byte or any other type of bad byte. In most cases properly working shellcode will not contain any type of bad bytes. </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a class="chapter" id="id2802280"></a>Dumping the shellcode from the executable</h2></div></div></div><p>We&rsquo;ve done a lot to get to our shellcode &ndash; debugging it further with all the additional C code such as runtime libraries is pointless. The idea of the previous exercise was to demonstrate how to extract the shellcode with <span class="emphasis"><em>IDA Pro</em></span> by locating it within the ELF binary. </p><p>Now let&rsquo;s dump our shellcode into a simple, flat binary file. In the case of emulating an execution environment, usually the simpler the things we load into it, the better the results. </p><p>There are many ways to achieve this goal. The method I&rsquo;ve used is not the simplest, but it demonstrates the power and possible usage of <span class="emphasis"><em>IDAPython</em></span>. We will use the Python script presented in Listing 2. Save this as &lsquo;dumpshellcode128b.py&rsquo; and place the cursor at the beginning of the shellcode. Starting from the cursor position, the next 128 bytes will be saved to the &lsquo;shelldump.bin&rsquo; file. To get the current cursor position (which, from <span class="emphasis"><em>IDA</em></span>&rsquo;s perspective, is an address) we use the ScreenEA() function. To access the byte at the address we use the Byte() function. Both are provided by <span class="emphasis"><em>IDAPython</em></span>, the rest is pure Python code. (Note that the script is for illustration purposes only. It lacks error checking and exception handling; it could use name markers for calculating size of dump, etc.) </p><pre class="programlisting">shelldump = &lsquo;&rsquo;
dump_size = 128
ea = ScreenEA()
print &lsquo;Dumping %02d bytes starting from address: 0x%X&rsquo; % (ea, dump_size)
for ea in range (ea, ea + dump_size):
    print &lsquo;%02X&rsquo; % Byte(ea),
    shelldump += &lsquo;%c&rsquo; % Byte(ea)
if len(shelldump) &gt; 0:
    print &lsquo;Writing shelldump.bin file&rsquo;
    fin = open(&lsquo;shelldump.bin&rsquo;,&rsquo;w+b&rsquo;)
    fin.write(shelldump)
    fin.close()

<span class="bold"><strong>Listing 2: Python script saved as &lsquo;dumpshellcode128b.py&rsquo;.
</strong></span></pre><p>By changing the dump_size variable you can control how many bytes will be dumped to the file.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a class="chapter" id="id4884151"></a>Summary</h2></div></div></div><p>All of what we&rsquo;ve done so far has been in preparation for a more challenging task: analysing polymorphic ARM shellcode with <span class="emphasis"><em>IDA Pro</em></span>. We will look at this in depth in the next part of the series.</p><div class="bibliography"><div class="titlepage"><div><div><h3 class="title"><a class="chapter" id="id4341673"></a>Bibliography</h3></div></div></div><div class="bibliomixed"><a id="citation.1"></a><p class="bibliomixed">[1] Czarnowski, A. Shellcoding ARM. Virus Bulletin, January 2013, p.9. <span class="bibliosource"><a href="/uploads/pdf/magazine/2013/201301.pdf" target="_blank">http://www.virusbtn.com/pdf/magazine/2013/201301.pdf</a></span>.</p></div><div class="bibliomixed"><a id="citation.2"></a><p class="bibliomixed">[2] Myers, J. S. Fix ARM stepping over Thumb-mode &lsquo;bx pc&rsquo; or &lsquo;blx pc&rsquo;. Sourceware.org. <span class="bibliosource"><a href="http://sourceware-org.1504.n7.nabble.com/Fix-ARM-stepping-over-Thumb-mode-quot-bx-pc-quot-or-quot-blx-pc-quot-td69213.html" target="_blank">http://sourceware-org.1504.n7.nabble.com/Fix-ARM-stepping-over-Thumb-mode-quot-bx-pc-quot-or-quot-blx-pc-quot-td69213.html</a></span>. </p></div></div></div> </div>
<div class="col-md-3 col-sm-3 col-lg-3">
<div id="NDPHPBlock13359" class="NDPHPBlock">
<div style="width: 100%;"><div style='float: left; width: 20%; margin-left: auto; margin-right: auto; text-align: center;'><center><a target='_blank' title='Tweet this!' href="https://twitter.com/share?text=Shellcoding ARM: part 2&url=https://www.virusbulletin.com/virusbulletin/2013/03/shellcoding-arm-part-2"><img src='/uploads/images/buttons/twitter.png' alt='twitter.png' width='45' height='45' class='responsive' /></a></center></div><div style='float: left; width: 20%; margin-left: auto; margin-right: auto; text-align: center;'><center><a target='_blank' title='Share on Facebook' href='https://www.facebook.com/sharer.php?u=https://www.virusbulletin.com/virusbulletin/2013/03/shellcoding-arm-part-2'><img src='/uploads/images/buttons/fb.png' alt='fb.png' width='45' height='45' class='responsive' /></a></center></div><div style='float: left; width: 20%; margin-left: auto; margin-right: auto; text-align: center;'><center><a target='_blank' title='Share on LinkedIn' href="https://www.linkedin.com/shareArticle?mini=true&url=https://www.virusbulletin.com/virusbulletin/2013/03/shellcoding-arm-part-2&title=Shellcoding ARM: part 2"><img src='/uploads/images/buttons/linkedin.png' alt='linkedin.png' width='45' height='45' class='responsive' /></a></center></div><div style='float: left; width: 20%; margin-left: auto; margin-right: auto; text-align: center;'><center><a target='_blank' title='Share on Hacker News' href="https://news.ycombinator.com/submitlink?u=https://www.virusbulletin.com/virusbulletin/2013/03/shellcoding-arm-part-2&t=Shellcoding ARM: part 2"><img src='/uploads/images/buttons/hackernews.png' alt='hackernews.png' width='45' height='45' class='responsive' /></a></center></div><div style='float: left; width: 20%; margin-left: auto; margin-right: auto; text-align: center;'><center><a target='_blank' title='reddit this!' href="https://www.reddit.com/submit?url=https://www.virusbulletin.com/virusbulletin/2013/03/shellcoding-arm-part-2"><img src='/uploads/images/buttons/reddit.png' alt='reddit.png' width='45' height='45' class='responsive' /></a></center></div></div></div><p> </p>
<h2>Latest articles:</h2>
<div class="ccm-page-list">
<h3 class="ccm-page-list-title">
<a href="/virusbulletin/2022/04/cryptojacking-fly-teamtnt-using-nvidia-drivers-mine-cryptocurrency/" target="_self">Cryptojacking on the fly: TeamTNT using NVIDIA drivers to mine cryptocurrency</a>
</h3>
<div class="ccm-page-list-description">
TeamTNT is known for attacking insecure and vulnerable Kubernetes deployments in order to infiltrate organizations&rsquo; dedicated environments and transform them into attack launchpads. In this article Aditya Sood presents a new module introduced by&hellip; </div>
<h3 class="ccm-page-list-title">
<a href="/virusbulletin/2021/12/collector-stealer-russian-origin-credential-and-information-extractor/" target="_self">Collector-stealer: a Russian origin credential and information extractor</a>
</h3>
<div class="ccm-page-list-description">
Collector-stealer, a piece of malware of Russian origin, is heavily used on the Internet to exfiltrate sensitive data from end-user systems and store it in its C&amp;C panels. In this article, researchers Aditya K Sood and Rohit Chaturvedi present a 360&hellip; </div>
<h3 class="ccm-page-list-title">
<a href="/virusbulletin/2021/06/fighting-fire-fire/" target="_self">Fighting Fire with Fire</a>
</h3>
<div class="ccm-page-list-description">
In 1989, Joe Wells encountered his first virus: Jerusalem. He disassembled the virus, and from that moment onward, was intrigued by the properties of these small pieces of self-replicating code. Joe Wells was an expert on computer viruses, was partly&hellip; </div>
<h3 class="ccm-page-list-title">
<a href="/virusbulletin/2021/04/run-your-malicious-vba-macros-anywhere/" target="_self">Run your malicious VBA macros anywhere!</a>
</h3>
<div class="ccm-page-list-description">
Kurt Natvig wanted to understand whether it&rsquo;s possible to recompile VBA macros to another language, which could then easily be &lsquo;run&rsquo; on any gateway, thus revealing a sample&rsquo;s true nature in a safe manner. In this article he explains how he recompiled&hellip; </div>
<h3 class="ccm-page-list-title">
<a href="/virusbulletin/2021/04/dissecting-design-and-vulnerabilities-azorultccpanels/" target="_self">Dissecting the design and vulnerabilities in AZORult&nbsp;C&amp;C&nbsp;panels</a>
</h3>
<div class="ccm-page-list-description">
Aditya K Sood looks at the command-and-control (C&amp;C) design of the AZORult malware, discussing his team's findings related to the C&amp;C design and some security issues they identified during the research. </div>
</div>
<p><br /><a class="btn btn-block btn-warning" href="/virusbulletin/archive">Bulletin Archive</a></p> </div>
</div>
</div>

<footer class="bs-footer" role="contentinfo">
<div class="container">
<div class="bs-social">
<div class="row ">
<div class="col-md-3">
<p><a title="About Us" href="/about-vb/about-us/">About us</a></p>
<p><a title="Contact Us" href="/about-vb/contact-us/">Contact us</a></p>
<p><a title="Advisory Board" href="/about-vb/advisory-board/">Advisory board</a></p>
<p><a title="Press" href="/about-vb/press/">Press information</a></p>
<p><a title="Security Events Calendar" href="/resources/calendar/">Security events calendar</a></p>
<p><a title="Newsletter" href="/newsletter/">Virus Bulletin newsletter</a></p> </div>
<div class="col-md-3">
<p><a title="VB Testing" href="/testing/">Testing</a></p>
<p><a title="VB100" href="/testing/vb1001/">VB100</a></p>
<p><a title="VBSpam" href="/testing/vbspam/">VBSpam</a></p>
<p><a title="VBWeb" href="/testing/vbweb/">VBWeb</a></p>
<p><a title="Consultancy Services" href="/testing/consultancy-services/">Consultancy services</a></p>
<p><a title="The Spammers' Compendium" href="/resources/spammerscompendium/">Spammers' Compendium</a></p> </div>
<div class="col-md-3">
<p><a title="VB2021 localhost" href="/conference/vb2021/">VB2021 localhost</a></p>
<p><a title="VB2020 localhost" href="/conference/vb2020/">VB2020 localhost</a></p>
<p><a title="VB2019" href="/conference/vb2019/">VB2019 (London)</a></p>
<p><a title="VB2018" href="/conference/vb2018">VB2018 (Montreal)</a></p>
<p><a title="VB2017" href="/conference/vb2017">VB2017 (Madrid)</a></p>
<p><a title="Conference Archive" href="/conference/vb-conference-archive/">Older conferences</a></p> </div>
<div class="col-md-3">
<div class="row">
<table style="float: right;" border="0">
<tbody>
<tr>
<td align="center"><a href="/rss" target="_blank"><img title="Get our blog updates" src="/uploads/images/buttons/rss-square-gray.png" alt="rss.png" width="35" height="35" /></a></td>
<td> </td>
<td align="center"><a href="https://twitter.com/virusbtn" target="_blank"><img class="bhtmbxoyxwpzahwcvxnw" title="Visit us on Twitter" src="/uploads/images/buttons/twitter-square-gray.png" alt="twitter.png" width="35" height="35" /></a></td>
<td> </td>
<td align="center"><a href="https://www.linkedin.com/company/virus-bulletin" target="_blank"><img class="bhtmbxoyxwpzahwcvxnw" title="Visit us on LinkedIn" src="/uploads/images/buttons/linkedin-square-gray.png" alt="linkedin.png" width="35" height="35" /></a></td>
<td> </td>
<td align="center"><a href="https://www.facebook.com/virusbulletin" target="_blank"><img title="Visit us on Facebook" src="/uploads/images/buttons/fb-square-gray.png" alt="twitter.png" width="35" height="35" /></a></td>
<td> </td>
<td align="center"><a href="https://www.youtube.com/user/virusbtn" target="_blank"><img title="Visit us on Youtube" src="/uploads/images/buttons/youtube-square-gray.png" alt="youtube.png" width="35" height="35" /></a></td>
</tr>
</tbody>
</table>
</div> </div>
</div>
<div class="row ">
<div class="col-md-12">
</div>
</div>
</div>
</div>
</footer>

<footer class="bs-footer2" role="contentinfo">
<div class="container">
<div class="bs-social2">
<div class="row ">
<div class="col-md-3">
</div>
<div class="col-md-3">
</div>
<div class="col-md-3">
</div>
<div class="col-md-3">
</div>
</div>
<div class="row ">
<div class="col-md-12">
<p style="text-align: left;">©1989-2022 Virus Bulletin.        <a title="Privacy Policy" href="/about-vb/privacy-policy/">Privacy policy</a>        <a title="Cookies" href="/about-vb/privacy-policy/cookies/">Cookies</a>        <a title="Terms and Conditions" href="/about-vb/terms-and-conditions/">Terms and Conditions</a></p> </div>
</div>
</div>
</div>
</footer>

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-21876594-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-21876594-2', { 'anonymize_ip': true });
</script><script type="text/javascript" src="/libraries/js/fancybox.load.js"></script>
<script type="text/javascript" src="/packages/bootstrap/js/common/app.js"></script>
<div id="ccm-cookiesDisclosure" class="disclosure-bottom">
<div class="disclosure-container">
<div class="disclosure-content">
<p> We have placed cookies on your device in order to improve the functionality of this site, as outlined in our <a href="/about-vb/privacy-policy/cookies" target="_blank">cookies policy</a>. However, you may delete and block all cookies from this site and your use of the site will be unaffected. By continuing to browse this site, you are agreeing to Virus Bulletin's use of data as outlined in our <a href="/about-vb/privacy-policy/" target="_blank">privacy policy</a>.</p>
</div>
<div class="disclosure-form">
<form action="/index.php/cookies_disclosure/" method="POST">
<input type="hidden" name="allowCookies" value="1" />
<div class="button">
<input class="btn btn-info btn-sm" type="submit" name="submit" value="I understand. Don't show this message again!" />
</div>
</form>
</div>
<div class="ccm-spacer">&nbsp;</div>
</div>
</div>
</body>
</html>