Detecting Extended Attributes (ZeroAccess) and other Frankensteinâ€™s Monsters with HMFT
January 25, 2013 in Anti-Forensics, Compromise Detection, Forensic Analysis, HMFT, Malware Analysis

The topic of Extended Attributes (EA) has been recently covered in an excellent post by Corey. Entitled Extracting ZeroAccess from NTFS Extended Attributes it goes into (amazing) depth explaining on what EA is and how to extract this artifact from the system. Itâ€™s a pure forensic gold and if you havenâ€™t read this post yet, please go ahead and do so before reading mine.
Similarly to Corey, I was very interested in researching EA, and I finally took some time tonight to have a deeper look at it myself. I actually wanted to dig in the code more than the $MFT artifacts alone not only to have something to write about (after all, Corey already covered everything! :-)), but also because I wanted to see how the EA is actually created and what system functions/APIs are used by malware. The reason behind this curiosity was improvement of my analysis tools and techniques, and a few other ideas that I will be quiet about for the moment.
I first assumed that the ZeroAccessâ€™ EAs are created using ZwSetEaFile/NtSetEaFile function from ntdll.dll. I saw this API name popping up on some blogs and I saw it being referenced in my ZeroAccess memory/file dumps so it was a natural â€˜breakpointâ€™ choice for OllyDbg analysis:

To my surprise, none of the samples I checked used this function at all!
Curious, I started digging into it a bit more and realized that for the samples I looked at, the EAs are actually created not byÂ  ZwSetEaFile/NtSetEaFile function, but by ZwCreateFile/NtCreateFile.
Surprised?
I was!
Looking at a documentation, you can see the following function parameters described on MSDN:
NTSTATUS NtCreateFile(
_Out_Â Â Â Â Â PHANDLE FileHandle,
_In_Â Â Â Â Â Â ACCESS_MASK DesiredAccess,
_In_Â Â Â Â Â Â POBJECT_ATTRIBUTES ObjectAttributes,
_Out_Â Â Â Â Â PIO_STATUS_BLOCK IoStatusBlock,
_In_opt_Â Â PLARGE_INTEGER AllocationSize,
_In_Â Â Â Â Â Â ULONG FileAttributes,
_In_Â Â Â Â Â Â ULONG ShareAccess,
_In_Â Â Â Â Â Â ULONG CreateDisposition,
_In_Â Â Â Â Â Â ULONG CreateOptions,
_In_Â Â Â Â Â Â PVOID EaBuffer,
_In_Â Â Â Â Â Â ULONG EaLength
);
Yes, itâ€™s that simple.
One thing to note â€“ the EA is added to files on both windows XP and Windows 7, but only under Windows 7 I observed the modification of services.exe. On Windows XP, it only appended EA to theÂ  â€˜Uâ€™ file and nothing else.
Okay, I mentioned I had a couple of ideas why I wanted to research this feature. Now itâ€™s time to reveal them!
Idea #1 â€“ POC
Once I found out what APIs are being used by the malware, I was also able to produce a simple snippet of code that reproduces the functionality:
.586
.MODEL FLAT,STDCALL

o equ OFFSET
includeÂ Â Â  windows.inc
includeÂ Â Â  kernel32.inc
includelib kernel32.lib
includeÂ Â Â  ntdll.inc
includelib ntdll.lib
includeÂ Â Â  masm32.inc
includelib masm32.lib

IO_STATUS_BLOCK STRUCT
union
StatusÂ Â  Â Â Â  Â dd ?
PointerÂ Â  Â Â Â  Â dd ?
ends
InformationÂ Â  Â dd ?
IO_STATUS_BLOCK ENDS

.data?
file db 256 dup (?)
faÂ Â  db 256 dup (?)
_FILE_FULL_EA_INFORMATION struct
NextEntryOffset dd ?
FlagsÂ Â Â Â Â Â Â Â Â Â  db ?
EaNameLengthÂ Â Â  db ?
EaValueLengthÂ Â  dw ?
EaNameÂ Â Â Â Â Â Â Â Â  db ?
_FILE_FULL_EA_INFORMATION ends
FEA equ _FILE_FULL_EA_INFORMATION
io IO_STATUS_BLOCK <>
.code
Start:
invoke GetCL,1, o file
leaÂ Â Â  edi,[fa+_FILE_FULL_EA_INFORMATION.EaName]
invoke GetCL,2, edi
invoke lstrlenA,edi
leaÂ Â Â  esi,[fa+_FILE_FULL_EA_INFORMATION.EaNameLength]
movÂ Â Â  [esi],al
addÂ Â Â  edi,eax
incÂ Â Â  edi
invoke GetCL,3, edi
invoke lstrlenA,edi
leaÂ Â Â  esi,[fa+_FILE_FULL_EA_INFORMATION.EaValueLength]
movÂ Â Â  [esi],al
addÂ Â Â  edi,eax
invoke CreateFileA, o file, \
GENERIC_WRITE, \
0, \
NULL, \
CREATE_NEW, \
FILE_ATTRIBUTE_NORMAL, \
NULL
xchgÂ Â  eax,ebx
movÂ Â Â  eax,edi
subÂ Â Â  eax,o fa
invoke NtSetEaFile,ebx,o io,o fa, eax
invoke CloseHandle,ebx
invoke ExitProcess,0
END Start
This code can be used for testing purposes in a lab environment.
You can either compile the code yourself using masm32 or you can use a precompiled binary â€“ download it here.
To run:
ea.exe <full path name to a file> <EA name> <EA value>
e.g.:
ea.exe g:\test.txt foo bar
Remember to specify a full path to a file. Also, choose a non-existing file name for a file (the program wonâ€™t work with files that are already present).
Last, but not least â€“ there is no error checks, you can add it yourself if you wish ðŸ™‚
Idea #2 â€“ Reduce the FUD factor
While it is a novelty technique, it is not very advanced â€“Â  a single API call does all the dirty job to _create_ the EA.
To _detect_ EA is not very difficult either â€“ as long as you have a right tool to do so ðŸ™‚
Idea #3 â€“ Show how to detect EA on a live system
Now that I got a POC, I can run it:
g:\test.txt foo bar
and then analyze changes introduced to the file system.
I can do it quicklyÂ  with hmft.
hmft -l g: mft_list
I tested the program on a small drive that I use for my tests. I formatted it first to ensure its MFT is clean:

I then opened theÂ mft_list file in a Total Commanderâ€™s Lister and searched for MFTA_EA.
I am pasting the full record for your reference:
[FILE]
SignatureDÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  = 1162627398
OffsetToFixupArrayWÂ Â Â Â Â Â Â Â Â Â  = 48
NumberOfEntriesInFixupArrayWÂ  = 3
LogFileSequenceNumberQÂ Â Â Â Â Â Â  = 1062946
SequenceValueWÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â  = 1
LinkCountWÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  = 1
OffsetToFirstAttributeWÂ Â Â Â Â Â  = 56
FlagsWÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  = 1
UsedSizeOfMFTEntryDÂ Â Â Â Â Â Â Â Â Â  = 368
AllocatedSizeOfMFTEntryDÂ Â Â Â Â  = 1024
FileReferenceToBaseRecordQÂ Â Â  = 0
NextAttributeIdDÂ Â Â Â Â Â Â Â Â Â Â Â Â  = 5
--

RESIDENT ATTRIBUTE
AttributeTypeIdentifierD = 16
LengthOfAttributeDÂ Â Â Â Â Â  = 96
NonResidentFlagBÂ Â Â Â Â Â Â Â  = 0
LengthOfNameBÂ Â Â Â Â Â Â Â Â Â Â  = 0
OffsetToNameWÂ Â Â Â Â Â Â Â Â Â Â  = 0
FlagsWÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  = 0
AttributeIdentifierWÂ Â Â Â  = 0
--
SizeOfContentDÂ Â Â Â Â Â Â Â Â  = 72
OffsetToContentWÂ Â Â Â Â Â Â  = 24
--
MFTA_STANDARD_INFORMATION
CreationTimeQÂ Â Â Â Â Â Â Â  = 130036100539989520
ModificationTimeQÂ Â Â Â  = 130036100539989520
MFTModificationTimeQÂ  = 130036100539989520
AccessTimeQÂ Â Â Â Â Â Â Â Â Â  = 130036100539989520
FlagsDÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â  = 32
MaxNumOfVersionsDÂ Â Â Â  = 0
VersionNumberDÂ Â Â Â Â Â Â  = 0
ClassIdDÂ Â Â Â Â Â Â Â Â Â Â Â Â  = 0
OwnerIdDÂ Â Â Â Â Â Â Â Â Â Â Â Â  = 0
SecurityIdDÂ Â Â Â Â Â Â Â Â Â  = 261
QuotaQÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â  = 0
USNQÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  = 0
CreationTime (epoch)Â Â Â  = 1359136453
ModificationTime (epoch)Â  = 1359136453
MFTModificationTime (epoch)Â  = 1359136453
AccessTime (epoch)Â Â Â Â Â Â Â Â Â Â  = 1359136453
--

RESIDENT ATTRIBUTE
AttributeTypeIdentifierD = 48
LengthOfAttributeDÂ Â Â Â Â Â  = 112
NonResidentFlagBÂ Â Â Â Â Â Â Â  = 0
LengthOfNameBÂ Â Â Â Â Â Â Â Â Â Â  = 0
OffsetToNameWÂ Â Â Â Â Â Â Â Â Â Â  = 0
FlagsWÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  = 0
AttributeIdentifierWÂ Â Â Â  = 2
--
SizeOfContentDÂ Â Â Â Â Â Â Â Â  = 82
OffsetToContentWÂ Â Â Â Â Â Â  = 24
--
MFTA_FILE_NAME
ParentID6Â Â Â Â Â Â Â Â Â Â Â Â  = 5
ParentUseIndexWÂ Â Â Â Â Â  = 5
CreationTimeQÂ Â Â Â Â Â Â Â  = 130036100539989520
ModificationTimeQÂ Â Â Â  = 130036100539989520
MFTModificationTimeQÂ  = 130036100539989520
AccessTimeQÂ Â Â Â Â Â Â Â Â Â  = 130036100539989520
CreationTime (epoch)Â Â Â  = 1359136453
ModificationTime (epoch)Â  = 1359136453
MFTModificationTime (epoch)Â  = 1359136453
AccessTime (epoch)Â Â Â Â Â Â Â Â Â Â  = 1359136453
AllocatedSizeQÂ Â Â Â Â Â Â  = 0
RealSizeQÂ Â Â Â Â Â Â Â Â Â Â Â  = 0
FlagsDÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â  = 32
ReparseValueDÂ Â Â Â Â Â Â Â  = 0
LengthOfNameBÂ Â Â Â Â Â Â Â  = 8
NameSpaceBÂ Â Â Â Â Â Â Â Â Â Â  = 3
FileName = test.txt
--

RESIDENT ATTRIBUTE
AttributeTypeIdentifierD = 128
LengthOfAttributeDÂ Â Â Â Â Â  = 24
NonResidentFlagBÂ Â Â Â Â Â Â Â  = 0
LengthOfNameBÂ Â Â Â Â Â Â Â Â Â Â  = 0
OffsetToNameWÂ Â Â Â Â Â Â Â Â Â Â  = 24
FlagsWÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  = 0
AttributeIdentifierWÂ Â Â Â  = 1
--
SizeOfContentDÂ Â Â Â Â Â Â Â Â  = 0
OffsetToContentWÂ Â Â Â Â Â Â  = 24
--
MFTA_DATA
--

RESIDENT ATTRIBUTE
AttributeTypeIdentifierD = 208
LengthOfAttributeDÂ Â Â Â Â Â  = 32
NonResidentFlagBÂ Â Â Â Â Â Â Â  = 0
LengthOfNameBÂ Â Â Â Â Â Â Â Â Â Â  = 0
OffsetToNameWÂ Â Â Â Â Â Â Â Â Â Â  = 0
FlagsWÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  = 0
AttributeIdentifierWÂ Â Â Â  = 3
--
SizeOfContentDÂ Â Â Â Â Â Â Â Â  = 8
OffsetToContentWÂ Â Â Â Â Â Â  = 24
--
MFTA_EA_INFORMATION
--

RESIDENT ATTRIBUTE
AttributeTypeIdentifierD = 224
LengthOfAttributeDÂ Â Â Â Â Â  = 40
NonResidentFlagBÂ Â Â Â Â Â Â Â  = 0
LengthOfNameBÂ Â Â Â Â Â Â Â Â Â Â  = 0
OffsetToNameWÂ Â Â Â Â Â Â Â Â Â Â  = 0
FlagsWÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  = 0
AttributeIdentifierWÂ Â Â Â  = 4
--
SizeOfContentDÂ Â Â Â Â Â Â Â Â  = 16
OffsetToContentWÂ Â Â Â Â Â Â  = 24
--
MFTA_EA

There are two EA-related entries here:

MFTA_EA_INFORMATION
MFTA_EA record

Manual analysis like this are quite tiring, so we can write a short perl snippet that can help us with postprocessing:
use strict;
my $f='';
my $l='';
while (<>)
{
s/[\r\n]+//g;
$f = $1 if /FileName = (.+)$/;
print "$f has $1 record\n" if ($l =~ /(MFTA_EA(_[A-Z]+)?)/);
$l = $_;
}
Saving it into ea.pl file, and running it as:
ea.pl mft_list
produces the following output:

Idea #4 â€“ Detect ZeroAccess with hmft
Itâ€™s simple ðŸ™‚

I ran hmft before the ZeroAccess installation
Then I infected my test box
I then ran hmft after the ZeroAccess installation

At this stage, all I had to do was to run ea.pl on both outputs and I got the following results:

Or, for the sake of copy & paste (and web bots :)):
r:\>ea.pl before_installation
V20~1.6 has MFTA_EA_INFORMATION record
V20~1.6 has MFTA_EA record

r:\>ea.pl after_installation
U has MFTA_EA_INFORMATION record
U has MFTA_EA record
V20~1.6 has MFTA_EA_INFORMATION record
V20~1.6 has MFTA_EA record
U has MFTA_EA_INFORMATION record
U has MFTA_EA record
services.exe has MFTA_EA_INFORMATION record
services.exe has MFTA_EA record/span>

As we can see, the malware activity is immediately visible.
Btw. V20~1.6 is a $MFT FILE record that refers to C:\Windows\CSC\v2.0.6 and is related to Offline files (client-side caching). I donâ€™t have any information about the content of this EA. Perhaps someone will be more curious than me to poke around there ðŸ™‚
Idea #5 â€“ Create a Frankensteinâ€™s monster
Using EA and ADS (Alternate Data Streams) with a single file is also possible.
You can use ea.exe to create such Frankensteinâ€™s monster in 2 simple steps:

by running it first with aÂ  filename only â€“ this will create EA record
and then re-runing it with a stream name, this will create the ADS, but EA for ADS will fail (sometimes itâ€™s OK to fail :))

The result is shown on the following screenshot:

Using hmft and a combination of ea.pl and ads.pl (posted in older post related to HMFT) in a single eads.pl script:
use strict;
my $f='';
my $l='';
while (<>)
{
s/[\r\n]+//g;
$f = $1 if /FileName = (.+)$/;
print "$f has $1 record\n" if ($l =~ /(MFTA_EA(_[A-Z]+)?)/);
print "$f:$1\n" if ($l =~ /MFTA_DATA/&&/AttributeName = (.+)$/);
$l = $_;
}
we can easily detect such beast as well.
Thatâ€™s all, thanks for reading!

Comments Off on Detecting Extended Attributes (ZeroAccess) and other Frankensteinâ€™s Monsters with HMFT

Comments are closed.
