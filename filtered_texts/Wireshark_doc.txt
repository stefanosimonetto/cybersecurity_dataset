Richard Sharpe, Ed Warnicke, Ulf Lamping
[Word Count: 6]

Wireshark is the world’s foremost network protocol analyzer, but the rich feature set can be
[Word Count: 15]

daunting for the unfamiliar. This document is part of an effort by the Wireshark team to improve
[Word Count: 17]

Wireshark’s usability. We hope that you find it useful and look forward to your comments.
[Word Count: 15]

The intended audience of this book is anyone using Wireshark.
[Word Count: 10]

This book explains all of the basic and some advanced features of Wireshark. As Wireshark has
[Word Count: 16]

become a very complex program, not every feature may be explained in this book.
[Word Count: 14]

This book is not intended to explain network sniffing in general and it will not provide details
[Word Count: 17]

about specific network protocols. A lot of useful information regarding these topics can be found at
[Word Count: 16]

the Wireshark Wiki at https://wiki.wireshark.org/.
[Word Count: 5]

By reading this book, you will learn how to install Wireshark, how to use the basic elements of the
[Word Count: 19]

graphical user interface (such as the menu) and what’s behind some of the advanced features that
[Word Count: 16]

are not always obvious at first sight. It will hopefully guide you around some common problems
[Word Count: 16]

that frequently appear for new (and sometimes even advanced) Wireshark users.
[Word Count: 11]

The authors would like to thank the whole Wireshark team for their assistance. In particular, the
[Word Count: 16]

• Gerald Combs, for initiating the Wireshark project and funding to do this documentation.
[Word Count: 14]

• Guy Harris, for many helpful hints and a great deal of patience in reviewing this document.
[Word Count: 17]

• Gilbert Ramirez, for general encouragement and helpful hints along the way.
[Word Count: 12]

The authors would also like to thank the following people for their helpful feedback on this
[Word Count: 16]

• Pat Eyler, for his suggestions on improving the example on generating a backtrace.
[Word Count: 14]

• Martin Regner, for his various suggestions and corrections.
[Word Count: 9]

• Graeme Hewson, for many grammatical corrections.
[Word Count: 7]

The authors would like to acknowledge those man page and README authors for the Wireshark
[Word Count: 15]

project from who sections of this document borrow heavily:
[Word Count: 9]

• Scott Renfro from whose mergecap man page mergecap: Merging multiple capture files into one
[Word Count: 15]

• Ashok Narayanan from whose text2pcap man page text2pcap: Converting ASCII hexdumps to
[Word Count: 13]

This book was originally developed by Richard Sharpe with funds provided from the Wireshark
[Word Count: 14]

Fund. It was updated by Ed Warnicke and more recently redesigned and updated by Ulf Lamping.
[Word Count: 16]

It was originally written in DocBook/XML and converted to AsciiDoc by Gerald Combs.
[Word Count: 13]

Where to get the latest copy of this document?
[Word Count: 9]

The latest copy of this documentation can always be found at https://www.wireshark.org/docs/
[Word Count: 12]

Should you have any feedback about this document, please send it to the authors through
[Word Count: 15]

The following table shows the typographic conventions that are used in this guide.
[Word Count: 13]

Italic
File names, folder names, and extensions C:\Development\wireshark.
[Word Count: 8]

Monospace
Commands, flags, and environment
[Word Count: 5]

[ Button ]
Dialog and window buttons
Press [ Launch ] to go to the Moon.
[Word Count: 16]

Key
Keyboard shortcut
Press Ctrl  +  Down  to move to the next
[Word Count: 12]

Menu
Menu item
Select Go › Next Packet to move to the
[Word Count: 12]

Important and notable items are marked as follows:
[Word Count: 8]

You should pay attention to a warning, otherwise data loss might occur.
[Word Count: 12]

Tips are helpful for your everyday work using Wireshark.
[Word Count: 9]

A note will point you to common mistakes and things that might not be obvious.
[Word Count: 15]

$ # This is a comment
$ git config --global log.abbrevcommit true
[Word Count: 12]

>rem This is a comment
>cd C:\Development
[Word Count: 7]

PS$># This is a comment
PS$> choco list -l
[Word Count: 9]

/* This method dissects foos */
static int
dissect_foo_message(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree _U_, void
*data _U_)
{
    /* TODO: implement your dissecting code */
    return tvb_captured_length(tvb);
}
[Word Count: 30]

Wireshark is a network packet analyzer. A network packet analyzer presents captured packet data
[Word Count: 14]

You could think of a network packet analyzer as a measuring device for examining what’s
[Word Count: 15]

happening inside a network cable, just like an electrician uses a voltmeter for examining what’s
[Word Count: 15]

happening inside an electric cable (but at a higher level, of course).
[Word Count: 12]

In the past, such tools were either very expensive, proprietary, or both. However, with the advent
[Word Count: 16]

of Wireshark, that has changed. Wireshark is available for free, is open source, and is one of the
[Word Count: 18]

Here are some reasons people use Wireshark:
[Word Count: 7]

• Network administrators use it to troubleshoot network problems
[Word Count: 9]

• Network security engineers use it to examine security problems
[Word Count: 10]

• QA engineers use it to verify network applications
[Word Count: 9]

• Developers use it to debug protocol implementations
[Word Count: 8]

• People use it to learn network protocol internals
[Word Count: 9]

Wireshark can also be helpful in many other situations.
[Word Count: 9]

The following are some of the many features Wireshark provides:
[Word Count: 10]

• Capture live packet data from a network interface.
[Word Count: 9]

• Open files containing packet data captured with tcpdump/WinDump, Wireshark, and many
[Word Count: 12]

• Import packets from text files containing hex dumps of packet data.
[Word Count: 12]

• Display packets with very detailed protocol information.
[Word Count: 8]

• Export some or all packets in a number of capture file formats.
[Word Count: 13]

• Colorize packet display based on filters.
[Word Count: 7]

However, to really appreciate its power you have to start using it.
[Word Count: 12]

Wireshark captures packets and lets you examine their contents. shows Wireshark having captured
[Word Count: 13]

some packets and waiting for you to examine them.
[Word Count: 9]

Figure 1. Wireshark captures packets and lets you examine their contents.
[Word Count: 11]

Live capture from many different network media
[Word Count: 7]

Wireshark can capture traffic from many different network media types, including Ethernet,
[Word Count: 12]

Wireless LAN, Bluetooth, USB, and more. The specific media types supported may be limited by
[Word Count: 15]

several factors, including your hardware and operating system. An overview of the supported
[Word Count: 13]

media types can be found at https://wiki.wireshark.org/CaptureSetup/NetworkMedia.
[Word Count: 7]

Import files from many other capture programs
[Word Count: 7]

Wireshark can open packet captures from a large number of capture programs. For a list of input
[Word Count: 17]

Export files for many other capture programs
[Word Count: 7]

Wireshark can save captured packets in many formats, including those used by other capture
[Word Count: 14]

programs. For a list of output formats see Output File Formats.
[Word Count: 11]

There are protocol dissectors (or decoders, as they are known in other products) for a great many
[Word Count: 17]

protocols: see Protocols and Protocol Fields.
[Word Count: 6]

Wireshark is an open source software project, and is released under the GNU General Public
[Word Count: 15]

License (GPL). You can freely use Wireshark on any number of computers you like, without
[Word Count: 15]

worrying about license keys or fees or such. In addition, all source code is freely available under
[Word Count: 17]

the GPL. Because of that, it is very easy for people to add new protocols to Wireshark, either as
[Word Count: 19]

plugins, or built into the source, and they often do!
[Word Count: 10]

Here are some things Wireshark does not provide:
[Word Count: 8]

• Wireshark isn’t an intrusion detection system. It will not warn you when someone does strange
[Word Count: 16]

things on your network that he/she isn’t allowed to do. However, if strange things happen,
[Word Count: 15]

Wireshark might help you figure out what is really going on.
[Word Count: 11]

• Wireshark will not manipulate things on the network, it will only “measure” things from it.
[Word Count: 16]

Wireshark doesn’t send packets on the network or do other active things (except domain name
[Word Count: 15]

The amount of resources Wireshark needs depends on your environment and on the size of the
[Word Count: 16]

capture file you are analyzing. The values below should be fine for small to medium-sized capture
[Word Count: 16]

files no more than a few hundred MB. Larger capture files will require more memory and disk
[Word Count: 17]

A busy network can produce huge capture files. Capturing on even a 100 megabit
[Word Count: 14]

network can produce hundreds of megabytes of capture data in a short time. A
[Word Count: 14]

computer with a fast processor, and lots of memory and disk space is always a good
[Word Count: 16]

If Wireshark runs out of memory it will crash. See https://wiki.wireshark.org/KnownBugs/
[Word Count: 11]

OutOfMemory for details and workarounds.
[Word Count: 5]

Although Wireshark uses a separate process to capture packets, the packet analysis is single-
[Word Count: 14]

threaded and won’t benefit much from multi-core systems.
[Word Count: 8]

Wireshark should support any version of Windows that is still within its extended support lifetime.
[Word Count: 15]

At the time of writing this includes Windows 11, 10, Server 2022, Server 2019, and Server 2016. It
[Word Count: 18]

• The Universal C Runtime. This is included with Windows 10 and Windows Server 2019 and is
[Word Count: 17]

installed automatically on earlier versions if Microsoft Windows Update is enabled. Otherwise
[Word Count: 12]

you must install KB2999226 or KB3118401.
[Word Count: 6]

• Any modern 64-bit Intel or Arm processor.
[Word Count: 8]

• 500 MB available RAM. Larger capture files require more RAM.
[Word Count: 11]

• 500 MB available disk space. Capture files require additional disk space.
[Word Count: 12]

• Any modern display. 1280 × 1024 or higher resolution is recommended. Wireshark will make
[Word Count: 15]

use of HiDPI or Retina resolutions if available. Power users will find multiple monitors useful.
[Word Count: 15]

• A supported network card for capturing
[Word Count: 7]

◦Ethernet. Any card supported by Windows should work. See the wiki pages on Ethernet
[Word Count: 14]

capture and offloading for issues that may affect your environment.
[Word Count: 10]

◦802.11. See the Wireshark wiki page. Capturing raw 802.11 information may be difficult
[Word Count: 13]

◦Other media. See https://wiki.wireshark.org/CaptureSetup/NetworkMedia.
[Word Count: 4]

Older versions of Windows which are outside Microsoft’s extended lifecycle support window are no
[Word Count: 14]

longer supported. It is often difficult or impossible to support these systems due to circumstances
[Word Count: 15]

beyond our control, such as third party libraries on which we depend or due to necessary features
[Word Count: 17]

that are only present in newer versions of Windows such as hardened security or memory
[Word Count: 15]

• Wireshark 4.2 was the last release branch to officially support Windows 10.
[Word Count: 13]

• Wireshark 4.0 was the last release branch to officially support Windows 8.1 and Windows
[Word Count: 15]

• Wireshark 3.6 was the last release branch to officially support 32-bit Windows.
[Word Count: 13]

• Wireshark 3.2 was the last release branch to officially support Windows 7 and Windows Server
[Word Count: 16]

• Wireshark 2.2 was the last release branch to support Windows Vista and Windows Server 2008
[Word Count: 16]

• Wireshark 1.12 was the last release branch to support Windows Server 2003.
[Word Count: 13]

• Wireshark 1.10 was the last release branch to officially support Windows XP.
[Word Count: 13]

See the Wireshark release lifecycle page for more details.
[Word Count: 9]

Wireshark supports macOS 11 and later. Similar to Windows, supported macOS versions depend on
[Word Count: 14]

third party libraries and on Apple’s requirements.
[Word Count: 7]

• Wireshark 4.2 was the last release branch to support macOS 10.14.
[Word Count: 12]

• Wireshark 3.6 was the last release branch to support macOS 10.13.
[Word Count: 12]

• Wireshark 3.4 was the last release branch to support macOS 10.12.
[Word Count: 12]

• Wireshark 2.6 was the last release branch to support Mac OS X 10.6 and 10.7 and OS X 10.8 to
[Word Count: 21]

• Wireshark 2.0 was the last release branch to support OS X on 32-bit Intel.
[Word Count: 15]

• Wireshark 1.8 was the last release branch to support Mac OS X on PowerPC.
[Word Count: 15]

See the Wireshark release lifecycle page for more details.
[Word Count: 9]

The system requirements should be comparable to the specifications listed above for Windows.
[Word Count: 13]

Wireshark runs on most UNIX and UNIX-like platforms including Linux and most BSD variants. The
[Word Count: 15]

system requirements should be comparable to the specifications listed above for Windows.
[Word Count: 12]

Binary packages are available for most Unices and Linux distributions including the following
[Word Count: 13]

• Red Hat Enterprise Linux / CentOS / Fedora
[Word Count: 9]

If a binary package is not available for your platform you can download the source and try to build
[Word Count: 19]

it. Please report your experiences to wireshark-dev[AT]wireshark.org.
[Word Count: 7]

You 
can 
get 
the 
latest 
copy 
of 
the 
program 
from 
the 
Wireshark 
website 
at
[Word Count: 14]

https://www.wireshark.org/download.html. The download page should automatically highlight the
[Word Count: 8]

appropriate download for your platform and direct you to the nearest mirror. Official Windows
[Word Count: 14]

and macOS installers are signed by Wireshark Foundation using trusted certificates on those
[Word Count: 13]

platforms. macOS installers are additionally notarized.
[Word Count: 6]

A new Wireshark version typically becomes available every six weeks.
[Word Count: 10]

If you want to be notified about new Wireshark releases you should subscribe to the wireshark-
[Word Count: 16]

announce mailing list. You will find more details in Mailing Lists.
[Word Count: 11]

Each release includes a list of file hashes which are sent to the wireshark-announce mailing list and
[Word Count: 17]

placed in a file named SIGNATURES-x.y.z.txt. Announcement messages are archived at
[Word Count: 11]

https://lists.wireshark.org/archives/wireshark-announce/ and SIGNATURES files can be found at
[Word Count: 8]

https://www.wireshark.org/download/src/all-versions/. 
Both 
are 
GPG-signed 
and 
include
[Word Count: 6]

verification instructions for Windows, Linux, and macOS. As noted above, you can also verify
[Word Count: 14]

downloads on Windows and macOS using the code signature validation features on those systems.
[Word Count: 14]

In late 1997 Gerald Combs needed a tool for tracking down network problems and wanted to learn
[Word Count: 17]

more about networking so he started writing Ethereal (the original name of the Wireshark project)
[Word Count: 15]

Ethereal was initially released after several pauses in development in July 1998 as version 0.2.0.
[Word Count: 15]

Within days patches, bug reports, and words of encouragement started arriving and Ethereal was
[Word Count: 14]

Not long after that Gilbert Ramirez saw its potential and contributed a low-level dissector to it.
[Word Count: 16]

In October, 1998 Guy Harris was looking for something better than tcpview so he started applying
[Word Count: 16]

patches and contributing dissectors to Ethereal.
[Word Count: 6]

In late 1998 Richard Sharpe, who was giving TCP/IP courses, saw its potential on such courses and
[Word Count: 17]

started looking at it to see if it supported the protocols he needed. While it didn’t at that point new
[Word Count: 20]

protocols could be easily added. So he started contributing dissectors and contributing patches.
[Word Count: 13]

The list of people who have contributed to the project has become very long since then, and almost
[Word Count: 18]

all of them started with a protocol that they needed that Wireshark did not already handle. So they
[Word Count: 18]

copied an existing dissector and contributed the code back to the team.
[Word Count: 12]

In 2006 the project moved house and re-emerged under a new name: Wireshark.
[Word Count: 13]

In 2008, after ten years of development, Wireshark finally arrived at version 1.0. This release was
[Word Count: 16]

the first deemed complete, with the minimum features implemented. Its release coincided with the
[Word Count: 14]

first Wireshark Developer and User Conference, called Sharkfest.
[Word Count: 8]

In 2015 Wireshark 2.0 was released, which featured a new user interface.
[Word Count: 12]

In 2023 Wireshark moved to the Wireshark Foundation, a nonprofit corporation that operates
[Word Count: 13]

under section 501(c)(3) of the U.S. tax code. The foundation provides the project’s infrastructure,
[Word Count: 14]

hosts SharkFest, our developer and user conference, and promotes low level network education.
[Word Count: 13]

Development And Maintenance Of Wireshark
[Word Count: 5]

Wireshark was initially developed by Gerald Combs. Ongoing development and maintenance of
[Word Count: 12]

Wireshark is handled by the Wireshark team, a loose group of individuals who fix bugs and
[Word Count: 16]

There have also been a large number of people who have contributed protocol dissectors to
[Word Count: 15]

Wireshark, and it is expected that this will continue. You can find a list of the people who have
[Word Count: 19]

contributed code to Wireshark by checking the about dialog box of Wireshark, or at the authors
[Word Count: 16]

Wireshark is an open source software project, and is released under the GNU General Public
[Word Count: 15]

License (GPL) version 2. All source code is freely available under the GPL. You are welcome to
[Word Count: 17]

modify Wireshark to suit your own needs, and it would be appreciated if you contribute your
[Word Count: 16]

improvements back to the Wireshark team.
[Word Count: 6]

You gain three benefits by contributing your improvements back to the community:
[Word Count: 12]

1. Other people who find your contributions useful will appreciate them, and you will know that
[Word Count: 16]

you have helped people in the same way that the developers of Wireshark have helped you.
[Word Count: 16]

2. The developers of Wireshark can further improve your changes or implement additional
[Word Count: 13]

features on top of your code, which may also benefit you.
[Word Count: 11]

3. The maintainers and developers of Wireshark will maintain your code, fixing it when API
[Word Count: 15]

changes or other changes are made, and generally keeping it in tune with what is happening
[Word Count: 16]

with Wireshark. So when Wireshark is updated (which is often), you can get a new Wireshark
[Word Count: 16]

version from the website and your changes will already be included without any additional
[Word Count: 14]

The Wireshark source code and binary kits for some platforms are all available on the download
[Word Count: 16]

page of the Wireshark website: https://www.wireshark.org/download.html.
[Word Count: 6]

If you have problems or need help with Wireshark there are several places that may be of interest
[Word Count: 18]

You will find lots of useful information on the Wireshark homepage at https://www.wireshark.org/.
[Word Count: 13]

The Wireshark Wiki at https://wiki.wireshark.org/ provides a wide range of information related to
[Word Count: 13]

Wireshark and packet capture in general. You will find a lot of information not part of this user’s
[Word Count: 18]

guide. For example, it contains an explanation how to capture on a switched network, an ongoing
[Word Count: 16]

effort to build a protocol reference, protocol-specific information, and much more.
[Word Count: 11]

And best of all, if you would like to contribute your knowledge on a specific topic (maybe a network
[Word Count: 19]

protocol you know well), you can edit the wiki pages with your web browser.
[Word Count: 14]

The Wireshark Q&A site at https://ask.wireshark.org/ offers a resource where questions and
[Word Count: 12]

answers come together. You can search for questions asked before and see what answers were
[Word Count: 15]

given by people who knew about the issue. Answers are ranked, so you can easily pick out the best
[Word Count: 19]

ones. If your question hasn’t been discussed before you can post one yourself.
[Word Count: 13]

The Frequently Asked Questions lists often asked questions and their corresponding answers.
[Word Count: 12]

Before sending any mail to the mailing lists below, be sure to read the FAQ. It will
[Word Count: 17]

often answer any questions you might have. This will save yourself and others a lot
[Word Count: 15]

of time. Keep in mind that a lot of people are subscribed to the mailing lists.
[Word Count: 16]

You will find the FAQ inside Wireshark by clicking the menu item Help/Contents and selecting the
[Word Count: 16]

An online version is available at the Wireshark website at https://www.wireshark.org/faq.html. You
[Word Count: 12]

might prefer this online version, as it’s typically more up to date and the HTML format is easier to
[Word Count: 19]

There are several mailing lists of specific Wireshark topics available:
[Word Count: 10]

Information about new program releases, which usually appear about every six weeks.
[Word Count: 12]

Topics of interest to users of Wireshark. People typically post questions about using Wireshark
[Word Count: 14]

Topics of interest to developers of Wireshark. If you want to develop a protocol dissector or
[Word Count: 16]

update the user interface, join this list.
[Word Count: 7]

You can subscribe to each of these lists from the Wireshark web site: https://www.wireshark.org/
[Word Count: 14]

lists/. From there, you can choose which mailing list you want to subscribe to by clicking on the
[Word Count: 18]

Subscribe/Unsubscribe/Options button under the title of the relevant list. The links to the archives
[Word Count: 14]

You can search in the list archives to see if someone asked the same question some
[Word Count: 16]

time before and maybe already got an answer. That way you don’t have to wait until
[Word Count: 16]

NOTE
Before reporting any problems, please make sure you have installed the latest
[Word Count: 13]

When reporting problems with Wireshark please supply the following information:
[Word Count: 10]

1. The version number of Wireshark and the dependent libraries linked with it, such as Qt or GLib.
[Word Count: 18]

You can obtain this from Wireshark’s about box or the command wireshark -v.
[Word Count: 13]

2. Information about the platform you run Wireshark on (Windows, Linux, etc. and 32-bit, 64-bit,
[Word Count: 15]

3. A detailed description of your problem.
[Word Count: 7]

4. If you get an error/warning message, copy the text of that message (and also a few lines before
[Word Count: 19]

and after it, if there are some) so others may find the place where things go wrong. Please don’t
[Word Count: 19]

give something like: “I get a warning while doing x” as this won’t give a good idea where to look.
[Word Count: 20]

If you send capture files to the mailing lists be sure they don’t contain any
[Word Count: 15]

sensitive or confidential information like passwords or personally identifiable
[Word Count: 9]

In many cases you can use a tool like TraceWrangler to sanitize a capture file
[Word Count: 15]

Do not send large files (> 1 MB) to the mailing lists. Instead, provide a download
[Word Count: 16]

link. For bugs and feature requests, you can create an issue on GitLab Issues and
[Word Count: 15]

Reporting Crashes on UNIX/Linux platforms
[Word Count: 5]

When reporting crashes with Wireshark it is helpful if you supply the traceback information along
[Word Count: 15]

with the information mentioned in “Reporting Problems”.
[Word Count: 7]

You can obtain this traceback information with the following commands on UNIX or Linux (note
[Word Count: 15]

$ gdb `whereis wireshark | cut -f2 -d: | cut -d' ' -f2` core >& backtrace.txt
backtrace
^D
[Word Count: 18]

If you do not have gdb available, you will have to check out your operating system’s debugger.
[Word Count: 17]

Email backtrace.txt to wireshark-dev[AT]wireshark.org.
[Word Count: 4]

The Windows distributions don’t contain the symbol files (.pdb) because they are very large. You
[Word Count: 15]

can download them separately at https://www.wireshark.org/download/win64/all-versions/ .
[Word Count: 7]

As with all things there must be a beginning and so it is with Wireshark. To use Wireshark you
[Word Count: 19]

must first install it. If you are running Windows or macOS you can download an official release at
[Word Count: 18]

https://www.wireshark.org/download.html, install it, and skip the rest of this chapter.
[Word Count: 10]

If you are running another operating system such as Linux or FreeBSD you might want to install
[Word Count: 17]

from source. Several Linux distributions offer Wireshark packages but they commonly provide out-
[Word Count: 13]

of-date versions. No other versions of UNIX ship Wireshark so far. For that reason, you will need to
[Word Count: 18]

know where to get the latest version of Wireshark and how to install it.
[Word Count: 14]

This chapter shows you how to obtain source and binary packages and how to build Wireshark
[Word Count: 16]

1. Download the relevant package for your needs, e.g., source or binary distribution.
[Word Count: 13]

2. For source distributions, compile the source into a binary. This may involve building and/or
[Word Count: 15]

3. Install the binaries into their final destinations.
[Word Count: 8]

Obtaining the source and binary distributions
[Word Count: 6]

You can obtain both source and binary distributions from the Wireshark main page or the
[Word Count: 15]

download page at https://www.wireshark.org/download.html. Select the package most appropriate
[Word Count: 9]

The official Windows packages can be downloaded from the Wireshark main page or the download
[Word Count: 15]

page. Installer names contain the version and platform. For example, Wireshark-4.5.0-x64.exe
[Word Count: 11]

installs Wireshark 4.5.0 for Windows on 64-bit Intel processors. The Wireshark installer includes
[Word Count: 13]

Npcap which is required for packet capture. Windows packages automatically update. See Updating
[Word Count: 13]

Simply download the Wireshark installer from https://www.wireshark.org/download.html and
[Word Count: 8]

execute it. Official packages are signed by Wireshark Foundation. You can choose to install several
[Word Count: 15]

optional components and select the location of the installed package. The default settings are
[Word Count: 14]

On the Choose Components page of the installer you can select from the following:
[Word Count: 14]

• Wireshark - The network protocol analyzer that we all know and mostly love.
[Word Count: 14]

• TShark - A command-line network protocol analyzer. If you haven’t tried it you should.
[Word Count: 15]

• External Capture (extcap) - External Capture Interfaces
[Word Count: 8]

◦Androiddump - Provide capture interfaces from Android devices.
[Word Count: 8]

◦Etwdump - Provide an interface to read Event Tracing for Windows (ETW) event trace
[Word Count: 14]

◦Randpktdump - Provide an interface to the random packet generator. (see also randpkt)
[Word Count: 13]

◦Sshdump, Ciscodump, and Wifidump - Provide remote capture through SSH. (tcpdump,
[Word Count: 11]

◦UDPdump - Provide capture interface to receive UDP packets streamed from network
[Word Count: 12]

• Wireshark Start Menu Item - Add a shortcut to the start menu.
[Word Count: 13]

• Wireshark Desktop Icon - Add a Wireshark icon to the desktop.
[Word Count: 12]

• Associate trace file extensions with Wireshark - Associate standard network trace files to
[Word Count: 14]

By 
default 
Wireshark 
installs 
into 
%ProgramFiles%\Wireshark 
on 
32-bit 
Windows 
and
[Word Count: 10]

%ProgramFiles64%\Wireshark on 64-bit Windows. This expands to C:\Program Files\Wireshark on
[Word Count: 10]

The Wireshark installer contains the latest Npcap installer.
[Word Count: 8]

If you don’t have Npcap installed you won’t be able to capture live network traffic but you will still
[Word Count: 19]

be able to open saved capture files. By default the latest version of Npcap will be installed. If you
[Word Count: 19]

don’t wish to do this or if you wish to reinstall Npcap you can check the Install Npcap box as
[Word Count: 20]

For more information about Npcap see https://npcap.com/ and https://wiki.wireshark.org/Npcap.
[Word Count: 9]

For special cases, there are some command line parameters available:
[Word Count: 10]

• /S runs the installer or uninstaller silently with default values. The silent installer will not
[Word Count: 16]

• /desktopicon installation of the desktop icon, =yes - force installation, =no - don’t install,
[Word Count: 15]

otherwise use default settings. This option can be useful for a silent installer.
[Word Count: 13]

• /D sets the default installation directory ($INSTDIR), overriding InstallDir and InstallDirRegKey.
[Word Count: 12]

It must be the last parameter used in the command line and must not contain any quotes even if
[Word Count: 19]

• /NCRC disables the CRC check. We recommend against using this flag.
[Word Count: 12]

• /EXTRACOMPONENTS comma separated list of optional components to install. The following extcap
[Word Count: 13]

◦androiddump - Provide interfaces to capture from Android devices
[Word Count: 9]

◦ciscodump - Provide interfaces to capture from a remote Cisco router through SSH
[Word Count: 13]

◦randpktdump - Provide an interface to generate random captures using randpkt
[Word Count: 11]

◦sshdump - Provide interfaces to capture from a remote host through SSH using a remote
[Word Count: 15]

◦udpdump - Provide a UDP receiver that gets packets from network devices
[Word Count: 12]

> Wireshark-4.2.5-x64.exe /NCRC /S /desktopicon=yes /D=C:\Program Files\Foo
[Word Count: 7]

> Wireshark-4.2.5-x64.exe /S /EXTRACOMPONENTS=sshdump,udpdump
[Word Count: 4]

Running the installer without any parameters shows the normal interactive installer.
[Word Count: 11]

As mentioned above, the Wireshark installer also installs Npcap. If you prefer to install Npcap
[Word Count: 15]

manually or want to use a different version than the one included in the Wireshark installer, you
[Word Count: 17]

can download Npcap from the main Npcap site at https://npcap.com/.
[Word Count: 10]

Wireshark updates may also include a new version of Npcap. Manual Npcap updates instructions
[Word Count: 14]

can be found on the Npcap web site at https://npcap.com/. You may have to reboot your machine
[Word Count: 17]

You can uninstall Wireshark using the Programs and Features control panel. Select the “Wireshark”
[Word Count: 14]

entry to start the uninstallation procedure.
[Word Count: 6]

The Wireshark uninstaller provides several options for removal. The default is to remove the core
[Word Count: 15]

components but keep your personal settings and Npcap. Npcap is kept in case other programs need
[Word Count: 16]

You can uninstall Npcap independently of Wireshark using the Npcap entry in the Programs and
[Word Count: 15]

Features control panel. Remember that if you uninstall Npcap you won’t be able to capture
[Word Count: 15]

We strongly recommended using the binary installer for Windows unless you want to start
[Word Count: 14]

developing Wireshark on the Windows platform.
[Word Count: 6]

For further information how to obtain sources and build Wireshark for Windows from the sources
[Word Count: 15]

• https://www.wireshark.org/docs/wsdg_html_chunked/ChSrcObtain
[Word Count: 2]

• https://www.wireshark.org/docs/wsdg_html_chunked/ChSetupWindows
[Word Count: 2]

You may also want to have a look at the Development Wiki (https://wiki.wireshark.org/
[Word Count: 13]

Development) for the latest available development documentation.
[Word Count: 7]

The official macOS packages can be downloaded from the Wireshark main page or the download
[Word Count: 15]

page. They are signed by Wireshark Foundation. Packages are distributed as disk images (.dmg)
[Word Count: 14]

containing the application bundle. Package names contain the platform and version. To install
[Word Count: 13]

Wireshark simply open the disk image and drag Wireshark to your /Applications folder. macOS
[Word Count: 14]

packages automatically update. See Updating Wireshark for details.
[Word Count: 8]

In order to capture packets, you must install the “ChmodBPF” launch daemon. You can do so by
[Word Count: 17]

opening the Install ChmodBPF.pkg file in the Wireshark .dmg or from Wireshark itself by opening
[Word Count: 15]

Wireshark › About Wireshark selecting the “Folders” tab, and double-clicking “macOS Extras”.
[Word Count: 12]

The installer package includes Wireshark along with ChmodBPF and system path packages. See the
[Word Count: 14]

included Read me first.html file for more details.
[Word Count: 8]

In general installing the binary under your version of UNIX will be specific to the installation
[Word Count: 16]

methods used with your version of UNIX. For example, under AIX, you would use smit to install the
[Word Count: 18]

Wireshark binary package, while under Tru64 UNIX (formerly Digital UNIX) you would use setld.
[Word Count: 14]

Installing from RPMs under Red Hat and alike
[Word Count: 8]

Building RPMs from Wireshark’s source code results in several packages (most distributions follow
[Word Count: 13]

• The wireshark package contains the core Wireshark libraries and command-line tools.
[Word Count: 12]

• The wireshark or wireshark-qt package contains the Qt-based GUI.
[Word Count: 10]

Many distributions use yum or a similar package management tool to make installation of software
[Word Count: 15]

(including its dependencies) easier. If your distribution uses yum, use the following command to
[Word Count: 14]

install Wireshark together with the Qt GUI:
[Word Count: 7]

If you’ve built your own RPMs from the Wireshark sources you can install them by running, for
[Word Count: 17]

rpm -ivh wireshark-2.0.0-1.x86_64.rpm wireshark-qt-2.0.0-1.x86_64.rpm
[Word Count: 4]

If the above command fails because of missing dependencies, install the dependencies first, and
[Word Count: 14]

Installing from debs under Debian, Ubuntu and other Debian derivatives
[Word Count: 10]

If you can just install from the repository then use
[Word Count: 10]

Apt should take care of all of the dependency issues for you.
[Word Count: 12]

By installing Wireshark packages non-root, users won’t gain rights automatically to
[Word Count: 11]

capture packets. To allow non-root users to capture packets follow the procedure
[Word Count: 12]

described 
in 
https://gitlab.com/wireshark/wireshark/-/blob/master/packaging/
[Word Count: 3]

debian/README.Debian (/usr/share/doc/wireshark-common/README.Debian.gz)
[Word Count: 2]

Installing from portage under Gentoo Linux
[Word Count: 6]

Use the following command to install Wireshark under Gentoo Linux with all of the extra features:
[Word Count: 16]

USE="c-ares ipv6 snmp ssl kerberos threads selinux" emerge wireshark
[Word Count: 9]

Use the following command to install Wireshark under FreeBSD:
[Word Count: 9]

pkg_add should take care of all of the dependency issues for you.
[Word Count: 12]

Building from source under UNIX or Linux
[Word Count: 7]

We recommended using the binary installer for your platform unless you want to start developing
[Word Count: 15]

Building Wireshark requires the proper build environment including a compiler and many
[Word Count: 12]

supporting libraries. For more information, see the Developer’s Guide at:
[Word Count: 10]

• https://www.wireshark.org/docs/wsdg_html_chunked/ChSrcObtain
[Word Count: 2]

• https://www.wireshark.org/docs/wsdg_html_chunked/ChapterSetup#ChSetupUNIX
[Word Count: 2]

By default, Wireshark on Windows and macOS will check for new versions and notify you when
[Word Count: 16]

they are available. If you have the Check for updates preference disabled or if you run Wireshark in
[Word Count: 18]

an isolated environment you should subscribe to the wireshark-announce mailing list to be notified
[Word Count: 14]

of new versions. See Mailing Lists for details on subscribing to this list.
[Word Count: 13]

New versions of Wireshark are usually released every four to six weeks. Updating Wireshark is
[Word Count: 15]

done the same way as installing it. Simply download and run the installer on Windows, or
[Word Count: 16]

download and drag the application on macOS. A reboot is usually not required and all your
[Word Count: 16]

personal settings will remain unchanged.
[Word Count: 5]

We offer two update channels, Stable and Development. The Stable channel is the default, and only
[Word Count: 16]

installs packages from stable (even-numbered) release branches. The Development channel installs
[Word Count: 11]

development and release candidate packages when they are available, and stable releases
[Word Count: 12]

otherwise. To configure your release channel, go to Preferences › Advanced and search for
[Word Count: 14]

“update.channel”. See Preferences for details.
[Word Count: 5]

By now you have installed Wireshark and are likely keen to get started capturing your first packets.
[Word Count: 17]

• How the Wireshark user interface works
[Word Count: 7]

You can start Wireshark from your shell or window manager.
[Word Count: 10]

When starting Wireshark it’s possible to specify optional settings using the command
[Word Count: 12]

line. See Start Wireshark from the command line for details.
[Word Count: 10]

The following chapters contain many screenshots of Wireshark. As Wireshark runs on many
[Word Count: 13]

different platforms with many different window managers, different styles applied and there are
[Word Count: 13]

different versions of the underlying GUI toolkit used, your screen might look different from the
[Word Count: 15]

provided screenshots. But as there are no real differences in functionality these screenshots should
[Word Count: 14]

Let’s look at Wireshark’s user interface. The Main window shows Wireshark as you would usually
[Word Count: 15]

see it after some packets are captured or loaded (how to do this will be described later).
[Word Count: 17]

Wireshark’s main window consists of parts that are commonly known from many other GUI
[Word Count: 14]

1. The menu (see The Menu) is used to start actions.
[Word Count: 11]

2. The main toolbar (see The “Main” Toolbar) provides quick access to frequently used items from
[Word Count: 16]

3. The filter toolbar (see The “Filter” Toolbar) allows users to set display filters to filter which
[Word Count: 17]

packets are displayed (see Filtering Packets While Viewing).
[Word Count: 8]

4. The packet list pane (see The “Packet List” Pane) displays a summary of each packet captured. By
[Word Count: 18]

clicking on packets in this pane you control what is displayed in the other two panes.
[Word Count: 16]

5. The packet details pane (see The “Packet Details” Pane) displays the packet selected in the packet
[Word Count: 17]

6. The packet bytes pane (see The “Packet Bytes” Pane) displays the data from the packet selected in
[Word Count: 18]

the packet list pane, and highlights the field selected in the packet details pane.
[Word Count: 14]

7. The packet diagram pane (see The “Packet Diagram” Pane) displays the packet selected in the
[Word Count: 16]

packet list as a textbook-style diagram.
[Word Count: 6]

8. The statusbar (see The Statusbar) shows some detailed information about the current program
[Word Count: 14]

TIP
The layout of the main window can be customized by changing preference settings.
[Word Count: 14]

Packet list and detail navigation can be done entirely from the keyboard. Keyboard Navigation
[Word Count: 14]

shows a list of keystrokes that will let you quickly move around a capture file. See Go menu items
[Word Count: 19]

Tab  or Shift  +  Tab
Move between screen elements, e.g., from the toolbars to the packet list to
[Word Count: 18]

↓
Move to the next packet or detail item.
[Word Count: 9]

↑
Move to the previous packet or detail item.
[Word Count: 9]

Ctrl  +  ↓ or F8
Move to the next packet, even if the packet list isn’t focused.
[Word Count: 17]

Ctrl  +  ↑ or F7
Move to the previous packet, even if the packet list isn’t focused.
[Word Count: 17]

Ctrl  +  .
Move to the next packet of the conversation (TCP, UDP or IP).
[Word Count: 15]

Ctrl  +  ,
Move to the previous packet of the conversation (TCP, UDP or IP).
[Word Count: 15]

Move to the next packet in the selection history.
[Word Count: 9]

Move to the previous packet in the selection history.
[Word Count: 9]

←
In the packet detail, closes the selected tree item. If it’s already closed,
[Word Count: 14]

→
In the packet detail, opens the selected tree item.
[Word Count: 10]

Shift  +  →
In the packet detail, opens the selected tree item and all of its subtrees.
[Word Count: 17]

Ctrl  +  →
In the packet detail, opens all tree items.
[Word Count: 11]

Ctrl  +  ←
In the packet detail, closes all tree items.
[Word Count: 11]

Backspace
In the packet detail, jumps to the parent node.
[Word Count: 10]

Return  or Enter
In the packet detail, toggles the selected tree item.
[Word Count: 12]

Help › About Wireshark › Keyboard Shortcuts will show a list of all shortcuts in the main
[Word Count: 17]

window. Additionally, typing anywhere in the main window will start filling in a display filter.
[Word Count: 15]

Wireshark’s main menu is located either at the top of the main window (Windows, Linux) or at the
[Word Count: 18]

top of your main screen (macOS). An example is shown in The Menu.
[Word Count: 13]

Some menu items will be disabled (greyed out) if the corresponding feature isn’t
[Word Count: 13]

available. For example, you cannot save a capture file if you haven’t captured or
[Word Count: 14]

The main menu contains the following items:
[Word Count: 7]

This menu contains items to open and merge capture files, save, print, or export capture files in
[Word Count: 17]

whole or in part, and to quit the Wireshark application. See The “File” Menu.
[Word Count: 14]

This menu contains items to find a packet, time reference or mark one or more packets, handle
[Word Count: 17]

configuration profiles, and set your preferences; (cut, copy, and paste are not presently
[Word Count: 13]

This menu controls the display of the captured data, including colorization of packets, zooming
[Word Count: 14]

the font, showing a packet in a separate window, expanding and collapsing trees in packet
[Word Count: 15]

This menu contains items to go to a specific packet. See The “Go” Menu.
[Word Count: 14]

This menu allows you to start and stop captures and to edit capture filters. See The “Capture”
[Word Count: 17]

This menu contains items to manipulate display filters, enable or disable the dissection of
[Word Count: 14]

protocols, configure user specified decodes and follow a TCP stream. See The “Analyze” Menu.
[Word Count: 14]

This menu contains items to display various statistic windows, including a summary of the
[Word Count: 14]

packets that have been captured, display protocol hierarchy statistics and much more. See The
[Word Count: 14]

This menu contains items to display various telephony related statistic windows, including a
[Word Count: 13]

media analysis, flow diagrams, display protocol hierarchy statistics and much more. See The
[Word Count: 13]

This menu contains items to display Bluetooth and IEEE 802.11 wireless statistics.
[Word Count: 12]

This menu contains various tools available in Wireshark, such as creating Firewall ACL Rules.
[Word Count: 14]

This menu contains items to help the user, e.g., access to some basic help, manual pages of the
[Word Count: 18]

various command line tools, online access to some of the webpages, and the usual about dialog.
[Word Count: 16]

Each of these menu items is described in more detail in the sections that follow.
[Word Count: 15]

Most common menu items have keyboard shortcuts. For example, you can press the
[Word Count: 13]

Control and the K keys together to open the “Capture Options” dialog.
[Word Count: 12]

The Wireshark file menu contains the fields shown in File menu items.
[Word Count: 12]

Open…
Ctrl  +  O
This shows the file open dialog box that allows
[Word Count: 13]

you to load a capture file for viewing. It is
[Word Count: 10]

discussed in more detail in The “Open Capture
[Word Count: 8]

Open Recent
This lets you open recently opened capture files.
[Word Count: 10]

Clicking on one of the submenu items will open
[Word Count: 9]

the corresponding capture file directly.
[Word Count: 5]

Merge…
This menu item lets you merge a capture file
[Word Count: 10]

into the currently loaded one. It is discussed in
[Word Count: 9]

Import from Hex Dump…
This menu item brings up the import file dialog
[Word Count: 13]

box that allows you to import a text file
[Word Count: 9]

containing a hex dump into a new temporary
[Word Count: 8]

capture. It is discussed in more detail in Import
[Word Count: 9]

Close
Ctrl  +  W
This menu item closes the current capture. If
[Word Count: 12]

you haven’t saved the capture, you will be asked
[Word Count: 9]

to do so first (this can be disabled by a
[Word Count: 10]

Save
Ctrl  +  S
This menu item saves the current capture. If you
[Word Count: 13]

have not set a default capture file name
[Word Count: 8]

Wireshark pops up the Save Capture File As
[Word Count: 8]

dialog box (which is discussed further in The
[Word Count: 8]

If you have already saved the current capture,
[Word Count: 8]

You cannot save a live capture while the capture
[Word Count: 9]

is in progress. You must stop the capture in
[Word Count: 9]

Save As…
Shift  +  Ctrl  +  S
This menu item allows you to save the current
[Word Count: 16]

capture file to whatever file you would like. It
[Word Count: 9]

pops up the Save Capture File As dialog box
[Word Count: 9]

(which is discussed further in The “Save Capture
[Word Count: 8]

File Set › List Files
This menu item allows you to show a list of files
[Word Count: 16]

in a file set. It pops up the Wireshark List File Set
[Word Count: 12]

dialog box (which is discussed further in File
[Word Count: 8]

File Set › Next File
If the currently loaded file is part of a file set,
[Word Count: 16]

jump to the next file in the set. If it isn’t part of a
[Word Count: 14]

file set or just the last file in that set, this item is
[Word Count: 13]

File Set › Previous File
If the currently loaded file is part of a file set,
[Word Count: 16]

jump to the previous file in the set. If it isn’t part
[Word Count: 12]

of a file set or just the first file in that set, this
[Word Count: 13]

Export Specified Packets…
This menu item allows you to export all (or
[Word Count: 12]

some) of the packets in the capture file to file. It
[Word Count: 11]

pops up the Wireshark Export dialog box (which
[Word Count: 8]

is discussed further in Exporting Data).
[Word Count: 6]

Ctrl  +  H
These menu items allow you to export the
[Word Count: 11]

currently selected bytes in the packet bytes pane
[Word Count: 8]

to a text file in a number of formats including
[Word Count: 10]

plain, CSV, and XML. It is discussed further in
[Word Count: 9]

The “Export Selected Packet Bytes” Dialog Box.
[Word Count: 7]

Export Objects
These menu items allow you to export captured
[Word Count: 10]

DICOM, FTP-DATA, HTTP, IMF, SMB, or TFTP
[Word Count: 7]

corresponding object list (which is discussed
[Word Count: 6]

further in The “Export Objects” Dialog Box)
[Word Count: 7]

Print…
Ctrl  +  P
This menu item allows you to print all (or some)
[Word Count: 14]

of the packets in the capture file. It pops up the
[Word Count: 11]

Wireshark Print dialog box (which is discussed
[Word Count: 7]

Quit
Ctrl  +  Q
This menu item allows you to quit from
[Word Count: 12]

Wireshark. Wireshark will ask to save your
[Word Count: 7]

capture file if you haven’t previously saved it
[Word Count: 8]

(this can be disabled by a preference setting).
[Word Count: 8]

The Wireshark Edit menu contains the fields shown in Edit menu items.
[Word Count: 12]

Copy
These menu items will copy the packet list,
[Word Count: 9]

packet detail, or properties of the currently
[Word Count: 7]

Find Packet…
Ctrl  +  F
This menu item brings up a toolbar that allows
[Word Count: 14]

you to find a packet by many criteria. There is
[Word Count: 10]

further information on finding packets in
[Word Count: 6]

Find Next
Ctrl  +  N
This menu item tries to find the next packet
[Word Count: 14]

matching the settings from “Find Packet…”.
[Word Count: 6]

Find Previous
Ctrl  +  B
This menu item tries to find the previous packet
[Word Count: 14]

matching the settings from “Find Packet…”.
[Word Count: 6]

Mark/Unmark Selected
Ctrl  +  M
This menu item marks the currently selected
[Word Count: 12]

packet. See Marking Packets for details.
[Word Count: 6]

Mark All Displayed Packets Ctrl  +  Shift  +  M
This menu item marks all displayed packets.
[Word Count: 16]

Ctrl  +  Alt  +  M
This menu item unmarks all displayed packets.
[Word Count: 12]

Next Mark
Ctrl  +  Shift  +  N
Find the next marked packet.
[Word Count: 12]

Previous Mark
Ctrl  +  Shift  +  B
Find the previous marked packet.
[Word Count: 12]

Ignore/Unignore Selected
Ctrl  +  D
This menu item marks the currently selected
[Word Count: 12]

packet as ignored. See Ignoring Packets for
[Word Count: 7]

Ignore All Displayed
Ctrl  +  Shift  +  D
This menu item marks all displayed packets as
[Word Count: 16]

Unignore All Displayed
Ctrl  +  Alt  +  D
This menu item unmarks all ignored packets.
[Word Count: 15]

Set/Unset Time Reference
Ctrl  +  T
This menu item set a time reference on the
[Word Count: 15]

currently selected packet. See Packet Time
[Word Count: 6]

Referencing for more information about the
[Word Count: 6]

Unset All Time References
Ctrl  +  Alt  +  T
This menu item removes all time references on
[Word Count: 17]

Next Time Reference
Ctrl  +  Alt  +  N
This menu item tries to find the next time
[Word Count: 17]

Previous Time Reference
Ctrl  +  Alt  +  B
This menu item tries to find the previous time
[Word Count: 17]

Time Shift…
Ctrl  +  Shift  +  T
Opens the “Time Shift” dialog, which allows you
[Word Count: 15]

to adjust the timestamps of some or all packets.
[Word Count: 9]

Packet Comment…
Ctrl  +  Alt  +  C
Opens the “Packet Comment” dialog, which lets
[Word Count: 14]

you add a comment to a single packet. Note that
[Word Count: 10]

the ability to save packet comments depends on
[Word Count: 8]

This will delete all comments from all packets.
[Word Count: 8]

Note that the ability to save capture comments
[Word Count: 8]

depends on your file format. E.g., pcapng
[Word Count: 7]

Inject TLS Secrets
Embeds the used TLS decryption secrets into the
[Word Count: 11]

capture file, which lets TLS be decrypted
[Word Count: 7]

without having the separate keylog file. Note
[Word Count: 7]

that the ability to save decryption secrets
[Word Count: 7]

depends on your file format. E.g., pcapng
[Word Count: 7]

supports Decryption Secrets Blocks, pcap does
[Word Count: 6]

Discard All Secrets
This will discard all embedded decryption
[Word Count: 9]

secrets from the capture file. Note that the
[Word Count: 8]

ability to save decryption secrets depends on
[Word Count: 7]

Decryption Secrets Blocks, pcap does not.
[Word Count: 6]

Configuration Profiles…
Ctrl  +  Shift  +  A
This menu item brings up a dialog box for
[Word Count: 16]

handling configuration profiles. More detail is
[Word Count: 6]

This menu item brings up a dialog box that
[Word Count: 9]

parameters that control Wireshark. You can also
[Word Count: 7]

save your preferences so Wireshark will use
[Word Count: 7]

them the next time you start it. More detail is
[Word Count: 10]

The Wireshark View menu contains the fields shown in View menu items.
[Word Count: 12]

Main Toolbar
This menu item hides or shows the main toolbar,
[Word Count: 11]

Filter Toolbar
This menu item hides or shows the filter toolbar,
[Word Count: 11]

Wireless Toolbar
This menu item hides or shows the wireless
[Word Count: 10]

toolbar. May not be present on some platforms.
[Word Count: 8]

Statusbar
This menu item hides or shows the statusbar,
[Word Count: 9]

Packet List
This menu item hides or shows the packet list
[Word Count: 11]

Packet Details
This menu item hides or shows the packet
[Word Count: 10]

details pane, see The “Packet Details” Pane.
[Word Count: 7]

Packet Bytes
This menu item hides or shows the packet bytes
[Word Count: 11]

Packet Diagram
This menu item hides or shows the packet
[Word Count: 10]

diagram pane. See The “Packet Diagram” Pane.
[Word Count: 7]

Selecting this tells Wireshark to display the time
[Word Count: 8]

stamps in date and time of day format, see Time
[Word Count: 10]

The fields “Time of Day”, “Date and Time of
[Word Count: 9]

Day”, “Seconds Since First Captured Packet”,
[Word Count: 6]

“Seconds Since Previous Captured Packet” and
[Word Count: 6]

“Seconds Since Previous Displayed Packet” are
[Word Count: 6]

Selecting this tells Wireshark to display time
[Word Count: 7]

stamps in time of day format, see Time Display
[Word Count: 9]

Selecting this tells Wireshark to display time
[Word Count: 7]

stamps in seconds since 1970-01-01 00:00:00, see
[Word Count: 7]

Time Display Formats And Time References.
[Word Count: 6]

Selecting this tells Wireshark to display time
[Word Count: 7]

stamps in seconds since first captured packet
[Word Count: 7]

format, see Time Display Formats And Time
[Word Count: 7]

Selecting this tells Wireshark to display time
[Word Count: 7]

stamps in seconds since previous captured
[Word Count: 6]

packet format, see Time Display Formats And
[Word Count: 7]

Selecting this tells Wireshark to display time
[Word Count: 7]

stamps in seconds since previous displayed
[Word Count: 6]

packet format, see Time Display Formats And
[Word Count: 7]

Selecting this tells Wireshark to display time
[Word Count: 7]

stamps with the precision given by the capture
[Word Count: 8]

file format used, see Time Display Formats And
[Word Count: 8]

The fields “Automatic”, “Seconds” and “…
[Word Count: 6]

Selecting this tells Wireshark to display time
[Word Count: 7]

stamps with a precision of one second, see Time
[Word Count: 9]

Selecting this tells Wireshark to display time
[Word Count: 7]

microsecond or nanosecond, see Time Display
[Word Count: 6]

Selecting this tells Wireshark to display time
[Word Count: 7]

stamps in seconds, with hours and minutes.
[Word Count: 7]

This item allows you to manually enter names to
[Word Count: 9]

resolve IP addresses in the current packet, see
[Word Count: 8]

This item allows you to control whether or not
[Word Count: 9]

Wireshark translates MAC addresses into names,
[Word Count: 6]

This item allows you to control whether or not
[Word Count: 9]

Wireshark translates network addresses into
[Word Count: 5]

This item allows you to control whether or not
[Word Count: 9]

Wireshark translates transport addresses into
[Word Count: 5]

Zoom In
Ctrl  +  +
Zoom into the packet data (increase the font
[Word Count: 13]

Zoom Out
Ctrl  +  -
Zoom out of the packet data (decrease the font
[Word Count: 14]

Normal Size
Ctrl  +  =
Set zoom level back to 100% (set font size back to
[Word Count: 16]

Expand Subtrees
Shift  +  →
This menu item expands the currently selected
[Word Count: 12]

Collapse Subtrees
Shift  +  ←
This menu item collapses the currently selected
[Word Count: 12]

Expand All
Ctrl  +  →
Wireshark keeps a list of all the protocol
[Word Count: 13]

subtrees that are expanded, and uses it to
[Word Count: 8]

ensure that the correct subtrees are expanded
[Word Count: 7]

when you display a packet. This menu item
[Word Count: 8]

expands all subtrees in all packets in the
[Word Count: 8]

Collapse All
Ctrl  +  ←
This menu item collapses the tree view of all
[Word Count: 14]

Colorize Packet List
This item allows you to control whether or not
[Word Count: 12]

Wireshark should colorize the packet list.
[Word Count: 6]

Enabling colorization will slow down the display
[Word Count: 7]

of new packets while capturing or loading
[Word Count: 7]

Colorize Conversation
This menu item brings up a submenu that allows
[Word Count: 11]

you to color packets in the packet list pane based
[Word Count: 10]

on the addresses of the currently selected
[Word Count: 7]

packet. This makes it easy to distinguish packets
[Word Count: 8]

belonging to different conversations. Packet
[Word Count: 5]

temporary color filters based on the currently
[Word Count: 7]

This menu item clears all temporary coloring
[Word Count: 7]

This menu item opens a dialog window in which
[Word Count: 9]

a new permanent coloring rule can be created
[Word Count: 8]

based on the currently selected conversation.
[Word Count: 6]

Coloring Rules…
This menu item brings up a dialog box that
[Word Count: 11]

allows you to color packets in the packet list
[Word Count: 9]

pane according to filter expressions you choose.
[Word Count: 7]

It can be very useful for spotting certain types of
[Word Count: 10]

Resize All Columns
Shift  +  Ctrl  +  R
Resize all column widths so the content will fit
[Word Count: 17]

Resizing may take a significant amount of time,
[Word Count: 8]

especially if a large capture file is loaded.
[Word Count: 8]

Internals
Information about various internal data
[Word Count: 6]

structures. See Internals menu items below for
[Word Count: 7]

Shows the selected packet in a separate window.
[Word Count: 8]

The separate window shows only the packet
[Word Count: 7]

details and bytes of that packet, and will
[Word Count: 8]

continue to do so even if another packet is
[Word Count: 9]

selected in the main window. See Viewing a
[Word Count: 8]

packet in a separate window for details.
[Word Count: 7]

Reload
Ctrl  +  R
This menu item allows you to reload the current
[Word Count: 13]

Conversation Hash Tables
Shows the tuples (address and port combinations) used to
[Word Count: 12]

Dissector Tables
Shows tables of subdissector relationships.
[Word Count: 7]

Supported Protocols
Displays supported protocols and protocol fields.
[Word Count: 8]

The Wireshark Go menu contains the fields shown in Go menu items.
[Word Count: 12]

Back
Alt  +  ←
Jump to the recently visited packet in the packet
[Word Count: 13]

history, much like the page history in a web
[Word Count: 9]

Forward
Alt  +  →
Jump to the next visited packet in the packet
[Word Count: 13]

history, much like the page history in a web
[Word Count: 9]

Go to Packet…
Ctrl  +  G
Bring up a window frame that allows you to
[Word Count: 15]

specify a packet number, and then goes to that
[Word Count: 9]

packet. See Go To A Specific Packet for details.
[Word Count: 9]

Go to the corresponding packet of the currently
[Word Count: 8]

selected protocol field (e.g., the reply
[Word Count: 6]

corresponding to a request packet, or vice
[Word Count: 7]

versa). If the selected field doesn’t correspond to
[Word Count: 8]

Previous Packet
Ctrl  +  ↑
Move to the previous packet in the list. This can
[Word Count: 15]

be used to move to the previous packet even if
[Word Count: 10]

the packet list doesn’t have keyboard focus.
[Word Count: 7]

Next Packet
Ctrl  +  ↓
Move to the next packet in the list. This can be
[Word Count: 16]

used to move to the previous packet even if the
[Word Count: 10]

packet list doesn’t have keyboard focus.
[Word Count: 6]

First Packet
Ctrl  +  Home
Jump to the first packet of the capture file.
[Word Count: 14]

Last Packet
Ctrl  +  End
Jump to the last packet of the capture file.
[Word Count: 14]

Ctrl  +  ,
Move to the previous packet in the current
[Word Count: 11]

conversation. This can be used to move to the
[Word Count: 9]

previous packet even if the packet list doesn’t
[Word Count: 8]

Ctrl  +  .
Move to the next packet in the current
[Word Count: 11]

conversation. This can be used to move to the
[Word Count: 9]

previous packet even if the packet list doesn’t
[Word Count: 8]

Auto Scroll in Live Capture
This item allows you to specify that Wireshark
[Word Count: 13]

should scroll the packet list pane as new packets
[Word Count: 9]

come in, so you are always looking at the last
[Word Count: 10]

packet. If you do not specify this, Wireshark
[Word Count: 8]

simply adds new packets onto the end of the list,
[Word Count: 10]

but does not scroll the packet list pane.
[Word Count: 8]

The Wireshark Capture menu contains the fields shown in Capture menu items.
[Word Count: 12]

Options…
Ctrl  +  K
Shows the Capture Options dialog box, which
[Word Count: 11]

allows you to configure interfaces and capture
[Word Count: 7]

options. See The “Capture Options” Dialog Box.
[Word Count: 7]

Start
Ctrl  +  E
Immediately starts capturing packets with the
[Word Count: 10]

Stop
Ctrl  +  E
Stops the currently running capture. See Stop
[Word Count: 11]

Restart
Ctrl  +  R
Stops the currently running capture and starts it
[Word Count: 12]

Capture Filters…
Shows a dialog box that allows you to create and
[Word Count: 12]

edit capture filters. You can name filters and
[Word Count: 8]

save them for future use. See Defining And
[Word Count: 8]

Refresh Interfaces
F5
Clear and recreate the interface list.
[Word Count: 9]

The Wireshark Analyze menu contains the fields shown in Analyze menu items.
[Word Count: 12]

Display Filters…
Displays a dialog box that allows you to create
[Word Count: 11]

and edit display filters. You can name filters, and
[Word Count: 9]

you can save them for future use. See Defining
[Word Count: 9]

Display Filter Macros…
Shows a dialog box that allows you to create and
[Word Count: 13]

edit display filter macros. You can name filter
[Word Count: 8]

macros, and you can save them for future use.
[Word Count: 9]

Display Filter Expression…
Shows a dialog box that allows you to build a
[Word Count: 13]

display filter expression to apply. This shows
[Word Count: 7]

possible fields and their applicable relations and
[Word Count: 7]

values, and allows you to search by name and
[Word Count: 9]

description. See The “Display Filter Expression”
[Word Count: 6]

Apply as Column
Shift  +  Ctrl  +  I
Adds the selected protocol item in the packet
[Word Count: 16]

details pane as a column to the packet list.
[Word Count: 9]

Apply as Filter
Change the current display filter and apply it
[Word Count: 11]

immediately. Depending on the chosen menu
[Word Count: 6]

item, the current display filter string will be
[Word Count: 8]

replaced or appended to by the selected protocol
[Word Count: 8]

Prepare as Filter
Change the current display filter but won’t apply
[Word Count: 11]

it. Depending on the chosen menu item, the
[Word Count: 8]

current display filter string will be replaced or
[Word Count: 8]

appended to by the selected protocol field in the
[Word Count: 9]

Conversation Filter
Apply a conversation filter for various protocols.
[Word Count: 9]

Enabled Protocols…
Shift  +  Ctrl  +  E
Enable or disable various protocol dissectors.
[Word Count: 13]

Decode As…
Decode certain packets as a particular protocol.
[Word Count: 9]

SCTP
Allows you to analyze and prepare a filter for
[Word Count: 10]

this SCTP association. See SCTP Windows.
[Word Count: 6]

Follow
Opens a sub-menu with options of various types
[Word Count: 9]

of protocol streams to follow. The entries for
[Word Count: 8]

protocols which aren’t found in the currently
[Word Count: 7]

selected packet will be disabled. See đFollowing
[Word Count: 7]

Show Packet Bytes
Open a window allowing for decoding and
[Word Count: 10]

reformatting packet bytes. You can do actions
[Word Count: 7]

like Base64 decode, decompress, interpret as a
[Word Count: 7]

different character encoding, interpret bytes as
[Word Count: 6]

an image format, and save, print, or copy to the
[Word Count: 10]

clipboard the results. See Show Packet Bytes for
[Word Count: 8]

Expert Info
Open a window showing expert information
[Word Count: 8]

found in the capture. Some protocol dissectors
[Word Count: 7]

add packet detail items for notable or unusual
[Word Count: 8]

retransmissions. Those items are shown here.
[Word Count: 6]

See Expert Information for more information.
[Word Count: 6]

The amount of information will vary depend on
[Word Count: 8]

The Wireshark Statistics menu contains the fields shown in Statistics menu items.
[Word Count: 12]

Each menu item brings up a new window showing specific statistics.
[Word Count: 11]

Capture File Properties
Show information about the capture file, see The
[Word Count: 11]

Resolved Addresses
See Resolved Addresses
[Word Count: 5]

Protocol Hierarchy
Display a hierarchical tree of protocol statistics,
[Word Count: 9]

Conversations
Display a list of conversations (traffic between
[Word Count: 8]

Endpoints
Display a list of endpoints (traffic to/from an
[Word Count: 9]

I/O Graphs
Display user specified graphs (e.g., the number
[Word Count: 9]

of packets in the course of time), see The “I/O
[Word Count: 10]

Service Response Time
Display the time between a request and the
[Word Count: 11]

corresponding response, see Service Response
[Word Count: 5]

DHCP (BOOTP)
See DHCP (BOOTP) Statistics
[Word Count: 6]

NetPerfMeter
See NetPerfMeter Statistics
[Word Count: 4]

HTTP
HTTP request/response statistics, see HTTP
[Word Count: 6]

UDP Multicast Streams
See UDP Multicast Streams
[Word Count: 7]

The Wireshark Telephony menu contains the fields shown in Telephony menu items.
[Word Count: 12]

Each menu item shows specific telephony related statistics.
[Word Count: 8]

IAX2 Stream Analysis
See IAX2 Stream Analysis Window
[Word Count: 8]

RTP
See RTP Streams Window and RTP Stream
[Word Count: 8]

SMPP Operations
See SMPP Operations Window
[Word Count: 6]

SIP Statistics
See SIP Statistics Window
[Word Count: 6]

WAP-WSP Packet Counter
See WAP-WSP Packet Counter Window
[Word Count: 8]

The Wireless menu lets you analyze Bluetooth and IEEE 802.11 wireless LAN activity as shown in
[Word Count: 16]

Each menu item shows specific Bluetooth and IEEE 802.11 statistics.
[Word Count: 10]

Bluetooth HCI Summary
See Bluetooth HCI Summary
[Word Count: 7]

The Wireshark Tools menu contains the fields shown in Tools menu items.
[Word Count: 12]

Firewall ACL Rules
This allows you to create command-line ACL
[Word Count: 10]

rules for many different firewall products,
[Word Count: 6]

including Cisco IOS, Linux Netfilter (iptables),
[Word Count: 6]

OpenBSD pf and Windows Firewall (via netsh).
[Word Count: 7]

Rules for MAC addresses, IPv4 addresses, TCP
[Word Count: 7]

and UDP ports, and IPv4+port combinations are
[Word Count: 7]

It is assumed that the rules will be applied to an
[Word Count: 11]

Menu item is greyed out unless one (and only
[Word Count: 9]

one) frame is selected in the packet list.
[Word Count: 8]

Credentials
This allows you to extract credentials from the
[Word Count: 9]

current capture file. Some of the dissectors (ftp,
[Word Count: 8]

http, imap, pop, smtp) have been instrumented
[Word Count: 7]

to provide the module with usernames and
[Word Count: 7]

passwords and more will be instrumented in the
[Word Count: 8]

future. The window dialog provides you the
[Word Count: 7]

packet number where the credentials have been
[Word Count: 7]

found, the protocol that provided them, the
[Word Count: 7]

username and protocol specific information.
[Word Count: 5]

MAC Address Blocks
This allows viewing the IEEE MAC address
[Word Count: 10]

registry data that Wireshark uses to resolve MAC
[Word Count: 8]

address blocks to vendor names. The table can
[Word Count: 8]

be searched by address prefix or vendor name.
[Word Count: 8]

TLS Keylog Launcher
This can launch an application such as a web
[Word Count: 12]

SSLKEYLOGFILE environment variable set to the
[Word Count: 6]

same value as the TLS secret log file. Note that
[Word Count: 10]

you will probably have to quit your existing web
[Word Count: 9]

browser session in order to have it run under a
[Word Count: 10]

Lua Console
This option allows you to work with the Lua
[Word Count: 11]

interpreter optionally built into Wireshark, to
[Word Count: 6]

inspect Lua internals and evaluate code. See
[Word Count: 7]

“Lua Support in Wireshark” in the Wireshark
[Word Count: 7]

The Wireshark Help menu contains the fields shown in Help menu items.
[Word Count: 12]

User’s Guide
F1
This menu item brings up the Wireshark User’s
[Word Count: 11]

Manual Pages › …
This menu item starts a Web browser showing
[Word Count: 12]

one of the locally installed html manual pages.
[Word Count: 8]

Website
This menu item starts a Web browser showing
[Word Count: 9]

the webpage from: https://www.wireshark.org/.
[Word Count: 4]

FAQs
This menu item starts a Web browser showing
[Word Count: 9]

Downloads
This menu item starts a Web browser showing
[Word Count: 9]

the downloads from: https://www.wireshark.org/
[Word Count: 4]

Wiki
This menu item starts a Web browser showing
[Word Count: 9]

the front page from: https://wiki.wireshark.org/.
[Word Count: 5]

Sample Captures
This menu item starts a Web browser showing
[Word Count: 10]

https://wiki.wireshark.org/SampleCaptures.
[Word Count: 1]

About Wireshark
This menu item brings up an information
[Word Count: 9]

information items on Wireshark, such as how
[Word Count: 7]

it’s built, the plugins loaded, the used folders, …
[Word Count: 9]

Opening a Web browser might be unsupported in your version of Wireshark. If this
[Word Count: 14]

is the case the corresponding menu items will be hidden.
[Word Count: 10]

If calling a Web browser fails on your machine, nothing happens, or the browser
[Word Count: 14]

starts but no page is shown, have a look at the web browser setting in the
[Word Count: 16]

The main toolbar provides quick access to frequently used items from the menu. This toolbar
[Word Count: 15]

cannot be customized by the user, but it can be hidden using the View menu if the space on the
[Word Count: 20]

screen is needed to show more packet data.
[Word Count: 8]

Items in the toolbar will be enabled or disabled (greyed out) similar to their corresponding menu
[Word Count: 16]

items. For example, in the image below shows the main window toolbar after a file has been
[Word Count: 17]

opened. Various file-related buttons are enabled, but the stop capture button is disabled because a
[Word Count: 15]

[ Start ]
Capture › Start
Starts capturing packets with the same
[Word Count: 12]

options as the last capture or the default
[Word Count: 8]

options if none were set (Start Capturing).
[Word Count: 7]

[ Stop ]
Capture › Stop
Stops the currently running capture (Start
[Word Count: 12]

[ Restart ]
Capture › Restart
Restarts the current capture session.
[Word Count: 11]

[ Options… ]
Capture › Options… Opens the “Capture Options” dialog box.
[Word Count: 12]

[ Open… ]
File › Open…
Opens the file open dialog box, which
[Word Count: 13]

viewing. It is discussed in more detail in
[Word Count: 8]

[ Save As… ]
File › Save As…
Save the current capture file to whatever
[Word Count: 15]

file you would like. See The “Save Capture
[Word Count: 8]

[ Close ]
File › Close
Closes the current capture. If you have not
[Word Count: 14]

[ Reload ]
View › Reload
Reloads the current capture file.
[Word Count: 11]

[ Find Packet… ]
Edit › Find Packet… Find a packet based on different criteria.
[Word Count: 15]

[ Go Back ]
Go › Go Back
Jump back in the packet history. Hold
[Word Count: 15]

down the Alt  key ( Option  on macOS) to go
[Word Count: 10]

[ Go Forward ]
Go › Go Forward
Jump forward in the packet history. Hold
[Word Count: 15]

down the Alt  key ( Option  on macOS) to go
[Word Count: 10]

[ Go to Packet… ]
Go › Go to Packet…
Go to a specific packet.
[Word Count: 15]

Go › First Packet
Jump to the first packet of the capture file.
[Word Count: 13]

Go › Last Packet
Jump to the last packet of the capture file.
[Word Count: 13]

Auto scroll packet list while doing a live
[Word Count: 8]

[ Colorize ]
View › Colorize
Colorize the packet list (or not).
[Word Count: 12]

[ Zoom In ]
View › Zoom In
Zoom into the packet data (increase the
[Word Count: 15]

[ Zoom Out ]
View › Zoom Out
Zoom out of the packet data (decrease the
[Word Count: 16]

[ Normal Size ]
View › Normal Size
Set zoom level back to 100%.
[Word Count: 14]

Resize columns, so the content fits into
[Word Count: 7]

[ Reset Layout ]
View › Reset Layout Reset layout to default size.
[Word Count: 13]

The filter toolbar lets you quickly edit and apply display filters. More information on display filters
[Word Count: 16]

is available in Filtering Packets While Viewing.
[Word Count: 7]

Bookmarks
Manage or select saved filters.
[Word Count: 6]

Filter Input
The area to enter or edit a display filter string, see
[Word Count: 13]

Building Display Filter Expressions. A syntax check of
[Word Count: 8]

your filter string is done while you are typing. The
[Word Count: 10]

background will turn red if you enter an incomplete
[Word Count: 9]

or invalid string, and will become green when you
[Word Count: 9]

After you’ve changed something in this field, don’t
[Word Count: 8]

forget to press the Apply button (or the Enter/Return
[Word Count: 9]

key), to apply this filter string to the display.
[Word Count: 9]

This field is also where the current applied filter is
[Word Count: 10]

Clear
Reset the current display filter and clear the edit area.
[Word Count: 11]

Apply
Apply the current value in the edit area as the new
[Word Count: 12]

Applying a display filter on large capture files might
[Word Count: 9]

Recent
Select from a list of recently applied filters.
[Word Count: 9]

Filter Button
Filter buttons are handy shortcuts that apply a display
[Word Count: 11]

filter as soon as you press them. You can create filter
[Word Count: 11]

buttons by pressing the [ + ] button, right-clicking in
[Word Count: 10]

the filter button area, or opening the Filter Button
[Word Count: 9]

section of the Preferences Dialog. The example shows
[Word Count: 8]

a filter button with the label “Squirrels”. If you have
[Word Count: 10]

lots of buttons you can arrange them into groups by
[Word Count: 10]

using “//” as a label separator. For example, if you
[Word Count: 10]

create buttons named “Not Squirrels // Rabbits” and
[Word Count: 8]

“Not Squirrels // Capybaras” they will show up in the
[Word Count: 10]

toolbar under a single button named “Not Squirrels”.
[Word Count: 8]

The packet list pane displays all the packets in the current capture file.
[Word Count: 13]

Each line in the packet list corresponds to one packet in the capture file. If you select a line in this
[Word Count: 21]

pane, more details will be displayed in the “Packet Details” and “Packet Bytes” panes.
[Word Count: 14]

While dissecting a packet, Wireshark will place information from the protocol dissectors into the
[Word Count: 14]

columns. As higher-level protocols might overwrite information from lower levels, you will
[Word Count: 12]

typically see the information from the highest possible level only.
[Word Count: 10]

For example, let’s look at a packet containing TCP inside IP inside an Ethernet packet. The Ethernet
[Word Count: 17]

dissector will write its data (such as the Ethernet addresses), the IP dissector will overwrite this by
[Word Count: 17]

its own (such as the IP addresses), the TCP dissector will overwrite the IP information, and so on.
[Word Count: 18]

There are many different columns available. You can choose which columns are displayed in the
[Word Count: 15]

• [ No. ] The number of the packet in the capture file. This number won’t change, even if a display
[Word Count: 21]

• [ Time ] The timestamp of the packet. The presentation format of this timestamp can be
[Word Count: 17]

changed, see Time Display Formats And Time References.
[Word Count: 8]

• [ Source ] The address where this packet is coming from.
[Word Count: 12]

• [ Destination ] The address where this packet is going to.
[Word Count: 12]

• [ Protocol ] The protocol name in a short (perhaps abbreviated) version.
[Word Count: 13]

• [ Info ] Additional information about the packet content.
[Word Count: 10]

The first column shows how each packet is related to the selected packet. For example, in the image
[Word Count: 18]

above the first packet is selected, which is a DNS request. Wireshark shows a rightward arrow for
[Word Count: 17]

the request itself, followed by a leftward arrow for the response in packet 2. Why is there a dashed
[Word Count: 19]

line? There are more DNS packets further down that use the same port numbers. Wireshark treats
[Word Count: 16]

them as belonging to the same conversation and draws a line connecting them.
[Word Count: 13]

The selected packet acknowledges this packet.
[Word Count: 6]

The selected packet is a duplicate acknowledgement of this packet.
[Word Count: 10]

The selected packet is related to this packet in some other way, e.g., as
[Word Count: 14]

The packet list has an Intelligent Scrollbar which shows a miniature map of nearby packets. Each
[Word Count: 16]

raster line of the scrollbar corresponds to a single packet, so the number of packets shown in the
[Word Count: 18]

map depends on your physical display and the height of the packet list. A tall packet list on a high-
[Word Count: 20]

resolution (“Retina”) display will show you quite a few packets. In the image above the scrollbar
[Word Count: 16]

shows the status of more than 500 packets along with the 15 shown in the packet list itself.
[Word Count: 18]

Right clicking will show a context menu, described in Pop-up menu of the “Packet List” pane.
[Word Count: 16]

The packet details pane shows the current packet (selected in the “Packet List” pane) in a more
[Word Count: 17]

This pane shows the protocols and protocol fields of the packet selected in the “Packet List” pane.
[Word Count: 17]

The protocol summary lines (subtree labels) and fields of the packet are shown in a tree which can
[Word Count: 18]

There is a context menu (right mouse click) available. See details in Pop-up menu of the “Packet
[Word Count: 17]

Some protocol fields have special meanings.
[Word Count: 6]

• Generated fields. Wireshark itself will generate additional protocol information which isn’t
[Word Count: 12]

present in the captured data. This information is enclosed in square brackets (“[” and “]”).
[Word Count: 15]

Generated information includes response times, TCP analysis, IP geolocation information, and
[Word Count: 11]

• Links. If Wireshark detects a relationship to another packet in the capture file it will generate a
[Word Count: 18]

link to that packet. Links are underlined and displayed in blue. If you double-clicked on a link
[Word Count: 17]

Wireshark will jump to the corresponding packet.
[Word Count: 7]

The packet bytes pane shows the data of the current packet (selected in the “Packet List” pane) in a
[Word Count: 19]

The “Packet Bytes” pane shows a canonical hex dump of the packet data. Each line contains the data
[Word Count: 18]

offset, sixteen hexadecimal bytes, and sixteen ASCII bytes. Non-printable bytes are replaced with a
[Word Count: 14]

Depending on the packet data, sometimes more than one page is available, e.g. when Wireshark has
[Word Count: 16]

reassembled some packets into a single chunk of data. (See Packet Reassembly for details). In this
[Word Count: 16]

case you can see each data source by clicking its corresponding tab at the bottom of the pane.
[Word Count: 18]

The default mode for viewing will highlight the bytes for a field where the mouse pointer is
[Word Count: 17]

hovering above. The highlight will follow the mouse cursor as it moves. If this highlighting is not
[Word Count: 17]

required or wanted, there are two methods for deactivating the functionality:
[Word Count: 11]

• Temporary By holding down the Ctrl button while moving the mouse, the highlighted field will
[Word Count: 16]

• Permanently Using the context menu (right mouse click) the hover highlighting may be
[Word Count: 14]

activated/deactivated. This setting is stored in the selected profile recent file.
[Word Count: 11]

Figure 20. The “Packet Bytes” pane with tabs
[Word Count: 8]

Additional tabs typically contain data reassembled from multiple packets or decrypted data.
[Word Count: 12]

The packet diagram pane shows the current packet (selected in the “Packet List” pane) as a
[Word Count: 16]

diagram, similar to ones used in textbooks and IETF RFCs.
[Word Count: 10]

This pane shows the protocols and top-level protocol fields of the packet selected in the “Packet
[Word Count: 16]

There is a context menu (right mouse click) available. For details see Pop-up menu of the “Packet
[Word Count: 17]

The statusbar displays informational messages.
[Word Count: 5]

In general, the left side will show context related information, the middle part will show
[Word Count: 15]

information about the current capture file, and the right side will show the selected configuration
[Word Count: 15]

profile. Drag the handles between the text areas to change the size.
[Word Count: 12]

This statusbar is shown while no capture file is loaded, e.g., when Wireshark is started.
[Word Count: 15]

Figure 23. The Statusbar with a loaded capture file
[Word Count: 9]

on the left shows the highest expert information level found in the currently loaded capture file.
[Word Count: 16]

Hovering the mouse over this icon will show a description of the expert info level, and clicking
[Word Count: 17]

the icon will bring up the Expert Information dialog box. For a detailed description of this dialog
[Word Count: 17]

and each expert level, see Expert Information.
[Word Count: 7]

on the left side lets you add a comment to the capture file using the Capture File Properties
[Word Count: 18]

shows the capture file name by default. It also shows field information when hovering over and
[Word Count: 16]

selecting items in the packet detail and packet bytes panes, as well as general notifications.
[Word Count: 15]

shows the current number of packets in the capture file. The following values are displayed:
[Word Count: 15]

The number of packets currently being displayed.
[Word Count: 7]

The number of marked packets. Only displayed if you marked any packets.
[Word Count: 12]

The number of dropped packets Only displayed if Wireshark was unable to capture all
[Word Count: 14]

The number of ignored packets Only displayed if you ignored any packets.
[Word Count: 12]

shows the selected configuration profile. Clicking on this part of the statusbar will bring up a
[Word Count: 16]

menu with all available configuration profiles, and selecting from this list will change the
[Word Count: 14]

Figure 24. The Statusbar with a configuration profile menu
[Word Count: 9]

For a detailed description of configuration profiles, see Configuration Profiles.
[Word Count: 10]

Figure 25. The Statusbar with a selected protocol field
[Word Count: 9]

This is displayed if you have selected a protocol field in the “Packet Details” pane.
[Word Count: 15]

The value between the parentheses (in this example “ipv6.src”) is the display filter
[Word Count: 13]

field for the selected item. You can become more familiar with display filter fields by
[Word Count: 15]

selecting different packet detail items.
[Word Count: 5]

Figure 26. The Statusbar with a display filter message
[Word Count: 9]

This is displayed if you are trying to use a display filter which may have unexpected results.
[Word Count: 17]

Capturing live network data is one of the major features of Wireshark.
[Word Count: 12]

The Wireshark capture engine provides the following features:
[Word Count: 8]

• Capture from different kinds of network hardware such as Ethernet or 802.11.
[Word Count: 13]

• Simultaneously capture from multiple network interfaces.
[Word Count: 7]

• Stop the capture on different triggers such as the amount of captured data, elapsed time, or the
[Word Count: 18]

• Simultaneously show decoded packets while Wireshark is capturing.
[Word Count: 9]

• Filter packets, reducing the amount of data to be captured. See Filtering while capturing.
[Word Count: 15]

• Save packets in multiple files while doing a long-term capture, optionally rotating through a
[Word Count: 15]

fixed number of files (a “ringbuffer”). See Capture files and file modes.
[Word Count: 12]

The capture engine still lacks the following features:
[Word Count: 8]

• Stop capturing (or perform some other action) depending on the captured data.
[Word Count: 13]

Setting up Wireshark to capture packets for the first time can be tricky. A comprehensive guide
[Word Count: 16]

“How To setup a Capture” is available at https://wiki.wireshark.org/CaptureSetup.
[Word Count: 9]

• You may need special privileges to start a live capture.
[Word Count: 11]

• You need to choose the right network interface to capture packet data from.
[Word Count: 14]

• You need to capture at the right place in the network to see the traffic you want to see.
[Word Count: 20]

If you have any problems setting up your capture environment, you should have a look at the guide
[Word Count: 18]

The following methods can be used to start capturing packets with Wireshark:
[Word Count: 12]

• You can double-click on an interface in the welcome screen.
[Word Count: 11]

• You can select an interface in the welcome screen, then select Capture › Start or click the first
[Word Count: 19]

• You can get more detailed information about available interfaces using The “Capture Options”
[Word Count: 14]

• If you already know the name of the capture interface you can start Wireshark from the
[Word Count: 17]

This will start Wireshark capturing on interface eth0. More details can be found at Start Wireshark
[Word Count: 16]

The “Capture” Section Of The Welcome Screen
[Word Count: 7]

When you open Wireshark without starting a capture or opening a capture file it will display the
[Word Count: 17]

“Welcome Screen,” which lists any recently opened capture files and available capture interfaces.
[Word Count: 13]

Network activity for each interface will be shown in a sparkline next to the interface name. It is
[Word Count: 18]

possible to select more than one interface and capture from them simultaneously.
[Word Count: 12]

Figure 27. Capture interfaces on Microsoft Windows
[Word Count: 7]

Some interfaces allow or require configuration prior to capture. This will be indicated by a
[Word Count: 15]

configuration icon (
) to the left of the interface name. Clicking on the icon will show the
[Word Count: 18]

configuration dialog for that interface.
[Word Count: 5]

Hovering over an interface will show any associated IPv4 and IPv6 addresses and its capture filter.
[Word Count: 16]

Wireshark isn’t limited to just network interfaces — on most systems you can also capture USB,
[Word Count: 16]

Bluetooth, and other types of packets. Note also that an interface might be hidden if it’s inaccessible
[Word Count: 17]

to Wireshark or if it has been hidden as described in The “Manage Interfaces” Dialog Box.
[Word Count: 16]

When you select Capture › Options… (or use the corresponding item in the main toolbar),
[Word Count: 15]

Wireshark pops up the “Capture Options” dialog box as shown in The “Capture Options” input tab.
[Word Count: 16]

If you are unsure which options to choose in this dialog box, leaving the defaults settings as they
[Word Count: 18]

Figure 29. The “Capture Options” input tab
[Word Count: 7]

The “Input” tab contains the “Interface” table, which shows the following columns:
[Word Count: 12]

Some interfaces allow or require configuration prior to capture. This will be indicated by a
[Word Count: 15]

configuration icon (
) to the left of the interface name. Clicking on the icon will show the
[Word Count: 18]

configuration dialog for that interface.
[Word Count: 5]

A sparkline showing network activity over time.
[Word Count: 7]

The type of packet captured by this interface. In some cases it is possible to change this. See Link-
[Word Count: 19]

Lets you put this interface in promiscuous mode while capturing. Note that another application
[Word Count: 14]

The snapshot length, or the number of bytes to capture for each packet. You can set an explicit
[Word Count: 18]

length if needed, e.g., for performance or privacy reasons.
[Word Count: 9]

The size of the kernel buffer that is reserved for capturing packets. You can increase or decrease
[Word Count: 17]

this as needed, but the default is usually sufficient.
[Word Count: 9]

Lets you capture full, raw 802.11 headers. Support depends on the interface type, hardware,
[Word Count: 14]

driver, and OS. Note that enabling this might disconnect you from your wireless network.
[Word Count: 14]

The capture filter applied to this interface. You can edit the filter by double-clicking on it. See
[Word Count: 17]

Filtering while capturing for more details about capture filters.
[Word Count: 9]

Hovering over an interface or expanding it will show any associated IPv4 and IPv6 addresses.
[Word Count: 15]

If “Enable promiscuous mode on all interfaces” is enabled, the individual promiscuous mode
[Word Count: 13]

“Capture filter for selected interfaces” can be used to set a filter for more than one interface at the
[Word Count: 19]

[ Manage Interfaces ] opens the The “Manage Interfaces” dialog box where pipes can be defined,
[Word Count: 16]

local interfaces scanned or hidden, or remote interfaces added.
[Word Count: 9]

[ Compile Selected BPFs ] opens The “Compiled Filter Output” dialog box, which shows you the
[Word Count: 16]

compiled bytecode for your capture filter. This can help to better understand the capture filter you
[Word Count: 16]

The execution of BPFs can be sped up on Linux by turning on BPF Just In Time
[Word Count: 17]

$ echo 1 >/proc/sys/net/core/bpf_jit_enable
[Word Count: 4]

if it is not enabled already. To make the change persistent you can use sysfsutils.
[Word Count: 15]

Figure 30. The “Capture Options” output tab
[Word Count: 7]

The “Output” tab shows the following information:
[Word Count: 7]

This field allows you to specify the file name that will be used for the capture file. It is left
[Word Count: 20]

blank by default. If left blank, the capture data will be stored in a temporary file. See Capture
[Word Count: 18]

files and file modes for details. You can also click on the button to the right of this field to
[Word Count: 20]

Allows you to set the format of the capture file. pcapng is the default and is more flexible than
[Word Count: 19]

pcap. pcapng might be required, e.g., if more than one interface is chosen for capturing. See
[Word Count: 16]

https://wiki.wireshark.org/Development/PcapNg for more details on pcapng.
[Word Count: 6]

Sets the conditions for switching a new capture file. A new capture file can be created based on
[Word Count: 18]

• The number of packets in the capture file.
[Word Count: 9]

Multiple files only. Form a ring buffer of the capture files with the given number of files.
[Word Count: 17]

More details about capture files can be found in Capture files and file modes.
[Word Count: 14]

Figure 31. The “Capture Options” options tab
[Word Count: 7]

The “Options” tab shows the following information:
[Word Count: 7]

Updates the packet list pane in real time during capture. If you do not enable this, Wireshark
[Word Count: 17]

will not display any packets until you stop the capture. When you check this, Wireshark
[Word Count: 15]

captures in a separate process and feeds the captures to the display process.
[Word Count: 13]

Automatically scroll during live capture
[Word Count: 5]

Scroll the packet list pane as new packets come in, so you are always looking at the most
[Word Count: 18]

recent packet. Automatic scrolling is temporarily disabled when manually scrolling upwards
[Word Count: 11]

or performing a "Go" action so that the selected packet can be examined. It will resume upon
[Word Count: 17]

manually scrolling to the end of the packet list. If you do not specify this Wireshark adds new
[Word Count: 18]

packets to the packet list but does not scroll the packet list pane. This option has no effect if
[Word Count: 19]

“Update list of packets in real-time” is disabled.
[Word Count: 8]

If this option is enabled, the capture information dialog described in While a Capture is
[Word Count: 15]

running … will be shown while packets are captured.
[Word Count: 9]

Translate transport names (port numbers).
[Word Count: 5]

See Name Resolution for more details on each of these options.
[Word Count: 11]

Capturing can be stopped based on the following conditions:
[Word Count: 9]

• The number of packets in the capture file.
[Word Count: 9]

You can double-click on an interface row in the “Input“ tab or click [ Start ] from any tab to
[Word Count: 20]

commence the capture. You can click [ Cancel ] to apply your changes and close the dialog.
[Word Count: 17]

Figure 32. The “Manage Interfaces” dialog box
[Word Count: 7]

The “Manage Interfaces” dialog box initially shows the “Local Interfaces” tab, which lets you
[Word Count: 14]

Whether or not to show or hide this interface in the welcome screen and the “Capture Options”
[Word Count: 17]

A name for the interface that is human readable.
[Word Count: 9]

Can be used to add a descriptive comment for the interface.
[Word Count: 11]

The “Pipes” tab lets you capture from a named pipe. To successfully add a pipe, its associated
[Word Count: 17]

named pipe must have already been created. Click [ + ] and type the name of the pipe including its
[Word Count: 20]

path. Alternatively, [ Browse ] can be used to locate the pipe.
[Word Count: 12]

To remove a pipe from the list of interfaces, select it and press [ - ].
[Word Count: 16]

On Microsoft Windows, the “Remote Interfaces” tab lets you capture from an interface on a
[Word Count: 15]

different machine. The Remote Packet Capture Protocol service must first be running on the target
[Word Count: 15]

platform before Wireshark can connect to it.
[Word Count: 7]

On Linux or Unix you can capture (and do so more securely) through an SSH tunnel.
[Word Count: 16]

To add a new remote capture interface, click [ + ] and specify the following:
[Word Count: 15]

The IP address or host name of the target platform where the Remote Packet Capture Protocol
[Word Count: 16]

service is listening. The drop-down list contains the hosts that have previously been successfully
[Word Count: 14]

contacted. The list can be emptied by choosing “Clear list” from the drop-down list.
[Word Count: 14]

Set the port number where the Remote Packet Capture Protocol service is listening on. Leave
[Word Count: 15]

Select this if you don’t need authentication to take place for a remote capture to be started. This
[Word Count: 18]

depends on the target platform. This is exactly as secure as it appears, i.e., it is not secure at all.
[Word Count: 20]

Lets you specify the username and password required to connect to the Remote Packet Capture
[Word Count: 15]

Each interface can optionally be hidden. In contrast to the local interfaces, they are not saved in the
[Word Count: 18]

NOTE
Make sure you have outside access to port 2002 on the target platform. This is the
[Word Count: 17]

default port used by the Remote Packet Capture Protocol service.
[Word Count: 10]

To remove a host including all its interfaces from the list, select it and click the [ - ] button.
[Word Count: 20]

This figure shows the results of compiling the BPF filter for the selected interfaces.
[Word Count: 14]

Figure 33. The “Compiled Filter Output” dialog box
[Word Count: 8]

In the list on the left the interface names are listed. The results of compiling a filter for the selected
[Word Count: 20]

While capturing, the underlying libpcap capturing engine will grab the packets from the network
[Word Count: 14]

card and keep the packet data in a (relatively) small kernel buffer. This data is read by Wireshark
[Word Count: 18]

By default, Wireshark saves packets to a temporary file. You can also tell Wireshark to save to a
[Word Count: 18]

specific (“permanent”) file and switch to a different file after a given time has elapsed or a given
[Word Count: 18]

number of packets have been captured. These options are controlled in the “Capture Options”
[Word Count: 14]

Working with large files (several hundred MB) can be quite slow. If you plan to do a
[Word Count: 17]

long-term capture or capturing from a high traffic network, think about using one of
[Word Count: 14]

the “Multiple files” options. This will spread the captured packets over several smaller
[Word Count: 13]

files which can be much more pleasant to work with.
[Word Count: 10]

Using the “Multiple files” option may cut context related information. Wireshark keeps context
[Word Count: 13]

information of the loaded packet data, so it can report context related problems (like a stream
[Word Count: 16]

error) and keeps information about context related protocols (e.g., where data is exchanged at the
[Word Count: 15]

establishing phase and only referred to in later packets). As it keeps this information only for the
[Word Count: 17]

loaded file, using one of the multiple file modes may cut these contexts. If the establishing phase is
[Word Count: 18]

saved in one file and the things you would like to see is in another, you might not see some of the
[Word Count: 22]

Information about the folders used for capture files can be found in Files and Folders.
[Word Count: 15]

Table 17. Capture file mode selected by capture options
[Word Count: 9]

A temporary file will be created and used (this is the default). After capturing is stopped this file
[Word Count: 18]

can be saved later under a user specified name.
[Word Count: 9]

A single capture file will be used. Choose this mode if you want to place the new capture file in a
[Word Count: 21]

Like the “Single named file” mode, but a new file is created and used after reaching one of the
[Word Count: 19]

multiple file switch conditions (one of the “Next file every…” values).
[Word Count: 11]

Much like “Multiple files continuous”, reaching one of the multiple files switch conditions (one
[Word Count: 14]

of the “Next file every …” values) will switch to the next file. This will be a newly created file if
[Word Count: 21]

value of “Ring buffer with n files” is not reached, otherwise it will replace the oldest of the
[Word Count: 18]

formerly used files (thus forming a “ring”).
[Word Count: 7]

This mode will limit the maximum disk usage, even for an unlimited amount of capture input
[Word Count: 16]

data, only keeping the latest captured data.
[Word Count: 7]

In most cases you won’t have to modify link-layer header type. Some exceptions are as follows:
[Word Count: 16]

If you are capturing on an Ethernet device you might be offered a choice of “Ethernet” or “DOCSIS”.
[Word Count: 18]

If you are capturing traffic from a Cisco Cable Modem Termination System that is putting DOCSIS
[Word Count: 16]

traffic onto the Ethernet to be captured, select “DOCSIS”, otherwise select “Ethernet”.
[Word Count: 12]

If you are capturing on an 802.11 device on some versions of BSD you might be offered a choice of
[Word Count: 20]

“Ethernet” or “802.11”. “Ethernet” will cause the captured packets to have fake (“cooked”) Ethernet
[Word Count: 14]

headers. “802.11” will cause them to have full IEEE 802.11 headers. Unless the capture needs to be
[Word Count: 17]

read by an application that doesn’t support 802.11 headers you should select “802.11”.
[Word Count: 13]

If you are capturing on an Endace DAG card connected to a synchronous serial line you might be
[Word Count: 18]

offered a choice of “PPP over serial” or “Cisco HDLC”. If the protocol on the serial line is PPP, select
[Word Count: 20]

“PPP over serial” and if the protocol on the serial line is Cisco HDLC, select “Cisco HDLC”.
[Word Count: 17]

If you are capturing on an Endace DAG card connected to an ATM network you might be offered a
[Word Count: 19]

choice of “RFC 1483 IP-over-ATM” or “Sun raw ATM”. If the only traffic being captured is RFC 1483
[Word Count: 18]

LLC-encapsulated IP, or if the capture needs to be read by an application that doesn’t support
[Word Count: 16]

SunATM headers, select “RFC 1483 IP-over-ATM”, otherwise select “Sun raw ATM”.
[Word Count: 11]

Wireshark supports limiting the packet capture to packets that match a capture filter. Wireshark
[Word Count: 14]

capture filters are written in libpcap filter language. Below is a brief overview of the libpcap filter
[Word Count: 17]

language’s syntax. Complete documentation can be found at the pcap-filter man page. You can find
[Word Count: 15]

many Capture Filter examples at https://wiki.wireshark.org/CaptureFilters.
[Word Count: 6]

You enter the capture filter into the “Filter” field of the Wireshark “Capture Options” dialog box, as
[Word Count: 17]

shown in The “Capture Options” input tab.
[Word Count: 7]

A capture filter takes the form of a series of primitive expressions connected by conjunctions
[Word Count: 15]

(and/or) and optionally preceded by not:
[Word Count: 6]

[not] primitive [and|or [not] primitive ...]
[Word Count: 6]

An example is shown in A capture filter for telnet that captures traffic to and from a particular host.
[Word Count: 19]

Example 1. A capture filter for telnet that captures traffic to and from a particular host
[Word Count: 16]

This example captures telnet traffic to and from the host 10.0.0.5, and shows how to use two
[Word Count: 17]

primitives and the and conjunction. Another example is shown in Capturing all telnet traffic not
[Word Count: 15]

from 10.0.0.5, and shows how to capture all telnet traffic except that from 10.0.0.5.
[Word Count: 14]

Example 2. Capturing all telnet traffic not from 10.0.0.5
[Word Count: 9]

A primitive is simply one of the following: [src|dst] host <host>
[Word Count: 11]

This primitive allows you to filter on a host IP address or name. You can optionally precede the
[Word Count: 18]

primitive with the keyword src|dst to specify that you are only interested in source or
[Word Count: 15]

destination addresses. If these are not present, packets where the specified address appears as
[Word Count: 14]

either the source or the destination address will be selected.
[Word Count: 10]

This primitive allows you to filter on Ethernet host addresses. You can optionally include the
[Word Count: 15]

keyword src|dst between the keywords ether and host to specify that you are only interested in
[Word Count: 16]

source or destination addresses. If these are not present, packets where the specified address
[Word Count: 14]

appears in either the source or destination address will be selected.
[Word Count: 11]

This primitive allows you to filter on packets that used host as a gateway. That is, where the
[Word Count: 18]

Ethernet source or destination was host but neither the source nor destination IP address was
[Word Count: 15]

[src|dst] net <net> [{mask <mask>}|{len <len>}]
[Word Count: 6]

This primitive allows you to filter on network numbers. You can optionally precede this
[Word Count: 14]

primitive with the keyword src|dst to specify that you are only interested in a source or
[Word Count: 16]

destination network. If neither of these are present, packets will be selected that have the
[Word Count: 15]

specified network in either the source or destination address. In addition, you can specify either
[Word Count: 15]

the netmask or the CIDR prefix for the network if they are different from your own.
[Word Count: 16]

This primitive allows you to filter on TCP and UDP port numbers. You can optionally precede this
[Word Count: 17]

primitive with the keywords src|dst and tcp|udp which allow you to specify that you are only
[Word Count: 16]

interested in source or destination ports and TCP or UDP packets respectively. The keywords
[Word Count: 14]

If these are not specified, packets will be selected for both the TCP and UDP protocols and when
[Word Count: 18]

the specified address appears in either the source or destination port field.
[Word Count: 12]

This primitive allows you to filter on packets whose length was less than or equal to the
[Word Count: 17]

specified length, or greater than or equal to the specified length, respectively.
[Word Count: 12]

This primitive allows you to filter on the specified protocol at either the Ethernet layer or the IP
[Word Count: 18]

This primitive allows you to filter on either Ethernet or IP broadcasts or multicasts.
[Word Count: 14]

This primitive allows you to create complex filter expressions that select bytes or ranges of bytes
[Word Count: 16]

in packets. Please see the pcap-filter man page at https://www.tcpdump.org/manpages/pcap-
[Word Count: 10]

If Wireshark is running remotely (using e.g., SSH, an exported X11 window, a terminal server, …),
[Word Count: 16]

the remote content has to be transported over the network, adding a lot of (usually unimportant)
[Word Count: 16]

packets to the actually interesting traffic.
[Word Count: 6]

To avoid this, Wireshark tries to figure out if it’s remotely connected (by looking at some specific
[Word Count: 17]

environment variables) and automatically creates a capture filter that matches aspects of the
[Word Count: 13]

The following environment variables are analyzed:
[Word Count: 6]

<remote IP> <remote port> <local IP> <local port>
[Word Count: 8]

On Windows it asks the operating system if it’s running in a Remote Desktop Services environment.
[Word Count: 16]

You might see the following dialog box while a capture is running:
[Word Count: 12]

Figure 35. The “Capture Information” dialog box
[Word Count: 7]

This dialog box shows a list of protocols and their activity over time. It can be enabled via the
[Word Count: 19]

“capture.show_info” setting in the “Advanced” preferences.
[Word Count: 6]

A running capture session will be stopped in one of the following ways:
[Word Count: 13]

1. The [ Stop Capture ] button in the “Capture Information” dialog box.
[Word Count: 13]

5. The capture will be automatically stopped if one of the Stop Conditions is met, e.g., the
[Word Count: 17]

A running capture session can be restarted with the same capture options as the last time, this will
[Word Count: 18]

remove all packets previously captured. This can be useful, if some uninteresting packets are
[Word Count: 14]

captured and there’s no need to keep them.
[Word Count: 8]

Restart is a convenience function and equivalent to a capture stop following by an immediate
[Word Count: 15]

capture start. A restart can be triggered in one of the following ways:
[Word Count: 13]

1. Using the Capture › Restart menu item.
[Word Count: 8]

2. Using the [ Restart ] toolbar button.
[Word Count: 8]

This chapter will describe input and output of capture data.
[Word Count: 10]

• Open capture files in various capture file formats
[Word Count: 9]

• Save and export capture files in various formats
[Word Count: 9]

• Import text files containing hex dumps of packets
[Word Count: 9]

Wireshark can read in previously saved capture files. To read them, simply select the File › Open
[Word Count: 17]

menu or toolbar item. Wireshark will then pop up the “File Open” dialog box, which is discussed in
[Word Count: 18]

more detail in The “Open Capture File” Dialog Box.
[Word Count: 9]

On most systems you can open a file by simply dragging it in your file manager and
[Word Count: 17]

dropping it onto Wireshark’s main window.
[Word Count: 6]

If you haven’t previously saved the current capture file you will be asked to do so to prevent data
[Word Count: 19]

loss. This warning can be disabled in the preferences.
[Word Count: 9]

In addition to its native file format (pcapng), Wireshark can read and write capture files from a
[Word Count: 17]

large number of other packet capture programs as well. See Input File Formats for the list of
[Word Count: 17]

The “Open Capture File” dialog box allows you to search for a capture file containing previously
[Word Count: 16]

captured packets for display in Wireshark. The following sections show some examples of the
[Word Count: 14]

Wireshark “Open File” dialog box. The appearance of this dialog depends on the system. However,
[Word Count: 15]

the functionality should be the same across systems.
[Word Count: 8]

• Click the [ Open ] button to accept your selected file and open it.
[Word Count: 15]

• Click the [ Cancel ] button to go back to Wireshark and not load a capture file.
[Word Count: 18]

• The [ Help ] button will take you to this section of the “User’s Guide”.
[Word Count: 16]

• View file preview information such as the size and the number of packets in a selected a
[Word Count: 18]

• Specify a read filter with the “Read filter” field. This filter will be used when opening the new
[Word Count: 19]

file. The text field background will turn green for a valid filter string and red for an invalid one.
[Word Count: 19]

Read filters can be used to exclude various types of traffic, which can be useful for large capture
[Word Count: 18]

files. They use the same syntax as display filters, which are discussed in detail in Filtering
[Word Count: 16]

• Optionally force Wireshark to read a file as a particular type using the “Automatically detect file
[Word Count: 17]

This is the common Windows file open dialog along with some Wireshark extensions.
[Word Count: 13]

This is the common Qt file open dialog along with some Wireshark extensions.
[Word Count: 13]

The native capture file formats used by Wireshark are:
[Word Count: 9]

• pcap. The default format used by the libpcap packet capture library. Used by tcpdump, _Snort,
[Word Count: 16]

• pcapng. A flexible, extensible successor to the pcap format. Wireshark 1.8 and later save files as
[Word Count: 17]

pcapng by default. Versions prior to 1.8 used pcap. Used by Wireshark and by tcpdump in newer
[Word Count: 17]

The following file formats from other capture tools can be opened by Wireshark:
[Word Count: 13]

• Oracle (previously Sun) snoop and atmsnoop captures
[Word Count: 8]

• Finisar (previously Shomiti) Surveyor captures
[Word Count: 6]

• NETSCOUT (previously Network Associates/Network General) Windows-based Sniffer and
[Word Count: 9]

• Network 
General/Network 
Associates 
DOS-based 
Sniffer 
captures 
(compressed 
or
[Word Count: 9]

• LiveAction (previously WildPackets/Savvius) *Peek/EtherHelp/PacketGrabber captures
[Word Count: 6]

• Viavi (previously Network Instruments) Observer captures
[Word Count: 7]

• output from i4btrace from the ISDN4BSD project
[Word Count: 8]

• the IPLog format output from the Cisco Secure Intrusion Detection System
[Word Count: 12]

• the output from VMS’s TCPIPtrace/TCPtrace/UCX$TRACE utilities
[Word Count: 7]

• the text output from the DBS Etherwatch VMS utility
[Word Count: 10]

• Visual Networks’ Visual UpTime traffic capture
[Word Count: 7]

• the output from InfoVista (previously Accellent) 5Views LAN agents
[Word Count: 10]

• Endace Measurement Systems’ ERF format captures
[Word Count: 7]

• Linux Bluez Bluetooth stack hcidump -w traces
[Word Count: 8]

• Catapult (now Ixia/Keysight) DCT2000 .out files
[Word Count: 7]

• Gammu generated text output from Nokia DCT3 phones in Netmonitor mode
[Word Count: 12]

• IBM Series (OS/400) Comm traces (ASCII & UNICODE)
[Word Count: 9]

• Tektronix K12xx 32bit .rf5 format captures
[Word Count: 7]

• Tektronix K12 text file format captures
[Word Count: 7]

• Captures from Aethra Telecommunications’ PC108 software for their test instruments
[Word Count: 11]

• Android Logcat binary and text format logs
[Word Count: 8]

• Colasoft Capsa and PacketBuilder captures
[Word Count: 6]

• Unigraf DPA-400 DisplayPort AUX channel monitor traces
[Word Count: 8]

• 802.15.4 traces from Daintree’s Sensor Network Analyzer
[Word Count: 8]

• MPEG-2 Transport Streams as defined in ISO/IEC 13818-1
[Word Count: 9]

New file formats are added from time to time.
[Word Count: 9]

It may not be possible to read some formats dependent on the packet types captured. Ethernet
[Word Count: 16]

captures are usually supported for most file formats but it may not be possible to read other packet
[Word Count: 18]

types such as PPP or IEEE 802.11 from all file formats.
[Word Count: 11]

You can save captured packets by using the File › Save or File › Save As… menu items. You can
[Word Count: 20]

choose which packets to save and which file format to be used.
[Word Count: 12]

Not all information will be saved in a capture file. For example, most file formats don’t record the
[Word Count: 18]

number of dropped packets. See Capture Files for details.
[Word Count: 9]

The “Save Capture File As” dialog box allows you to save the current capture to a file. The exact
[Word Count: 19]

appearance of this dialog depends on your system. However, the functionality is the same across
[Word Count: 15]

This is the common Windows file save dialog with some additional Wireshark extensions.
[Word Count: 13]

This is the common Qt file save dialog with additional Wireshark extensions.
[Word Count: 12]

• Type in the name of the file in which you wish to save the captured packets.
[Word Count: 17]

• Select the directory to save the file into.
[Word Count: 9]

• Specify the format of the saved capture file by clicking on the “Save as” drop-down box. You can
[Word Count: 19]

choose from the types described in Output File Formats. Some capture formats may not be
[Word Count: 15]

available depending on the packet types captured.
[Word Count: 7]

• The [ Help ] button will take you to this section of the “User’s Guide”.
[Word Count: 16]

• “Compress with gzip” will compress the capture file as it is being written to disk.
[Word Count: 16]

• Click the [ Save ] button to accept your selected file and save it.
[Word Count: 15]

• Click on the [ Cancel ] button to go back to Wireshark without saving any packets.
[Word Count: 17]

If you don’t provide a file extension to the filename (e.g., .pcap) Wireshark will append the standard
[Word Count: 17]

You can convert capture files from one format to another by opening a capture and
[Word Count: 15]

If you wish to save some of the packets in your capture file you can do so via The “Export Specified
[Word Count: 21]

Wireshark can save the packet data in its native file format (pcapng) and in the file formats of other
[Word Count: 19]

protocol analyzers so other tools can read the capture data.
[Word Count: 10]

Saving in a different format might lose data
[Word Count: 8]

Saving your file in a different format might lose information such as comments,
[Word Count: 13]

name resolution, and time stamp resolution. See Time Stamps for more information
[Word Count: 12]

The following file formats can be saved by Wireshark (with the known file extensions):
[Word Count: 14]

• pcapng (*.pcapng). A flexible, extensible successor to the libpcap format. Wireshark 1.8 and
[Word Count: 14]

later save files as pcapng by default. Versions prior to 1.8 used libpcap.
[Word Count: 13]

• pcap (*.pcap). The default format used by the libpcap packet capture library. Used by tcpdump,
[Word Count: 16]

_Snort, Nmap, Ntop, and many other tools.
[Word Count: 7]

• captures from HP-UX nettl ({asterisktrc0,*.trc1)
[Word Count: 6]

• Microsoft Network Monitor - NetMon (*.cap)
[Word Count: 7]

• Network Associates Sniffer - DOS (*.cap,*.enc,*.trc,*.fdc,*.syc)
[Word Count: 7]

• Cinco Networks NetXray captures (*.cap)
[Word Count: 6]

• Network Associates Sniffer - Windows (*.cap)
[Word Count: 7]

• Network Instruments/Viavi Observer (*.bfr)
[Word Count: 5]

• Oracle (previously Sun) snoop (*.snoop,*.cap)
[Word Count: 6]

• Visual Networks Visual UpTime traffic (*.*)
[Word Count: 7]

• Catapult (now Ixia/Keysight) DCT2000 .out files (*.out)
[Word Count: 8]

• Endace Measurement Systems’ ERF format capture(*.erf)
[Word Count: 7]

• Tektronix K12 text file format captures (*.txt)
[Word Count: 8]

• Tektronix K12xx 32bit .rf5 format captures (*.rf5)
[Word Count: 8]

New file formats are added from time to time.
[Word Count: 9]

Whether or not the above tools will be more helpful than Wireshark is a different question ;-)
[Word Count: 17]

Third party protocol analyzers may require specific file extensions
[Word Count: 9]

Wireshark examines a file’s contents to determine its type. Some other protocol
[Word Count: 12]

analyzers only look at a file’s extension. For example, you might need to use the
[Word Count: 15]

.cap extension in order to open a file using the Windows version of Sniffer.
[Word Count: 14]

Sometimes you need to merge several capture files into one. For example, this can be useful if you
[Word Count: 18]

have captured simultaneously from multiple interfaces at once (e.g., using multiple instances of
[Word Count: 13]

There are three ways to merge capture files using Wireshark:
[Word Count: 10]

• Use the File › Merge menu to open the “Merge” dialog. See The “Merge With Capture File”
[Word Count: 18]

Dialog Box for details. This menu item will be disabled unless you have loaded a capture file.
[Word Count: 17]

• Use drag and drop to drop multiple files on the main window. Wireshark will try to merge the
[Word Count: 19]

packets in chronological order from the dropped files into a newly created temporary file. If you
[Word Count: 16]

drop a single file, it will simply replace the existing capture.
[Word Count: 11]

• Use the mergecap tool from the command line to merge capture files. This tool provides the most
[Word Count: 18]

options to merge capture files. See mergecap: Merging multiple capture files into one for details.
[Word Count: 15]

The “Merge With Capture File” Dialog Box
[Word Count: 7]

This lets you select a file to be merged into the currently loaded file. If your current data has not
[Word Count: 20]

been saved you will be asked to save it first.
[Word Count: 10]

Most controls of this dialog will work the same way as described in the “Open Capture File” dialog
[Word Count: 18]

box. See The “Open Capture File” Dialog Box for details.
[Word Count: 10]

Specific controls of this merge dialog are:
[Word Count: 7]

Prepend the packets from the selected file before the currently loaded packets.
[Word Count: 12]

Merge both the packets from the selected and currently loaded file in chronological order.
[Word Count: 14]

Append the packets from the selected file after the currently loaded packets.
[Word Count: 12]

This is the common Windows file open dialog with additional Wireshark extensions.
[Word Count: 12]

This is the Qt file open dialog with additional Wireshark extensions.
[Word Count: 11]

Wireshark can read in a hex dump and write the data described into a temporary libpcap capture
[Word Count: 17]

file. It can read hex dumps with multiple packets in them, and build a capture file of multiple
[Word Count: 18]

packets. It is also capable of generating dummy Ethernet, IP and UDP, TCP, or SCTP headers, in order
[Word Count: 18]

to build fully processable packet dumps from hexdumps of application-level data only.
[Word Count: 12]

Alternatively, a Dummy PDU header can be added to specify a dissector the data should be passed
[Word Count: 17]

Two methods for converting the input are supported:
[Word Count: 8]

Wireshark understands a hexdump of the form generated by od -Ax -tx1 -v. In other words, each
[Word Count: 17]

byte is individually displayed, with spaces separating the bytes from each other. Hex digits can be
[Word Count: 16]

In normal operation, each line must begin with an offset describing the position in the packet,
[Word Count: 16]

followed a colon, space, or tab separating it from the bytes. There is no limit on the width or
[Word Count: 19]

number of bytes per line, but lines with only hex bytes without a leading offset are ignored (i.e., line
[Word Count: 19]

breaks should not be inserted in long lines that wrap.) Offsets are more than two digits; they are in
[Word Count: 19]

hex by default, but can also be in octal or decimal. Each packet must begin with offset zero, and an
[Word Count: 20]

offset zero indicates the beginning of a new packet. Offset values must be correct; an unexpected
[Word Count: 16]

value causes the current packet to be aborted and the next packet start awaited. There is also a
[Word Count: 18]

Packets may be preceded by a direction indicator ('I' or 'O') and/or a timestamp if indicated. If both
[Word Count: 18]

are present, the direction indicator precedes the timestamp. The format of the timestamps must be
[Word Count: 15]

specified. If no timestamp is parsed, in the case of the first packet the current system time is used,
[Word Count: 19]

while subsequent packets are written with timestamps one microsecond later than that of the
[Word Count: 14]

Other text in the input data is ignored. Any text before the offset is ignored, including email
[Word Count: 17]

forwarding characters '>'. Any text on a line after the bytes is ignored, e.g., an ASCII character dump
[Word Count: 18]

(but see -a to ensure that hex digits in the character dump are ignored). Any line where the first
[Word Count: 19]

non-whitespace character is a '#' will be ignored as a comment. Any lines of text between the
[Word Count: 17]

bytestring lines are considered preamble; the beginning of the preamble is scanned for the
[Word Count: 14]

direction indicator and timestamp as mentioned above and otherwise ignored.
[Word Count: 10]

Any line beginning with #TEXT2PCAP is a directive and options can be inserted after this command
[Word Count: 16]

to be processed by Wireshark. Currently there are no directives implemented; in the future, these
[Word Count: 15]

may be used to give more fine-grained control on the dump and the way it should be processed e.g.,
[Word Count: 19]

In general, short of these restrictions, Wireshark is pretty liberal about reading in hexdumps and
[Word Count: 15]

has been tested with a variety of mangled outputs (including being forwarded through email
[Word Count: 14]

multiple times, with limited line wrap etc.)
[Word Count: 7]

Here is a sample dump that can be imported, including optional directional indicator and
[Word Count: 14]

I 2019-05-14T19:04:57Z
000000 00 e0 1e a7 05 6f 00 10 ........
[Word Count: 12]

000008 5a a0 b9 12 08 00 46 00 ........
000010 03 68 00 00 00 00 0a 2e ........
000018 ee 33 0f 19 08 7f 0f 19 ........
000020 03 80 94 04 00 00 10 01 ........
000028 16 a2 0a 00 03 50 00 0c ........
000030 01 01 0f 19 03 80 11 01 ........
[Word Count: 60]

Wireshark is also capable of scanning the input using a custom Perl regular expression as specified
[Word Count: 16]

by GLib’s GRegex here. Using a regex capturing a single packet in the given file Wireshark will
[Word Count: 17]

search the given file from start to the second to last character (the last character has to be \n and is
[Word Count: 21]

ignored) for non-overlapping (and non-empty) strings matching the given regex and then identify
[Word Count: 13]

the fields to import using named capturing subgroups. Using provided format information for each
[Word Count: 14]

field they are then decoded and translated into a standard libpcap file retaining packet order.
[Word Count: 15]

Note that each named capturing subgroup has to match exactly once a packet, but they may be
[Word Count: 17]

> 0:00:00.265620 a130368b000000080060
> 0:00:00.280836 a1216c8b00000000000089086b0b82020407
< 0:00:00.295459 a2010800000000000000000800000000
> 0:00:00.296982 a1303c8b00000008007088286b0bc1ffcbf0f9ff
> 0:00:00.305644 a121718b0000000000008ba86a0b8008
< 0:00:00.319061 a2010900000000000000001000600000
> 0:00:00.330937 a130428b00000008007589186b0bb9ffd9f0fdfa3eb4295e99f3aaffd2f005
> 0:00:00.356037 a121788b0000000000008a18
[Word Count: 24]

regex: ^(?<dir>[<>])\s(?<time>\d+:\d\d:\d\d.\d+)\s(?<data>[0-9a-fA-F]+)$
timestamp: %H:%M:%S.%f
dir: in: <   out: >
encoding: HEX
[Word Count: 11]

Caution has to be applied when discarding the anchors ^ and $, as the input is searched, not parsed,
[Word Count: 19]

meaning even most incorrect regexes will produce valid looking results when not anchored
[Word Count: 13]

(however, anchors are not guaranteed to prevent this). It is generally recommended to sanity check
[Word Count: 15]

any files created using this conversion.
[Word Count: 6]

The only mandatory field. This should match the encoded binary data captured and is used as
[Word Count: 16]

The captured field will be parsed according to the given timestamp format into a timestamp.
[Word Count: 15]

If no timestamp is present an arbitrary counter will count up seconds and nanoseconds by one
[Word Count: 16]

• dir: the direction the packet was sent over the wire
[Word Count: 11]

The captured field is expected to be one character in length, any remaining characters are
[Word Count: 15]

ignored (e.g., given "Input" only the 'I' is looked at). This character is compared to lists of
[Word Count: 17]

characters corresponding to inbound and outbound and the packet is assigned the
[Word Count: 12]

corresponding direction. If neither list yields a match, the direction is set to unknown.
[Word Count: 14]

If this field is not specified the entire file has no directional information.
[Word Count: 13]

Each packet can be assigned an arbitrary ID that can used as field by Wireshark. This field is
[Word Count: 18]

assumed to be a positive integer base 10. This field can e.g. be used to reorder out of order
[Word Count: 19]

If this field is not given, no IDs will be present in the resulting file.
[Word Count: 15]

This dialog box lets you select a text file, containing a hex dump of packet data, to be imported and
[Word Count: 20]

Figure 42. The “Import from Hex Dump” dialog in Hex Dump mode
[Word Count: 12]

Specific controls of this import dialog are split in three sections:
[Word Count: 11]

Determine which input file has to be imported
[Word Count: 8]

Determine how the input file has to be interpreted.
[Word Count: 9]

Determine how the data is to be encapsulated.
[Word Count: 8]

Enter the name of the text file to import. You can use Browse to browse for a file.
[Word Count: 18]

This section is split in the two alternatives for input conversion, accessible in the two Tabs "Hex
[Word Count: 17]

In addition to the conversion mode specific inputs, there are also common parameters, currently
[Word Count: 14]

Select the radix of the offsets given in the text file to import. This is usually hexadecimal, but
[Word Count: 18]

decimal and octal are also supported. Select None when only the bytes are present. These will be
[Word Count: 17]

Tick this box if the text file to import has direction indicators before each frame. These are on a
[Word Count: 19]

separate line before each frame and start with either I or i for input and O or o for output.
[Word Count: 20]

Figure 43. The "Regular Expression" tab inside the "Import from Hex Dump” dialog.
[Word Count: 13]

This is the regex used for searching packets and metadata inside the input file. Named capturing
[Word Count: 16]

subgroups are used to find the individual fields. Anchors ^ and $ are set to match directly before
[Word Count: 18]

and after newlines \n or \r\n. See GRegex for a full documentation.
[Word Count: 12]

The Encoding used for the binary data. Supported encodings are plain-hexadecimal, -octal,
[Word Count: 12]

-binary and base64. Plain here means no additional characters are present in the data field
[Word Count: 15]

beyond whitespaces, which are ignored. Any unexpected characters abort the import process.
[Word Count: 12]

Ignored whitespaces are \r, \n, \t, \v, ` ` and only for hex :, only for base64 =.
[Word Count: 18]

Any incomplete bytes at the field’s end are assumed to be padding to fill the last complete byte.
[Word Count: 18]

These bits should be zero, however, this is not checked.
[Word Count: 10]

The lists of characters indicating incoming vs. outgoing packets. These fields are only available
[Word Count: 14]

when the regex contains a (?<dir>…) group.
[Word Count: 7]

This is the format specifier used to parse the timestamps in the text file to import. It uses the
[Word Count: 19]

same format as strptime(3) with the addition of %f for zero padded fractions of seconds. The
[Word Count: 16]

precision of %f is determined from its length. The most common fields are %H, %M and %S for hours,
[Word Count: 19]

minutes and seconds. The straightforward HH:MM:SS format is covered by %T. For a full
[Word Count: 14]

definition of the syntax look for strptime(3),
[Word Count: 7]

In Regex mode this field is only available when a (?<time>…) group is present.
[Word Count: 14]

In Hex Dump mode if there are no timestamps in the text file to import, leave this field empty
[Word Count: 19]

and timestamps will be generated based on the time of import.
[Word Count: 11]

Here you can select which type of frames you are importing. This all depends on from what type
[Word Count: 18]

of medium the dump to import was taken. It lists all types that Wireshark understands, so as to
[Word Count: 18]

pass the capture file contents to the right dissector.
[Word Count: 9]

When Ethernet encapsulation is selected you have to option to prepend dummy headers to the
[Word Count: 15]

frames to import. These headers can provide artificial Ethernet, IP, UDP, TCP or SCTP headers or
[Word Count: 16]

SCTP data chunks. When selecting a type of dummy header, the applicable entries are enabled,
[Word Count: 15]

others are greyed out and default values are used. When the Wireshark Upper PDU export
[Word Count: 15]

encapsulation is selected the option ExportPDU becomes available. This allows you to select the
[Word Count: 14]

name of the dissector these frames are to be directed to.
[Word Count: 11]

You may not be interested in the full frames from the text file, just the first part. Here you can
[Word Count: 20]

define how much data from the start of the frame you want to import. If you leave this open the
[Word Count: 20]

Once all input and import parameters are setup click [ Import ] to start the import. If your current
[Word Count: 19]

data wasn’t saved before you will be asked to save it first.
[Word Count: 12]

If the import button doesn’t unlock, make sure all encapsulation parameters are in the expected
[Word Count: 15]

range and all unlocked fields are populated when using regex mode (the placeholder text is not
[Word Count: 16]

When completed there will be a new capture file loaded with the frames imported from the text
[Word Count: 17]

When using the “Multiple Files” option while doing a capture (see: Capture files and file modes), the
[Word Count: 17]

capture data is spread over several capture files, called a file set.
[Word Count: 12]

As it can become tedious to work with a file set by hand, Wireshark provides some features to
[Word Count: 18]

handle these file sets in a convenient way.
[Word Count: 8]

How does Wireshark detect the files of a file set?
[Word Count: 10]

A filename in a file set uses the format Prefix_Number_DateTimeSuffix (or, in Wireshark 4.4.0
[Word Count: 14]

and 
later, 
Prefix_DateTime_NumberSuffix) 
which 
might 
look 
something 
like
[Word Count: 8]

test_00001_20240714183910.pcap. All files of a file set share the same prefix (e.g., “test”) and
[Word Count: 14]

suffix (e.g., “.pcap”) and a varying middle part. Files are also allowed to have a second
[Word Count: 16]

compression suffix of types that Wireshark can open; the compression suffix does not have to
[Word Count: 15]

To find the files of a file set, Wireshark scans the directory where the currently loaded file
[Word Count: 17]

resides and checks for files matching the filename pattern (prefix and suffix) of the currently
[Word Count: 15]

This simple mechanism usually works well but has its drawbacks. If several file sets were
[Word Count: 15]

captured with the same prefix and suffix, Wireshark will detect them as a single file set. If
[Word Count: 17]

files were renamed or spread over several directories the mechanism will fail to find all files
[Word Count: 16]

The following features in the File › File Set submenu are available to work with file sets in a
[Word Count: 19]

• The “List Files” dialog box will list the files Wireshark has recognized as being part of the
[Word Count: 18]

• [ Next File ] closes the current and opens the next file in the file set.
[Word Count: 17]

• [ Previous File ] closes the current and opens the previous file in the file set.
[Word Count: 17]

Each line contains information about a file of the file set:
[Word Count: 11]

The name of the file. If you click on the filename (or the radio button left to it), the current file
[Word Count: 21]

will be closed and the corresponding capture file will be opened.
[Word Count: 11]

The last line will contain info about the currently used directory where all of the files in the file set
[Word Count: 20]

The content of this dialog box is updated each time a capture file is opened/closed.
[Word Count: 15]

The [ Close ] button will, well, close the dialog box.
[Word Count: 11]

Wireshark provides a variety of options for exporting packet data. This section describes general
[Word Count: 14]

ways to export data from the main Wireshark application. There are many other ways to export or
[Word Count: 17]

extract data from capture files, including processing tshark output and customizing Wireshark and
[Word Count: 13]

The “Export Specified Packets” Dialog Box
[Word Count: 6]

Figure 45. The “Export Specified Packets” dialog box
[Word Count: 8]

This is similar to the “Save” dialog box, but it lets you save specific packets. This can be useful for
[Word Count: 20]

trimming irrelevant or unwanted packets from a capture file. See Packet Range for details on the
[Word Count: 16]

The “Export Packet Dissections” Dialog Box
[Word Count: 6]

This lets you save the packet list, packet details, and packet bytes as plain text, CSV, JSON, and other
[Word Count: 19]

Figure 46. The “Export Packet Dissections” dialog box
[Word Count: 8]

The format can be selected from the “Export As” drop-down and further customized using the
[Word Count: 15]

“Packet Range” and “Packet Format” controls. Some controls are unavailable for some formats,
[Word Count: 13]

notably CSV and JSON. The following formats are supported:
[Word Count: 9]

• Plain text as shown in the main window
[Word Count: 9]

Here are some examples of exported data:
[Word Count: 7]

No.     Time           Source                Destination           Protocol Length
SSID       Info
      1 0.000000       200.121.1.131         172.16.0.122          TCP      1454
10554 → 80 [ACK] Seq=1 Ack=1 Win=65535 Len=1400 [TCP segment of a reassembled PDU]
[Word Count: 28]

If you would like to be able to import any previously exported packets from a plain
[Word Count: 16]

text file it is recommended that you do the following:
[Word Count: 10]

• Add the “Absolute date and time” column.
[Word Count: 8]

• Disable the Edit › Preferences › Protocols › Data “Show not dissected data on new
[Word Count: 16]

Packet Bytes pane” preference. More details are provided in Preferences
[Word Count: 10]

"No.","Time","Source","Destination","Protocol","Length","SSID","Info","Win Size"
"1","0.000000","200.121.1.131","172.16.0.122","TCP","1454","","10554  >  80 [ACK]
Seq=1 Ack=1 Win=65535 Len=1400 [TCP segment of a reassembled PDU]","65535"
"2","0.000011","172.16.0.122","200.121.1.131","TCP","54","","[TCP ACKed unseen
segment] 80  >  10554 [ACK] Seq=1 Ack=11201 Win=53200 Len=0","53200"
"3","0.025738","200.121.1.131","172.16.0.122","TCP","1454","","[TCP Spurious
Retransmission] 10554  >  80 [ACK] Seq=1401 Ack=1 Win=65535 Len=1400 [TCP segment of a
reassembled PDU]","65535"
"4","0.025749","172.16.0.122","200.121.1.131","TCP","54","","[TCP Window Update] [TCP
ACKed unseen segment] 80  >  10554 [ACK] Seq=1 Ack=11201 Win=63000 Len=0","63000"
"5","0.076967","200.121.1.131","172.16.0.122","TCP","1454","","[TCP Previous segment
not captured] [TCP Spurious Retransmission] 10554  >  80 [ACK] Seq=4201 Ack=1
Win=65535 Len=1400 [TCP segment of a reassembled PDU]","65535"
[Word Count: 82]

{
    "_index": "packets-2014-06-22",
    "_type": "doc",
    "_score": null,
    "_source": {
      "layers": {
        "frame": {
          "frame.encap_type": "1",
          "frame.time": "Jun 22, 2014 13:29:41.834477000 PDT",
          "frame.offset_shift": "0.000000000",
          "frame.time_epoch": "1403468981.834477000",
          "frame.time_delta": "0.450535000",
          "frame.time_delta_displayed": "0.450535000",
          "frame.time_relative": "0.450535000",
          "frame.number": "2",
          "frame.len": "86",
          "frame.cap_len": "86",
          "frame.marked": "0",
[Word Count: 39]

"frame.ignored": "0",
          "frame.protocols": "eth:ethertype:ipv6:icmpv6",
          "frame.coloring_rule.name": "ICMP",
          "frame.coloring_rule.string": "icmp || icmpv6"
        },
        "eth": {
          "eth.dst": "33:33:ff:9e:e3:8e",
          "eth.dst_tree": {
            "eth.dst_resolved": "33:33:ff:9e:e3:8e",
            "eth.dst.oui": "3355647",
            "eth.addr": "33:33:ff:9e:e3:8e",
            "eth.addr_resolved": "33:33:ff:9e:e3:8e",
            "eth.addr.oui": "3355647",
            "eth.dst.lg": "1",
            "eth.lg": "1",
            "eth.dst.ig": "1",
            "eth.ig": "1"
          },
          "eth.src": "00:01:5c:62:8c:46",
          "eth.src_tree": {
            "eth.src_resolved": "00:01:5c:62:8c:46",
            "eth.src.oui": "348",
            "eth.src.oui_resolved": "Cadant Inc.",
            "eth.addr": "00:01:5c:62:8c:46",
            "eth.addr_resolved": "00:01:5c:62:8c:46",
            "eth.addr.oui": "348",
            "eth.addr.oui_resolved": "Cadant Inc.",
            "eth.src.lg": "0",
            "eth.lg": "0",
            "eth.src.ig": "0",
            "eth.ig": "0"
          },
          "eth.type": "0x000086dd"
        },
        "ipv6": {
          "ipv6.version": "6",
          "ip.version": "6",
          "ipv6.tclass": "0x00000000",
          "ipv6.tclass_tree": {
            "ipv6.tclass.dscp": "0",
            "ipv6.tclass.ecn": "0"
          },
          "ipv6.flow": "0x00000000",
          "ipv6.plen": "32",
          "ipv6.nxt": "58",
          "ipv6.hlim": "255",
          "ipv6.src": "2001:558:4080:16::1",
          "ipv6.addr": "2001:558:4080:16::1",
[Word Count: 95]

"ipv6.src_host": "2001:558:4080:16::1",
          "ipv6.host": "2001:558:4080:16::1",
          "ipv6.dst": "ff02::1:ff9e:e38e",
          "ipv6.addr": "ff02::1:ff9e:e38e",
          "ipv6.dst_host": "ff02::1:ff9e:e38e",
          "ipv6.host": "ff02::1:ff9e:e38e",
          "ipv6.geoip.src_summary": "US, ASN 7922, Comcast Cable Communications, LLC",
          "ipv6.geoip.src_summary_tree": {
            "ipv6.geoip.src_country": "United States",
            "ipv6.geoip.country": "United States",
            "ipv6.geoip.src_country_iso": "US",
            "ipv6.geoip.country_iso": "US",
            "ipv6.geoip.src_asnum": "7922",
            "ipv6.geoip.asnum": "7922",
            "ipv6.geoip.src_org": "Comcast Cable Communications, LLC",
            "ipv6.geoip.org": "Comcast Cable Communications, LLC",
            "ipv6.geoip.src_lat": "37.751",
            "ipv6.geoip.lat": "37.751",
            "ipv6.geoip.src_lon": "-97.822",
            "ipv6.geoip.lon": "-97.822"
          }
        },
        "icmpv6": {
          "icmpv6.type": "135",
          "icmpv6.code": "0",
          "icmpv6.checksum": "0x00005b84",
          "icmpv6.checksum.status": "1",
          "icmpv6.reserved": "00:00:00:00",
          "icmpv6.nd.ns.target_address": "2001:558:4080:16:be36:e4ff:fe9e:e38e",
          "icmpv6.opt": {
            "icmpv6.opt.type": "1",
            "icmpv6.opt.length": "1",
            "icmpv6.opt.linkaddr": "00:01:5c:62:8c:46",
            "icmpv6.opt.src_linkaddr": "00:01:5c:62:8c:46"
          }
        }
      }
    }
  }
]
[Word Count: 86]

The “Export Selected Packet Bytes” Dialog Box
[Word Count: 7]

Export the bytes selected in the “Packet Bytes” pane into a raw binary file.
[Word Count: 14]

Figure 47. The “Export Selected Packet Bytes” dialog box
[Word Count: 9]

The file name to export the packet data to.
[Word Count: 9]

The “Export PDUs to File…” dialog box allows you to filter the captured Protocol Data Units (PDUs)
[Word Count: 17]

and export them into the file. It allows you to export reassembled PDUs avoiding lower layers such
[Word Count: 17]

as HTTP without TCP, and decrypted PDUs without the lower protocols such as HTTP without TLS
[Word Count: 16]

1. In the main menu select File › Export PDUs to File…. Wireshark will open a corresponding
[Word Count: 17]

2. To select the data according to your needs, optionally type a filter value into the Display Filter
[Word Count: 18]

field. For more information about filter syntax, see the Wireshark Filters man page.
[Word Count: 13]

3. In the field below the Display Filter field you can choose the level from which you want to
[Word Count: 19]

export the PDUs to the file. There are seven levels:
[Word Count: 10]

a. DLT User. You can export a protocol, which is framed in the user data link type table without
[Word Count: 19]

the need to reconfigure the DLT user table. For more information, see the How to Dissect
[Word Count: 16]

b. DVB-CI. You can use it for the Digital Video Broadcasting (DVB) protocol.
[Word Count: 13]

c. Logcat and Logcat Text. You can use them for the Android logs.
[Word Count: 13]

d. OSI layer 3. You can use it to export PDUs encapsulated in the IPSec or SCTP protocols.
[Word Count: 18]

e. OSI layer 4. You can use it to export PDUs encapsulated in the TCP or UDP protocols.
[Word Count: 18]

f. OSI layer 7. You can use it to export the following protocols: CredSSP over TLS, Diameter,
[Word Count: 17]

protocols encapsulated in TLS and DTLS, H.248, Megaco, RELOAD framing, SIP, SMPP.
[Word Count: 12]

NOTE
As a developer you can add any dissector to the existing list or define a new
[Word Count: 17]

entry in the list by using the functions in epan/exported_pdu.h.
[Word Count: 10]

4. To finish exporting PDUs to file, click the [ OK ] button in the bottom-right corner. This will close
[Word Count: 20]

the originally captured file and open the exported results instead as a temporary file in the
[Word Count: 16]

5. You may save the temporary file just like any captured file. See Saving Captured Packets for
[Word Count: 17]

The file produced has a Wireshark Upper PDU encapsulation type that has
[Word Count: 12]

somewhat limited support outside of Wireshark, but is very flexible and can
[Word Count: 12]

contain PDUs for any protocol for which there is a Wireshark dissector.
[Word Count: 12]

The “Strip Headers…” dialog box allows you to filter known encapsulation types on whatever
[Word Count: 14]

protocol layer they appear and export them into a new capture file, removing lower-level protocols.
[Word Count: 15]

It allows you to export reassembled packets and frames without lower layers such as GPF, GRE,
[Word Count: 16]

GSE, GTP-U, MPLS, MPE, PPP, and more. If Wireshark has performed decryption, then you can
[Word Count: 15]

export decrypted IP from protocols like IEEE 802.11 or IPSec without having to save encryption
[Word Count: 15]

The procedure is similar to that of The “Export PDUs to File…” Dialog Box:
[Word Count: 14]

1. In the main menu select File › Strip Headers…. Wireshark will open a corresponding dialog.
[Word Count: 16]

2. To select the data according to your needs, optionally type a filter value into the Display Filter
[Word Count: 18]

field. For more information about filter syntax, see the Wireshark Filters man page.
[Word Count: 13]

3. In the field below the Display Filter field you can choose the encapsulation type you want to
[Word Count: 18]

find and export to the file. There are two encapsulations supported:
[Word Count: 11]

a. Ethernet. You can use it to export Ethernet encapsulated in other protocols.
[Word Count: 13]

b. IP. You can use it to export IPv4 and IPv6 encapsulated in other protocols.
[Word Count: 15]

NOTE
As a developer you can add encapsulations to the list by using the functions
[Word Count: 15]

4. To finish exporting to file, click the [ OK ] button in the bottom-right corner. This will close the
[Word Count: 20]

originally captured file and open the exported results instead as a temporary file in the main
[Word Count: 16]

5. You may save the temporary file just like any captured file. See Saving Captured Packets for
[Word Count: 17]

NOTE
The new capture files produced have standard encapsulation types and can be
[Word Count: 13]

The “Export TLS Session Keys…” Dialog Box
[Word Count: 7]

Transport Layer Security (TLS) encrypts the communication between a client and a server. The
[Word Count: 14]

most common use for it is web browsing via HTTPS.
[Word Count: 10]

Decryption of TLS traffic requires TLS secrets. You can get them in the form of stored session keys
[Word Count: 18]

in a "key log file", or by using an RSA private key file. For more details, see the TLS wiki page.
[Word Count: 21]

The File › Export TLS Session Keys… menu option generates a new "key log file" which contains
[Word Count: 17]

TLS session secrets known by Wireshark. This feature is useful if you typically decrypt TLS sessions
[Word Count: 16]

using the RSA private key file. The RSA private key is very sensitive because it can be used to
[Word Count: 19]

decrypt other TLS sessions and impersonate the server. Session keys can be used only to decrypt
[Word Count: 16]

sessions from the packet capture file. However, session keys are the preferred mechanism for
[Word Count: 14]

To export captured TLS session keys, follow the steps below:
[Word Count: 10]

1. In the main menu select File › Export TLS Session Keys…. Wireshark will open a
[Word Count: 16]

corresponding dialog Export TLS Session Keys window.
[Word Count: 7]

Figure 49. Export TLS Session Keys window
[Word Count: 7]

2. Type the desired file name in the Save As field.
[Word Count: 11]

3. Choose the destination folder for your file in the Where field.
[Word Count: 12]

4. Press the [ Save ] button to complete the export file procedure.
[Word Count: 13]

This feature scans through the selected protocol’s streams in the currently open capture file or
[Word Count: 15]

running capture and allows the user to export reassembled objects to the disk. For example, if you
[Word Count: 17]

select HTTP, you can export HTML documents, images, executables, and any other files transferred
[Word Count: 14]

over HTTP to the disk. If you have a capture running, this list is automatically updated every few
[Word Count: 18]

seconds with any new objects seen. The saved objects can then be opened or examined
[Word Count: 15]

Figure 50. The “Export Objects” dialog box
[Word Count: 7]

The packet number in which this object was found. In some cases, there can be multiple objects
[Word Count: 17]

The hostname of the server that sent this object.
[Word Count: 9]

Filename: The filename for this object. Each protocol generates the filename differently. For
[Word Count: 13]

example, HTTP uses the final part of the URI and IMF uses the subject of the email.
[Word Count: 17]

Only displays objects containing the specified text string.
[Word Count: 8]

Opens this section of the “User’s Guide”.
[Word Count: 7]

Saves all objects (including those not displayed) using the filename from the filename column.
[Word Count: 14]

You will be asked what directory or folder to save them in.
[Word Count: 12]

Saves the currently selected object as a filename you specify. The default filename to save as is
[Word Count: 17]

taken from the filename column of the objects list.
[Word Count: 9]

To print packets, select the File › Print… menu item. Wireshark will display the “Print” dialog box
[Word Count: 17]

Printed output can contain lots of text, particularly if you print packet details
[Word Count: 13]

The “Print” dialog box shows a preview area which shows the result of changing the packet format
[Word Count: 17]

settings. You can zoom in and out using the +  and -  keys and reset the zoom level using the 0  key.
[Word Count: 22]

The following settings are available in the Print dialog box:
[Word Count: 10]

Lets you specify what gets printed. See The “Packet Format” frame for details.
[Word Count: 13]

Include a summary line for each packet. The line will contain the same fields as the packet
[Word Count: 17]

Select the packets to be printed. See The “Packet Range” Frame for details.
[Word Count: 13]

[ Page Setup… ] lets you select the page size and orientation.
[Word Count: 12]

[ Print… ] prints to your default printer.
[Word Count: 8]

[ Cancel ] will close the dialog without printing.
[Word Count: 9]

[ Help ] will display this section of the “User’s Guide”.
[Word Count: 11]

The packet range frame is a part of the “Export Specified Packets,” “Export Packet Dissections,” and
[Word Count: 16]

“Print” dialog boxes. You can use it to specify which packets will be exported or printed.
[Word Count: 16]

By default, the [ Displayed ] button is set, which only exports or prints the packets that match the
[Word Count: 19]

current display filter. Selecting [ Captured ] will export or print all packets. You can further limit
[Word Count: 17]

what you export or print to the following:
[Word Count: 8]

All captured or displayed packets depending on the primary selection above.
[Word Count: 11]

Only marked packets. See Marking Packets.
[Word Count: 6]

Lets you mark an inclusive range of packets.
[Word Count: 8]

Lets you manually specify a range of packets, e.g., 5,10-15,20- will process the packet number
[Word Count: 15]

five, the packets from packet number ten to fifteen (inclusive) and every packet from number
[Word Count: 15]

Don’t export or print ignored packets. See Ignoring Packets.
[Word Count: 9]

The packet format frame is also a part of the “Export Packet Dissections” and “Print” dialog boxes.
[Word Count: 17]

You can use it to specify which parts of dissection are exported or printed.
[Word Count: 14]

Each of the settings below correspond to the packet list, packet detail, and packet bytes in the main
[Word Count: 18]

Export or print each summary line as shown in the “Packet List” pane.
[Word Count: 13]

Export or print the contents of the “Packet Details” tree.
[Word Count: 10]

Export or print as if the “Packet Details” tree is in the “all collapsed” state.
[Word Count: 15]

Export or print as if the “Packet Details” tree is in the “as displayed” state.
[Word Count: 15]

Export or print as if the “Packet Details” tree is in the “all expanded” state.
[Word Count: 15]

Export or print the contents of the “Packet Bytes” pane.
[Word Count: 10]

For printing and some export formats, put each packet on a separate page. For example, when
[Word Count: 16]

exporting to a text file this will put a form feed character between each packet.
[Word Count: 15]

Add a header to each page with capture filename and the number of total packets and shown
[Word Count: 17]

Once you have captured some packets or you have opened a previously saved capture file, you can
[Word Count: 17]

view the packets that are displayed in the packet list pane by simply clicking on a packet in the
[Word Count: 19]

packet list pane, which will bring up the selected packet in the tree view and byte view panes.
[Word Count: 18]

You can then expand any part of the tree to view detailed information about each protocol in each
[Word Count: 18]

packet. Clicking on an item in the tree will highlight the corresponding bytes in the byte view. An
[Word Count: 18]

example with a TCP packet selected is shown in Wireshark with a TCP packet selected for viewing.
[Word Count: 17]

It also has the Acknowledgment number in the TCP header selected, which shows up in the byte
[Word Count: 17]

Figure 54. Wireshark with a TCP packet selected for viewing
[Word Count: 10]

You can also select and view packets the same way while Wireshark is capturing if you selected
[Word Count: 17]

“Update list of packets in real time” in the “Capture Preferences” dialog box.
[Word Count: 13]

In addition you can view individual packets in a separate window as shown in Viewing a packet in
[Word Count: 18]

a separate window. You can do this by double-clicking on an item in the packet list or by selecting
[Word Count: 19]

the packet in which you are interested in the packet list pane and selecting View › Show Packet in
[Word Count: 19]

New Window. This allows you to easily compare two or more packets, even across multiple files.
[Word Count: 16]

Figure 55. Viewing a packet in a separate window
[Word Count: 9]

Along with double-clicking the packet list and using the main menu there are a number of other
[Word Count: 17]

• Hold down the shift key and double-click on a frame link in the packet details.
[Word Count: 16]

• From The menu items of the “Packet List” pop-up menu.
[Word Count: 11]

• From The menu items of the “Packet Details” pop-up menu.
[Word Count: 11]

You can open a pop-up menu over the “Packet List”, its column heading, “Packet Details”, or “Packet
[Word Count: 17]

Bytes” by clicking your right mouse button on the corresponding item.
[Word Count: 11]

Pop-up Menu Of The “Packet List” Column Header
[Word Count: 8]

Figure 56. Pop-up menu of the “Packet List” column header
[Word Count: 10]

The following table gives an overview of which functions are available in this header, where to find
[Word Count: 17]

the corresponding function in the main menu, and a description of each item.
[Word Count: 13]

Table 18. The menu items of the “Packet List” column header pop-up menu
[Word Count: 13]

Align Left
Left-align values in this column.
[Word Count: 7]

Align Center
Center-align values in this column.
[Word Count: 7]

Align Right
Right-align values in this column.
[Word Count: 7]

Column Preferences…
Open the “Preferences” dialog for this column.
[Word Count: 9]

Edit Column
Open the column editor toolbar for this column.
[Word Count: 10]

Resize To Contents
Resize the column to fit its values.
[Word Count: 10]

Display as Values
Display the raw values for fields.
[Word Count: 9]

Display as Strings
Display human-readable strings instead of raw values for fields.
[Word Count: 12]

Only applicable to custom columns with fields that have value
[Word Count: 10]

strings and custom columns which can be resolved to strings.
[Word Count: 10]

Display as packet Details
Display the values using the same format as in Packet Details. Only
[Word Count: 16]

No., Time, Source, et al.
Show or hide a column by selecting its item.
[Word Count: 14]

Remove Column
Remove this column, similar to deleting it in the “Preferences”
[Word Count: 12]

Figure 57. Pop-up menu of the “Packet List” pane
[Word Count: 9]

The following table gives an overview of which functions are available in this pane, where to find
[Word Count: 17]

the corresponding function in the main menu, and a short description of each item.
[Word Count: 14]

Table 19. The menu items of the “Packet List” pop-up menu
[Word Count: 11]

Mark Packet (toggle)
Edit
Mark or unmark a packet.
[Word Count: 9]

Ignore Packet (toggle)
Edit
Ignore or inspect this packet while dissecting the capture
[Word Count: 13]

Time Shift
Edit
Opens the “Time Shift” dialog, which allows you to adjust
[Word Count: 13]

Packet Comment…
Edit
Opens the “Packet Comment” dialog, which lets you add a
[Word Count: 13]

comment to a single packet. Note that the ability to save
[Word Count: 11]

packet comments depends on your file format. E.g.,
[Word Count: 8]

pcapng supports comments, pcap does not.
[Word Count: 6]

Edit Resolved Name
Allows you to enter a name to resolve for the selected
[Word Count: 14]

Apply as Filter
Analyze Immediately replace or append the current display filter
[Word Count: 12]

based on the most recent packet list or packet details item
[Word Count: 11]

selected. The first submenu item shows the filter and
[Word Count: 9]

subsequent items show the different ways that the filter
[Word Count: 9]

Prepare as Filter
Analyze Change the current display filter based on the most recent
[Word Count: 14]

packet list or packet details item selected, but don’t apply
[Word Count: 10]

it. The first submenu item shows the filter and subsequent
[Word Count: 10]

items show the different ways that the filter can be
[Word Count: 10]

Conversation Filter
Apply a display filter with the address information from
[Word Count: 11]

the selected packet. For example, the IP menu entry will
[Word Count: 10]

set a filter to show the traffic between the two IP
[Word Count: 11]

Colorize Conversation
Create a new colorizing rule based on address information
[Word Count: 11]

SCTP
Allows you to analyze and prepare a filter for this SCTP
[Word Count: 12]

Follow
Analyze Opens a sub-menu with options of various types of
[Word Count: 11]

protocol streams to follow. The entries for protocols which
[Word Count: 9]

aren’t found in the currently selected packet will not be
[Word Count: 10]

Copy › Summary as Text
Copy the summary fields as displayed to the clipboard as
[Word Count: 15]

Copy › …as CSV
Copy the summary fields as displayed to the clipboard as
[Word Count: 14]

Copy › …as YAML
Copy the summary fields as displayed to the clipboard as
[Word Count: 14]

Copy › As Filter
Prepare a display filter based on the currently selected
[Word Count: 13]

item and copy that filter to the clipboard.
[Word Count: 8]

Copy the packet bytes to the clipboard in full “hexdump”
[Word Count: 10]

Copy › …as Hex Dump
Copy the packet bytes to the clipboard in “hexdump”
[Word Count: 14]

Copy › …as Printable Text
Copy the packet bytes to the clipboard as ASCII text,
[Word Count: 15]

Copy › …as a Hex Stream
Copy the packet bytes to the clipboard as an unpunctuated
[Word Count: 16]

Copy › …as Raw Binary
Copy the packet bytes to the clipboard as raw binary. The
[Word Count: 16]

data is stored in the clipboard using the MIME type
[Word Count: 10]

Protocol Preferences
Adjust the preferences for the selected protocol, or disable
[Word Count: 11]

it entirely. (You can re-enable it with the “Enabled
[Word Count: 9]

Decode As…
Analyze Change or apply a new relation between two dissectors.
[Word Count: 12]

View
Shows the selected packet in a separate window. The
[Word Count: 10]

separate window shows only the packet details and bytes.
[Word Count: 9]

See Viewing a packet in a separate window for details.
[Word Count: 10]

Pop-up Menu Of The “Packet Details” Pane
[Word Count: 7]

Figure 58. Pop-up menu of the “Packet Details” pane
[Word Count: 9]

The following table gives an overview of which functions are available in this pane, where to find
[Word Count: 17]

the corresponding function in the main menu, and a short description of each item.
[Word Count: 14]

Table 20. The menu items of the “Packet Details” pop-up menu
[Word Count: 11]

Expand Subtrees
View
Expand the currently selected subtree.
[Word Count: 8]

Collapse Subtrees
View
Collapse the currently selected subtree.
[Word Count: 8]

Expand All
View
Expand all subtrees in all packets in the capture.
[Word Count: 12]

Collapse All
View
Wireshark keeps a list of all the protocol subtrees that are
[Word Count: 14]

expanded, and uses it to ensure that the correct subtrees
[Word Count: 10]

are expanded when you display a packet. This menu item
[Word Count: 10]

collapses the tree view of all packets in the capture list.
[Word Count: 11]

Edit Resolved Name
View
Allows you to enter a name to resolve for the selected
[Word Count: 15]

Apply as Column
Use the selected protocol item to create a new column in
[Word Count: 14]

Apply as Filter
Analyze Immediately replace or append the current display filter
[Word Count: 12]

based on the most recent packet list or packet details item
[Word Count: 11]

selected. The first submenu item shows the filter and
[Word Count: 9]

subsequent items show the different ways that the filter
[Word Count: 9]

Prepare as Filter
Analyze Change the current display filter based on the most recent
[Word Count: 14]

packet list or packet details item selected, but don’t apply
[Word Count: 10]

it. The first submenu item shows the filter and subsequent
[Word Count: 10]

items show the different ways that the filter can be
[Word Count: 10]

Colorize with Filter
This menu item uses a display filter with the information
[Word Count: 13]

from the selected protocol item to build a new colorizing
[Word Count: 10]

Follow
Analyze Opens a sub-menu with options of various types of
[Word Count: 11]

protocol streams to follow. The entries for protocols which
[Word Count: 9]

aren’t found in the currently selected packet will not be
[Word Count: 10]

Copy › All Visible Items
Edit
Copy the packet details as displayed.
[Word Count: 12]

Edit
Copy the selected packet detail and its children as
[Word Count: 10]

Copy › Description
Edit
Copy the displayed text of the selected field to the system
[Word Count: 15]

Copy › Fieldname
Edit
Copy the name of the selected field to the system
[Word Count: 14]

Copy › Value
Edit
Copy the value of the selected field to the system
[Word Count: 14]

Copy › As Filter
Edit
Prepare a display filter based on the currently selected
[Word Count: 14]

Copy the packet bytes to the clipboard in full “hexdump”
[Word Count: 10]

Copy › …as Hex Dump
Copy the packet bytes to the clipboard in “hexdump”
[Word Count: 14]

Copy › …as Printable Text
Copy the packet bytes to the clipboard as ASCII text,
[Word Count: 15]

Copy › …as a Hex Stream
Copy the packet bytes to the clipboard as an unpunctuated
[Word Count: 16]

Copy › …as Raw Binary
Copy the packet bytes to the clipboard as raw binary. The
[Word Count: 16]

data is stored in the clipboard using the MIME type
[Word Count: 10]

Copy › …as Escaped String
Copy the packet bytes to the clipboard as C-style escape
[Word Count: 15]

Export Packet Bytes…
File
This menu item is the same as the File menu item of the
[Word Count: 17]

same name. It allows you to export raw packet bytes to a
[Word Count: 12]

Wiki Protocol Page
Open the wiki page for the selected protocol in your web
[Word Count: 14]

Filter Field Reference
Open the filter field reference web page for the selected
[Word Count: 13]

Protocol Preferences
Adjust the preferences for the selected protocol, or disable
[Word Count: 11]

it entirely. (You can re-enable it with the “Enabled
[Word Count: 9]

Decode As…
Analyze Change or apply a new relation between two dissectors.
[Word Count: 12]

Go to Linked Packet
Go
If the selected field has a corresponding packet such as the
[Word Count: 16]

matching request for a DNS response, go to it.
[Word Count: 9]

Go
If the selected field has a corresponding packet such as the
[Word Count: 12]

matching request for a DNS response, show the selected
[Word Count: 9]

packet in a separate window. See Viewing a packet in a
[Word Count: 11]

Figure 59. Pop-up menu of the “Packet Bytes” pane
[Word Count: 9]

The following table gives an overview of which functions are available in this pane along with a
[Word Count: 17]

Table 21. The menu items of the “Packet Bytes” pop-up menu
[Word Count: 11]

Copy the packet bytes to the clipboard in full “hexdump” format.
[Word Count: 11]

…as Hex Dump
Copy the packet bytes to the clipboard in “hexdump” format without
[Word Count: 14]

…as Printable Text
Copy the packet bytes to the clipboard as ASCII text, excluding non-
[Word Count: 15]

…as a Hex Stream
Copy the packet bytes to the clipboard as an unpunctuated list of hex
[Word Count: 17]

…as Raw Binary
Copy the packet bytes to the clipboard as raw binary. The data is
[Word Count: 16]

stored in the clipboard using the MIME type “application/octet-
[Word Count: 9]

…as Escaped String
Copy the packet bytes to the clipboard as C-style escape sequences.
[Word Count: 14]

Show bytes as hexadecimal Display the byte data as hexadecimal digits.
[Word Count: 11]

Show bytes as bits
Display the byte data as binary digits.
[Word Count: 11]

Show text based on packet
Show the “hexdump” data with text.
[Word Count: 11]

…as ASCII
Use ASCII encoding when displaying “hexdump” text.
[Word Count: 9]

…as EBCDIC
Use EBCDIC encoding when displaying “hexdump” text.
[Word Count: 9]

Pop-up Menu Of The “Packet Diagram” Pane
[Word Count: 7]

Figure 60. Pop-up menu of the “Packet Diagram” pane
[Word Count: 9]

The following table gives an overview of which functions are available in this pane along with a
[Word Count: 17]

Table 22. The menu items of the “Packet Diagram” pop-up menu
[Word Count: 11]

Show Field Values
Display current value for each field on the packet diagram.
[Word Count: 13]

Save Diagram As…
Save the packet diagram to an image file (PNG, BMP, JPEG).
[Word Count: 14]

Copy as Raster Image
Copy the packet diagram to the clipboard in raster (ARGB32) format.
[Word Count: 15]

Wireshark has two filtering languages: capture filters and display filters. Capture filters are used for
[Word Count: 15]

filtering when capturing packets and are discussed in Filtering while capturing. Display filters are
[Word Count: 14]

used for filtering which packets are displayed and are discussed below. For more information about
[Word Count: 15]

display filter syntax, see the wireshark-filter(4) man page.
[Word Count: 8]

Display filters allow you to concentrate on the packets you are interested in while hiding the
[Word Count: 16]

currently uninteresting ones. They allow you to only display packets based on:
[Word Count: 12]

To only display packets containing a particular protocol, type the protocol name in the display filter
[Word Count: 16]

toolbar of the Wireshark window and press enter to apply the filter. Filtering on the TCP protocol
[Word Count: 17]

shows an example of what happens when you type tcp in the display filter toolbar.
[Word Count: 15]

NOTE
Protocol and field names are usually in lowercase.
[Word Count: 9]

NOTE
Don’t forget to press enter or click on the apply display filter button after entering
[Word Count: 16]

Figure 61. Filtering on the TCP protocol
[Word Count: 7]

As you may have noticed, only packets containing the TCP protocol are now displayed, so packets 1-
[Word Count: 17]

10 are hidden and packet number 11 is the first packet displayed.
[Word Count: 12]

NOTE
When using a display filter, all packets remain in the capture file. The display filter
[Word Count: 16]

only changes the display of the capture file but not its content!
[Word Count: 12]

To remove the filter, click on the [ Clear ] button to the right of the display filter field. All packets
[Word Count: 21]

Display filters can be very powerful and are discussed in further detail in Building Display Filter
[Word Count: 16]

It’s also possible to create display filters with the Display Filter Expression dialog box. More
[Word Count: 15]

information about the Display Filter Expression dialog box is available in The “Display Filter
[Word Count: 14]

Wireshark provides a display filter language that enables you to precisely control which packets
[Word Count: 14]

are displayed. They can be used to check for the presence of a protocol or field, the value of a field,
[Word Count: 21]

or even compare two fields to each other. These comparisons can be combined with logical
[Word Count: 15]

operators, like "and" and "or", and parentheses into complex expressions.
[Word Count: 10]

The following sections will go into the display filter functionality in more detail.
[Word Count: 13]

TIP
There are many display filter examples on the Wireshark Wiki Display Filter page at:
[Word Count: 15]

https://wiki.wireshark.org/DisplayFilters.
[Word Count: 1]

The simplest display filter is one that displays a single protocol. To only display packets containing a
[Word Count: 17]

particular protocol, type the protocol into Wireshark’s display filter toolbar. For example, to only
[Word Count: 14]

display TCP packets, type tcp into Wireshark’s display filter toolbar. Similarly, to only display
[Word Count: 14]

packets containing a particular field, type the field into Wireshark’s display filter toolbar. For
[Word Count: 14]

example, to only display HTTP requests, type http.request into Wireshark’s display filter toolbar.
[Word Count: 13]

You can filter on any protocol that Wireshark supports. You can also filter on any field that a
[Word Count: 18]

dissector adds to the tree view, if the dissector has added an abbreviation for that field. A full list of
[Word Count: 20]

the available protocols and fields is available through the menu item View › Internals › Supported
[Word Count: 16]

You can build display filters that compare values using a number of different comparison
[Word Count: 14]

operators. For example, to only display packets to or from the IP address 192.168.0.1, use
[Word Count: 15]

A complete list of available comparison operators is shown in Display Filter comparison operators.
[Word Count: 14]

TIP
English and C-like operators are interchangeable and can be mixed within a filter
[Word Count: 14]

Table 23. Display Filter comparison operators
[Word Count: 6]

English
Alias
C-like
Description
Example
[Word Count: 5]

eq
any_eq
==
Equal (any if more than one)
ip.src == 10.0.0.5
[Word Count: 12]

ne
all_ne
!=
Not equal (all if more than one)
ip.src != 10.0.0.5
[Word Count: 13]

all_eq
===
Equal (all if more than one)
ip.src === 10.0.0.5
[Word Count: 11]

ge
>=
Greater than or equal to
frame.len ge 0x100
[Word Count: 10]

le
<=
Less than or equal to
frame.len <= 0x20
[Word Count: 10]

contains
Protocol, field or slice contains
[Word Count: 6]

matches
~
Protocol or text field matches a
[Word Count: 8]

http.host matches
"acme\\.(org|com|net)"
[Word Count: 3]

NOTE
The meaning of != (all not equal) was changed in Wireshark 3.6. Before it used to
[Word Count: 17]

All protocol fields have a type. Display Filter Field Types provides a list of the types with examples
[Word Count: 18]

Can be 8, 16, 24, 32, or 64 bits. You can express integers in decimal, octal, hexadecimal or binary.
[Word Count: 19]

The following display filters are equivalent:
[Word Count: 6]

Can be 8, 16, 24, 32, or 64 bits. As with unsigned integers you can use decimal, octal, hexadecimal
[Word Count: 19]

Can be 1 or "True", 0 or "False" (without quotes).
[Word Count: 10]

A Boolean field is present regardless if its value is true or false. For example, tcp.flags.syn is
[Word Count: 17]

present in all TCP packets containing the flag, whether the SYN flag is 0 or 1. To only match TCP
[Word Count: 20]

packets with the SYN flag set, you need to use tcp.flags.syn == 1 or tcp.flags.syn == True.
[Word Count: 17]

6 bytes separated by a colon (:), dot (.), or dash (-) with one or two bytes between separators:
[Word Count: 19]

Classless InterDomain Routing (CIDR) notation can be used to test if an IPv4 address is in a
[Word Count: 17]

certain subnet. For example, this display filter will find all packets in the 129.111 Class-B
[Word Count: 15]

As with IPv4 addresses, IPv6 addresses can match a subnet.
[Word Count: 10]

http.request.uri == "https://www.wireshark.org/"
[Word Count: 3]

Strings are a sequence of bytes. Functions like lower() use ASCII, otherwise no particular
[Word Count: 14]

encoding is assumed. String literals are specified with double quotes. Characters can also be
[Word Count: 14]

specified using a byte escape sequence using hex \xhh or octal \ddd, where h and d are hex and
[Word Count: 19]

dns.qry.name contains "www.\x77\x69\x72\x65\x73\x68\x61\x72\x6b.org"
[Word Count: 3]

Alternatively, a raw string syntax can be used. Such strings are prefixed with r or R and treat
[Word Count: 18]

frame.time == "Sep 26, 2004 23:18:04.954975"
[Word Count: 6]

The value of an absolute time field is expressed as a string, using one of the two formats above.
[Word Count: 19]

Fractional seconds can be omitted or specified up to nanosecond precision; extra trailing zeros
[Word Count: 14]

are allowed but not other digits. The string cannot take a time zone suffix, and is always parsed
[Word Count: 18]

as in the local time zone, even for fields that are displayed in UTC.
[Word Count: 14]

In the first format, the abbreviated month names must be in English regardless of locale. In the
[Word Count: 17]

second format, any number of time fields may be omitted, in the order from least significant
[Word Count: 16]

(seconds) to most, but at least the entire date must be specified:
[Word Count: 12]

In the second format, a T may appear between the date and time as in ISO 8601, but not when
[Word Count: 20]

The display filter above matches packets that contains the 3-byte sequence 0x81, 0x60, 0x03
[Word Count: 14]

The display filter above matches packets where the SIP To-header contains the string "a1762"
[Word Count: 14]

http.host matches "acme\\.(org|com|net)"
[Word Count: 3]

The display filter above matches HTTP packets where the HOST header contains acme.org,
[Word Count: 13]

acme.com, or acme.net. Comparisons are case-insensitive.
[Word Count: 6]

That display filter will match all packets that contain the “tcp.flags” field with the 0x02 bit, i.e., the
[Word Count: 18]

Possible Pitfalls Using Regular Expressions
[Word Count: 5]

String literals containing regular expressions are parsed twice. Once by Wireshark’s display filter
[Word Count: 13]

engine and again by the PCRE2 library. It’s important to keep this in mind when using the "matches"
[Word Count: 18]

operator with regex escape sequences and special characters.
[Word Count: 8]

For example, the filter expression frame matches "AB\x43" uses the string "ABC" as input pattern to
[Word Count: 16]

PCRE. However, the expression frame matches "AB\\x43" uses the string "AB\x43" as the pattern. In
[Word Count: 15]

this case both expressions give the same result because Wireshark and PCRE both support the same
[Word Count: 16]

byte escape sequence (0x43 is the ASCII hex code for C).
[Word Count: 11]

An example where this fails badly is foo matches "bar\x28". Because 0x28 is the ASCII code for ( the
[Word Count: 19]

pattern input to PCRE is "bar(". This regular expression is syntactically invalid (missing closing
[Word Count: 14]

parenthesis). To match a literal parenthesis in a display filter regular expression it must be escaped
[Word Count: 16]

TIP
Using raw strings avoids most problem with the "matches" operator and double
[Word Count: 13]

You can combine filter expressions in Wireshark using the logical operators shown in Display Filter
[Word Count: 15]

Table 24. Display Filter Logical Operations
[Word Count: 6]

and
&&
Logical AND
ip.src==10.0.0.5 and tcp.flags.fin
[Word Count: 7]

or
||
Logical OR
ip.src==10.0.0.5 or ip.src==192.1.1.1
[Word Count: 7]

xor
^^
Logical XOR
tr.dst[0:3] == 0.6.29 xor tr.src[0:3] == 0.6.29
[Word Count: 11]

[…]
Subsequence See “Slice Operator” below.
[Word Count: 6]

http.request.method in {"HEAD", "GET"}. See
[Word Count: 5]

Wireshark allows you to select a subsequence of byte arrays (including protocols) or text strings in
[Word Count: 16]

rather elaborate ways. After a label you can place a pair of brackets [] containing a comma
[Word Count: 17]

The example above uses the n:m format to specify a single range. In this case n is the beginning
[Word Count: 19]

offset and m is the length of the range being specified.
[Word Count: 11]

The example above uses the n-m format to specify a single range. In this case n is the beginning
[Word Count: 19]

The example above uses the :m format, which takes everything from the beginning of a sequence to
[Word Count: 17]

The example above uses the n: format, which takes everything from offset n to the end of the
[Word Count: 18]

The example above uses the n format to specify a single range. In this case the element in the
[Word Count: 19]

sequence at offset n is selected. This is equivalent to n:1.
[Word Count: 11]

eth.src[0:3,1-2,:4,4:,2] ==
00:00:83:00:83:00:00:83:00:20:20:83
[Word Count: 3]

Wireshark allows you to string together single ranges in a comma separated list to form compound
[Word Count: 16]

You can use the slice operator on a protocol name, too, to slice the bytes associated with that
[Word Count: 18]

protocol. The frame protocol can be useful, encompassing all the captured data (not including
[Word Count: 14]

secondary data sources like decrypted data.)
[Word Count: 6]

Offsets can be negative, indicating an offset from the end of a field.
[Word Count: 13]

frame[-4:4] == 0.1.2.3
frame[-4:] == 0.1.2.3
[Word Count: 6]

The two examples above both check the last four bytes of a frame.
[Word Count: 13]

Slices of string fields yield strings, and are indexed on codepoint boundaries after conversation of
[Word Count: 15]

http.content_type[0:4] == "text"
smpp.message_text[:10] == "Абвгдеёжзи"
[Word Count: 6]

The second example above will match regardless of whether the original string was in Windows-
[Word Count: 15]

1251, UTF-8, or UTF-16, so long as the converted string starts with those ten characters.
[Word Count: 15]

Byte slices can be directly compared to strings; this converts the string to the corresponding UTF-8
[Word Count: 16]

byte sequence. To compare string slices with byte sequences, use the @ operator, below.
[Word Count: 14]

A field can be restricted to a certain layer in the protocol stack using the layer operator (#), followed
[Word Count: 19]

matches only the inner (second) layer in the packet. Layers use simple stacking semantics and
[Word Count: 15]

protocol layers are counted sequentially starting from 1. For example, in a packet that contains two
[Word Count: 16]

IPv4 headers, the outer (first) source address can be matched with "ip.src#1" and the inner (second)
[Word Count: 16]

source address can be matched with "ip.src#2".
[Word Count: 7]

For more complicated ranges the same syntax used with slices is valid:
[Word Count: 12]

means layers number 2, 3 or 4 inclusive. The hash symbol is required to distinguish a layer range
[Word Count: 18]

By prefixing the field name with an at sign (@) the comparison is done against the raw packet data
[Word Count: 19]

A character string must be decoded from a source encoding during dissection. If there are decoding
[Word Count: 16]

errors the resulting string will usually contain replacement characters:
[Word Count: 9]

browser.comment == "string is &#xFFFD;&#xFFFD;&#xFFFD;&#xFFFD;"
[Word Count: 5]

The at operator allows testing the raw undecoded data:
[Word Count: 9]

@browser.comment == 73:74:72:69:6e:67:20:69:73:20:aa:aa:aa:aa
[Word Count: 3]

The syntactical rules for a bytes field type apply to the second example.
[Word Count: 13]

When a bytes field is compared with a literal string, it is compared with the UTF-8
[Word Count: 16]

representation of that string. The at operator compares a string field with the actual
[Word Count: 14]

byte representation in the original encoding, which may not be UTF-8.
[Word Count: 11]

As an example, SMPP has a bytes field, smpp.message, and a string field,
[Word Count: 13]

smpp.message_text, that refer to the same data. If the first four characters of the
[Word Count: 14]

message is the string "Text" in the UTF-16 encoding, the following filters all match.
[Word Count: 14]

smpp.message[:8] == 00:54:00:65:00:73:00:74
smpp.message[:8] == "\x00T\x00e\x00s\x00t"
smpp.message_text[:4] == "Test"
smpp.message_text[:4] == "\x54\x65\x73\x74"
@smpp.message_text[:8] == 00:54:00:65:00:73:00:74
@smpp.message_text[:8] == "\x00T\x00e\x00s\x00t"
[Word Count: 18]

@smpp.message_text[:4] == "\x00T\x00e\x00s\x00t"
smpp.message[:4] == "Test"
smpp.message[:8] == "Test"
@smpp.message_text[:4] == "Test"
@smpp.message_text[:8] == "Test"
[Word Count: 15]

The first filter above does not match because of operator precedence left-to-right;
[Word Count: 12]

+@smpp.message_text is converted to bytes before the slice operator is applied, so the
[Word Count: 13]

length of the necessary slice is 8. The other filters do not match because the literal
[Word Count: 16]

string "Test" is always converted to its 4 octet UTF-8 representation when
[Word Count: 12]

comparing against bytes, and it does not match the UTF-16 representation of the
[Word Count: 13]

Wireshark allows you to test a field for membership in a set of values or fields. After the field name,
[Word Count: 20]

use the in operator followed by the set items surrounded by braces {}. For example, to display
[Word Count: 17]

packets with a TCP source or destination port of 80, 443, or 8080, you can use tcp.port in {80, 443,
[Word Count: 20]

8080}. Set elements must be separated by commas. The set of values can also contain ranges:
[Word Count: 16]

tcp.port == 80 || tcp.port == 443 || tcp.port == 8080
[Word Count: 11]

tcp.port == 443 || (tcp.port >= 4430 && tcp.port <= 4434)
[Word Count: 11]

This is because comparison operators are satisfied when any field matches the
[Word Count: 12]

filter, so a packet with a source port of 56789 and destination port of port 80 would
[Word Count: 17]

also match the second filter since 56789 >= 4430 && 80 <= 4434 is true. In contrast,
[Word Count: 17]

the membership operator tests a single field against the range condition.
[Word Count: 11]

Sets are not just limited to numbers, other types can be used as well:
[Word Count: 14]

http.request.method in {"HEAD", "GET"}
ip.addr in {10.0.0.5 .. 10.0.0.9, 192.168.1.1..192.168.1.9}
frame.time_delta in {10 .. 10.5}
[Word Count: 15]

You can perform the arithmetic operations on numeric fields shown in Display Filter Arithmetic
[Word Count: 14]

Table 25. Display Filter Arithmetic Operations
[Word Count: 6]

Modulo
A % B
Remainder of A divided by B
[Word Count: 10]

Bitwise AND
A & B
A bitand B
Bitwise AND of A and B
[Word Count: 14]

An unfortunate quirk in the filter syntax is that the subtraction operator must be preceded by a
[Word Count: 17]

space character, so "A-B" must be written as "A -B" or "A - B".
[Word Count: 14]

Arithmetic expressions can be grouped using curly braces.
[Word Count: 8]

For example, frames where capture length resulted in truncated TCP options:
[Word Count: 11]

frame.cap_len < { 14 +  ip.hdr_len + tcp.hdr_len }
[Word Count: 9]

The display filter language has a number of functions to convert fields, see Display Filter Functions.
[Word Count: 16]

upper
Converts a string field to uppercase.
[Word Count: 7]

lower
Converts a string field to lowercase.
[Word Count: 7]

len
Returns the byte length of a string or bytes field.
[Word Count: 11]

count
Returns the number of field occurrences in a frame.
[Word Count: 10]

string
Converts a non-string field to a string.
[Word Count: 8]

vals
Converts a field value to its value string, if it has one.
[Word Count: 13]

dec
Converts an unsigned integer field to a decimal string.
[Word Count: 10]

hex
Converts an unsigned integer field to a hexadecimal string.
[Word Count: 10]

float
Converts a field to single precision floating point.
[Word Count: 9]

double
Converts a field to double precision floating point.
[Word Count: 9]

max
Return the maximum value for the arguments.
[Word Count: 8]

min
Return the minimum value for the arguments.
[Word Count: 8]

abs
Return the absolute value for the argument.
[Word Count: 8]

The upper and lower functions can used to force case-insensitive matches: lower(http.server)
[Word Count: 12]

To find HTTP requests with long request URIs: len(http.request.uri) > 100. Note that the len
[Word Count: 15]

function yields the string length in bytes rather than (multi-byte) characters.
[Word Count: 11]

Usually an IP frame has only two addresses (source and destination), but in case of ICMP errors or
[Word Count: 18]

tunneling, a single packet might contain even more addresses. These packets can be found with
[Word Count: 15]

The string function converts a field value to a string, suitable for use with operators like "matches"
[Word Count: 17]

or "contains". Integer fields are converted to their decimal representation. It can be used with
[Word Count: 15]

IP/Ethernet addresses (as well as others), but not with string or byte fields.
[Word Count: 13]

For example, to match odd frame numbers:
[Word Count: 7]

To match IP addresses ending in 255 in a block of subnets (172.16 to 172.31):
[Word Count: 15]

string(ip.dst) matches r"^172\.(1[6-9]|2[0-9]|3[0-1])\.[0-9]{1,3}\.255"
[Word Count: 3]

The vals function converts an integer or boolean field value to a string using the field’s associated
[Word Count: 17]

The double function converts certain field types to doubles, including floats, doubles (a no-op),
[Word Count: 14]

integers, booleans, times (absolute times are converted to seconds since the UN*X epoch), and the
[Word Count: 15]

special IEEE 11073 Personal Health Devices floating point formats. The results can be used with
[Word Count: 15]

further arithmetic operations and, like other filters, placed in a custom column.
[Word Count: 12]

The functions max() and min() take any number of arguments of the same type and returns the
[Word Count: 17]

largest/smallest respectively of the set.
[Word Count: 5]

An expression of the form ${proto.field} is called a field reference. Its value is read from the
[Word Count: 17]

corresponding field in the currently selected frame in the GUI. This is a powerful way to build
[Word Count: 17]

dynamic filters, such as frames since the last five minutes to the selected frame:
[Word Count: 14]

frame.time_relative >= ${frame.time_relative} - 300
[Word Count: 5]

or all HTTP packets whose +ip.dst value equals the "A" record of the DNS response in the current
[Word Count: 18]

The notation of field references is similar to that of macros but they are syntactically distinct. Field
[Word Count: 17]

references, like other complex filters, make excellent use cases for macros, saved filters, and filter
[Word Count: 15]

As protocols evolve they sometimes change names or are superseded by newer standards. For
[Word Count: 14]

example, DHCP extends and has largely replaced BOOTP and TLS has replaced SSL. If a protocol
[Word Count: 16]

dissector originally used the older names and fields for a protocol the Wireshark development team
[Word Count: 15]

might update it to use the newer names and fields. In such cases they will add an alias from the old
[Word Count: 21]

protocol name to the new one in order to make the transition easier.
[Word Count: 13]

For example, the DHCP dissector was originally developed for the BOOTP protocol but as of
[Word Count: 15]

Wireshark 3.0 all of the “bootp” display filter fields have been renamed to their “dhcp” equivalents.
[Word Count: 16]

You can still use the old filter names for the time being, e.g., “bootp.type” is equivalent to
[Word Count: 17]

“dhcp.type” but Wireshark will show the warning “"bootp" is deprecated” when you use it. Support
[Word Count: 15]

for the deprecated fields may be removed in the future.
[Word Count: 10]

In some particular cases relational expressions (equal, less than, etc.) can be ambiguous. The filter
[Word Count: 15]

name of a protocol or protocol field can contain any letter and digit in any order, possibly separated
[Word Count: 18]

by dots. That can be indistinguishable from a literal value (usually numerical values in
[Word Count: 14]

hexadecimal). For example the semantic value of fc can be the protocol Fibre Channel or the
[Word Count: 16]

number 0xFC in hexadecimal because the 0x prefix is optional for hexadecimal numbers.
[Word Count: 13]

Any value that matches a registered protocol or protocol field filter name is interpreted
[Word Count: 14]

semantically as such. If it doesn’t match a protocol name the normal rules for parsing literal values
[Word Count: 17]

So in the case of 'fc' the lexical token is interpreted as "Fibre Channel" and not 0xFC. In the case of
[Word Count: 21]

'fd' it would be interpreted as 0xFD because it is a well-formed hexadecimal literal value (according
[Word Count: 16]

to the rules of display filter language syntax) and there is no protocol registered with the filter
[Word Count: 17]

How ambiguous values are interpreted may change in the future. To avoid this problem and
[Word Count: 15]

resolve the ambiguity there is additional syntax available. Values prefixed with a dot are always
[Word Count: 15]

treated as a protocol name. The dot stands for the root of the protocol namespace and is optional).
[Word Count: 18]

Values prefixed with a colon are always interpreted as a byte array.
[Word Count: 12]

frame[10:] contains .fc or frame[10] == :fc
[Word Count: 7]

If you are writing a script, or you think your expression may not be giving the expected results
[Word Count: 18]

because of the syntactical ambiguity of some filter expression it is advisable to use the explicit
[Word Count: 16]

syntax to indicate the correct meaning for that expression.
[Word Count: 9]

The “Display Filter Expression” Dialog Box
[Word Count: 6]

When you are accustomed to Wireshark’s filtering system and know what labels you wish to use in
[Word Count: 17]

your filters it can be very quick to simply type a filter string. However, if you are new to Wireshark
[Word Count: 20]

or are working with a slightly unfamiliar protocol it can be very confusing to try to figure out what
[Word Count: 19]

to type. The “Display Filter Expression” dialog box helps with this.
[Word Count: 11]

TIP
The “Display Filter Expression” dialog box is an excellent way to learn how to write
[Word Count: 16]

Figure 62. The “Display Filter Expression” dialog box
[Word Count: 8]

When you first bring up the Display Filter Expression dialog box you are shown a tree of field
[Word Count: 18]

names, organized by protocol, and a box for selecting a relation.
[Word Count: 11]

Select a protocol field from the protocol field tree. Every protocol with filterable fields is listed at
[Word Count: 17]

the top level. You can search for a particular protocol entry by entering the first few letters of the
[Word Count: 19]

protocol name. By expanding a protocol name you can get a list of the field names available for
[Word Count: 18]

Select a relation from the list of available relation. The is present is a unary relation which is
[Word Count: 18]

true if the selected field is present in a packet. All other listed relations are binary relations
[Word Count: 17]

which require additional data (e.g. a Value to match) to complete.
[Word Count: 11]

When you select a field from the field name list and select a binary relation (such as the equality
[Word Count: 19]

relation ==) you will be given the opportunity to enter a value, and possibly some range
[Word Count: 16]

You may enter an appropriate value in the Value text box. The Value will also indicate the type of
[Word Count: 19]

value for the Field Name you have selected (like character string).
[Word Count: 11]

Some of the protocol fields have predefined values available, much like enumerations in C. If the
[Word Count: 16]

selected protocol field has such values defined, you can choose one of them here.
[Word Count: 14]

Lets you search for a full or partial field name or description. Regular expressions are
[Word Count: 15]

supported. For example, searching for “tcp.*flag” shows the TCP flags fields supported by a wide
[Word Count: 15]

variety of dissectors, while “^tcp.flag” shows only the TCP flags fields supported by the TCP
[Word Count: 15]

A range of integers or a group of ranges, such as 1-12 or 39-42,98-2000.
[Word Count: 14]

When you have built a satisfactory expression click [ OK ] and a filter string will be built for you.
[Word Count: 20]

You can leave the “Add Expression…” dialog box without any effect by clicking the [ Cancel ]
[Word Count: 17]

You create pre-defined filters that appear in the capture and display filter bookmark menus (
).
[Word Count: 16]

This can save time in remembering and retyping some of the more complex filters you use.
[Word Count: 16]

To create or edit capture filters, select Manage Capture Filters from the capture filter bookmark
[Word Count: 15]

menu or Capture › Capture Filters… from the main menu. Display filters can be created or edited
[Word Count: 17]

by selecting Manage Display Filters from the display filter bookmark menu or Analyze › Display
[Word Count: 15]

Filters… from the main menu. Wireshark will open the corresponding dialog as shown in The
[Word Count: 15]

“Capture Filters” and “Display Filters” dialog boxes. The two dialogs look and work similar to one
[Word Count: 16]

another. Both are described here, and the differences are noted as needed.
[Word Count: 12]

Figure 63. The “Capture Filters” and “Display Filters” dialog boxes
[Word Count: 10]

Adds a new filter to the list. You can edit the filter name or expression by double-clicking on it.
[Word Count: 19]

The filter name is used in this dialog to identify the filter for your convenience and is not used
[Word Count: 19]

elsewhere. You can create multiple filters with the same name, but this is not very useful.
[Word Count: 16]

When typing in a filter string, the background color will change depending on the validity of the
[Word Count: 17]

filter similar to the main capture and display filter toolbars.
[Word Count: 10]

Delete the selected filter. This will be greyed out if no filter is selected.
[Word Count: 14]

Copy the selected filter. This will be greyed out if no filter is selected.
[Word Count: 14]

Saves the filter settings and closes the dialog.
[Word Count: 8]

Closes the dialog without saving any changes.
[Word Count: 7]

Display Filter Macros are a mechanism to create shortcuts for complex filters. You can define a
[Word Count: 16]

filter macro with Wireshark and label it for later use. This can save time in remembering and
[Word Count: 17]

retyping some of the more complex filters you use.
[Word Count: 9]

To define and save your own filter macros, follow the steps below:
[Word Count: 12]

1. In the main menu select Analyze › Display Filter Macros…. Wireshark will open a
[Word Count: 15]

corresponding dialog Display Filter Macros window.
[Word Count: 6]

2. To add a new filter macro, click the [ + ] button in the bottom-left corner. A new row will appear
[Word Count: 22]

in the Display Filter Macros table above.
[Word Count: 7]

3. Enter the name of your macro in the Macro Name column. Enter your filter macro in the Macro
[Word Count: 19]

4. To save your modifications, click the [ OK ] button in the bottom-right corner of the Display
[Word Count: 18]

Display filter macros are invoked with the macro name and a number of input arguments. There
[Word Count: 16]

The Macro Name must consist of ASCII alphanumerics or the '_' character. (Note that the presence of a
[Word Count: 18]

'.' character would indicate a field reference.)
[Word Count: 7]

The Macro Expression is replacement text for the macro name. It substitutes $1, $2, $3, … with the
[Word Count: 18]

For example, defining a display filter macro named tcp_conv whose text is
[Word Count: 12]

(ip.src == $1 and ip.dst == $2 and tcp.srcport == $3 and tcp.dstport == $4)
or (ip.src == $2 and ip.dst == $1 and tcp.srcport == $4 and tcp.dstport == $3)
[Word Count: 31]

would allow to use a display filter like
[Word Count: 8]

instead of typing the whole filter. Both notations are equivalent. Once defined, a macro can be used
[Word Count: 17]

in saved display (but not capture) filters and filter buttons.
[Word Count: 10]

You can easily find packets once you have captured some packets or have read in a previously
[Word Count: 17]

saved capture file. Simply select Edit › Find Packet… in the main menu. Wireshark will open a
[Word Count: 17]

toolbar between the main toolbar and the packet list shown in The “Find Packet” toolbar.
[Word Count: 15]

You can search using the following criteria:
[Word Count: 7]

Enter a display filter string into the text entry field and click the [ Find ] button. + For example,
[Word Count: 20]

to find the three-way handshake for a connection from host 192.168.0.1, use the following filter
[Word Count: 15]

ip.src==192.168.0.1 and tcp.flags.syn==1
[Word Count: 3]

The value to be found will be syntax checked while you type it in. If the syntax check of your
[Word Count: 20]

value succeeds, the background of the entry field will turn green, if it fails, it will turn red. For
[Word Count: 19]

more details see Filtering Packets While Viewing
[Word Count: 7]

Search for a specific byte sequence in the packet data.
[Word Count: 10]

For example, use “ef:bb:bf” to find the next packet that contains the UTF-8 byte order mark.
[Word Count: 16]

Find a string in the packet data, with various options.
[Word Count: 10]

Search the packet data using Perl-compatible regular expressions. PCRE patterns are beyond the
[Word Count: 13]

scope of this document, but typing “pcre test” into your favorite search engine should return a
[Word Count: 16]

number of sites that will help you test and explore your expressions.
[Word Count: 12]

You can easily jump to specific packets with one of the menu items in the Go menu.
[Word Count: 17]

Go back in the packet history, works much like the page history in most web browsers.
[Word Count: 16]

Go forward in the packet history, works much like the page history in most web browsers.
[Word Count: 16]

This toolbar can be opened by selecting Go › Go to packet… from the main menu. It appears
[Word Count: 18]

between the main toolbar and the packet list, similar to the ”Find Packet” toolbar.
[Word Count: 14]

When you enter a packet number and press [ Go to packet ] Wireshark will jump to that packet.
[Word Count: 19]

The “Go to Corresponding Packet” Command
[Word Count: 6]

If a protocol field is selected which points to another packet in the capture file, this command will
[Word Count: 18]

As these protocol fields now work like links (just as in your Web browser), it’s easier to simply
[Word Count: 18]

double-click on the field to jump to the corresponding field.
[Word Count: 10]

This command will jump to the first packet displayed.
[Word Count: 9]

This command will jump to the last packet displayed.
[Word Count: 9]

You can mark packets in the “Packet List” pane. A marked packet will be shown with black
[Word Count: 17]

background, regardless of the coloring rules set. Marking a packet can be useful to find it later
[Word Count: 17]

while analyzing in a large capture file.
[Word Count: 7]

Marked packet information is not stored in the capture file or anywhere else. It will be lost when
[Word Count: 18]

You can use packet marking to control the output of packets when saving, exporting, or printing. To
[Word Count: 17]

do so, an option in the packet range is available, see The “Packet Range” Frame.
[Word Count: 15]

There are several ways to mark and unmark packets. From the Edit menu you can select from the
[Word Count: 18]

• Mark/Unmark Selected toggles the marked state of the current selection. This option is also
[Word Count: 15]

available in the packet list context menu.
[Word Count: 7]

• Mark All Displayed set the mark state of all displayed packets.
[Word Count: 12]

• Unmark All Displayed reset the mark state of all packets.
[Word Count: 11]

You can also mark and unmark a packet by clicking on it in the packet list with the middle mouse
[Word Count: 20]

You can ignore packets in the “Packet List” pane. Wireshark will then pretend that they not exist in
[Word Count: 18]

the capture file. An ignored packet will be shown with white background and grey foreground,
[Word Count: 15]

Ignored packet information is not stored in the capture file or anywhere else. It will be lost when
[Word Count: 18]

There are several ways to ignore and unignore packets. From the Edit menu you can select from
[Word Count: 17]

• Ignore/Unignore Selected toggles the ignored state of the current selection. This option is also
[Word Count: 15]

available in the packet list context menu.
[Word Count: 7]

• Ignore All Displayed set the ignored state of all displayed packets.
[Word Count: 12]

• Unignore All Displayed reset the ignored state of all packets.
[Word Count: 11]

Time Display Formats And Time References
[Word Count: 6]

While packets are captured, each packet is timestamped. These timestamps will be saved to the
[Word Count: 15]

capture file, so they will be available for later analysis.
[Word Count: 10]

A detailed description of timestamps, timezones and alike can be found at: Time Stamps.
[Word Count: 14]

The timestamp presentation format and the precision in the packet list can be chosen using the
[Word Count: 16]

• Date and Time of Day: 1970-01-01 01:02:03.123456 The absolute date and time of the day when
[Word Count: 17]

• Time of Day: 01:02:03.123456 The absolute time of the day when the packet was captured.
[Word Count: 16]

• Seconds Since First Captured Packet: 123.123456 The time relative to the start of the capture
[Word Count: 16]

file or the first “Time Reference” before this packet (see Packet Time Referencing).
[Word Count: 13]

• Seconds Since Previous Captured Packet: 1.123456 The time relative to the previous captured
[Word Count: 14]

• Seconds Since Previous Displayed Packet: 1.123456 The time relative to the previous
[Word Count: 13]

• Seconds Since Epoch (1970-01-01): 1234567890.123456 The time relative to epoch (midnight
[Word Count: 12]

The available precisions (aka. the number of displayed decimal places) are:
[Word Count: 11]

• Automatic (from capture file) The timestamp precision of the loaded capture file format will
[Word Count: 15]

• Seconds, Tenths of a second, Hundredths of a second, Milliseconds, Microseconds or
[Word Count: 13]

Nanoseconds The timestamp precision will be forced to the given setting. If the actually
[Word Count: 14]

available precision is smaller, zeros will be appended. If the precision is larger, the remaining
[Word Count: 15]

Precision example: If you have a timestamp and it’s displayed using, “Seconds Since Previous
[Word Count: 14]

Packet” the value might be 1.123456. This will be displayed using the “Automatic” setting for
[Word Count: 15]

libpcap files (which is microseconds). If you use Seconds it would show simply 1 and if you use
[Word Count: 18]

The user can set time references to packets. A time reference is the starting point for all subsequent
[Word Count: 18]

packet time calculations. It will be useful, if you want to see the time values relative to a special
[Word Count: 19]

packet, e.g., the start of a new request. It’s possible to set multiple time references in the capture
[Word Count: 18]

The time references will not be saved permanently and will be lost when you close the capture file.
[Word Count: 18]

Time referencing supercedes the value for the time relative to first capture packet. It affects the
[Word Count: 16]

default Time column if the time display format is set to “Seconds Since First Captured Packet”, or a
[Word Count: 18]

“Relative Time” column if one has been added. It also affects the frame.time_relative field.
[Word Count: 14]

To work with time references, choose one of the Time Reference items in the menu:[Edit] menu or
[Word Count: 17]

from the pop-up menu of the “Packet List” pane. See The “Edit” Menu.
[Word Count: 13]

• Set Time Reference (toggle) Toggles the time reference state of the currently selected packet to
[Word Count: 16]

• Find Next Find the next time referenced packet in the “Packet List” pane.
[Word Count: 14]

• Find Previous Find the previous time referenced packet in the “Packet List” pane.
[Word Count: 14]

Figure 67. Wireshark showing a time referenced packet
[Word Count: 8]

A time referenced packet will be marked with the string *REF* in the Time column (see packet
[Word Count: 17]

number 10). All subsequent packets will show the time since the last time reference. If there is a
[Word Count: 18]

column displayed for “Cumulative Bytes” its counter will also reset at every time reference packet.
[Word Count: 15]

# Somewhat odd that cumulative bytes also resets.
[Word Count: 8]

Time referenced packets will always be displayed in the packet list pane. Display filters will not
[Word Count: 16]

Sometimes you will want to adjust the timestamps in a capture file. This may be because a machine
[Word Count: 18]

performing the capture had an inaccurate clock, or because the capture was originally saved with
[Word Count: 15]

timestamps in local time (perhaps even to a capture file format that only writes times in local time,
[Word Count: 18]

or only writes the time of day but not the date). One common use is to synchronize timestamps
[Word Count: 18]

between captures made on different machines with relative clock skew or clock drift before
[Word Count: 14]

merging them. Selecting Edit › Time Shift… from the main menu opens the "Time Shift" dialog.
[Word Count: 16]

Apply a fixed offset, entered as a relative time in hours, minutes, and seconds, to the timestamps
[Word Count: 17]

for all packets. This is useful for correcting small known errors or timezones.
[Word Count: 13]

Apply offsets based on one or, if the box is checked, two given packets to the timestamps for all
[Word Count: 19]

packets. Enter the packet number and absolute date and time for the packet(s). When one packet
[Word Count: 16]

is used, a fixed offset is applied that can be used to correct for clock skew. When two packets are
[Word Count: 20]

used, the correction for all other packets is computed linearly, which can be used to correct for
[Word Count: 17]

clock drift. This is useful when the precise date and time for particular packets are known, e.g.
[Word Count: 17]

packets containing the NTP or PTP protocols.
[Word Count: 7]

This removes all unsaved time shifts from packets.
[Word Count: 8]

Time shifts are applied to all packets in the capture, including ignored packets and
[Word Count: 14]

packets that are not displayed due to the current filter. Wireshark does not have a
[Word Count: 15]

method to adjust the timestamps of individual or selected packets.
[Word Count: 10]

The offset currently applied to time shifted packets is in the frame.offset_shift field, which can be
[Word Count: 16]

After time shifts are applied, the file will have unsaved changes, which are indicated with an *
[Word Count: 17]

beside its name in the title bar. Beginning with Wireshark 4.2.0, saving the file will write the
[Word Count: 17]

corrected timestamps to the capture file. If you attempt to close the capture file without saving it, a
[Word Count: 18]

dialog will prompt you to save in order to prevent losing your changes (unless that warning has
[Word Count: 17]

This chapter will describe some of Wireshark’s advanced features.
[Word Count: 9]

It can be very helpful to see a protocol in the way that the application layer sees it. Perhaps you are
[Word Count: 21]

looking for passwords in a Telnet stream, or you are trying to make sense of a data stream. Maybe
[Word Count: 19]

you just need a display filter to show only the packets in a TLS or SSL stream. If so, Wireshark’s
[Word Count: 20]

ability to follow protocol streams will be useful to you.
[Word Count: 10]

To filter to a particular stream, select a packet in the packet list of the stream/connection you are
[Word Count: 18]

interested in and then select the menu item you want under Analyze › Follow (or in the context
[Word Count: 18]

menu in the packet list). Wireshark will set an appropriate display filter and display a dialog box
[Word Count: 17]

with the data from the stream laid out, as shown in The “Follow TCP Stream” dialog box.
[Word Count: 17]

Following a protocol stream applies a display filter which selects all the packets in the
[Word Count: 15]

current stream. Some people open the “Follow TCP Stream” dialog and immediately
[Word Count: 12]

close it as a quick way to isolate a particular stream. Closing the dialog with the “Back”
[Word Count: 17]

button will reset the display filter if this behavior is not desired.
[Word Count: 12]

Wireshark supports following the streams of many different protocols, including TCP, UDP, DCCP,
[Word Count: 13]

TLS, HTTP, HTTP/2, QUIC, WebSocket, SIP, and USB CDC. The dialog for following TCP streams is
[Word Count: 16]

covered in detail here; most other supported protocols will show dialogs which are very similar.
[Word Count: 15]

NOTE
If the type of stream you wish to follow is disabled or missing from the menu,
[Word Count: 17]

Wireshark did not find the respective protocol in the currently selected packet.
[Word Count: 12]

TIP
To follow TLS or SSL streams, see the wiki page on TLS for instructions on providing
[Word Count: 17]

Figure 70. The “Follow TCP Stream” dialog box
[Word Count: 8]

The stream content is displayed in the same sequence as it appeared on the network. Non-printable
[Word Count: 16]

characters are replaced by dots. Traffic from the client to the server is colored red, while traffic
[Word Count: 17]

from the server to the client is colored blue. These colors can be changed by opening Edit ›
[Word Count: 18]

Preferences and under Appearance › Font and Colors, selecting different colors for the [ Sample
[Word Count: 15]

"Follow Stream" client text ] and [ Sample "Follow Stream" server text ] options.
[Word Count: 14]

The stream content won’t be updated while doing a live capture. To get the latest content you’ll
[Word Count: 17]

You can choose from the following actions:
[Word Count: 7]

Apply a display filter removing the current stream data from the display.
[Word Count: 12]

Print the stream data in the currently selected format.
[Word Count: 9]

Save the stream data in the currently selected format.
[Word Count: 9]

Close this dialog box and restore the previous display filter.
[Word Count: 10]

Close this dialog box, leaving the current display filter in effect.
[Word Count: 11]

By default, Wireshark displays both client and server data. You can select the Entire conversation
[Word Count: 15]

to switch between both, client to server, or server to client data.
[Word Count: 12]

You can choose to view the data in one of the following formats:
[Word Count: 13]

In this view you see the data from each direction in ASCII. Obviously best for ASCII based
[Word Count: 17]

This allows you to import the stream data into your own C program.
[Word Count: 13]

This allows you to see all the data. This will require a lot of screen space and is best used with
[Word Count: 21]

Like ASCII, but decode the data as UTF-8.
[Word Count: 8]

Like ASCII, but decode the data as UTF-16.
[Word Count: 8]

This allows you to load the stream as YAML.
[Word Count: 9]

The YAML output is divided into 2 main sections:
[Word Count: 9]

• The peers section where for each peer you found the peer index, the host address and the port
[Word Count: 19]

• The packets section where for each packet you found the packet number in the original capture,
[Word Count: 17]

the peer index, the packet index for this peer, the timestamp in seconds and the data in base64
[Word Count: 18]

peers:
  - peer: 0
    host: 127.0.0.1
    port: 54048
  - peer: 1
    host: 127.0.10.1
    port: 5000
[Word Count: 15]

packets:
  - packet: 1
    peer: 0
    index: 0
    timestamp: 1599485409.693955274
    data: !!binary |
      aGVsbG8K
  - packet: 3
    peer: 1
    index: 0
    timestamp: 1599485423.885866692
    data: !!binary |
      Ym9uam91cgo=
[Word Count: 27]

The same example but in old YAML format (before version 3.5):
[Word Count: 11]

# Packet 1
peer0_0: !!binary |
  aGVsbG8K
# Packet 3
peer1_0: !!binary |
  Ym9uam91cgo=
[Word Count: 14]

How the old format data can be found in the new format:
[Word Count: 12]

...
packets:
  - packet: AAA
    peer: BBB
    index: CCC
    data: !!binary |
      DDD
[Word Count: 13]

# Packet AAA
peerBBB_CCC !!binary |
  DDD
[Word Count: 7]

AAA: packet number in the
original capture
BBB: peer index
CCC: packet index for
this peer
DDD: data in base64
encoding
[Word Count: 21]

This allows you to load the unaltered stream data into a different program for further
[Word Count: 15]

examination. The display will show the data as strings of hex characters with each frame on a
[Word Count: 17]

separate line, but “Save As” will result in a binary file without any added line separators.
[Word Count: 16]

You can optionally show the delta time each time the direction changes (turns) or for every packet
[Word Count: 17]

You can switch between streams using the “Stream” selector.
[Word Count: 9]

You can search for text by entering it in the “Find” entry box and pressing [ Find Next ].
[Word Count: 19]

Figure 71. The “Follow HTTP/2 Stream” dialog box
[Word Count: 8]

The HTTP/2 Stream dialog is similar to the "Follow TCP Stream" dialog, except for an additional
[Word Count: 16]

"Substream" dialog field. HTTP/2 Streams are identified by a HTTP/2 Stream Index (field name
[Word Count: 14]

http2.streamid) which are unique within a TCP connection. The “Stream” selector determines the
[Word Count: 13]

TCP connection whereas the “Substream” selector is used to pick the HTTP/2 Stream ID.
[Word Count: 14]

The QUIC protocol is similar, the first number selects the QUIC connection number while the
[Word Count: 15]

"Substream" field selects the QUIC Stream ID.
[Word Count: 7]

Figure 72. The “Follow SIP Call” dialog box
[Word Count: 8]

The SIP call is shown with same dialog, just filter is based on sip.Call-ID field. Count of streams is
[Word Count: 19]

If a selected packet field does not show all the bytes (i.e., they are truncated when displayed) or if
[Word Count: 19]

they are shown as bytes rather than string or if they require more formatting because they contain
[Word Count: 17]

an image or HTML then this dialog can be used.
[Word Count: 10]

This dialog can also be used to decode field bytes from base64, various compressed formats or
[Word Count: 16]

quoted-printable and show the decoded bytes as configurable output. It’s also possible to select a
[Word Count: 15]

subset of bytes setting the start byte and end byte.
[Word Count: 10]

You can choose from the following actions:
[Word Count: 7]

Print the bytes in the currently selected format.
[Word Count: 8]

Copy the bytes to the clipboard in the currently selected format.
[Word Count: 11]

Save the bytes in the currently selected format.
[Word Count: 8]

You can choose to decode the data from one of the following formats:
[Word Count: 13]

This is the default which does not decode anything.
[Word Count: 9]

This will decode from Base64 or Base64Url.
[Word Count: 7]

This will decompress the buffer using lz77, lz77huff, lznt1, snappy, zlib or zstd.
[Word Count: 13]

This will decode from a string of hex digits. Non-hex characters are skipped.
[Word Count: 13]

This will decode from a Percent-Encoded string.
[Word Count: 7]

This will decode from a Quoted-Printable string.
[Word Count: 7]

You can choose to view the data in one of the following formats:
[Word Count: 13]

In this view you see the bytes as ASCII. All control characters and non-ASCII bytes are replaced
[Word Count: 17]

In this view all control characters are shown using a UTF-8 symbol and all non-ASCII bytes are
[Word Count: 17]

This allows you to import the field data into your own C program.
[Word Count: 13]

This allows you to see all the data. This will require a lot of screen space and is best used with
[Word Count: 21]

This allows you to see all the data formatted as a HTML document. The HTML supported is
[Word Count: 17]

what’s supported by the Qt QTextEdit class.
[Word Count: 7]

This will try to convert the bytes into an image. Most popular formats are supported including
[Word Count: 16]

In this view you see the bytes as ISO 8859-1.
[Word Count: 10]

This allows you to load the bytes into a different program for further examination. The display
[Word Count: 16]

will show HEX data, but “Save As” will result in a binary file.
[Word Count: 13]

In this view you see the bytes as UTF-8.
[Word Count: 9]

In this view you see the bytes as UTF-16.
[Word Count: 9]

This will show the bytes as a YAML binary dump.
[Word Count: 10]

You can search for text by entering it in the “Find” entry box and pressing [ Find Next ].
[Word Count: 19]

Wireshark keeps track of any anomalies and other items of interest it finds in a capture file and
[Word Count: 18]

shows them in the Expert Information dialog. The goal is to give you a better idea of uncommon or
[Word Count: 19]

notable network behavior and to let novice and expert users find network problems faster than
[Word Count: 15]

manually scanning through the packet list.
[Word Count: 6]

Expert information is the starting point for investigation, not the stopping
[Word Count: 11]

point. Every network is different, and it’s up to you to verify that Wireshark’s
[Word Count: 14]

expert information applies to your particular situation. The presence of expert
[Word Count: 11]

information doesn’t necessarily indicate a problem and absence of expert
[Word Count: 10]

information doesn’t necessarily mean everything is OK.
[Word Count: 7]

The amount of expert information largely depends on the protocol being used. While dissectors for
[Word Count: 15]

some common protocols like TCP and IP will show detailed information, other dissectors will show
[Word Count: 15]

The following describes the components of a single expert information entry along with the expert
[Word Count: 15]

Expert information entries are grouped by severity level (described below) and contain the
[Word Count: 13]

Table 27. Example expert information items
[Word Count: 6]

Every expert information item has a severity level. The following levels are used, from lowest to
[Word Count: 16]

highest. Wireshark marks them using different colors, which are shown in parentheses:
[Word Count: 12]

Information about usual workflow, e.g., a TCP packet with the SYN flag set.
[Word Count: 13]

Notable events, e.g., an application returned a common error code such as HTTP 404.
[Word Count: 14]

Warnings, e.g., application returned an unusual error code like a connection problem.
[Word Count: 12]

Serious problems, such as malformed packets.
[Word Count: 6]

Short explanatory text for each expert information item.
[Word Count: 8]

Along with severity levels, expert information items are categorized by group. The following groups
[Word Count: 14]

The protocol field has incomplete data and was dissected based on assumed value.
[Word Count: 13]

Debugging information. You shouldn’t see this group in release versions of Wireshark.
[Word Count: 12]

Malformed packet or dissector has a bug. Dissection of this packet aborted.
[Word Count: 12]

Violation of a protocol’s specification (e.g., invalid field values or illegal lengths). Dissection of
[Word Count: 14]

Problems while reassembling, e.g., not all fragments were available or an exception happened
[Word Count: 13]

An application request (e.g., File Handle == x). Usually assigned the Chat severity level.
[Word Count: 14]

An application response code indicates a potential problem, e.g., HTTP 404 page not found.
[Word Count: 14]

A security problem, e.g., an insecure implementation.
[Word Count: 7]

A protocol sequence number was suspicious, e.g., it wasn’t continuous or a retransmission was
[Word Count: 14]

Dissection incomplete or data can’t be decoded for other reasons.
[Word Count: 10]

It’s possible that more groups will be added in the future.
[Word Count: 11]

The protocol dissector that created the expert information item.
[Word Count: 9]

You can open the expert info dialog by selecting Analyze › Expert Info or by clicking the expert
[Word Count: 18]

Right-clicking on an item will allow you to apply or prepare a filter based on the item, copy its
[Word Count: 19]

Figure 73. The “Expert Information” dialog box
[Word Count: 7]

You can choose from the following actions:
[Word Count: 7]

Only show expert information items present in packets that match the current display filter.
[Word Count: 14]

Group items by their summary instead of the groups described above.
[Word Count: 11]

Only show items that match the search string, such as “dns”. Regular expressions are supported.
[Word Count: 15]

Lets you show or hide each severity level. For example, you can deselect Chat and Note
[Word Count: 16]

Takes you to this section of the User’s Guide.
[Word Count: 9]

Figure 74. The “Colorized” protocol details tree
[Word Count: 7]

The packet detail tree marks fields with expert information based on their severity level color, e.g.,
[Word Count: 16]

“Warning” severities have a yellow background. This color is propagated to the top-level protocol
[Word Count: 14]

item in the tree in order to make it easy to find the field that created the expert information.
[Word Count: 19]

For the example screenshot above, the IP “Time to live” value is very low (only 1), so the
[Word Count: 18]

corresponding protocol field is marked with a cyan background. To make it easier find that item in
[Word Count: 17]

the packet tree, the IP protocol toplevel item is marked cyan as well.
[Word Count: 13]

Figure 75. The “Expert” packet list column
[Word Count: 7]

An optional “Expert Info Severity” packet list column is available that displays the most significant
[Word Count: 15]

severity of a packet or stays empty if everything seems OK. This column is not displayed by default
[Word Count: 18]

but can be easily added using the Preferences Columns page described in Preferences.
[Word Count: 13]

By default, Wireshark’s TCP dissector tracks the state of each TCP session and provides additional
[Word Count: 15]

information when problems or potential problems are detected. Analysis is done once for each TCP
[Word Count: 15]

packet when a capture file is first opened. Packets are processed in the order in which they appear
[Word Count: 18]

in the packet list. You can enable or disable this feature via the “Analyze TCP sequence numbers”
[Word Count: 17]

For analysis of data or protocols layered on top of TCP (such as HTTP), see TCP Reassembly.
[Word Count: 17]

Figure 76. “TCP Analysis” packet detail items
[Word Count: 7]

TCP Analysis flags are added to the TCP protocol tree under “SEQ/ACK analysis”. Each flag is
[Word Count: 16]

described below. Terms such as “next expected sequence number” and “next expected
[Word Count: 12]

acknowledgment number” refer to the following”:
[Word Count: 6]

The last-seen sequence number plus segment length. Set when there are no analysis flags and
[Word Count: 15]

for zero window probes. This is initially zero and calculated based on the previous packet in the
[Word Count: 17]

same TCP flow. Note that this may not be the same as the tcp.nxtseq protocol field.
[Word Count: 16]

The last-seen sequence number for segments. Set when there are no analysis flags and for zero
[Word Count: 16]

Always updated for each packet. Note that this is not the same as the next expected
[Word Count: 16]

Set when the expected next acknowledgment number is set for the reverse direction and it’s less
[Word Count: 16]

TCP Dup ACK <frame>#<acknowledgment number>
[Word Count: 5]

• The window size is non-zero and hasn’t changed, or there is valid SACK data.
[Word Count: 15]

• The next expected sequence number and last-seen acknowledgment number are non-zero (i.e.,
[Word Count: 13]

• In the forward direction, the segment size is greater than zero or the SYN or FIN is set.
[Word Count: 19]

• The next expected sequence number is greater than the current sequence number.
[Word Count: 13]

• We have at least two duplicate ACKs in the reverse direction.
[Word Count: 12]

• The current sequence number equals the next expected acknowledgment number.
[Word Count: 11]

• We saw the last acknowledgment less than 20ms ago.
[Word Count: 10]

Supersedes “Out-Of-Order” and “Retransmission”.
[Word Count: 4]

Set when the segment size is zero or one, the current sequence number is one byte less than the
[Word Count: 19]

next expected sequence number, and none of SYN, FIN, or RST are set.
[Word Count: 13]

Supersedes 
“Fast 
Retransmission”, 
“Out-Of-Order”, 
“Spurious 
Retransmission”, 
and
[Word Count: 7]

• The window size is non-zero and hasn’t changed.
[Word Count: 9]

• The current sequence number is the same as the next expected sequence number.
[Word Count: 14]

• The current acknowledgment number is the same as the last-seen acknowledgment number.
[Word Count: 13]

• The most recently seen packet in the reverse direction was a keepalive.
[Word Count: 13]

Supersedes “Dup ACK” and “ZeroWindowProbeAck”.
[Word Count: 5]

• In the forward direction, the segment length is greater than zero or the SYN or FIN is set.
[Word Count: 19]

• The next expected sequence number is greater than the current sequence number.
[Word Count: 13]

• The next expected sequence number and the next sequence number differ.
[Word Count: 12]

• The last segment arrived within the Out-Of-Order RTT threshold. The threshold is either the
[Word Count: 15]

value shown in the “iRTT” (tcp.analysis.initial_rtt) field under “SEQ/ACK analysis” if it is present,
[Word Count: 14]

or the default value of 3ms if it is not.
[Word Count: 10]

Set when the SYN flag is set (not SYN+ACK), we have an existing conversation using the same
[Word Count: 17]

addresses and ports, and the sequence number is different than the existing conversation’s initial
[Word Count: 14]

Set when the current sequence number is greater than the next expected sequence number.
[Word Count: 14]

Checks for a retransmission based on analysis data in the reverse direction. Set when all of the
[Word Count: 17]

• The segment length is greater than zero.
[Word Count: 8]

• Data for this flow has been acknowledged. That is, the last-seen acknowledgment number has
[Word Count: 15]

• The next sequence number is less than or equal to the last-seen acknowledgment number.
[Word Count: 15]

Supersedes “Fast Retransmission”, “Out-Of-Order”, and “Retransmission”.
[Word Count: 6]

• In the forward direction, the segment length is greater than zero or the SYN or FIN flag is set.
[Word Count: 20]

• The next expected sequence number is greater than the current sequence number.
[Word Count: 13]

Set when the segment size is non-zero, we know the window size in the reverse direction, and our
[Word Count: 18]

segment size exceeds the window size in the reverse direction.
[Word Count: 10]

Set when the all of the following are true:
[Word Count: 9]

• The window size is non-zero and not equal to the last-seen window size, and there is no valid
[Word Count: 19]

• The sequence number is equal to the next expected sequence number.
[Word Count: 12]

• The acknowledgment number is equal to the last-seen acknowledgment number,
[Word Count: 11]

• or to the next expected sequence number when answering to a ZeroWindowProbe.
[Word Count: 13]

Set when the receive window size is zero and none of SYN, FIN, or RST are set.
[Word Count: 17]

The window field in each TCP header advertises the amount of data a receiver can accept. If the
[Word Count: 18]

receiver can’t accept any more data it will set the window value to zero, which tells the sender to
[Word Count: 19]

pause its transmission. In some specific cases this is normal — for example, a printer might use a
[Word Count: 18]

zero window to pause the transmission of a print job while it loads or reverses a sheet of paper.
[Word Count: 19]

However, in most cases this indicates a performance or capacity problem on the receiving end. It
[Word Count: 16]

might take a long time (sometimes several minutes) to resume a paused connection, even if the
[Word Count: 16]

underlying condition that caused the zero window clears up quickly.
[Word Count: 10]

Set when the sequence number is equal to the next expected sequence number, the segment size is
[Word Count: 17]

one, and last-seen window size in the reverse direction was zero.
[Word Count: 11]

If the single data byte from a Zero Window Probe is dropped by the receiver (not ACKed), then a
[Word Count: 19]

subsequent segment should not be flagged as retransmission if all of the following conditions are
[Word Count: 15]

true for that segment: * The segment size is larger than one. * The next expected sequence number
[Word Count: 18]

is one less than the current sequence number.
[Word Count: 8]

This affects “Fast Retransmission”, “Out-Of-Order”, or “Retransmission”.
[Word Count: 7]

Set when the all of the following are true:
[Word Count: 9]

• The sequence number is equal to the next expected sequence number.
[Word Count: 12]

• The acknowledgment number is equal to the last-seen acknowledgment number.
[Word Count: 11]

• The last-seen packet in the reverse direction was a zero window probe.
[Word Count: 13]

Some captures are quite difficult to analyze automatically, particularly when the time frame may
[Word Count: 14]

cover both Fast Retransmission and Out-Of-Order packets. A TCP preference allows to switch the
[Word Count: 14]

precedence of these two interpretations at the protocol level.
[Word Count: 9]

TCP conversations are said to be complete when they have both opening and closing handshakes,
[Word Count: 15]

independently of any data transfer. However, we might be interested in identifying complete
[Word Count: 13]

conversations with some data sent, and we are using the following bit values to build a filter value
[Word Count: 18]

For example, a conversation containing only a three-way handshake will be found with the filter
[Word Count: 15]

'tcp.completeness==7' (1+2+4) while a complete conversation with data transfer will be found with
[Word Count: 13]

a longer filter as closing a connection can be associated with FIN or RST packets, or even both :
[Word Count: 19]

'tcp.completeness==31 or tcp.completeness==47 or tcp.completeness==63'
[Word Count: 5]

Another way to select specific conversation values is to filter on individual flags, the summary field,
[Word Count: 16]

or a combination of them. Thus, '(tcp.completeness.fin==1 || tcp.completeness.rst==1) &&
[Word Count: 10]

tcp.completeness.str contains "DASS"' will find all 'Complete, WITH_DATA' conversations, while the
[Word Count: 11]

'Complete, NO_DATA' ones will be found with '(tcp.completeness.fin==1 || tcp.completeness.rst==1)
[Word Count: 10]

&& tcp.completeness.data==0 && tcp.completeness.str contains "ASS"'.
[Word Count: 6]

Time stamps, their precisions and all that can be quite confusing. This section will provide you with
[Word Count: 17]

information about what’s going on while Wireshark processes time stamps.
[Word Count: 10]

While packets are captured, each packet is time stamped as it comes in. These time stamps will be
[Word Count: 18]

saved to the capture file, so they also will be available for (later) analysis.
[Word Count: 14]

So where do these time stamps come from? While capturing, Wireshark gets the time stamps from
[Word Count: 16]

the libpcap (Npcap) library, which in turn gets them from the operating system kernel. If the
[Word Count: 16]

capture data is loaded from a capture file, Wireshark obviously gets the data from that file.
[Word Count: 16]

The internal format that Wireshark uses to keep a packet time stamp consists of the date (in days
[Word Count: 18]

since 1.1.1970) and the time of day (in nanoseconds since midnight). You can adjust the way
[Word Count: 16]

Wireshark displays the time stamp data in the packet list, see the “Time Display Format” item in the
[Word Count: 18]

While reading or writing capture files, Wireshark converts the time stamp data between the
[Word Count: 14]

capture file format and the internal format as required.
[Word Count: 9]

While capturing, Wireshark uses the libpcap (Npcap) capture library which supports nanosecond
[Word Count: 12]

resolution for both pcapng and pcap files, though some devices may only provide microsecond
[Word Count: 14]

resolution, in which case that will be used. Unless you are working with specialized capturing
[Word Count: 15]

hardware, this resolution should be adequate.
[Word Count: 6]

The vast majority of capture file formats that Wireshark knows support time stamps. The time
[Word Count: 15]

stamp precision supported by a specific capture file format differs widely and varies from one
[Word Count: 15]

second “0” to one nanosecond “0.123456789”. Most file formats store the time stamps with a fixed
[Word Count: 16]

precision (e.g., microseconds, “0.123456”), while some file formats are capable of storing the time
[Word Count: 14]

stamp precision itself or even having a different precision for different records in the file (whatever
[Word Count: 16]

The pcapng capture file format supports a wide range of time stamp resolutions, which can be
[Word Count: 16]

different for each interface in the file, as well as records without time stamps. The common libpcap
[Word Count: 17]

capture file format, which is widely supported by many other tools, supports two possible fixed
[Word Count: 15]

resolutions, microsecond or nanosecond, indicated by a magic number at the start of the file.
[Word Count: 15]

Wireshark and tools like editcap can convert pcap files with nanosecond resolution to microsecond
[Word Count: 14]

resolution for use with tools that only support the original time stamp precision.
[Word Count: 13]

Writing data into a capture file format that doesn’t provide the capability to store the actual
[Word Count: 16]

precision will lead to loss of information. For example, if you load a capture file with nanosecond
[Word Count: 17]

resolution and store the capture data in a libpcap file (with microsecond resolution) Wireshark
[Word Count: 14]

obviously must reduce the precision from nanosecond to microsecond.
[Word Count: 9]

People often ask “Which time stamp accuracy is provided by Wireshark?”. Well, Wireshark doesn’t
[Word Count: 14]

create any time stamps itself but simply gets them from “somewhere else” and displays them. So
[Word Count: 16]

accuracy will depend on the capture system (operating system, performance, etc.) that you use.
[Word Count: 14]

Because of this, the above question is difficult to answer in a general way.
[Word Count: 14]

USB connected network adapters often provide a very bad time stamp accuracy. The
[Word Count: 13]

incoming packets have to take “a long and winding road” to travel through the USB
[Word Count: 15]

cable until they actually reach the kernel. As the incoming packets are time stamped
[Word Count: 14]

when they are processed by the kernel, this time stamping mechanism becomes
[Word Count: 12]

Don’t use USB connected NICs when you need precise time stamp accuracy.
[Word Count: 12]

If you travel across the planet, time zones can be confusing. If you get a capture file from
[Word Count: 18]

somewhere around the world time zones can even be a lot more confusing ;-)
[Word Count: 14]

First of all, there are two reasons why you may not need to think about time zones at all:
[Word Count: 19]

• You are only interested in the time differences between the packet time stamps and don’t need
[Word Count: 17]

to know the exact date and time of the captured packets (which is often the case).
[Word Count: 16]

• You don’t get capture files from different time zones than your own, so there are simply no time
[Word Count: 19]

zone problems. For example, everyone in your team is working in the same time zone as
[Word Count: 16]

People expect that the time reflects the sunset. Dawn should be in the morning maybe around
[Word Count: 16]

06:00 and dusk in the evening maybe at 20:00. These times will obviously vary depending on
[Word Count: 16]

the season. It would be very confusing if everyone on earth would use the same global time
[Word Count: 17]

as this would correspond to the sunset only at a small part of the world.
[Word Count: 15]

For that reason, the earth is split into several different time zones, each zone with a local time
[Word Count: 18]

The time zone’s base time is UTC (Coordinated Universal Time) or Zulu Time (military and
[Word Count: 15]

aviation). The older term GMT (Greenwich Mean Time) shouldn’t be used as it is slightly
[Word Count: 15]

incorrect (up to 0.9 seconds difference to UTC). The UTC base time equals to 0 (based at
[Word Count: 17]

Greenwich, England) and all time zones have an offset to UTC between -12 to +14 hours!
[Word Count: 16]

For example: If you live in Berlin, you are in a time zone one hour earlier than UTC, so you
[Word Count: 20]

are in time zone “+1” (time difference in hours compared to UTC). If it’s 3 o’clock in Berlin it’s
[Word Count: 19]

Be aware that at a few places on earth don’t use time zones with even hour offsets (e.g., New
[Word Count: 19]

Further 
information 
can 
be 
found 
at: 
https://en.wikipedia.org/wiki/Time_zone 
and
[Word Count: 8]

https://en.wikipedia.org/wiki/Coordinated_Universal_Time.
[Word Count: 1]

Daylight Saving Time (DST), also known as Summer Time is intended to “save” some daylight
[Word Count: 15]

during the summer months. To do this, a lot of countries (but not all!) add a DST hour to the
[Word Count: 20]

already existing UTC offset. So you may need to take another hour (or in very rare cases even
[Word Count: 18]

two hours!) difference into your “time zone calculations”.
[Word Count: 8]

Unfortunately, the date at which DST actually takes effect is different throughout the world.
[Word Count: 14]

You may also note, that the northern and southern hemispheres have opposite DST’s (e.g.,
[Word Count: 14]

while it’s summer in Europe it’s winter in Australia).
[Word Count: 9]

Keep in mind: UTC remains the same all year around, regardless of DST!
[Word Count: 13]

Further information can be found at https://en.wikipedia.org/wiki/Daylight_saving.
[Word Count: 7]

Further time zone and DST information can be found at https://wwp.greenwichmeantime.com/ and
[Word Count: 12]

https://www.timeanddate.com/worldclock/.
[Word Count: 1]

If you work with people around the world it’s very helpful to set your computer’s time and time
[Word Count: 18]

You should set your computers time and time zone in the correct sequence:
[Word Count: 13]

1. Set your time zone to your current location
[Word Count: 9]

2. Set your computer’s clock to the local time
[Word Count: 9]

This way you will tell your computer both the local time and also the time offset to UTC. Many
[Word Count: 19]

organizations simply set the time zone on their servers and networking gear to UTC in order to
[Word Count: 17]

make coordination and troubleshooting easier.
[Word Count: 5]

TIP
If you travel around the world, it’s an often-made mistake to adjust the hours of your
[Word Count: 17]

computer clock to the local time. Don’t adjust the hours but your time zone setting
[Word Count: 15]

instead! For your computer, the time is essentially the same as before, you are simply
[Word Count: 15]

in a different time zone with a different local time.
[Word Count: 10]

You can use the Network Time Protocol (NTP) to automatically adjust your computer to the correct
[Word Count: 16]

time, by synchronizing it to Internet NTP clock servers. NTP clients are available for all operating
[Word Count: 16]

systems that Wireshark supports (and for a lot more), for examples see http://www.ntp.org/.
[Word Count: 13]

So what’s the relationship between Wireshark and time zones anyway?
[Word Count: 10]

Wireshark’s native capture file format (libpcap format), and some other capture file formats, such
[Word Count: 14]

as the Windows Sniffer, *Peek, Sun snoop formats, and newer versions of the Microsoft Network
[Word Count: 15]

Monitor and Network Instruments/Viavi Observer formats, save the arrival time of packets as UTC
[Word Count: 14]

values. UN*X systems, and “Windows NT based” systems represent time internally as UTC. When
[Word Count: 14]

Wireshark is capturing, no conversion is necessary. However, if the system time zone is not set
[Word Count: 16]

correctly, the system’s UTC time might not be correctly set even if the system clock appears to
[Word Count: 17]

display correct local time. When capturing, Npcap has to convert the time to UTC before supplying
[Word Count: 16]

it to Wireshark. If the system’s time zone is not set correctly, that conversion will not be done
[Word Count: 18]

Other capture file formats, such as the OOS-based Sniffer format and older versions of the
[Word Count: 15]

Microsoft Network Monitor and Network Instruments/Viavi Observer formats, save the arrival time
[Word Count: 12]

Internally to Wireshark, time stamps are represented in UTC. This means that when reading
[Word Count: 14]

capture files that save the arrival time of packets as local time values, Wireshark must convert
[Word Count: 16]

Wireshark in turn will display the time stamps always in local time. The displaying computer will
[Word Count: 16]

convert them from UTC to local time and displays this (local) time. For capture files saving the
[Word Count: 17]

arrival time of packets as UTC values, this means that the arrival time will be displayed as the local
[Word Count: 19]

time in your time zone, which might not be the same as the arrival time in the time zone in which
[Word Count: 21]

the packet was captured. For capture files saving the arrival time of packets as local time values, the
[Word Count: 18]

conversion to UTC will be done using your time zone’s offset from UTC and DST rules, which means
[Word Count: 18]

the conversion will not be done correctly; the conversion back to local time for display might undo
[Word Count: 17]

this correctly, in which case the arrival time will be displayed as the arrival time in which the
[Word Count: 18]

Table 28. Time zone examples for UTC arrival times (without DST)
[Word Count: 11]

Los Angeles
New York
Madrid
London
Berlin
Tokyo
[Word Count: 8]

Los Angeles
New York
Madrid
London
Berlin
Tokyo
[Word Count: 8]

For example, let’s assume that someone in Los Angeles captured a packet with Wireshark at exactly
[Word Count: 16]

2 o’clock local time and sends you this capture file. The capture file’s time stamp will be
[Word Count: 17]

represented in UTC as 10 o’clock. You are located in Berlin and will see 11 o’clock on your
[Word Count: 18]

Now you have a phone call, video conference or Internet meeting with that one to talk about that
[Word Count: 18]

capture file. As you are both looking at the displayed time on your local computers, the one in Los
[Word Count: 19]

Angeles still sees 2 o’clock but you in Berlin will see 11 o’clock. The time displays are different as
[Word Count: 19]

both Wireshark displays will show the (different) local times at the same point in time.
[Word Count: 15]

Conclusion: You may not bother about the date/time of the time stamp you currently look at unless
[Word Count: 17]

you must make sure that the date/time is as expected. So, if you get a capture file from a different
[Word Count: 20]

time zone and/or DST, you’ll have to find out the time zone/DST difference between the two local
[Word Count: 17]

times and “mentally adjust” the time stamps accordingly. In any case, make sure that every
[Word Count: 15]

computer in question has the correct time and time zone setting.
[Word Count: 11]

Network protocols often need to transport large chunks of data which are complete in themselves,
[Word Count: 15]

e.g., when transferring a file. The underlying protocol might not be able to handle that chunk size
[Word Count: 17]

(e.g., limitation of the network packet size), or is stream-based like TCP, which doesn’t know data
[Word Count: 16]

In that case the network protocol has to handle the chunk boundaries itself and (if required) spread
[Word Count: 17]

the data over multiple packets. It obviously also needs a mechanism to determine the chunk
[Word Count: 15]

Wireshark calls this mechanism reassembly, although a specific protocol specification might use a
[Word Count: 13]

different term for this (e.g., desegmentation, defragmentation, etc.).
[Word Count: 8]

For some of the network protocols Wireshark knows of, a mechanism is implemented to find,
[Word Count: 15]

decode and display these chunks of data. Wireshark will try to find the corresponding packets of
[Word Count: 16]

this chunk, and will show the combined data as additional tabs in the “Packet Bytes” pane (for
[Word Count: 17]

information about this pane. See The “Packet Bytes” Pane).
[Word Count: 9]

Figure 77. The “Packet Bytes” pane with a reassembled tab
[Word Count: 10]

Reassembly might take place at several protocol layers, so it’s possible that multiple tabs in the
[Word Count: 16]

NOTE
You will find the reassembled data in the last packet of the chunk.
[Word Count: 14]

For example, in a HTTP GET response, the requested data (e.g., an HTML page) is returned.
[Word Count: 16]

Wireshark will show the hex dump of the data in a new tab “Uncompressed entity body” in the
[Word Count: 18]

Reassembly is enabled in the preferences by default but can be disabled in the preferences for the
[Word Count: 17]

protocol in question. Enabling or disabling reassembly settings for a protocol typically requires two
[Word Count: 14]

1. The lower-level protocol (e.g., TCP) must support reassembly. Often this reassembly can be
[Word Count: 14]

enabled or disabled via the protocol preferences.
[Word Count: 7]

2. The higher-level protocol (e.g., HTTP) must use the reassembly mechanism to reassemble
[Word Count: 13]

fragmented protocol data. This too can often be enabled or disabled via the protocol
[Word Count: 14]

The tooltip of the higher-level protocol setting will notify you if and which lower-level protocol
[Word Count: 15]

Protocols such as HTTP or TLS are likely to span multiple TCP segments. The TCP protocol
[Word Count: 16]

preference “Allow subdissector to reassemble TCP streams” (enabled by default) makes it possible
[Word Count: 13]

for Wireshark to collect a contiguous sequence of TCP segments and hand them over to the higher-
[Word Count: 17]

level protocol (for example, to reconstruct a full HTTP message). All but the final segment will be
[Word Count: 17]

marked with “[TCP segment of a reassembled PDU]” in the packet list.
[Word Count: 12]

Disable this preference to reduce memory and processing overhead if you are only interested in
[Word Count: 15]

TCP sequence number analysis (TCP Analysis). Keep in mind, though, that higher-level protocols
[Word Count: 13]

might be wrongly dissected. For example, HTTP messages could be shown as “Continuation” and
[Word Count: 14]

TLS records could be shown as “Ignored Unknown Record”. Such results can also be observed if you
[Word Count: 17]

start capturing while a TCP connection was already started or when TCP segments are lost or
[Word Count: 16]

To reassemble of out-of-order TCP segments, the TCP protocol preference “Reassemble out-of-order
[Word Count: 12]

segments” (currently disabled by default) must be enabled in addition to the previous preference. If
[Word Count: 15]

all packets are received in-order, this preference will not have any effect. Otherwise (if missing
[Word Count: 15]

segments are encountered while sequentially processing a packet capture), it is assuming that the
[Word Count: 14]

new and missing segments belong to the same PDU. Caveats:
[Word Count: 10]

• Lost packets are assumed to be received out-of-order or retransmitted later. Applications
[Word Count: 13]

usually retransmit segments until these are acknowledged, but if the packet capture drops
[Word Count: 13]

packets, then Wireshark will not be able to reconstruct the TCP stream. In such cases, you can
[Word Count: 17]

try to disable this preference and hopefully have a partial dissection instead of seeing just “[TCP
[Word Count: 16]

segment of a reassembled PDU]” for every TCP segment.
[Word Count: 9]

• When doing a capture in monitor mode (IEEE 802.11), packets are more likely to get lost due to
[Word Count: 19]

signal reception issues. In that case it is recommended to disable the option.
[Word Count: 13]

• If the new and missing segments are in fact part of different PDUs, then processing is currently
[Word Count: 18]

delayed until no more segments are missing, even if the begin of the missing segments
[Word Count: 15]

completed a PDU. For example, assume six segments forming two PDUs ABC and DEF. When
[Word Count: 15]

received as ABECDF, an application can start processing the first PDU after receiving ABEC.
[Word Count: 14]

Wireshark however requires the missing segment D to be received as well. This issue will be
[Word Count: 16]

• In the GUI and during a two-pass dissection (tshark -2), the previous scenario will display both
[Word Count: 17]

PDUs in the packet with last segment (F) rather than displaying it in the first packet that has the
[Word Count: 19]

final missing segment of a PDU. This issue will be addressed in the future.
[Word Count: 14]

• When enabled, fields such as the SMB “Time from request” (smb.time) might be smaller if the
[Word Count: 17]

request follows other out-of-order segments (this reflects application behavior). If the previous
[Word Count: 12]

scenario however occurs, then the time of the request is based on the frame where all missing
[Word Count: 17]

Regardless of the setting of these two reassembly-related preferences, you can always use the
[Word Count: 14]

“Follow TCP Stream” option (đFollowing Protocol Streams) which displays segments in the expected
[Word Count: 13]

Name resolution tries to convert some of the numerical address values into a human readable
[Word Count: 15]

format. There are two possible ways to do these conversions, depending on the resolution to be
[Word Count: 16]

done: calling system/network services (like the gethostname() function) and/or resolving from
[Word Count: 11]

Wireshark specific configuration files. For details about the configuration files Wireshark uses for
[Word Count: 13]

name resolution and alike, see Files and Folders.
[Word Count: 8]

The name resolution feature can be enabled individually for the protocol layers listed in the
[Word Count: 15]

Name resolution can be invaluable while working with Wireshark and may even save you hours of
[Word Count: 16]

work. Unfortunately, it also has its drawbacks.
[Word Count: 7]

• Name resolution can often fail. The name to be resolved might simply be unknown by the name
[Word Count: 18]

servers asked, or the servers are just not available and the name is also not found in
[Word Count: 17]

• Resolved names might not be available. Wireshark obtains name resolution information from a
[Word Count: 14]

variety of sources, including DNS servers, the capture file itself (e.g., for a pcapng file), and the
[Word Count: 17]

hosts files on your system and in your profile directory. The resolved names might not be
[Word Count: 16]

available if you open the capture file later or on a different machine. As a result, each time you
[Word Count: 19]

or someone else opens a particular capture file it may look slightly different due to changing
[Word Count: 16]

• DNS may add additional packets to your capture file. You might run into the observer effect if the
[Word Count: 19]

extra traffic from Wireshark’s DNS queries and responses affects the problem you’re trying to
[Word Count: 14]

troubleshoot or any subsequent analysis.
[Word Count: 5]

The same sort of thing can happen when capturing over a remote connection, e.g., SSH or RDP.
[Word Count: 17]

• Resolved DNS names are cached by Wireshark. This is required for acceptable performance.
[Word Count: 14]

However, if the name resolution information should change while Wireshark is running,
[Word Count: 12]

Wireshark won’t notice a change in the name resolution information once it gets cached. If this
[Word Count: 16]

information changes while Wireshark is running, e.g., a new DHCP lease takes effect, Wireshark
[Word Count: 14]

Name resolution in the packet list is done while the list is filled. If a name can be resolved after a
[Word Count: 21]

packet is added to the list, its former entry won’t be changed. As the name resolution results are
[Word Count: 18]

cached, you can use View › Reload to rebuild the packet list with the correctly resolved names.
[Word Count: 17]

However, this isn’t possible while a capture is in progress.
[Word Count: 10]

Try to resolve an Ethernet MAC address (e.g., 00:09:5b:01:02:03) to a human readable name.
[Word Count: 14]

ARP name resolution (system service): Wireshark will ask the operating system to convert an
[Word Count: 14]

Ethernet address to the corresponding IP address (e.g. 00:09:5b:01:02:03 → 192.168.0.1).
[Word Count: 11]

Ethernet codes (ethers file): If the ARP name resolution failed, Wireshark tries to convert the
[Word Count: 15]

Ethernet address to a known device name, which has been assigned by the user using an ethers file
[Word Count: 18]

Ethernet manufacturer codes (manuf file): If neither ARP or ethers returns a result, Wireshark tries
[Word Count: 15]

to convert the first 3 bytes of an ethernet address to an abbreviated manufacturer name, which has
[Word Count: 17]

been assigned by the IEEE (e.g. 00:09:5b:01:02:03 → Netgear_01:02:03).
[Word Count: 9]

Try to resolve an IP address (e.g., 216.239.37.99) to a human readable name.
[Word Count: 13]

DNS name resolution (system/library service): Wireshark will use a name resolver to convert an IP
[Word Count: 15]

address to the hostname associated with it (e.g., 216.239.37.99 → www.1.google.com).
[Word Count: 11]

Most applications use synchronously DNS name resolution. For example, your web browser must
[Word Count: 13]

resolve the host name portion of a URL before it can connect to the server. Capture file analysis is
[Word Count: 19]

different. A given file might have hundreds, thousands, or millions of IP addresses so for usability
[Word Count: 16]

and performance reasons Wireshark uses asynchronous resolution. Both mechanisms convert IP
[Word Count: 11]

addresses to human readable (domain) names and typically use different sources such as the
[Word Count: 14]

system hosts file (/etc/hosts) and any configured DNS servers.
[Word Count: 9]

Since Wireshark doesn’t wait for DNS responses, the host name for a given address might be
[Word Count: 16]

missing from a given packet when you view it the first time but be present when you view it
[Word Count: 19]

You can adjust name resolution behavior in the Name Resolution section in the Preferences Dialog.
[Word Count: 15]

You can control resolution itself by adding a hosts file to your personal configuration directory. You
[Word Count: 16]

can also edit your system hosts file, but that isn’t generally recommended.
[Word Count: 12]

TCP/UDP Port Name Resolution (Transport Layer)
[Word Count: 6]

Try to resolve a TCP/UDP port (e.g., 80) to a human readable name.
[Word Count: 13]

TCP/UDP port conversion (system service): Wireshark will ask the operating system to convert a TCP
[Word Count: 15]

or UDP port to its well-known name (e.g., 80 → http).
[Word Count: 11]

To get a descriptive name for a VLAN tag ID a vlans file can be used.
[Word Count: 16]

To get a node name for a SS7 point code a ss7pcs file can be used.
[Word Count: 16]

Several network protocols use checksums to ensure data integrity. Applying checksums as
[Word Count: 12]

described here is also known as redundancy checking.
[Word Count: 8]

Checksums are used to ensure the integrity of data portions for data transmission or storage.
[Word Count: 15]

A checksum is basically a calculated summary of such a data portion.
[Word Count: 12]

Network data transmissions often produce errors, such as toggled, missing or duplicated bits.
[Word Count: 13]

As a result, the data received might not be identical to the data transmitted, which is
[Word Count: 16]

Because of these transmission errors, network protocols very often use checksums to detect
[Word Count: 13]

such errors. The transmitter will calculate a checksum of the data and transmits the data
[Word Count: 15]

together with the checksum. The receiver will calculate the checksum of the received data
[Word Count: 14]

with the same algorithm as the transmitter. If the received and calculated checksums don’t
[Word Count: 14]

match a transmission error has occurred.
[Word Count: 6]

Some checksum algorithms are able to recover (simple) errors by calculating where the
[Word Count: 13]

expected error must be and repairing it.
[Word Count: 7]

If there are errors that cannot be recovered, the receiving side throws away the packet.
[Word Count: 15]

Depending on the network protocol, this data loss is simply ignored or the sending side needs
[Word Count: 16]

to detect this loss somehow and retransmits the required packet(s).
[Word Count: 10]

Using a checksum drastically reduces the number of undetected transmission errors.
[Word Count: 11]

However, the usual checksum algorithms cannot guarantee an error detection of 100%, so a
[Word Count: 14]

very small number of transmission errors may remain undetected.
[Word Count: 9]

There are several different kinds of checksum algorithms; an example of an often used
[Word Count: 14]

checksum algorithm is CRC32. The checksum algorithm actually chosen for a specific network
[Word Count: 13]

protocol will depend on the expected error rate of the network medium, the importance of
[Word Count: 15]

error detection, the processor load to perform the calculation, the performance needed and
[Word Count: 13]

Further information about checksums can be found at: https://en.wikipedia.org/wiki/
[Word Count: 9]

Wireshark will validate the checksums of many protocols, e.g., IP, TCP, UDP, etc.
[Word Count: 13]

It will do the same calculation as a “normal receiver” would do, and shows the checksum fields in
[Word Count: 18]

the packet details with a comment, e.g., [correct] or [invalid, must be 0x12345678].
[Word Count: 13]

Checksum validation can be switched off for various protocols in the Wireshark protocol
[Word Count: 13]

preferences, e.g., to (very slightly) increase performance.
[Word Count: 7]

If the checksum validation is enabled and it detected an invalid checksum, features like packet
[Word Count: 15]

reassembly won’t be processed. This is avoided as incorrect connection data could “confuse” the
[Word Count: 14]

The checksum calculation might be done by the network driver, protocol driver or even in
[Word Count: 15]

For example: The Ethernet transmitting hardware calculates the Ethernet CRC32 checksum and the
[Word Count: 13]

receiving hardware validates this checksum. If the received checksum is wrong Wireshark won’t
[Word Count: 13]

even see the packet, as the Ethernet hardware internally throws away the packet.
[Word Count: 13]

Higher-level checksums are “traditionally” calculated by the protocol implementation and the
[Word Count: 11]

completed packet is then handed over to the hardware.
[Word Count: 9]

Recent network hardware can perform advanced features such as IP checksum calculation, also
[Word Count: 13]

known as checksum offloading. The network driver won’t calculate the checksum itself but will
[Word Count: 14]

simply hand over an empty (zero or garbage filled) checksum field to the hardware.
[Word Count: 14]

Checksum offloading often causes confusion as network packets to be transmitted
[Word Count: 11]

are given to Wireshark before they are handed over to the hardware. Wireshark
[Word Count: 13]

gets these “empty” checksums and displays them as invalid, even though the
[Word Count: 12]

packets will contain valid checksums when they transit the network.
[Word Count: 10]

This only applies to packets that are locally generated by the capture point.
[Word Count: 13]

Received packets will have traveled through network hardware and should have
[Word Count: 11]

Checksum offloading can be confusing and having a lot of [invalid] messages on the screen can be
[Word Count: 17]

quite annoying. As mentioned above, invalid checksums may lead to unreassembled packets,
[Word Count: 12]

making the analysis of the packet data much harder.
[Word Count: 9]

You can do two things to avoid this checksum offloading problem:
[Word Count: 11]

• Turn off the checksum offloading in the network driver, if this option is available.
[Word Count: 15]

• Turn off checksum validation of the specific protocol in the Wireshark preferences. Recent
[Word Count: 14]

releases of Wireshark disable checksum validation by default due to the prevalence of
[Word Count: 13]

offloading in modern hardware and operating systems.
[Word Count: 7]

TCP and UDP checksums are calculated over both the payload and from selected elements from the
[Word Count: 16]

IPv4 or IPv6 header, known as the pseudo header. Linux and Windows, when offloading
[Word Count: 14]

checksums, will calculate the contribution from the pseudo header and place it in the checksum
[Word Count: 15]

field. The driver then directs the hardware to calculate the checksum over the payload area, which
[Word Count: 16]

will produce the correct result including the pseudo header’s portion of the sum as a matter of
[Word Count: 17]

This precomputation speeds up the hardware checksum calculation later, allows the driver to
[Word Count: 13]

direct the hardware to do checksums over encapsulated payloads (Local Checksum Offload), and
[Word Count: 13]

allows applications to send the kernel large "superpacket" buffers that will be later divided by the
[Word Count: 16]

hardware into multiple maximum size packets when sent on the network (TCP Segmentation
[Word Count: 13]

Offload (TSO) and Generic Segmentation Offload (GSO)).
[Word Count: 7]

Wireshark 4.2.0 and later can calculate the partial checksum contribution from the
[Word Count: 12]

pseudo header, and when validating TCP and UDP checksums will mark partial
[Word Count: 12]

checksums as valid but partial. The packets with partial checksums will not be
[Word Count: 13]

colored as Bad Checksums by the default coloring rules, and will still be used for
[Word Count: 15]

reassembly. This eliminates spurious checksum errors seen on packets transmitted
[Word Count: 10]

from the capturing host on those platforms that use partial checksums when
[Word Count: 12]

Wireshark provides a wide range of network statistics which can be accessed via the Statistics
[Word Count: 15]

These statistics range from general information about the loaded capture file (like the number of
[Word Count: 15]

captured packets), to statistics about specific protocols (e.g., statistics about the number of HTTP
[Word Count: 14]

• Capture File Properties about the capture file.
[Word Count: 8]

• Protocol Hierarchy of the captured packets.
[Word Count: 7]

• Conversations e.g., traffic between specific IP addresses.
[Word Count: 8]

• Endpoints e.g., traffic to and from IP addresses.
[Word Count: 9]

• I/O Graphs visualizing the number of packets (or similar) in time.
[Word Count: 12]

• Service Response Time between request and response of some protocols.
[Word Count: 11]

• Various other protocol specific statistics.
[Word Count: 6]

The protocol specific statistics require detailed knowledge about the specific
[Word Count: 10]

protocol. Unless you are familiar with that protocol, statistics about it may be
[Word Count: 13]

Wireshark has many other statistics windows that display detailed information about specific
[Word Count: 12]

protocols and might be described in a later version of this document.
[Word Count: 12]

Some of these statistics are described at https://wiki.wireshark.org/Statistics.
[Word Count: 8]

General information about the current capture file.
[Word Count: 7]

Figure 78. The “Capture File Properties” dialog
[Word Count: 7]

This dialog shows the following information:
[Word Count: 6]

Notable information about the capture file.
[Word Count: 6]

General information about the capture file, including its full path, size, cryptographic hashes,
[Word Count: 13]

The timestamps of the first and the last packet in the file along with their difference.
[Word Count: 16]

Information about the capture environment. This will only be shown for live captures or if
[Word Count: 15]

this information is present in a saved capture file. The pcapng format supports this, while
[Word Count: 15]

Information about the capture interface or interfaces.
[Word Count: 7]

A statistical summary of the capture file. If a display filter is set, you will see values in the
[Word Count: 19]

Captured column, and if any packets are marked, you will see values in the Marked column.
[Word Count: 16]

The values in the Captured column will remain the same as before, while the values in the
[Word Count: 17]

Displayed column will reflect the values corresponding to the packets shown in the display.
[Word Count: 14]

The values in the Marked column will reflect the values corresponding to the marked
[Word Count: 14]

Some capture file formats (notably pcapng) allow a text comment for the entire file. You can
[Word Count: 16]

Saves the contents of the “Capture file comments” text entry.
[Word Count: 10]

Copies the “Details” information to the clipboard.
[Word Count: 7]

The Resolved Addresses window shows the list of resolved addresses and their host names. Users
[Word Count: 15]

can choose the Hosts field to display IPv4 and IPv6 addresses only. In this case, the dialog displays
[Word Count: 18]

host names for each IP address in a capture file with a known host. This host is typically taken from
[Word Count: 20]

DNS answers in a capture file. In case of an unknown host name, users can populate it based on a
[Word Count: 20]

reverse DNS lookup. To do so, follow these steps:
[Word Count: 9]

1. Enable Resolve Network Addresses in the View › Name Resolution menu as this option is
[Word Count: 16]

2. Select Use an external network name resolver in the Preferences › Name Resolution menu.
[Word Count: 15]

NOTE
The resolved addresses are not updated automatically after a user changes the
[Word Count: 13]

settings. To display newly available names, the user has to reopen the dialog.
[Word Count: 13]

The Ports tab shows the list of service names, ports and types.
[Word Count: 12]

Wireshark reads the entries for port mappings from the hosts service configuration files. See
[Word Count: 14]

Configuration Files section for more information.
[Word Count: 6]

The protocol hierarchy of the captured packets.
[Word Count: 7]

Figure 80. The “Protocol Hierarchy” Window
[Word Count: 6]

This is a tree of all the protocols in the capture. Each row contains the statistical values of one
[Word Count: 19]

protocol. Two of the columns (Percent Packets and Percent Bytes) serve double duty as bar graphs. If
[Word Count: 17]

a display filter is set it will be shown at the bottom.
[Word Count: 12]

The [ Copy ] button will let you copy the window contents as CSV or YAML.
[Word Count: 16]

The percentage of protocol packets relative to all packets in the capture.
[Word Count: 12]

The total number of packets that contain this protocol.
[Word Count: 9]

The percentage of protocol bytes relative to the total bytes in the capture.
[Word Count: 13]

The total number of bytes of this protocol.
[Word Count: 8]

The bandwidth of this protocol relative to the capture time.
[Word Count: 10]

The absolute number of packets of this protocol where it was the highest protocol in the stack
[Word Count: 17]

The absolute number of bytes of this protocol where it was the highest protocol in the stack (last
[Word Count: 18]

The bandwidth of this protocol relative to the capture time where was the highest protocol in
[Word Count: 16]

The total number of PDUs of this protocol.
[Word Count: 8]

Packets usually contain multiple protocols. As a result, more than one protocol will be counted for
[Word Count: 16]

each packet. Example: In the screenshot 100% of packets are IP and 99.3% are TCP (which is
[Word Count: 17]

Protocol layers can consist of packets that won’t contain any higher layer protocol, so the sum of all
[Word Count: 18]

higher layer packets may not sum to the protocol’s packet count. This can be caused by segments
[Word Count: 17]

and fragments reassembled in other frames, TCP protocol overhead, and other undissected data.
[Word Count: 13]

Example: In the screenshot 99.3% of the packets are TCP but the sum of the subprotocols (TLS,
[Word Count: 17]

A single packet can contain the same protocol more than once. In this case, the entry in the PDUs
[Word Count: 19]

column will be greater than that of Packets. Example: In the screenshot there are many more TLS
[Word Count: 17]

A network conversation is the traffic between two specific endpoints. For example, an IP
[Word Count: 14]

conversation is all the traffic between two IP addresses. The description of the known endpoint
[Word Count: 15]

The conversations are influenced by the Deinterlacing conversations key preference.
[Word Count: 10]

The conversations window is similar to the endpoint Window. See The “Endpoints” Window for a
[Word Count: 15]

description of their common features. Along with addresses, packet counters, and byte counters the
[Word Count: 14]

conversation window adds four columns: the start time of the conversation (“Rel Start”) or (“Abs
[Word Count: 15]

Start”), the duration of the conversation in seconds, and the average bits (not bytes) per second in
[Word Count: 17]

each direction. A timeline graph is also drawn across the “Rel Start” / “Abs Start” and “Duration”
[Word Count: 17]

Each row in the list shows the statistical values for exactly one conversation.
[Word Count: 13]

Name resolution will be done if selected in the window and if it is active for the specific protocol
[Word Count: 19]

layer (MAC layer for the selected Ethernet endpoints page). Limit to display filter will only show
[Word Count: 16]

conversations matching the current display filter. Absolute start time switches the start time
[Word Count: 13]

column between relative (“Rel Start”) and absolute (“Abs Start”) times. Relative start times match
[Word Count: 14]

the “Seconds Since First Captured Packet” time display format in the packet list and absolute start
[Word Count: 16]

times match the “Time of Day” display format.
[Word Count: 8]

If a display filter had been applied before the dialog is opened, Limit to display filter will be set
[Word Count: 19]

automatically. Additionally, after a display filter had been applied, two columns ("Total Packets")
[Word Count: 13]

and ("Percent Filtered") show the number of unfiltered total packets and the percentage of packets
[Word Count: 15]

The [ Copy ] button will copy the list values to the clipboard in CSV (Comma Separated Values),
[Word Count: 18]

YAML format or JSON format. The numbers are generally exported without special formatting, but
[Word Count: 14]

The [ Follow Stream… ] button will show the stream contents as described in The “Follow TCP
[Word Count: 17]

Stream” dialog box dialog. The [ Graph… ] button will show a graph as described in The “I/O
[Word Count: 18]

[ Conversation Types ] lets you choose which traffic type tabs are shown. See Endpoints for a list of
[Word Count: 19]

endpoint types. The enabled types are saved in your profile settings.
[Word Count: 11]

TIP
This window will be updated frequently so it will be useful even if you open it before
[Word Count: 18]

(or while) you are doing a live capture.
[Word Count: 8]

A network endpoint is the logical endpoint of separate protocol traffic of a specific protocol layer.
[Word Count: 16]

The endpoint statistics of Wireshark will take the following endpoints into account:
[Word Count: 12]

TIP
If you are looking for a feature other network tools call a hostlist, here is the right
[Word Count: 18]

place to look. The list of Ethernet or IP endpoints is usually what you’re looking for.
[Word Count: 16]

Identical to the Ethernet device’s MAC-48 identifier.
[Word Count: 7]

A concatenation of a 32-bit network number and 48-bit node address, by default the Ethernet
[Word Count: 15]

A combination of various RSVP session attributes and IPv4 addresses.
[Word Count: 10]

A combination of the host IP addresses (plural) and the SCTP port used. So different SCTP ports
[Word Count: 17]

on the same IP address are different SCTP endpoints, but the same SCTP port on different IP
[Word Count: 17]

addresses of the same host are still the same endpoint.
[Word Count: 10]

A combination of the IP address and the TCP port used. Different TCP ports on the same IP
[Word Count: 18]

Identical to the Token Ring MAC-48 address.
[Word Count: 7]

A combination of the IP address and the UDP port used, so different UDP ports on the same IP
[Word Count: 19]

Broadcast and multicast traffic will be shown separately as additional endpoints. Of
[Word Count: 12]

course, as these aren’t physical endpoints the real traffic will be received by some
[Word Count: 14]

This window shows statistics about the endpoints captured.
[Word Count: 8]

For each supported protocol, a tab is shown in this window. Each tab label shows the number of
[Word Count: 18]

endpoints captured (e.g., the tab label “Ethernet · 4” tells you that four ethernet endpoints have
[Word Count: 16]

been captured). If no endpoints of a specific protocol were captured, the tab label will be greyed out
[Word Count: 18]

(although the related page can still be selected).
[Word Count: 8]

Each row in the list shows the statistical values for exactly one endpoint.
[Word Count: 13]

Name resolution will be done if selected in the window and if it is active for the specific protocol
[Word Count: 19]

layer (MAC layer for the selected Ethernet endpoints page). Limit to display filter will only show
[Word Count: 16]

conversations matching the current display filter. Note that in this example we have MaxMind DB
[Word Count: 15]

configured which gives us extra geographic columns. See MaxMind Database Paths for more
[Word Count: 13]

If a display filter had been applied before the dialog is opened, Limit to display filter will be set
[Word Count: 19]

automatically. Additionally, after a display filter had been applied, two columns ("Total Packets")
[Word Count: 13]

and ("Percent Filtered") show the number of unfiltered total packets and the percentage of packets
[Word Count: 15]

For IPv4 endpoints only, the Hide aggregated checkbox controls how the traffic identified from the
[Word Count: 15]

subnets file should be displayed. By default (not checked), the individual endpoints and the subnets
[Word Count: 15]

are both displayed, and when checked, only the aggregation is. The traffic which is not matching
[Word Count: 16]

any subnet is kept as it is. This checkbox is available only when the IPv4 user preference Aggregate
[Word Count: 18]

subnets in Statistics Dialogs is enabled. See Configuration Files for the subnets file description.
[Word Count: 14]

image::images/ws-stats-endpoints-ipv4aggregation.png[scaledwidth="85%"]
[Word Count: 1]

The [ Copy ] button will copy the list values to the clipboard in CSV (Comma Separated Values),
[Word Count: 18]

YAML format or JSON format. The numbers are generally exported without special formatting, but
[Word Count: 14]

this can be enabled if needed. The [ Map ] button will show the endpoints mapped in your web
[Word Count: 19]

[ Endpoint Types ] lets you choose which traffic type tabs are shown. See Endpoints above for a list
[Word Count: 19]

of endpoint types. The enabled types are saved in your profile settings.
[Word Count: 12]

TIP
This window will be updated frequently, so it will be useful even if you open it before
[Word Count: 18]

(or while) you are doing a live capture.
[Word Count: 8]

Shows the distribution of packet lengths and related information.
[Word Count: 9]

Information is broken down by packet length ranges as shown above.
[Word Count: 11]

Ranges can be configured in the “Statistics → Stats Tree” section of the Preferences Dialog.
[Word Count: 15]

The number of packets that fall into this range.
[Word Count: 9]

The arithmetic mean of the packet lengths in this range.
[Word Count: 10]

The minimum and maximum lengths in this range.
[Word Count: 8]

The average packets per millisecond for the packets in this range.
[Word Count: 11]

The percentage of packets in this range, by count.
[Word Count: 9]

Packet bursts are detected by counting the number of packets in a given time interval and
[Word Count: 16]

comparing that count to the intervals across a window of time. Statistics for the interval with the
[Word Count: 17]

maximum number of packets are shown. By default, bursts are detected across 5 millisecond
[Word Count: 14]

intervals and intervals are compared across 100 millisecond windows.
[Word Count: 9]

These calculations can be adjusted in the “Statistics” section of the Preferences Dialog.
[Word Count: 13]

The start time, in seconds from the beginning of the capture, for the interval with the maximum
[Word Count: 17]

You can show statistics for a portion of the capture by entering a display filter into the Display filter
[Word Count: 19]

[ Copy ] copies the statistics to the clipboard. [ Save as… ] lets you save the data as text, CSV, YAML,
[Word Count: 22]

Lets you plot packet and protocol data in a variety of ways.
[Word Count: 12]

As shown above, this window contains a chart drawing area along with a customizable list of
[Word Count: 16]

graphs. Graphs are saved in your current profile. They are divided into time intervals, which can be
[Word Count: 17]

set as described below. Hovering over the graph shows the last packet number of the selected graph
[Word Count: 17]

(or by default, the first enabled graph in the graphs list) in each interval except as noted below. If
[Word Count: 19]

the graph was customized, instead of the packet number it will show a value computed according to
[Word Count: 17]

the custom settings (ex: MAX,MIN,..). Clicking on the graph takes you to the associated packet in the
[Word Count: 17]

packet list. Individual graphs can be configured using the following options:
[Word Count: 11]

When checked and the “Y Axis” value is one of Packets/Bytes/Bits, the displayed value is an
[Word Count: 16]

average over time based on the Interval, instead of the raw value. The ordinary throughput is
[Word Count: 16]

Limits the graph to packets that match this filter.
[Word Count: 9]

The color to use for plotting the graph’s lines, bars, or points.
[Word Count: 12]

How to visually represent the graph’s data, e.g., by drawing a line, bar, circle, plus, etc.
[Word Count: 16]

The value to use for the graph’s Y axis. Can be one of:
[Word Count: 13]

The total number of packets, packet bytes, or packet bits that match the graph’s display filter
[Word Count: 16]

per interval. Zero values are omitted in some cases.
[Word Count: 9]

The sum of the values of the field specified in “Y Field” per interval.
[Word Count: 14]

The number of frames that contain the field specified in “Y Field” per interval.
[Word Count: 14]

The number of instances of the field specified in “Y Field” per interval. Some fields, such as
[Word Count: 17]

dns.resp.name, can show up multiple times in a packet.
[Word Count: 9]

MAX(Y Field), MIN(Y Field), AVG(Y Field)
[Word Count: 6]

The maximum, minimum, and arithmetic mean values of the specified “Y Field” per interval.
[Word Count: 14]

For MAX and MIN values, hovering and clicking the graph will show and take you to the
[Word Count: 17]

packet with the MAX or MIN value in the interval instead of the most recent packet.
[Word Count: 16]

The queue depth, i.e., number of concurrent requests or calls, in each interval expressed in
[Word Count: 15]

Erlangs. Requires “Y Field” be a relative time value, and treats it as the duration of an event
[Word Count: 18]

which ended in the containing packet. Useful for response time fields like smb.time.
[Word Count: 13]

If the “Y Field” is a payload (as frame.len, ip.len, ipv6.plen..), this is the computed throughput
[Word Count: 16]

based on this payload. The “Y Axis Factor” needs to be set accordingly to the payload unit to
[Word Count: 18]

have a value expressed in bits unit (ex: ip.len being expressed as Bytes, set Y Axis Factor to 8).
[Word Count: 19]

The display filter field from which to extract values for the Y axis calculations listed above.
[Word Count: 16]

Show a simple moving average of values over a specified period of intervals.
[Word Count: 13]

Scale the Y axis for this graph by multiplying by a constant factor, e.g. to graph bits if the “Y
[Word Count: 20]

Field” contains bytes, or to present multiple graphs at a similar scale.
[Word Count: 12]

The chart as a whole can be configured using the controls under the graph list:
[Word Count: 15]

Move the selected graph(s) up in the list.
[Word Count: 8]

Move the selected graph(s) down in the list.
[Word Count: 8]

When using the mouse inside the graph area, either drag the graph contents or select a zoom
[Word Count: 17]

Switch between showing the absolute time of day or the time relative from the start of capture
[Word Count: 17]

Switch between a logarithmic or linear Y axis.
[Word Count: 8]

The main dialog buttons along the bottom let you do the following:
[Word Count: 12]

[ Help ] will take you to this section of the User’s Guide.
[Word Count: 13]

[ Reset ] will autoscale the axes to full display all graphs.
[Word Count: 12]

[ Copy ] will copy values from selected graphs to the clipboard in CSV (Comma Separated Values)
[Word Count: 17]

[ Copy from ] will let you copy graphs from another profile to the current dialog.
[Word Count: 16]

[ Save As… ] will save the currently displayed graph as an image or CSV data.
[Word Count: 16]

TIP
You can see a list of useful keyboard shortcuts by right-clicking on the graph.
[Word Count: 15]

Wireshark’s I/O Graph window counts or calculates summary statistics over intervals. If a packet or
[Word Count: 15]

field does not occur in a given interval, the calculation might yield zero. This is particularly likely
[Word Count: 17]

for very small intervals. For "counting" graphs (Packets, Bytes, Bits, COUNT FRAMES, COUNT
[Word Count: 13]

FIELDS) zero values are omitted from scatter plots, but shown in line graphs and bar charts. For the
[Word Count: 18]

summary statistics SUM, MAX, and AVG, values are always omitted if the Y field was not present in
[Word Count: 18]

the interval. For LOAD graphs, values are omitted if no field’s time indicated that an event was was
[Word Count: 18]

present in the interval. (Note for LOAD graphs that a response time can contribute to earlier
[Word Count: 16]

intervals than the one containing the packet if the duration is longer than the interval.)
[Word Count: 15]

The service response time is the time between a request and the corresponding response. This
[Word Count: 15]

information is available for many protocols, including the following:
[Word Count: 9]

As an example, the SMB2 service response time is described below in more detail. The other Service
[Word Count: 17]

Response Time windows will show statistics specific to their respective protocols, but will offer the
[Word Count: 15]

The “SMB2 Service Response Time Statistics” Window
[Word Count: 7]

This window shows the number of transactions for each SMB2 opcode present in the capture file
[Word Count: 16]

along with various response time statistics. Right-clicking on a row will let you apply or prepare
[Word Count: 16]

filters for, search for, or colorize a specific opcode. You can also copy all of the response time
[Word Count: 18]

information or save it in a variety of formats.
[Word Count: 9]

Figure 85. The “SMB2 Service Response Time Statistics” window
[Word Count: 9]

You can optionally apply a display filter in order to limit the statistics to a specific set of packets.
[Word Count: 19]

The main dialog buttons along the bottom let you do the following:
[Word Count: 12]

The [ Copy ] button will copy the response time information as text.
[Word Count: 13]

[ Save As… ] will save the response time information in various formats.
[Word Count: 13]

The Dynamic Host Configuration Protocol (DHCP) is an option of the Bootstrap Protocol (BOOTP). It
[Word Count: 15]

dynamically assigns IP addresses and other parameters to a DHCP client. The DHCP (BOOTP)
[Word Count: 14]

Statistics window displays a table over the number of occurrences of a DHCP message type. The
[Word Count: 16]

user can filter, copy or save the data into a file.
[Word Count: 11]

The NetPerfMeter Protocol (NPMP) is the control and data transfer protocol of NetPerfMeter, the
[Word Count: 14]

transport protocol performance testing tool. It transmits data streams over TCP, SCTP, UDP and
[Word Count: 14]

DCCP with given parameters, such as frame rate, frame size, saturated flows, etc.
[Word Count: 13]

• Observed number of messages and bytes per message type.
[Word Count: 10]

• The share of messages and bytes for each message type.
[Word Count: 11]

• See the first and last occurrence of each message type.
[Word Count: 11]

• See the interval between first and last occurrence of each message type (if there are at least 2
[Word Count: 19]

• See the message and byte rate within the interval for each message type (if there are at least 2
[Word Count: 20]

See NetPerfMeter – A TCP/MPTCP/UDP/SCTP/DCCP Network Performance Meter Tool and Section 6.3
[Word Count: 12]

of Evaluation and Optimisation of Multi-Path Transport using the Stream Control Transmission
[Word Count: 12]

Protocol for more details about NetPerfMeter and the NetPerfMeter Protocol.
[Word Count: 10]

Figure 86. NetPerfMeter Statistics window
[Word Count: 5]

Open Network Computing (ONC) Remote Procedure Call (RPC) uses TCP or UDP protocols to map a
[Word Count: 16]

program number to a specific port on a remote machine and call a required service at that port.
[Word Count: 18]

The ONC-RPC Programs window shows the description for captured program calls, such as program
[Word Count: 14]

name, its number, version, and other data.
[Word Count: 7]

The 29West technology now refers to Ultra-Low Latency Messaging (ULLM) technology. It allows
[Word Count: 13]

sending and receiving a high number of messages per second with microsecond delivery times for
[Word Count: 15]

The Topics submenu shows counters for:
• Advertisement by Topic
[Word Count: 10]

The Queues submenu shows counters for:
• Advertisement by Queue
[Word Count: 10]

The UIM submenu shows Streams:
Each stream is provided by Endpoints, Messages,
[Word Count: 12]

Bytes, and the First and Last Frame statistics.
[Word Count: 8]

The LBT-RM submenu
The LBT-RM Transport Statistics window shows
[Word Count: 9]

the Sources and Receivers sequence numbers
[Word Count: 6]

The LBT-RU submenu
The LBT-Ru Transport Statistics window shows
[Word Count: 9]

the Sources and Receivers sequence numbers
[Word Count: 6]

The Access Node Control Protocol (ANCP) is an TCP based protocol, which operates between an
[Word Count: 15]

Access Node and Network Access Server. The Wireshark ANCP dissector supports the listed below
[Word Count: 14]

• Topology Discovery Extensions, such as Port-Up and Port-Down Messages
[Word Count: 10]

• Operation And Maintenance (OAM) Extension, such as Port Management Message.
[Word Count: 11]

The ANCP window shows the related statistical data. The user can filter, copy or save the data into a
[Word Count: 19]

Building Automation and Control Networks (BACnet) is a communication protocol which provides
[Word Count: 12]

control for various building automated facilities, such as light control, fire alarm control, and
[Word Count: 14]

others. Wireshark provides the BACnet statistics which is a packet counter. You can sort packets by
[Word Count: 16]

instance ID, IP address, object type or service.
[Word Count: 8]

Collectd is a system statistics collection daemon. It collects various statistics from your system and
[Word Count: 15]

converts it for the network use. The Collectd statistics window shows counts for values, which split
[Word Count: 16]

into type, plugin, and host as well as total packets counter. You can filter, copy or save the data to a
[Word Count: 21]

The Domain Name System (DNS) associates different information, such as IP addresses, with
[Word Count: 13]

domain names. DNS returns different codes, request-response and counters for various
[Word Count: 11]

aggregations. The DNS statistics window enlists a total count of DNS messages, which are divided
[Word Count: 15]

into groups by request types (opcodes), response code (rcode), query type, and others.
[Word Count: 13]

You might find these statistics useful for quickly examining the health of a DNS service or other
[Word Count: 17]

investigations. See the few possible scenarios below:
[Word Count: 7]

• The DNS server might have issues if you see that DNS queries have a long request-response time
[Word Count: 18]

or, if there are too many unanswered queries.
[Word Count: 8]

• DNS requests with abnormally large requests and responses might be indicative of DNS
[Word Count: 14]

tunneling or command and control traffic.
[Word Count: 6]

• The order of magnitude more DNS responses than requests and the responses are very large
[Word Count: 16]

might indicate that the target is being attacked with a DNS-based DDoS.
[Word Count: 12]

You can filter, copy or save the data into a file.
[Word Count: 11]

The Flow Graph window shows connections between hosts. It displays the packet time, direction,
[Word Count: 14]

ports and comments for each captured connection. You can filter all connections by ICMP Flows,
[Word Count: 15]

ICMPv6 Flows, UIM Flows and TCP Flows. Flow Graph window is used for showing multiple
[Word Count: 15]

different topics. Based on it, it offers different controls.
[Word Count: 9]

Each vertical line represents the specific host, which you can see in the top of the window.
[Word Count: 17]

The numbers in each row at the very left of the window represent the time packet. You can change
[Word Count: 19]

the time format in the View › Time Display Format. If you change the time format, you must
[Word Count: 18]

relaunch the Flow Graph window to observe the time in a new format.
[Word Count: 13]

The numbers at the both ends of each arrow between hosts represent the port numbers.
[Word Count: 15]

Left-click a row to select a corresponding packet in the packet list.
[Word Count: 12]

Right-click on the graph for additional options, such as selecting the previous, current, or next
[Word Count: 15]

packet in the packet list. This menu also contains shortcuts for moving the diagram.
[Word Count: 14]

• [ Limit to display filter ] filters calls just to ones matching display filter. When display filter is
[Word Count: 19]

active before window is opened, checkbox is checked.
[Word Count: 8]

• [ Flow type ] allows limit type of protocol flows should be based on.
[Word Count: 15]

• [ Addresses ] allows switch shown addresses in diagram.
[Word Count: 10]

• [ Reset Diagram ] resets view position and zoom to default state.
[Word Count: 13]

• [ Export ] allows export diagram as image in multiple different formats (PDF, PNG, BMP, JPEG
[Word Count: 17]

and ASCII (diagram is stored with ASCII characters only)).
[Word Count: 9]

Figure 89. Flow Graph window showing VoIP call sequences
[Word Count: 9]

Additional shortcuts available for VoIP calls:
[Word Count: 6]

◦S  - Selects the stream in RTP Streams window (if not opened, it opens it and put it on
[Word Count: 19]

◦D  - Deselects the stream in RTP Streams window (if not opened, it opens it and put it on
[Word Count: 19]

Additional controls available for VoIP calls:
[Word Count: 6]

• [ Reset Diagram ] resets view position and zoom to default state.
[Word Count: 13]

• [ Play Streams ] sends selected RTP stream to playlist of RTP Player window.
[Word Count: 15]

• [ Export ] allows to export diagram as image in multiple different formats (PDF, PNG, BMP, JPEG
[Word Count: 18]

and ASCII (diagram is stored with ASCII characters only)).
[Word Count: 9]

Highway Addressable Remote Transducer over IP (HART-IP) is an application layer protocol. It
[Word Count: 13]

sends and receives digital information between smart devices and control or monitoring systems.
[Word Count: 13]

The HART-IP statistics window shows the counter for response, request, publish and error packets.
[Word Count: 14]

You can filter, copy or save the data to a file.
[Word Count: 11]

Hpfeeds protocol provides a lightweight authenticated publishing and subscription. It supports
[Word Count: 11]

arbitrary binary payloads which can be separated into different channels. HPFEEDS statistics
[Word Count: 12]

window shows a counter for payload size per channel and opcodes. You can filter, copy or save the
[Word Count: 18]

Statistics for HTTP request types and response codes.
[Word Count: 8]

HTTP statistics based on the host and URI.
[Word Count: 8]

HTTP request and response statistics based on the server address and host.
[Word Count: 12]

HTTP Request Sequences uses HTTP’s Referer and Location headers to sequence a capture’s HTTP
[Word Count: 14]

requests as a tree. This enables analysts to see how one HTTP request leads to the next.
[Word Count: 17]

Figure 90. The “HTTP Request Sequences” window
[Word Count: 7]

Hypertext Transfer Protocol version 2 (HTTP/2) allows multiplexing various HTTP requests and
[Word Count: 12]

responses over a single connection. It uses a binary encoding which is consisting of frames. The
[Word Count: 16]

HTTP/2 statistics window shows the total number of HTTP/2 frames and also provides a breakdown
[Word Count: 15]

per frame types, such as HEADERS, DATA, and others.
[Word Count: 9]

As HTTP/2 traffic is typically encrypted with TLS, you must configure decryption to observe HTTP/2
[Word Count: 15]

traffic. For more details, see the TLS wiki page.
[Word Count: 9]

Sametime is a protocol for the IBM Sametime software. The Sametime statistics window shows the
[Word Count: 15]

counter for message type, send type, and user status.
[Word Count: 9]

Show different visual representations of the TCP streams in a capture.
[Word Count: 11]

This is a simple graph of the TCP sequence number over time, similar to the ones used in
[Word Count: 18]

Richard Stevens’ “TCP/IP Illustrated” series of books.
[Word Count: 7]

Shows 
TCP 
metrics 
similar 
to 
the 
tcptrace 
utility, 
including 
forward 
segments,
[Word Count: 11]

acknowledgements, selective acknowledgements, reverse window sizes, and zero windows.
[Word Count: 9]

Round trip time vs time or sequence number. RTT is based on the acknowledgment timestamp
[Word Count: 15]

The UDP Multicast Streams window shows statistics for all UDP multicast streams. It includes
[Word Count: 14]

source addresses and ports, destination addresses and ports, packets counter and other data. You
[Word Count: 14]

can specify the burst interval, the alarm limits and output speeds. To apply new settings, press
[Word Count: 16]

• Measure the burst size for a video stream. This uses the sliding window algorithm.
[Word Count: 15]

• Measure of the output buffer size limit, that no packet drop will occur. This uses the Leaky
[Word Count: 18]

• Detect the packet loss inside the MPEG2 video stream.
[Word Count: 10]

The Reliable Server Pooling (RSerPool) windows show statistics for the different protocols of
[Word Count: 13]

• Aggregate Server Access Protocol (ASAP)
[Word Count: 6]

• Endpoint Handlespace Redundancy Protocol (ENRP)
[Word Count: 6]

Furthermore, statistics for application protocols provided by RSPLIB are provided as well:
[Word Count: 12]

• Observed number of messages and bytes per message type.
[Word Count: 10]

• The share of messages and bytes for each message type.
[Word Count: 11]

• See the first and last occurrence of each message type.
[Word Count: 11]

• See the interval between first and last occurrence of each message type (if there are at least 2
[Word Count: 19]

• See the message and byte rate within the interval for each message type (if there are at least 2
[Word Count: 20]

See Thomas Dreibholz’s Reliable Server Pooling (RSerPool) Page and Chapter 3 of Reliable Server
[Word Count: 14]

Pooling – Evaluation, Optimization and Extension of a Novel IETF Architecture for more details
[Word Count: 14]

Figure 94. Component Status Protocol Statistics window
[Word Count: 7]

Figure 95. CalcApp Protocol Statistics window
[Word Count: 6]

Figure 96. Fractal Generator Protocol Statistics window
[Word Count: 7]

Figure 97. Ping Pong Protocol Statistics window
[Word Count: 7]

Figure 98. Scripting Service Protocol Statistics window
[Word Count: 7]

In F5 Networks, TMM stands for Traffic Management Microkernel. It processes all load-balanced
[Word Count: 13]

The F5 statistics menu shows packet and byte counts for both Virtual Server Distribution and tmm
[Word Count: 16]

Each Virtual Server Distribution window contains the statistics for the following data:
[Word Count: 12]

• A line for each named virtual server name.
[Word Count: 9]

• A line for traffic with a flow ID and no virtual server name.
[Word Count: 14]

Each tmm Distribution window contains the statistics for the following data:
[Word Count: 11]

◦A line for each ingress and egress (should add to tmm total), which contains:
[Word Count: 14]

▪Traffic with a flow ID and no virtual server name.
[Word Count: 10]

Internet Protocol version 4 (IPv4) is a core protocol for the internet layer. It uses 32-bit addresses
[Word Count: 17]

and allows packets routing from one source host to the next one.
[Word Count: 12]

The Statistics › IPv4 menu provides the packet counter by submenus:
[Word Count: 11]

• All Addresses. Divides data by IP address.
[Word Count: 8]

• Destination and Ports. Divides data by IP address, and further by IP protocol type, such as TCP,
[Word Count: 18]

UDP, and others. It also shows port number.
[Word Count: 8]

• IP Protocol Types. Divides data by IP protocol type.
[Word Count: 10]

• Source TTLs. Divides data by source IP address and then by TTL. Also shows the destination IP
[Word Count: 18]

• Source and Destination addresses. Divides data by source and destination IP address.
[Word Count: 13]

You can see similar statistics in the Statistics › Conversations and Statistics › Endpoints menus.
[Word Count: 15]

Internet Protocol version 6 (IPv6) is a core protocol for the internet layer. It uses 128-bit addresses
[Word Count: 17]

and routes internet traffic. Similar to IPv4 Statistics, the Statistics › IPv6 menu shows the packet
[Word Count: 16]

Wireshark provides a wide range of telephony related network statistics which can be accessed via
[Word Count: 15]

These statistics range from specific signaling protocols, to analysis of signaling and media flows. If
[Word Count: 15]

encoded in a compatible encoding the media flow can even be played.
[Word Count: 12]

The protocol specific statistics windows display detailed information of specific protocols and might
[Word Count: 13]

be described in a later version of this document.
[Word Count: 9]

Some of these statistics are described at the https://wiki.wireshark.org/Statistics pages.
[Word Count: 10]

The tool for playing VoIP calls is called RTP Player. It shows RTP streams and its waveforms, allows
[Word Count: 18]

play stream and export it as audio or payload to file. Its capabilities depend on supported codecs.
[Word Count: 17]

RTP Player is able to play any codec supported by an installed plugin. The codecs supported by RTP
[Word Count: 18]

Player depend on the version of Wireshark you’re using. The official builds contain all of the
[Word Count: 16]

plugins maintained by the Wireshark developers, but custom/distribution builds might not include
[Word Count: 12]

some of those codecs. To check your Wireshark installation’s installed codec plugins, do the
[Word Count: 14]

• In the Filter by type menu on the top-right, select codec
[Word Count: 12]

Wireshark can be used for RTP stream analysis. User can select one or more streams which can be
[Word Count: 18]

played later. RTP Player window maintains playlist (list of RTP streams) for this purpose.
[Word Count: 14]

Playlist is created empty when RTP Player window is opened and destroyed when window is closed.
[Word Count: 16]

RTP Player window can be opened on background when not needed and put to front later. During
[Word Count: 17]

When RTP Player window is opened, playlist can be modified from other tools (Wireshark
[Word Count: 14]

• button Play Streams › Set playlist clears existing playlist and adds streams selected in the tool.
[Word Count: 17]

• button Play Streams › Add to playlist adds streams selected in the tool to playlist. Duplicated
[Word Count: 17]

• button Play Streams › Remove from playlist removes streams selected in the tool from
[Word Count: 15]

Figure 100. [ Play Streams ] button with opened action menu
[Word Count: 11]

[ Play Streams ] button can be clicked directly and opens RTP Player window directly with [ Set
[Word Count: 18]

playlist ] action. All actions can be selected with the small down arrow next to the button.
[Word Count: 17]

When the playlist is empty, there is no difference between [ Set playlist ] and [ Add to playlist ].
[Word Count: 20]

When the RTP Player window is not opened, all three actions above open it.
[Word Count: 14]

[ Remove from playlist ] is useful e.g. in case user selected all RTP streams and wants to remove
[Word Count: 19]

RTP streams from specific calls found with VoIPCalls.
[Word Count: 8]

Tools below can be used to maintain content of playlist, they contain [ Play Streams ] button. You
[Word Count: 18]

can use one of procedures (Note: [ Add to playlist ] action is demonstrated):
[Word Count: 14]

• Open Telephony › RTP › RTP Streams window, it will show all streams in the capture. Select
[Word Count: 18]

one or more streams and then press [ Play Streams ]. Selected streams are added to playlist.
[Word Count: 17]

• Select any RTP packet in packet list, open Telephony › RTP › Stream Analysis window. It will
[Word Count: 18]

show analysis of selected forward stream and its reverse stream (if [ Ctrl ] is pressed during
[Word Count: 17]

window opening). Then press [ Play Streams ]. Forward and reverse stream is added to playlist.
[Word Count: 16]

◦RTP Stream Analysis window can be opened from other tools too.
[Word Count: 11]

• Open Telephony › VoIP Calls or Telephony › SIP Flows window, it will show all calls. Select one
[Word Count: 19]

or more calls and then press [ Play Streams ]. It will add all RTP streams related to selected calls
[Word Count: 20]

• Open [ Flow Sequence ] window in Telephony › VoIP Calls or Telephony › SIP Flows window,
[Word Count: 18]

it will show flow sequence of calls. Select any RTP stream and then press [ Play Streams ]. It will
[Word Count: 20]

Figure 101. Tools for modifying playlist in RTP Player window
[Word Count: 10]

Same approach with set/add/remove actions is used for RTP Stream Analysis
[Word Count: 11]

window. The playlist is there handled as different tabs in the window, see RTP
[Word Count: 14]

Decoding RTP payload and showing waveforms is time consuming task. To speedup it RTP Player
[Word Count: 15]

window uses copy of packet payload for all streams in the playlist. During live capture the dialog is
[Word Count: 18]

not refreshed automatically as other Wireshark dialogs, but user must initiate it.
[Word Count: 12]

The copy is created or refreshed and dialog updated:
[Word Count: 9]

• Every time a new stream is added or set.
[Word Count: 10]

• During live capture, when [ Refresh streams ] is pressed.
[Word Count: 11]

• Every time live capture is finished/stopped by a user.
[Word Count: 10]

When capture file is opened (no live capturing), streams are read complete, no user action is
[Word Count: 16]

required. Button [ Refresh streams ] is disabled as it is useless.
[Word Count: 12]

When live capture is running, streams are read only till "now" and are shown. When stream is
[Word Count: 17]

continuous and user would like to see additional part, they must press [ Refresh stream ]. When
[Word Count: 17]

the user ends live capture, view is refreshed and button is disabled.
[Word Count: 12]

RTP Player dialog stays open even live capture is stopped and then started again.
[Word Count: 14]

Play list stays unchanged. Therefore, [ Refresh stream ] tries to read same streams
[Word Count: 14]

as before and shows them if they are still running. Past part of them (from previous
[Word Count: 16]

RTP is carried usually in UDP packets with random source and destination ports. Therefore,
[Word Count: 14]

Wireshark can only recognize RTP streams based on VoIP signaling, e.g., based on SDP messages in
[Word Count: 16]

SIP signaling. If signaling is not captured, Wireshark shows just UDP packets. However, there are
[Word Count: 15]

multiple settings which help Wireshark recognize RTP even when there is no related signaling.
[Word Count: 14]

You can use Decode As… function from Analyze › Decode As… menu or in mouse context menu.
[Word Count: 17]

Here you can set that traffic on specific source or destination should be decoded as RTP. You can
[Word Count: 18]

Use of Decode As… menu works fine, but is arduous for many streams.
[Word Count: 13]

You can enable heuristic dissector rtp_udp in Analyze › Enabled Protocols…. See Control Protocol
[Word Count: 14]

Dissection for details. Once rtp_udp is enabled, Wireshark tries to decode every UDP packet as RTP.
[Word Count: 16]

If decoding is possible, packet (and entire UDP stream) is decoded as RTP.
[Word Count: 13]

When an RTP stream uses a well-known port, the heuristic dissector ignores it. So you might miss
[Word Count: 17]

some RTP streams. You can enable setting for udp protocol Preferences › Protocols › udp › Try
[Word Count: 17]

heuristic sub-dissectors first, see Preferences. In this case heuristics dissector tries to decode UDP
[Word Count: 14]

NOTE
Take into account that heuristics is just simple "test" whether packet can be read as
[Word Count: 16]

RTP. It can be false positive and you can see decoded as RTP more UDP packets than
[Word Count: 17]

When you enable udp › Try heuristic sub-dissectors first, it increases possibility
[Word Count: 12]

of false positives. If you capture all traffic in network, false positives rate can be
[Word Count: 15]

RTP Player must store decoded data somewhere to be able to play it. When data are decoded, there
[Word Count: 18]

are audio samples and dictionary for fast navigation. Both types of data are stored in memory for
[Word Count: 17]

default, but you can configure Wireshark to store it on disk. There are two settings:
[Word Count: 15]

• ui.rtp_player_use_disk1 - When set to FALSE (default), audio samples are kept in memory. When
[Word Count: 15]

set to TRUE, audio samples are stored on temporary file.
[Word Count: 10]

• ui.rtp_player_use_disk2 - When set to FALSE (default), dictionary is kept in memory. When set to
[Word Count: 16]

TRUE, dictionary is stored on temporary file.
[Word Count: 7]

When any data are configured to be stored on disk, one file is created for each stream. Therefore,
[Word Count: 18]

there might be up to two files for one RTP stream (audio samples and dictionary). If your OS or user
[Word Count: 20]

has OS enforced limit for count of opened files (most of Unix/Linux systems), you can see fewer
[Word Count: 17]

streams that was added to playlist. Warnings are printed on console in this case and you will see
[Word Count: 18]

fewer streams in the playlist than you send to it from other tools.
[Word Count: 13]

For common use you can use default settings - store everything in memory. When you will be out of
[Word Count: 19]

memory, switch ui.rtp_player_use_disk1 to TRUE first - it saves much more memory than
[Word Count: 13]

VoIP Processing Performance and Related Limits
[Word Count: 6]

Processing of RTP and decoding RTP voice takes resources. There are raw estimates you can use as
[Word Count: 17]

RTP Streams window can show as many streams as found in the capture. Its performance is limited
[Word Count: 17]

RTP Player can handle 1000+ streams, but take into account that waveforms are very small and
[Word Count: 16]

RTP Player plays audio by OS sound system and OS is responsible for mixing audio when multiple
[Word Count: 17]

streams are played. In many cases OS sound system has limited count of mixed streams it can
[Word Count: 17]

play/mix. RTP Player tries to handle playback failures and show warning. If it happens, just mute
[Word Count: 16]

RTP Analysis window can handle 1000+ streams, but it is difficult to use it with so many streams - it
[Word Count: 20]

is difficult to navigate between them. It is expected that RTP Analysis window will be used for
[Word Count: 17]

The VoIP Calls window shows a list of all detected VoIP calls in the captured traffic. It finds calls by
[Word Count: 20]

their signaling and shows related RTP streams. The current VoIP supported protocols are:
[Word Count: 13]

See VOIPProtocolFamily for an overview of the used VoIP protocols.
[Word Count: 10]

VoIP Calls window can be opened as window showing all protocol types (Telephony › VoIP Calls
[Word Count: 16]

window) or limited to SIP messages only (Telephony › SIP Flows window).
[Word Count: 12]

◦Note: Common Mouse click
 
, Shift  +  Mouse click
 
 and Ctrl  +  Mouse click
 
 works too
[Word Count: 16]

◦S  - Selects stream/streams related to call in RTP Streams window (if not opened, it opens it
[Word Count: 17]

◦D  - Deselects stream/streams related to call in RTP Streams window (if not opened, it opens it
[Word Count: 17]

• [ Limit to display filter ] filters calls just to ones matching display filter. When display filter is
[Word Count: 19]

active before window is opened, checkbox is checked.
[Word Count: 8]

• [ Time of Day ] switches format of shown time between relative to start of capture or absolute
[Word Count: 19]

• [ Flow Sequence ] opens Flow Sequence window and shows selected calls in it.
[Word Count: 15]

• [ Prepare Filter ] generates display filter matching to selected calls (signaling and RTP streams)
[Word Count: 16]

• [ Play Streams ] opens RTP Player window. Actions [ Set ], [ Add ] and [ Remove ] are available.
[Word Count: 22]

• [ Copy ] copies information from table to clipboard in CSV or YAML.
[Word Count: 14]

This menu shows groups of statistic data for mobile communication protocols according to ETSI
[Word Count: 14]

The A-Interface Base Station Management Application Part (BSMAP) Statistics window shows the
[Word Count: 12]

messages list and the number of the captured messages. There is a possibility to filter the messages,
[Word Count: 17]

The A-Interface Direct Transfer Application Part (DTAP) Statistics widow shows the messages list
[Word Count: 13]

and the number of the captured messages. There is a possibility to filter the messages, copy or save
[Word Count: 18]

The Global System for Mobile Communications (GSM) is a standard for mobile networks. This menu
[Word Count: 15]

shows a group of statistic data for mobile communication protocols according to ETSI GSM
[Word Count: 14]

The “IAX2 Stream Analysis” window shows statistics for the forward and reverse streams of a
[Word Count: 15]

Integrated Service User Part (ISUP) protocol provides voice and non-voice signaling for telephone
[Word Count: 13]

communications. ISUP Messages menu opens the window which shows the related statistics. The
[Word Count: 13]

user can filter, copy or save the data into a file.
[Word Count: 11]

Statistics of the captured LTE or NR MAC traffic. This window will summarize the MAC traffic found
[Word Count: 17]

Figure 103. The “3GPP MAC Traffic Statistics” window
[Word Count: 8]

Each row in the top pane shows statistical highlights for exactly one UE/C-RNTI. Opening a UE item
[Word Count: 17]

shows details of each logical channel identifier of that UE.
[Word Count: 10]

The bottom pane shows statistics for common channels, and controls to apply more detailed display
[Word Count: 15]

The RLC Graph menu launches a graph which shows LTE/NR Radio Link Control protocol sequence
[Word Count: 15]

numbers changing over time along with (for AM) acknowledgements received in the opposite
[Word Count: 13]

NOTE
That graph shows data of a single bearer and direction. This graph may also be
[Word Count: 16]

launched from the RLC Statistics window.
[Word Count: 6]

The image of the RLC Graph is borrowed from the Wireshark wiki.
[Word Count: 12]

Statistics of the captured LTE/NR RLC traffic. This window will summarize the RLC traffic found in
[Word Count: 16]

Figure 105. The “LTE RLC Traffic Statistics” window
[Word Count: 8]

A check-box controls whether this window should include RLC PDUs logged within MAC PDUs or
[Word Count: 15]

not. This will affect both the PDUs counted as well as the display filters generated (see below).
[Word Count: 17]

The upper list shows summaries of each active UE. Opening up a UE entry will show the same
[Word Count: 18]

information broken down by individual bearers.
[Word Count: 6]

The lower part of the windows allows display filters to be generated and set for the selected
[Word Count: 17]

bearer/channel. Note that in the case of Acknowledged Mode channels, if a single direction is
[Word Count: 15]

chosen, the generated filter will show data in that direction and control PDUs in the opposite
[Word Count: 16]

The Message Transfer Part level 3 (MTP3) protocol is a part of the Signaling System 7 (SS7). The
[Word Count: 18]

Public Switched Telephone Networks use it for reliable, unduplicated and in-sequence transport of
[Word Count: 13]

SS7 messaging between communication partners.
[Word Count: 5]

This menu shows MTP3 Statistics and MTP3 Summary windows.
[Word Count: 9]

OSmux is a multiplex protocol designed to reduce bandwidth usage of satellite-based GSM systems’s
[Word Count: 14]

voice (RTP-AMR) and signaling traffic. The OSmux menu opens the packet counter window with the
[Word Count: 15]

related statistic data. The user can filter, copy or save the data into a file.
[Word Count: 15]

The RTP streams window shows all RTP streams in capture file. Streams can be selected there and
[Word Count: 17]

on selected streams other tools can be initiated.
[Word Count: 8]

◦Note: Common Mouse click
 
, Shift  +  Mouse click
 
 and Ctrl  +  Mouse click
 
 works too
[Word Count: 16]

◦R  - Try search for reverse streams related to already selected streams. If found, selects them
[Word Count: 16]

◦[ Shift+R ] - Select all pair streams (forward/reverse relation).
[Word Count: 10]

◦[ Ctrl+R ] - Select all single streams (no reverse stream does exist).
[Word Count: 13]

• G  - Go to packet of stream under the mouse cursor.
[Word Count: 12]

• M  - Mark all packets of selected streams.
[Word Count: 9]

• P  - Prepare filter matching selected streams and apply it.
[Word Count: 11]

• E  - Export selected streams in RTPDump format.
[Word Count: 9]

• A  - Open RTP Stream Analysis window and add selected streams to it.
[Word Count: 14]

◦[ Find Reverse ] search for reverse stream of every selected stream. If found, selects it in the
[Word Count: 18]

◦[ Find All Pairs ] select all streams which have forward/reverse relation.
[Word Count: 12]

◦[ Find Only Single ] select all streams which are single - have no reverse stream.
[Word Count: 16]

• [ Analyze ] opens RTP Stream Analysis window. Actions [ Set ], [ Add ] and [ Remove ] are
[Word Count: 21]

• [ Prepare Filter ] prepares filter matching selected streams and apply it.
[Word Count: 13]

• [ Play Streams ] opens RTP Player window. Actions [ Set ], [ Add ] and [ Remove ] are available.
[Word Count: 22]

• [ Copy ] copies information from table to clipboard in CSV or YAML.
[Word Count: 14]

• [ Export ] exports selected streams in RTPDump format.
[Word Count: 10]

The RTP analysis function takes the selected RTP streams and generates a list of statistics on them
[Word Count: 17]

The Telephony › RTP › RTP Stream Analysis menu item is enabled only when the selected packet
[Word Count: 17]

is an RTP packet. When the action is selected, the RTP Stream Analysis window is opened (if not
[Word Count: 18]

already) and the RTP stream of the current packet is added for analysis. If [ Ctrl ] is pressed when
[Word Count: 20]

selecting the menu item, other RTP streams on the same addresses and ports (in both forward and
[Word Count: 17]

reverse direction) are scanned for and added to the window too if found.
[Word Count: 13]

Every stream is shown on its own tab. Tabs are numbered as streams are added and each tooltip
[Word Count: 18]

shows the identification of the stream. When a tab is closed, its number is not reused. The tab color
[Word Count: 19]

matches the color of the corresponding graph on the graph tab.
[Word Count: 11]

Figure 107. The “RTP Stream Analysis” window
[Word Count: 7]

Figure 108. Error indicated in “RTP Stream Analysis” window
[Word Count: 9]

• Marker - packet is marked in RTP header
[Word Count: 9]

• Status - information related to the packet. E. g. change of codec, DTMF number, warning about
[Word Count: 17]

Side panel left to packet list shows stream statistics:
[Word Count: 9]

• Maximal delta and at which packet it occurred
[Word Count: 9]

• Count of lost packets - calculated from sequence numbers
[Word Count: 10]

• When the stream starts and first packet number
[Word Count: 9]

NOTE
Some statistic columns are calculated only when Wireshark is able to decode codec
[Word Count: 14]

• G  - Go to selected packet of stream in packet list
[Word Count: 12]

◦[ Current Tab ] prepares filter matching current tab and applies it.
[Word Count: 12]

◦[ All Tabs ] prepares filter matching all tabs and applies it.
[Word Count: 12]

• [ Play Streams ] opens RTP Player window. Actions [ Set ], [ Add ] and [ Remove ] are available.
[Word Count: 22]

• [ Export ] allows export current stream or all streams as CSV or export graph as image in
[Word Count: 19]

multiple different formats (PDF, PNG, BMP and JPEG).
[Word Count: 8]

Figure 109. Graph in “RTP Stream Analysis” window
[Word Count: 8]

• difference - absolute value of difference between expected and real time of packet arrival
[Word Count: 15]

• delta - time difference from reception of previous packet
[Word Count: 10]

for every stream. Checkboxes below graph are enabling or disabling showing of a graph for every
[Word Count: 16]

stream. [ Stream X ] checkbox enables or disables all graphs for the stream.
[Word Count: 14]

Stream Analysis window contained tool for save audio and payload for analyzed
[Word Count: 12]

streams. This tool was moved in Wireshark 3.5.0 to RTP Player window. New tool
[Word Count: 14]

The RTP Player function is a tool for playing VoIP calls. It shows RTP streams and their waveforms,
[Word Count: 18]

and can play the streams and export them to file as audio or raw payload. See related concepts in
[Word Count: 19]

The Telephony › RTP › RTP Player menu item is enabled only when the selected packet is an RTP
[Word Count: 19]

packet. When the action is selected, the RTP Player window is opened (if not already) and the RTP
[Word Count: 18]

stream of the current packet is added to the playlist. If [ Ctrl ] is pressed when selecting the menu
[Word Count: 20]

item, other RTP streams on the same addresses and ports (in both forward and reverse direction)
[Word Count: 16]

are scanned for and added to the playlist too if found.
[Word Count: 11]

RTP Player Window consists of three parts:
[Word Count: 7]

Waveform view shows visual presentation of RTP stream. Color of waveform and playlist row are
[Word Count: 15]

Waveform shows error marks for Out of Sequence, Jitter Drops, Wrong Timestamps and Inserted
[Word Count: 14]

Silence marks if it happens in a stream.
[Word Count: 8]

Playlist shows information about every stream:
[Word Count: 6]

• Source Address, Source Port, Destination Address, Destination Port, SSRC
[Word Count: 10]

◦SETUP <number> is shown, when there is known signaling packet. Number is packet
[Word Count: 13]

number of signaling packet. Note: Word SETUP is shown even RTP stream was initiated e. g.
[Word Count: 16]

by SKINNY where no SETUP message exists.
[Word Count: 7]

◦RTP <number> is shown, when no related signaling was found. Number is packet number of
[Word Count: 15]

• Packets - Count of packets in the stream.
[Word Count: 9]

• Time Span - Start - Stop (Duration) of the stream
[Word Count: 11]

• PR - Decoded play rate used for stream playing
[Word Count: 10]

• Payloads - One or more payload types used by the stream
[Word Count: 12]

When rtp_udp is active, most of streams shows just RTP <number> even there is
[Word Count: 14]

When RTP stream contains multiple codecs, SR and PR is based on first observed
[Word Count: 14]

coded. Later codecs in stream are resampled to first one.
[Word Count: 10]

• [ Start ]/[ Pause ]/[ Stop ] playing of unmuted streams
[Word Count: 12]

• [ >> ] enabling/disabling silence skipping
[Word Count: 7]

◦Min silence - Minimal duration of silence to skip in seconds. Shorter silence is played as it is.
[Word Count: 18]

• Select [ Output audio device ] and [ Output audio rate ]
[Word Count: 13]

◦Jitter Buffer - Packets outside [ Jitter Buffer ] size are discarded during decoding
[Word Count: 14]

◦RTP Timestamp - Packets are ordered and played by its Timestamp, no Jitter Buffer is used
[Word Count: 16]

◦Uninterrupted Mode - All gaps (e. g. Comfort Noise, lost packets) are discarded therefore
[Word Count: 14]

• [ Time of Day ] selects whether waveform timescale is shown in seconds from start of capture
[Word Count: 18]

• [ Refresh streams ] refreshes streams during live capture (see Playing audio during live
[Word Count: 15]

capture). Button is disabled when no live capture is running.
[Word Count: 10]

◦[ Select ] select all inaudible streams (streams with zero play rate)
[Word Count: 12]

◦[ Deselect ] deselect all inaudible streams (streams with zero play rate)
[Word Count: 12]

• [ Analyze ] open RTP Stream Analysis window. Actions [ Set ], [ Add ] and [ Remove ] are
[Word Count: 21]

• [ Prepare Filter ] prepare filter matching selected streams and apply it.
[Word Count: 13]

NOTE
RTP Player detects silence just by missing voice samples (Comfort Noise, interrupted
[Word Count: 13]

RTP, missing RTP, …) or when some streams are muted.
[Word Count: 10]

Waveform view and playlist shows state of a RTP stream:
[Word Count: 10]

1. stream is muted (dashed waveform, Muted is shown in Play column) or unmuted (non-dashed
[Word Count: 15]

waveform, audio routing is shown in Play column)
[Word Count: 8]

2. stream is selected (blue waveform, blue row)
[Word Count: 8]

3. stream is below mouse cursor (bold waveform, bold font)
[Word Count: 10]

User can control to where audio of a stream is routed to:
[Word Count: 12]

• P - Play (when mono soundcard is available only)
[Word Count: 10]

Audio routing can be changed by double-clicking on first column of a row, by shortcut or by menu.
[Word Count: 18]

◦Note: Common Mouse click
 
, Shift  +  Mouse click
 
 and Ctrl  +  Mouse click
 
 works too
[Word Count: 16]

◦G  - Go to packet of stream under the mouse cursor
[Word Count: 11]

◦Shift  +  G  - Go to setup packet of stream under the mouse cursor
[Word Count: 14]

◦Shift  +  M  - Unmute all selected streams
[Word Count: 8]

◦Ctrl  +  M  - Invert muting of all selected streams
[Word Count: 10]

• Del  or Ctrl  +  X  - Remove all selected streams from playlist
[Word Count: 13]

◦Shift  +  N  - Deselect all inaudible streams
[Word Count: 8]

Export was moved from RTP Stream Analysis window to RTP Player window in
[Word Count: 13]

Wireshark is able to export decoded audio in .au or .wav file format. Prior to
[Word Count: 15]

version 3.2.0, Wireshark only supported exporting audio using the G.711 codec.
[Word Count: 11]

From 3.2.0 it supports audio export using any codec with 8000 Hz sampling. From
[Word Count: 14]

3.5.0 is supported export of any codec, rate is defined by Output Audio Rate.
[Word Count: 14]

• for one or more selected non-muted streams
[Word Count: 8]

◦From cursor - Streams are saved from play start cursor. If some streams are shorter, they
[Word Count: 16]

are removed from the list before save and count of saved streams is lower than count of
[Word Count: 17]

◦Stream Synchronized Audio - File starts at the begin of earliest stream in export, therefore
[Word Count: 15]

there is no silence at beginning of exported file.
[Word Count: 9]

◦File Synchronized Audio - Streams starts at beginning of file, therefore silence can be at start
[Word Count: 16]

◦Payload - just payload with no information about coded is stored in the file
[Word Count: 14]

Audio is exported as multi-channel file - one channel per RTP stream. One or two channels are
[Word Count: 17]

equal to mono or stereo, but Wireshark can export e.g., 100 channels. For playing a tool with multi-
[Word Count: 18]

channel support must be used (e.g., https://www.audacityteam.org/).
[Word Count: 7]

Export of payload function is useful for codecs not supported by Wireshark.
[Word Count: 12]

Default value of [ Output Audio Rate ] is [ Automatic ]. When multiple codecs with
[Word Count: 16]

different codec rates are captured, Wireshark decodes each stream with its own
[Word Count: 12]

play audio rate. Therefore, each stream can have a different audio rate. If you
[Word Count: 14]

attempt to export audio when there are multiple audio rates, it will fail because .au
[Word Count: 15]

In this case user must manually select one of rates in [ Output Audio Rate ],
[Word Count: 16]

streams will be resampled and audio export succeeds.
[Word Count: 8]

In the Real Time Streaming Protocol (RTSP) menu the user can check the Packet Counter window. It
[Word Count: 17]

shows Total RTCP Packets and divided into RTSP Response Packets, RTSP Request Packets and Other
[Word Count: 15]

RTSP packets. The user can filter, copy or save the data into a file.
[Word Count: 14]

Stream Control Transmission Protocol (SCTP) is a computer network protocol which provides a
[Word Count: 13]

message transfer in telecommunication in the transport layer. It overcomes some lacks of User
[Word Count: 14]

Datagram Protocol (UDP) and Transmission Control Protocol (TCP). The SCTP packets consist of the
[Word Count: 14]

The SCTP Analyze Association window shows the statistics of the captured packets between two
[Word Count: 14]

Endpoints. You can check the different chunk types by pressing [ Chunk Statistics ] button in the
[Word Count: 17]

Statistics tab. In the Endpoint tabs you can see various statistics, such as IP addresses, ports and
[Word Count: 17]

others. You can also check different graphs here.
[Word Count: 8]

Figure 113. SCTP Analyze Association window
[Word Count: 6]

The SCTP Associations window shows the table with the data for captured packets, such as port and
[Word Count: 17]

counter. You can also call for the SCTP Analyze Association window by pressing the [ Analyze ]
[Word Count: 17]

Short Message Peer-to-Peer (SMPP) protocol uses TCP protocol as its transfer for exchanging Short
[Word Count: 14]

Message Service (SMS) Messages, mainly between Short Message Service Centers (SMSC). The
[Word Count: 12]

dissector determines whether the captured packet is SMPP or not by using the heuristics in the
[Word Count: 16]

fixed header. The SMPP Operations window displays the related statistical data. The user can filter,
[Word Count: 15]

The Universal Computer Protocol (UCP) plays role in transferring Short Messages between a Short
[Word Count: 14]

Message Service Centre (SMSC) and an application, which is using transport protocol, such as TCP
[Word Count: 15]

or X.25. The UCP Messages window displays the related statistical data. The user can filter, copy or
[Word Count: 17]

H.225 telecommunication protocol which is responsible for messages in call signaling and media
[Word Count: 13]

stream packetization for packet-based multimedia communication systems. The H.225 window
[Word Count: 10]

shows the counted messages by types and reasons. The user can filter, copy or save the data into a
[Word Count: 19]

Session Initiation Protocol (SIP) Flows window shows the list of all captured SIP transactions, such
[Word Count: 15]

as client registrations, messages, calls and so on.
[Word Count: 8]

This window will list both complete and in-progress SIP transactions.
[Word Count: 10]

Window has same features as VoIP Calls window.
[Word Count: 8]

SIP Statistics window shows captured SIP transactions. It is divided into SIP Responses and SIP
[Word Count: 15]

Requests. In this window the user can filter, copy or save the statistics into a file.
[Word Count: 16]

The WAP-WSP Packet Counter menu displays the number of packets for each Status Code and PDU
[Word Count: 16]

Type in Wireless Session Protocol traffic. The user can filter, copy or save the data into a file.
[Word Count: 18]

The Wireless menu provides access to statistics related to wireless traffic. For configuring keys to
[Word Count: 15]

decrypt wireless traffic, see IEEE 802.11 WLAN Decryption Keys
[Word Count: 9]

Bluetooth ATT Server Attributes window displays a list of captured Attribute Protocol (ATT) packets.
[Word Count: 14]

The user can filter the list by the interfaces or devices, and also exclude repetitions by checking the
[Word Count: 18]

Handle is a unique attribute which is specific to the device.
[Word Count: 11]

UUID is a value which defines a type of an attribute.
[Word Count: 11]

UUID Name is a specified name for the captured packet.
[Word Count: 10]

The Bluetooth Devices window displays the list of the captured information about devices, such as
[Word Count: 15]

MAC address, Organizationally Unique Identifier (OUI), Name and other. Users can filter it by
[Word Count: 14]

The Bluetooth HCI Summary window displays the summary for the captured Host Controller
[Word Count: 13]

Interface (HCI) layer packets. This window allows users to apply filters and choose to display
[Word Count: 15]

information about specific interfaces or devices.
[Word Count: 6]

Figure 116. Bluetooth HCI Summary window
[Word Count: 6]

Statistics about captured WLAN traffic. This can be found under the Wireless menu and
[Word Count: 14]

summarizes the wireless network traffic found in the capture. Probe requests will be merged into
[Word Count: 15]

an existing network if the SSID matches.
[Word Count: 7]

Figure 117. The “WLAN Traffic Statistics” window
[Word Count: 7]

Each row in the list shows the statistical values for exactly one wireless network.
[Word Count: 14]

Name resolution will be done if selected in the window and if it is active for the MAC layer.
[Word Count: 19]

Only show existing networks will exclude probe requests with a SSID not matching any network
[Word Count: 15]

The [ Copy ] button will copy the list values to the clipboard in CSV (Comma Separated Values)
[Word Count: 18]

TIP
This window will be updated frequently, so it will be useful, even if you open it before
[Word Count: 18]

(or while) you are doing a live capture.
[Word Count: 8]

Wireshark’s default behavior will usually suit your needs pretty well. However, as you become
[Word Count: 14]

more familiar with Wireshark, it can be customized in various ways to suit your needs even better.
[Word Count: 17]

• How to start Wireshark with command line parameters
[Word Count: 9]

• How to use the various preference settings
[Word Count: 8]

You can start Wireshark from the command line, but it can also be started from most Window
[Word Count: 17]

managers as well. In this section we will look at starting it from the command line.
[Word Count: 16]

Wireshark supports a large number of command line parameters. To see what they are, simply
[Word Count: 15]

enter the command wireshark -h and the help information shown in Help information available
[Word Count: 14]

from Wireshark (or something similar) should be printed.
[Word Count: 8]

Help information available from Wireshark
[Word Count: 5]

Wireshark 4.5.0 (v4.5.0rc0-1147-g31b31e100870)
Interactively dump and analyze network traffic.
See https://www.wireshark.org for more information.
[Word Count: 14]

Usage: wireshark [options] ... [ <infile> ]
[Word Count: 7]

Capture interface:
  -i <interface>, --interface <interface>
                           name or idx of interface (def: first non-loopback)
  -f <capture filter>      packet filter in libpcap filter syntax
  -s <snaplen>, --snapshot-length <snaplen>
                           packet snapshot length (def: appropriate maximum)
  -p, --no-promiscuous-mode
                           don't capture in promiscuous mode
  -I, --monitor-mode       capture in monitor mode, if available
  -B <buffer size>, --buffer-size <buffer size>
                           size of kernel buffer in MiB (def: 2MiB)
  -y <link type>, --linktype <link type>
                           link layer type (def: first appropriate)
  --time-stamp-type <type> timestamp method for interface
[Word Count: 80]

-D, --list-interfaces    print list of interfaces and exit
  -L, --list-data-link-types
                           print list of link-layer types of iface and exit
  --list-time-stamp-types  print list of timestamp types for iface and exit
[Word Count: 29]

Processing:
  -R <read filter>, --read-filter <read filter>
                           packet filter in display filter (wireshark-filter(4))
syntax
  -n                       disable all name resolutions (def: all enabled)
  -N <name resolve flags>  enable specific name resolution(s): "mtndsNvg"
  -d <layer_type>==<selector>,<decode_as_protocol> ...
                           "Decode As", see the man page for details
                           Example: tcp.port==8888,http
  --enable-protocol <proto_name>
                           enable dissection of proto_name
  --disable-protocol <proto_name>
                           disable dissection of proto_name
  --only-protocols <protocols>
                           Only enable dissection of these protocols, comma
                           separated. Disable everything else
  --disable-all-protocols
                           Disable dissection of all protocols
[Word Count: 75]

--enable-heuristic <short_name>
                           enable dissection of heuristic protocol
  --disable-heuristic <short_name>
                           disable dissection of heuristic protocol
[Word Count: 14]

Output:
  -w <outfile|->           set the output filename (or '-' for stdout)
  -F <capture type>        set the output file type; default is pcapng.
                           an empty "-F" option will list the file types.
  --capture-comment <comment>
                           add a capture file comment, if supported
  --temp-dir <directory>   write temporary files to this directory
                           (default: /tmp)
[Word Count: 50]

Diagnostic output:
  --log-level <level>      sets the active log level ("critical", "warning", etc.)
  --log-fatal <level>      sets level to abort the program ("critical" or "warning")
  --log-domains <[!]list>  comma-separated list of the active log domains
  --log-fatal-domains <list>
                           list of domains that cause the program to abort
  --log-debug <[!]list>    list of domains with "debug" level
  --log-noisy <[!]list>    list of domains with "noisy" level
  --log-file <path>        file to output messages to (in addition to stderr)
[Word Count: 70]

Miscellaneous:
  -h, --help               display this help and exit
  -v, --version            display version info and exit
  -P <key>:<path>          persconf:path - personal configuration files
                           persdata:path - personal data files
  -o <name>:<value> ...    override preference or recent setting
  -K <keytab>              keytab file to use for kerberos decryption
  --display <X display>    X display to use
[Word Count: 51]

--fullscreen             start Wireshark in full screen
[Word Count: 6]

We will examine each of the command line options in turn.
[Word Count: 11]

The first thing to notice is that issuing the command wireshark by itself will launch Wireshark.
[Word Count: 16]

However, you can include as many of the command line parameters as you like. Their meanings
[Word Count: 16]

are as follows ( in alphabetical order ):
[Word Count: 8]

Specify a criterion that specifies when Wireshark is to stop writing to a capture file. The
[Word Count: 16]

criterion is of the form test:value, where test is one of:
[Word Count: 11]

Stop writing to a capture file after value of seconds have elapsed.
[Word Count: 12]

Stop writing to a capture file after it reaches a size of value kilobytes (where a kilobyte is 1000
[Word Count: 19]

bytes, not 1024 bytes). If this option is used together with the -b option, Wireshark will stop
[Word Count: 17]

writing to the current capture file and switch to the next one if filesize is reached.
[Word Count: 16]

Stop writing to capture files after value number of files were written.
[Word Count: 12]

Stop writing to a capture file after value number of packets were written.
[Word Count: 13]

If a maximum capture file size was specified, this option causes Wireshark to run in “ring
[Word Count: 16]

buffer” mode, with the specified number of files. In “ring buffer” mode, Wireshark will write to
[Word Count: 16]

several capture files. Their name is based on the number of the file and on the creation date and
[Word Count: 19]

When the first capture file fills up Wireshark will switch to writing to the next file, and so on.
[Word Count: 19]

With the files option it’s also possible to form a “ring buffer.” This will fill up new files until the
[Word Count: 20]

number of files specified, at which point the data in the first file will be discarded so a new file
[Word Count: 20]

If the optional duration is specified, Wireshark will also switch to the next file when the
[Word Count: 16]

specified number of seconds has elapsed even if the current file is not completely filled up.
[Word Count: 16]

Switch to the next file after value seconds have elapsed, even if the current file is not
[Word Count: 17]

Switch to the next file after it reaches a size of value kilobytes (where a kilobyte is 1000 bytes,
[Word Count: 19]

Begin again with the first file after value number of files were written (form a ring buffer).
[Word Count: 17]

Switch to the next file after value number of packets were written, even if the current file is
[Word Count: 18]

Switch to the next file when the time is an exact multiple of value seconds.
[Word Count: 15]

Set capture buffer size (in MB, default is 2MB). This is used by the capture driver to buffer packet
[Word Count: 19]

data until that data can be written to disk. If you encounter packet drops while capturing, try to
[Word Count: 18]

increase this size. Not supported on some platforms.
[Word Count: 8]

Start with the specified configuration profile.
[Word Count: 6]

This option specifies the maximum number of packets to capture when capturing live data. It
[Word Count: 15]

would be used in conjunction with the -k option.
[Word Count: 9]

Add the comment string to the capture file, if supported by the file format.
[Word Count: 14]

-d <layer_type>==<selector>,<decode_as_dissector>
[Word Count: 2]

"Decode As": override what protocol is called under specific circumstances. See User Specified
[Word Count: 13]

Decodes for details about how this feature works.
[Word Count: 8]

An example of causing TCP traffic on port 8888 to be decoded as HTTP:
[Word Count: 14]

To see all possible values for <layer_type>, run Wireshark or tshark with -d help. You can see all
[Word Count: 18]

possible values for <decode_as_dissectors> by running tshark -G dissectors but note that not all
[Word Count: 14]

Print a list of the interfaces on which Wireshark can capture, then exit. For each network
[Word Count: 16]

interface, a number and an interface name, possibly followed by a text description of the
[Word Count: 15]

interface, is printed. The interface name or the number can be supplied to the -i flag to specify
[Word Count: 18]

This can be useful on systems that don’t have a command to list them (e.g., Windows systems, or
[Word Count: 18]

UNIX systems lacking ifconfig -a). The number can be especially useful on Windows, where the
[Word Count: 15]

Note that “can capture” means that Wireshark was able to open that device to do a live capture.
[Word Count: 18]

If, on your system, a program doing a network capture must be run from an account with
[Word Count: 17]

special privileges, then, if Wireshark is run with the -D flag and is not run from such an account,
[Word Count: 19]

Set the X display to use, instead of the one defined in the environment, or the default display.
[Word Count: 18]

Enable and disable the dissection of the protocol.
[Word Count: 8]

Enable and disable the dissection of the heuristic protocol.
[Word Count: 9]

This option sets the initial capture filter expression to be used when capturing packets.
[Word Count: 14]

After reading in a capture file using the -r flag, go to the given packet number.
[Word Count: 16]

This option requests Wireshark to print its version and usage instructions (as shown here) and
[Word Count: 15]

Hide the capture info dialog during live packet capture.
[Word Count: 9]

Set the name of the network interface or pipe to use for live packet capture.
[Word Count: 15]

Network interface names should match one of the names listed in wireshark -D (described
[Word Count: 14]

above). A number, as reported by wireshark -D, can also be used. If you’re using UNIX, netstat -
[Word Count: 18]

i, ifconfig -a or ip link might also work to list interface names, although not all versions of
[Word Count: 18]

If no interface is specified, Wireshark searches the list of interfaces, choosing the first non-
[Word Count: 15]

loopback interface if there are any non-loopback interfaces, and choosing the first loopback
[Word Count: 13]

interface if there are no non-loopback interfaces; if there are no interfaces, Wireshark reports
[Word Count: 14]

Pipe names should be either the name of a FIFO (named pipe) or “-” to read data from the
[Word Count: 19]

standard input. Data read from pipes must be in standard libpcap format.
[Word Count: 12]

After reading in a capture file using the -r flag, jump to the first packet which matches the filter
[Word Count: 19]

expression. The filter expression is in display filter format. If an exact match cannot be found
[Word Count: 16]

the first packet afterwards is selected.
[Word Count: 6]

Capture wireless packets in monitor mode if available.
[Word Count: 8]

Use this option after the -J option to search backwards for a first packet to go to.
[Word Count: 17]

The -k option specifies that Wireshark should start capturing packets immediately. This option
[Word Count: 13]

requires the use of the -i parameter to specify the interface that packet capture will occur from.
[Word Count: 17]

Use the specified file for Kerberos decryption.
[Word Count: 7]

This option turns on automatic scrolling if the packet list pane is being updated automatically as
[Word Count: 16]

packets arrive during a capture (as specified by the -S flag).
[Word Count: 11]

List the data link types supported by the interface and exit.
[Word Count: 11]

List timestamp types configurable for the interface and exit.
[Word Count: 9]

This option sets the name of the font used for most text displayed by Wireshark.
[Word Count: 15]

Disable network object name resolution (such as hostname, TCP and UDP port names).
[Word Count: 13]

Turns on name resolving for particular types of addresses and port numbers. The argument is a
[Word Count: 16]

string that may contain the following letters:
[Word Count: 7]

Enable name resolution from captured DNS packets.
[Word Count: 7]

Enable transport layer port number resolution.
[Word Count: 6]

Sets a preference or recent value, overriding the default value and any value read from a
[Word Count: 16]

preference or recent file. The argument to the flag is a string of the form prefname:value, where
[Word Count: 17]

prefname is the name of the preference (which is the same name that would appear in the
[Word Count: 17]

preferences or recent file), and value is the value to which it should be set. Multiple instances of
[Word Count: 18]

`-o <preference settings> ` can be given on a single command line.
[Word Count: 12]

The preferences you specify on the command line will override any settings you
[Word Count: 13]

have changed in any of your profiles; this includes when switching from one
[Word Count: 13]

If you change a setting using the Preferences dialog (see Preferences) that you
[Word Count: 13]

have also set on the command line, the command line option will then be
[Word Count: 14]

ignored, and the setting will change as normal when you switch profiles.
[Word Count: 12]

An example of setting a single preference would be:
[Word Count: 9]

wireshark -o mgcp.display_dissect_tree:TRUE
[Word Count: 3]

An example of setting multiple preferences would be:
[Word Count: 8]

wireshark -o mgcp.display_dissect_tree:TRUE -o mgcp.udp.callagent_port:2627
[Word Count: 5]

You can get a list of all available preference strings from the preferences file. See Files and
[Word Count: 17]

User Accessible Tables (UATs) can be overridden using “uat:” followed by the UAT file name (not
[Word Count: 16]

the preference name) and a valid record for the file:
[Word Count: 10]

wireshark -o "uat:user_dlts:\"User 0 (DLT=147)\",\"http\",\"0\",\"\",\"0\",\"\""
[Word Count: 5]

The example above would dissect packets with a libpcap data link type 147 as HTTP, just as if
[Word Count: 18]

you had configured it in the DLT_USER protocol preferences.
[Word Count: 9]

NOTE
You can only add UAT entries from the command line. You can not modify or
[Word Count: 16]

remove existing entries in a UAT in this way.
[Word Count: 9]

Don’t put the interface into promiscuous mode. Note that the interface might be in promiscuous
[Word Count: 15]

mode for some other reason. Hence, -p cannot be used to ensure that the only traffic that is
[Word Count: 18]

captured is traffic sent to or from the machine on which Wireshark is running, broadcast traffic,
[Word Count: 16]

and multicast traffic to addresses received by that machine.
[Word Count: 9]

Special path settings usually detected automatically. This is used for special cases, e.g., starting
[Word Count: 14]

Wireshark from a known location on an USB stick.
[Word Count: 9]

The criterion is of the form key:path, where key is one of:
[Word Count: 12]

Path of personal configuration files, like the preferences files.
[Word Count: 9]

Path of personal data files, it’s the folder initially opened. After the initialization, the recent
[Word Count: 15]

This option provides the name of a capture file for Wireshark to read and display. This capture
[Word Count: 17]

file can be in one of the formats Wireshark understands.
[Word Count: 10]

This option specifies a display filter to be applied when reading packets from a capture file. The
[Word Count: 17]

syntax of this filter is that of the display filters discussed in Filtering Packets While Viewing.
[Word Count: 16]

Packets not matching the filter are discarded.
[Word Count: 7]

--snapshot-length <capture snapshot length>
[Word Count: 4]

This option specifies the snapshot length to use when capturing packets. Wireshark will only
[Word Count: 14]

capture snaplen bytes of data for each packet.
[Word Count: 8]

This option specifies that Wireshark will display packets as it captures them. This is done by
[Word Count: 16]

capturing in one process and displaying them in a separate process. This is the same as “Update
[Word Count: 17]

list of packets in real time” in the “Capture Options” dialog box.
[Word Count: 12]

This option sets the format of packet timestamps that are displayed in the packet list window.
[Word Count: 16]

Relative, which specifies timestamps are displayed relative to the first packet captured.
[Word Count: 12]

Absolute, which specifies that actual times be displayed for all packets.
[Word Count: 11]

Absolute with date, which specifies that actual dates and times be displayed for all packets.
[Word Count: 15]

Absolute with YYYY/DOY date, which specifies that actual dates and times be displayed for all
[Word Count: 15]

Delta, which specifies that timestamps are relative to the previous packet.
[Word Count: 11]

dd: Delta, which specifies that timestamps are relative to the previous displayed packet.
[Word Count: 13]

Epoch, which specifies that timestamps are seconds since epoch (Jan 1, 1970 00:00:00)
[Word Count: 13]

Absolute, which specifies that actual times be displayed for all packets in UTC.
[Word Count: 13]

Absolute with date, which specifies that actual dates and times be displayed for all packets in
[Word Count: 16]

Absolute with YYYY/DOY date, which specifies that actual dates and times be displayed for all
[Word Count: 15]

Show timesamps as seconds (“s”, the default) or hours, minutes, and seconds (“hms”)
[Word Count: 13]

This option requests Wireshark to print out its version information and exit.
[Word Count: 12]

This option sets the name of the file to be used to save captured packets. This can be '-' for stdout.
[Word Count: 21]

If a capture is started from the command line with -k, set the data link type to use while
[Word Count: 19]

capturing packets. The values reported by -L are the values that can be used.
[Word Count: 14]

If a capture is started from the command line with -k, set the time stamp type to use while
[Word Count: 19]

capturing packets. The values reported by --list-time-stamp-types are the values that can be
[Word Count: 13]

Specify an option to be passed to a Wireshark/TShark module. The eXtension option is in the
[Word Count: 16]

form extension_key:value, where extension_key can be:
[Word Count: 6]

Tells Wireshark to load the given script in addition to the default Lua scripts.
[Word Count: 14]

Tells Wireshark to pass the given argument to the lua script identified by num, which is the
[Word Count: 17]

number indexed order of the lua_script command. For example, if only one script was loaded
[Word Count: 15]

with -X lua_script:my.lua, then -X lua_script1:foo will pass the string foo to the my.lua
[Word Count: 14]

script. If two scripts were loaded, such as -X lua_script:my.lua -X lua_script:other.lua in
[Word Count: 13]

that order, then a -X lua_script2:bar would pass the string bar to the second lua script, ie.,
[Word Count: 17]

Tells Wireshark to use a specific input file type, instead of determining it automatically.
[Word Count: 14]

Define a description for the standard input interface, instead of the default: "Standard input".
[Word Count: 14]

Get Wireshark to collect various types of statistics and display the result in a window that
[Word Count: 16]

updates in semi-real time. For the currently implemented statistics consult the Wireshark
[Word Count: 12]

A very useful mechanism available in Wireshark is packet colorization. You can set up Wireshark
[Word Count: 15]

so that it will colorize packets according to a display filter. This allows you to emphasize the packets
[Word Count: 18]

You can find a lot of coloring rule examples at the Wireshark Wiki Coloring Rules page at
[Word Count: 17]

https://wiki.wireshark.org/ColoringRules.
[Word Count: 1]

There are two types of coloring rules in Wireshark: temporary rules that are only in effect until you
[Word Count: 18]

quit the program, and permanent rules that are saved in a preference file so that they are available
[Word Count: 18]

Temporary rules can be added by selecting a packet and pressing the Ctrl  key together with one of
[Word Count: 18]

the number keys. This will create a coloring rule based on the currently selected conversation. It
[Word Count: 16]

will try to create a conversation filter based on TCP first, then UDP, then IP and at last Ethernet.
[Word Count: 19]

Temporary filters can also be created by selecting the Colorize with Filter › Color X menu items
[Word Count: 17]

when right-clicking in the packet detail pane.
[Word Count: 7]

To permanently colorize packets, select View › Coloring Rules…. Wireshark will display the
[Word Count: 13]

“Coloring Rules” dialog box as shown in The “Coloring Rules” dialog box.
[Word Count: 12]

Figure 118. The “Coloring Rules” dialog box
[Word Count: 7]

If this is the first time using the Coloring Rules dialog and you’re using the default configuration
[Word Count: 17]

profile you should see the default rules, shown above.
[Word Count: 9]

More specific rules should usually be listed before more general rules. For example,
[Word Count: 13]

if you have a coloring rule for UDP before the one for DNS, the rule for DNS may not
[Word Count: 19]

be applied (DNS is typically carried over UDP and the UDP rule will match first).
[Word Count: 15]

You can create a new rule by clicking on the [ + ] button. You can delete one or more rules by
[Word Count: 22]

clicking the [ - ] button. The “copy” button will duplicate a rule.
[Word Count: 13]

You can edit a rule by double-clicking on its name or filter. In The “Coloring Rules” dialog box the
[Word Count: 19]

name of the rule “Checksum Errors” is being edited. Clicking on the [ Foreground ] and
[Word Count: 16]

[ Background ] buttons will open a color chooser (A color chooser) for the foreground (text) and
[Word Count: 17]

The color chooser appearance depends on your operating system. The macOS color picker is shown.
[Word Count: 15]

Select the color you desire for the selected packets and click [ OK ].
[Word Count: 14]

Using color filters with Wireshark shows an example of several color filters being used in
[Word Count: 15]

Wireshark. Note that the frame detail shows that the “Bad TCP” rule was applied, along with the
[Word Count: 17]

Figure 120. Using color filters with Wireshark
[Word Count: 7]

The user can control how protocols are dissected.
[Word Count: 8]

Each protocol has its own dissector, so dissecting a complete packet will typically involve several
[Word Count: 15]

dissectors. As Wireshark tries to find the right dissector for each packet (using static “routes” and
[Word Count: 16]

heuristics “guessing”), it might choose the wrong dissector in your specific case. For example,
[Word Count: 14]

Wireshark won’t know if you use a common protocol on an uncommon TCP port, e.g., using HTTP
[Word Count: 17]

on TCP port 800 instead of the standard port 80.
[Word Count: 10]

There are two ways to control the relations between protocol dissectors: disable a protocol
[Word Count: 14]

dissector completely or temporarily divert the way Wireshark calls the dissectors.
[Word Count: 11]

The Enabled Protocols dialog box lets you enable or disable specific protocols. Most protocols are
[Word Count: 15]

enabled by default. When a protocol is disabled, Wireshark stops processing a packet whenever
[Word Count: 14]

Disabling a protocol will prevent information about higher-layer protocols from
[Word Count: 10]

being displayed. For example, suppose you disabled the IP protocol and selected a
[Word Count: 13]

packet containing Ethernet, IP, TCP, and HTTP information. The Ethernet
[Word Count: 10]

information would be displayed, but the IP, TCP and HTTP information would not -
[Word Count: 14]

disabling IP would prevent it and the higher-layer protocols from being displayed.
[Word Count: 12]

To enable or disable protocols select Analyze › Enabled Protocols…. Wireshark will pop up the
[Word Count: 15]

“Enabled Protocols” dialog box as shown in The “Enabled Protocols” dialog box.
[Word Count: 12]

Figure 121. The “Enabled Protocols” dialog box
[Word Count: 7]

To disable or enable a protocol, simply click the checkbox using the mouse. Note that typing a few
[Word Count: 18]

letters of the protocol name in the search box will limit the list to those protocols that contain these
[Word Count: 19]

You can choose from the following actions:
[Word Count: 7]

Toggle the state of all protocols in the list.
[Word Count: 9]

Save and apply the changes and close the dialog box, see Files and Folders for details.
[Word Count: 16]

Cancel the changes and close the dialog box.
[Word Count: 8]

The “Decode As” functionality lets you override what protocol is called under specific
[Word Count: 13]

circumstances. This might be useful if Wireshark is incorrectly choosing which dissector to use for
[Word Count: 15]

a particular TCP port, for example, or if you do some uncommon experiments on your network.
[Word Count: 16]

NOTE
Not all protocols support this feature, and not just any protocol field can be used to
[Word Count: 17]

override Wireshark’s choice of dissector.
[Word Count: 5]

Decode As is accessed by selecting the Analyze › Decode As…. Wireshark will pop up the “Decode
[Word Count: 17]

As” dialog box as shown in The “Decode As” dialog box.
[Word Count: 11]

In this dialog you are able to edit entries by means of the edit buttons on the left.
[Word Count: 18]

You can also pop up this dialog box from the context menu in the “Packet List” or “Packet Details”
[Word Count: 19]

panes. It will then contain a new line based on the currently selected packet.
[Word Count: 14]

These settings will be lost if you quit Wireshark or change profile unless you save the entries.
[Word Count: 17]

Clear the list of user specified decodes.
[Word Count: 7]

Apply the user specified decodes and close the dialog box.
[Word Count: 10]

Save and apply the user specified decodes and close the dialog box.
[Word Count: 12]

Cancel the changes and close the dialog box.
[Word Count: 8]

Each entry in this dialog will have the following columns. You can double-click on an entry’s field to
[Word Count: 18]

change its value, as long as it’s not an informational (read-only) field.
[Word Count: 12]

Field
The field whose value should be examined when determining the
[Word Count: 11]

dissector to use. Double-click to show a list of all fields which are
[Word Count: 13]

Value
The specific value of the chosen field which should indicate to
[Word Count: 12]

Wireshark to use your chosen dissector override.
[Word Count: 7]

Type
Read-only. Shows the type of the chosen field’s value; for
[Word Count: 11]

Default
Read-only. Shows what dissector would normally be called if the
[Word Count: 11]

Current
The dissector you wish to be called instead.
[Word Count: 9]

You will only be able to choose dissectors for protocols which
[Word Count: 11]

could be directly carried by the containing protocol. For example,
[Word Count: 10]

you cannot specify that data carried over TCP should be passed to
[Word Count: 12]

TIP
You can also specify “Decode As” entries on the Wireshark or tshark command line.
[Word Count: 15]

See the documentation of the -d option in Start Wireshark from the command line.
[Word Count: 14]

There are a large number of preferences you can set. Simply select the Edit › Preferences…
[Word Count: 16]

(Wireshark › Preferences… on macOS) and Wireshark will pop up the Preferences dialog box as
[Word Count: 15]

shown in The preferences dialog box, with the “Appearance” page as default. On the left side is a
[Word Count: 18]

tree where you can select the page to be shown.
[Word Count: 10]

• The [ OK ] button will apply the preferences settings and close the dialog.
[Word Count: 15]

• The [ Cancel ] button will restore all preferences settings to the last saved state.
[Word Count: 16]

You can also see a protocol’s preferences from the pop-up menus for the “Packet List”
[Word Count: 15]

or “Packet Details” panes, by going to the Protocol Preferences menu item, which will
[Word Count: 14]

The top entry in this new menu will take you to the Preferences dialog box as shown
[Word Count: 17]

in The preferences dialog box, with the chosen protocol’s page showing.
[Word Count: 11]

The final entry in this menu will completely disable the dissection of the chosen
[Word Count: 14]

protocol. See The “Enabled Protocols” dialog box for how to re-enable the protocol.
[Word Count: 13]

Any other entries in this menu will let you quickly adjust individual preferences for
[Word Count: 14]

this protocol without needing to open the full Preferences dialog box.
[Word Count: 11]

These preferences give you the option to control the makeup of the GUI.
[Word Count: 13]

Selecting Remember main window size and placement allow for a repeatable experience when
[Word Count: 13]

Selecting Open files in allows you to determine where to start the file selection dialog when opening
[Word Count: 17]

The preference Show up to allows you to determine how much history is tracked for display filter
[Word Count: 17]

entries and recent files shown in the main application window.
[Word Count: 10]

Selecting Confirm unsaved capture files causes a dialog to appear when closing a capture file when it
[Word Count: 17]

was not yet saved. This may help preventing inadvertent loss of data, eg., when Wireshark is closed.
[Word Count: 17]

Selecting Display autocompletion for filter text causes a drop down list to appear when you enter a
[Word Count: 17]

display filter. This drop down list contains known display filters for easy selection.
[Word Count: 13]

The preference Main toolbar style allows you to tailor the toolbar style in one of three ways.
[Word Count: 17]

The Wireshark main window title is replaced by the name of the opened capture file. The
[Word Count: 16]

preferences Window title and Prepend window title allow you to add bracketed strings after and
[Word Count: 15]

before the window title. These window title strings can contain variables which will be replaced by
[Word Count: 16]

• %C = Capture comment from command line
[Word Count: 8]

• %S = Conditional separator (dash) that only shows when surrounded by variables with values
[Word Count: 15]

The Language preference allows you to select the language used in the GUI. Note that the protocol
[Word Count: 17]

information and details are kept in the language commonly used in this field, that being English.
[Word Count: 16]

These preferences give you the option to control the definition of the columns shown in the packet
[Word Count: 17]

Selecting Show displayed columns only hides all non-displayed columns from the list, possibly
[Word Count: 13]

The rows can be dragged and dropped to arrange them in the desired order.
[Word Count: 14]

The columns in the entries are as follows.
[Word Count: 8]

Selecting Displayed causes the column to be shown in the packet list.
[Word Count: 12]

The Title is the text shown in the header of the column in the packet list.
[Word Count: 16]

The Type is the type of value to be shown. This can be a predefined type, ie. a value in a defined
[Word Count: 22]

The following settings are applicable when the Type is set to "custom"
[Word Count: 12]

The Fields setting is the display filter name of the field to be shown in the column in the packet list.
[Word Count: 21]

The Field Occurrence setting is count of the given field in the frame, for fields that appear more
[Word Count: 18]

Selecting Resolved causes name resolution to be applied to the field value, when available.
[Word Count: 14]

These preferences give you the option to select the font and colors used in the various packet panes.
[Word Count: 18]

Most usable is to select a mono spaced font, which allows for a cleaner presentation, but using a
[Word Count: 18]

These preferences allow you to define the layout of the GUI once a capture file is loaded.
[Word Count: 17]

Make sure that you have at least one pane configured to contain the Packet list. Three panes can be
[Word Count: 19]

active at the same time and they can be laid out as shown in the top layer. The exact sizes of these
[Word Count: 22]

panes can be changed as needed once a capture file is opened.
[Word Count: 12]

Selecting Show packet list separator causes the packet list entries to be slightly set apart, which may
[Word Count: 17]

improve readability at the cost of the amount of packets shown in the packet list.
[Word Count: 15]

Selecting Show column definition in column context menu make the column context menu wider to
[Word Count: 15]

show the currently configured field type for the column. This may help identify the column to select
[Word Count: 17]

Selecting Allow the list to be sorted enables the sort operator on all the columns. This may prevent
[Word Count: 18]

inadvertently triggering a sort, which may take considerable time for larger capture files.
[Word Count: 13]

The Maximum number of cached rows setting determines how much packet list information is
[Word Count: 14]

cached to speed up sort operations, where a larger number causes more memory to be consumed
[Word Count: 16]

by the cache. Be aware that changing other dissection settings may invalidate the cache content.
[Word Count: 15]

Selecting Enable mouse-over colorization enables the highlighting of the currently pointed to packet
[Word Count: 13]

in the packet list. The currently selected packet is always highlighted.
[Word Count: 11]

Selecting Show selected packet number adds the selected packet number to the capture file details in
[Word Count: 16]

the status bar, taking up some space in the status bar.
[Word Count: 11]

Selecting Show file load time adds the time it took to load the capture file to the status bar, taking up
[Word Count: 21]

These preferences allow you to set the default conditions for packet capture.
[Word Count: 12]

The default interface is the interface used for packet capture in case no other is selected on the
[Word Count: 18]

opening page of GUI. Note that this can be multiple interfaces separated by a comma.
[Word Count: 15]

Selecting Capture packets in promiscuous mode causes the network interface(s) to capture on to be
[Word Count: 15]

configured in promiscuous mode. This allows all (Ethernet) frames to be received by the network
[Word Count: 15]

interface to be capture, not only those that are addressed to the capture interface.
[Word Count: 14]

Selecting Capture packets in pcapng format causes the Next-Generation packet capture file format to
[Word Count: 14]

be used when capturing. This much more capable packet capture file format has many advantages
[Word Count: 15]

over the original format, although not every external tool may be capable of handling packet
[Word Count: 15]

Selecting Update list of packets in real time causes the packet list to fill up and possibly scroll up
[Word Count: 19]

during the packet capture process. This does give an insight in the packets captured, although it
[Word Count: 16]

takes processing power to dissect the capture packets.
[Word Count: 8]

The preference Interval between updates (ms) allows you to configure how often the packet list is
[Word Count: 16]

updated during the packet capture process. A higher interval reduces processing, but causes more
[Word Count: 14]

delay between capture and display in the packet list.
[Word Count: 9]

Selecting Don’t load interfaces on startup prevents Wireshark from spawning dumpcap to populate
[Word Count: 13]

the list of capture interfaces on the local system. This might be a time consuming operation
[Word Count: 16]

delaying the start of the program, however on most systems this is not an issue. The interface list
[Word Count: 18]

can always be populated after Wireshark is started via Capture › Refresh Interfaces.
[Word Count: 13]

Selecting Disable external capture interfaces prevents Wireshark from spawning extcap programs to
[Word Count: 12]

list off their capture interfaces. This might be a time consuming operation delaying the start of the
[Word Count: 17]

program, however on most systems this is not an issue.
[Word Count: 10]

These preferences allow you to modify the severity set for expert items.
[Word Count: 12]

If, for whatever reason, you find that the severity for certain expert items does not match your
[Word Count: 17]

needs you can change them here and have them used as such, showing up in the appropriate lists
[Word Count: 18]

and overviews. Get the Field name from selecting the field in the packet details pane, then observe
[Word Count: 17]

the name shown in the status bar. This is the name you enter on a new line in the list, while setting
[Word Count: 22]

the desired Severity in the next column.
[Word Count: 7]

Move the selected entry down in the list.
[Word Count: 8]

Clear the list of user specified expert item severities.
[Word Count: 9]

Copy the list of user specified expert item severities from another profile.
[Word Count: 12]

Having quick access to regularly used display filter expressions can be a real productivity boost.
[Word Count: 15]

Here you can define your own display filter buttons.
[Word Count: 9]

Move the selected entry down in the list.
[Word Count: 8]

Clear the list of user specified display filter buttons.
[Word Count: 9]

Copy the list of user specified display filter buttons from another profile.
[Word Count: 12]

The columns in the entries are as follows.
[Word Count: 8]

Selecting Show in toolbar causes the button to be shown in the toolbar besides the display filter text
[Word Count: 18]

The Button Label is the text shown on the button in the toolbar. The use of a double slash causes the
[Word Count: 21]

button to create a dropdown list to allow grouping of multiple buttons, e.g. TCP//Syn and TCP//Res.
[Word Count: 16]

The Filter Expression is the display filter expression entered into the display filter text entry when
[Word Count: 16]

The Comment is the comment text which appears in a bubble when the mouse hovers over the
[Word Count: 17]

These preferences allow you to configure which numeric identifiers in protocols are translated into
[Word Count: 14]

human readable text. For some of these identifiers the readable texts are read from configurable
[Word Count: 15]

Selecting Resolve MAC addresses causes the OUI (Organizationally Unique Identifier) at the start of
[Word Count: 14]

an Ethernet address to be translated into the name registered with the IEEE for that OUI.
[Word Count: 16]

Selecting Resolve transport names causes the UDP and TCP port numbers to be translated into the
[Word Count: 16]

service registered to these ports by IANA.
[Word Count: 7]

Selecting Resolve network (IP) addresses causes IPv4, IPv6 and IPX addresses to be translated into
[Word Count: 15]

their corresponding host name. To do this Wireshark reaches out to DNS servers to request names
[Word Count: 16]

for addresses it finds in packets. There are several way to do this, which can be controlled through
[Word Count: 18]

Selecting Use captured DNS packet data for name resolution causes DNS response packets in the
[Word Count: 15]

capture file to fill the network address resolution table. These can then be used to resolve addresses
[Word Count: 17]

Selecting Use your system’s DNS settings for name resolution causes DNS requests to be made as
[Word Count: 16]

would be for other network applications.
[Word Count: 6]

Selecting Use a custom list of DNS servers for name resolution causes DNS requests to be made to
[Word Count: 18]

The DNS Servers [ Edit… ] button provides access to the dialog to manage these manually
[Word Count: 16]

The Maximum concurrent requests input field allows you to limit the amount of DNS queries made
[Word Count: 16]

Selecting Resolve VLAN IDs causes the file "vlans" to be read and used to name VLANs. This file has
[Word Count: 19]

the simple format of one line per VLAN, starting wit VLAN ID, a tab character, followed by the
[Word Count: 18]

Selecting Resolve SS7 PCs causes the file "ss7pcs" to be read and used to name SS7 Point Codes. This
[Word Count: 19]

file has the simple format of one line per Point Code, starting with Network Indicator, a dash, the
[Word Count: 18]

Point Code in decimal, a tab character, followed by the name of the Point Code.
[Word Count: 15]

Selecting Enable OID resolution causes the SMI library to be initialized. This library is capable of
[Word Count: 16]

loading MIB/PIB files to provide name resolution for SMI objects, as present in SNMP packets.
[Word Count: 15]

Selecting Suppress SMI errors prevents the SMI library from emitting error messages while loading
[Word Count: 14]

MIB/PIB files. The SMI library is very sensitive to irregularities in these files often resulting in
[Word Count: 16]

The SMI (MIB and PIB) paths [ Edit… ] button provides access to the dialog to manage the
[Word Count: 18]

directories where the MIB/PIB files to be loaded can be found.
[Word Count: 11]

The SMI (MIB and PIB) modules [ Edit… ] button provides access to the dialog to manage the
[Word Count: 18]

Selecting Enable IP geolocation causes the background MaxMind database IP geolocation resolver to
[Word Count: 13]

be used to attempt to geolocate IP addresses in the packets.
[Word Count: 11]

The MaxMind database directories [ Edit… ] button provides access to the dialog to manage the
[Word Count: 16]

directories where the MaxMind database files can be found. See MaxMind Database Paths.
[Word Count: 13]

Wireshark supports quite a few protocols, which is reflected in the long list of child entries of the
[Word Count: 18]

“Protocols” pane. You can jump to the preferences for a specific protocol by expanding “Protocols”
[Word Count: 15]

and typing the first few letters of the protocol name.
[Word Count: 10]

There are a few general protocol related preferences, listed below.
[Word Count: 10]

Selecting Display hidden protocol items influences what is shown in the packet details pane of the
[Word Count: 16]

packet selected from the packet list. Some protocol dissectors add hidden protocol items that
[Word Count: 14]

provide additional interpretations of the packet data, or with different display filter strings. These
[Word Count: 14]

may or may not provide valuable information to the user and may clutter the output, therefor these
[Word Count: 17]

Selecting Display byte fields with a space character between bytes influences the way a byte field in
[Word Count: 17]

shown in the packet details pane of the packet selected in the packet list, if the dissector creates a
[Word Count: 19]

byte field that is. The bytes in the byte field are normally shown as a concatenated sequence of
[Word Count: 18]

hexadecimals. This preference allows you to get the representation of each byte separated by a
[Word Count: 15]

space. This may improve readability of the individual bytes in the byte field.
[Word Count: 13]

Selecting Look for incomplete dissectors causes expert items to be added to the dissection of packet
[Word Count: 16]

data for which the dissector does not create an interpretation. Dissectors should strive to not skip
[Word Count: 16]

packet bytes and this preference allows you to be made aware of this.
[Word Count: 13]

Selecting Enable stricter conversation tracking heuristics allows dissectors to take more identifiers
[Word Count: 12]

into consideration when creating "conversations". These are used to track related packets. The
[Word Count: 13]

heuristics for these conversations are sensitive to mis-identification of packets, possibly corrupting
[Word Count: 12]

conversation analysis. Adding more identifiers can reduce the change of this happening. Currently
[Word Count: 13]

only the IPv4, ICMP and ICMPv6 dissector use this preference.
[Word Count: 10]

Selecting Ignore duplicate frames causes a duplicate frame to appear in the packet list, but flagged
[Word Count: 16]

as ignored, hence not dissected. The determination of a duplicate frame is made based on the
[Word Count: 16]

The preference Deinterlacing conversations key gives you options for deinterlacing the
[Word Count: 11]

conversations, for the Ethernet encapsulation only. As opposed to hardware duplicates which show
[Word Count: 13]

absolutely similar frames, capture duplicates are the consequence of the capture method (capture
[Word Count: 13]

on multiple interfaces for example) and show similar payloads with one or more different fields.
[Word Count: 15]

While NONE keeps the historical behaviour, the other options are built on three keys with the
[Word Count: 16]

following meanings: V (VLAN), M (MAC Address), I (Interface). The presence of packets which seem
[Word Count: 15]

to be duplicates because they have the same payload but aren’t filtered by the other preference
[Word Count: 16]

Ignore duplicate frames, is a strong indication that a deinterlacing key is likely to change the
[Word Count: 16]

interpretation. Check carefully the different values of Interface IDs, MAC Addresses, and VLAN
[Word Count: 13]

Tags, to identify which deinterlacing key is appropriate for isolating the conversations and bringing
[Word Count: 14]

The preference The max number of hashes to keep in memory for determining duplicate frames
[Word Count: 15]

allows you to set how large the set of frames to consider for duplication is.
[Word Count: 15]

For more information see https://wiki.wireshark.org/TLS.
[Word Count: 5]

These preference have influence on the Statistics Tree (stats_tree) based dialogs accessible via the
[Word Count: 14]

The preference Tap update interval in ms allows you to set how quickly protocol taps are being
[Word Count: 17]

updated, partially determining the update speed of various dialogs and graphs.
[Word Count: 11]

Selecting Enable the calculation of burst information allows the Statistics Tree system to calculate
[Word Count: 14]

Selecting Show burst count for item rather than rate allows the statistics nodes to show the count of
[Word Count: 18]

events within the burst window instead of a burst rate. Burst rate is calculated as number of events
[Word Count: 18]

within burst window divided by the burst window length.
[Word Count: 9]

The preference Burst rate resolution (ms) sets the duration of the time interval into which events
[Word Count: 16]

are grouped when calculating the burst rate. Setting a higher resolution (ie., a smaller number)
[Word Count: 15]

The preference Burst rate window size (ms) sets the duration of the sliding window during which
[Word Count: 16]

the burst rate is measured. Longer window relative to burst rate resolution increases processing
[Word Count: 14]

overhead. This value will be truncated to a multiple of the Burst rate resolution preference setting.
[Word Count: 16]

The preference Default sort column for stats_tree stats gives you to option to select one of the
[Word Count: 17]

Selecting Default stats_tree sort order is descending causes a descending sort order based on the
[Word Count: 15]

Selecting Case sensitive sort of stats_tree item names causes a case sensitive sort based on the
[Word Count: 16]

Selecting Always sort 'range' nodes by name causes the sort to take place by name rather than
[Word Count: 17]

Selecting Always sort 'range' nodes in ascending order makes an exception for range nodes to the
[Word Count: 16]

Selecting Display the full stats_tree plug-in name causes the full menu path of the Statistics Tree
[Word Count: 16]

The “Advanced” pane will let you view and edit all of Wireshark’s preferences, similar to
[Word Count: 15]

about:config and chrome:flags in the Firefox and Chrome web browsers.
[Word Count: 10]

You can search for a preference by typing text into the “Search” entry. You can also pass preference
[Word Count: 18]

names to Wireshark and TShark on the command line. For example, the gui.prepend_window_title
[Word Count: 13]

can be used to differentiate between different instances of Wireshark on your screen:
[Word Count: 13]

$ wireshark -o "gui.prepend_window_title:LAN" &
$ wireshark -o "gui.prepend_window_title:External Network" &
[Word Count: 11]

For more information, including how to specify a User Accessible Table entry on the command line,
[Word Count: 16]

see the documentation for -o in Start Wireshark from the command line.
[Word Count: 12]

Configuration Profiles can be used to configure and use more than one set of preferences and
[Word Count: 16]

configurations. Select the Edit › Configuration Profiles… menu item or press Shift  +  Ctrl  +  A  or
[Word Count: 17]

Shift  +  Cmd  +  A  (macOS) and Wireshark will pop up the Configuration Profiles dialog box as shown in
[Word Count: 19]

The configuration profiles dialog box. It is also possible to click in the “Profile” part of the statusbar
[Word Count: 18]

to popup a menu with available Configuration Profiles (The Statusbar with a configuration profile
[Word Count: 14]

Configuration files stored in each profile include:
[Word Count: 7]

• Preferences (preferences) (Preferences)
[Word Count: 4]

• Capture Filters (cfilters) (Defining And Saving Filters)
[Word Count: 8]

• Display Filters (dfilters) (Defining And Saving Filters)
[Word Count: 8]

• Display Filter Macros (dmacros) (Defining And Saving Filter Macros)
[Word Count: 10]

• Coloring Rules (colorfilters) (Packet colorization)
[Word Count: 6]

• Disabled Protocols (disabled_protos) (The “Enabled Protocols” dialog box)
[Word Count: 9]

• Most User Accessible Tables (User Accessible Tables)
[Word Count: 8]

• Changed dissector assignments (decode_as_entries), which can be set in the “Decode As…” dialog
[Word Count: 14]

• Some recent settings (recent), such as pane sizes in the Main window (The Main window),
[Word Count: 16]

column widths in the packet list (The “Packet List” Pane), all selections in the View menu (The
[Word Count: 17]

“View” Menu) and the last directory navigated to in the “File Open” dialog.
[Word Count: 13]

All other configurations are stored in the personal configuration folder and are common to all
[Word Count: 15]

Figure 135. The configuration profiles dialog box
[Word Count: 7]

The list of profiles can be filtered by entering part of the profile’s name into the search box.
[Word Count: 18]

Profiles can be filtered between displaying "All profiles", "Personal profiles" and "Global profiles"
[Word Count: 13]

• Personal profiles - these are profiles stored in the user’s configuration directory
[Word Count: 13]

• Global profiles - these are profiles provided with Wireshark
[Word Count: 10]

Create a new profile. The name of the created profile is “New profile” and is highlighted so that
[Word Count: 18]

Deletes the selected profile. This includes all configuration files used in this profile. Multiple
[Word Count: 14]

profiles can be selected and deleted at the same time. It is not possible to delete the “Default”
[Word Count: 18]

profile or global profiles. Deletion of the "Default" profile will reset this profile.
[Word Count: 13]

Copies the selected profile. This copies the configuration of the profile currently selected in the
[Word Count: 15]

list. The name of the created profile is the same as the copied profile, with the text “(copy)” and
[Word Count: 19]

is highlighted so that you can more easily change it.
[Word Count: 10]

The number of packets to check for automatic profile switching, described below. Setting this to
[Word Count: 15]

zero disables automatic profile switching.
[Word Count: 5]

Profiles can be imported from zip-archives as well as directly from directory structures. Profiles,
[Word Count: 14]

which already exist by name will be skipped, as well as profiles named "Default".
[Word Count: 14]

Profiles can be exported to a zip-archive. Global profiles, as well as the default profile will be
[Word Count: 17]

skipped during export. Profiles can be selected in the list individually and only the selected
[Word Count: 15]

This button saves all changes, applies the selected profile and closes the dialog.
[Word Count: 13]

Close this dialog. This will discard unsaved settings, new profiles will not be added and deleted
[Word Count: 16]

You can configure Wireshark to automatically change configuration profiles by adding a display
[Word Count: 13]

filter to the "Auto Switch Filter" setting for a profile. When you open a capture file, Wireshark will
[Word Count: 18]

check each filter against a limited number of packets and will switch to the first profile with a
[Word Count: 18]

matching filter. The number of packets is determined by the "Auto switch packet limit" setting, and
[Word Count: 16]

a limit of 0 will disable this feature. Manually changing your profile will disable this behavior until
[Word Count: 17]

User Accessible Tables (UATs) are a type of preference table which may be associated with
[Word Count: 15]

particular protocols or with the application as a whole.
[Word Count: 9]

User Accessible Tables have a common editor dialog which works as described in Expert Items and
[Word Count: 16]

Filter Buttons. Note that the name of the file appears in the lower right corner of the dialog.
[Word Count: 18]

The files are saved in a CSV format, where values are either double quoted ASCII strings (using C-
[Word Count: 18]

style backslash escapes for non-printable characters) or unquoted hexstrings, depending on the
[Word Count: 12]

field type. They can be edited directly when Wireshark is not running, though this is discouraged.
[Word Count: 16]

Entries can also be appended to the table by passing an appropriate CSV formatted record string on
[Word Count: 17]

Most UATs are stored in the configuration profile:
[Word Count: 8]

• Custom HTTP headers (custom_http_header_fields)
[Word Count: 5]

• Custom IMF headers (imf_header_fields)
[Word Count: 5]

• Custom LDAP AttributeValue types (custom_ldap_attribute_types)
[Word Count: 6]

• Display Filter Buttons (dfilter_buttons)
[Word Count: 5]

• Display Filter Macros (dfilter_macros), prior to Wireshark 4.4
[Word Count: 9]

• DNS Servers (addr_resolve_dns_servers)
[Word Count: 4]

• ESS Category Attributes (ess_category_attributes)
[Word Count: 5]

• Expert Item Severity (expert_severity)
[Word Count: 5]

• IEEE 802.11 WLAN Decryption Keys (80211_keys)
[Word Count: 7]

• IKEv2 decryption table (ikev2_decryption_table)
[Word Count: 5]

• Object Identifier Names and Associated Syntaxes ()
[Word Count: 8]

• PRES Users Context List (pres_context_list)
[Word Count: 6]

• SNMP Enterprise Specific Trap Types (snmp_specific_traps)
[Word Count: 7]

• Protobuf Search Paths (protobuf_search_paths)
[Word Count: 5]

• Protobuf UDP Message Types (protobuf_udp_message_types)
[Word Count: 6]

Other UATs are stored in the personal configuration directory and are common to all profiles:
[Word Count: 15]

• MaxMind Database Paths (maxmind_db_paths)
[Word Count: 5]

• RSA Private Keys (rsa_keys) and PKCS #11 Provider Libraries (pkcs11_libs)
[Word Count: 11]

• SMI Modules (smi_modules) and SMI Paths (smi_paths)
[Word Count: 8]

Wireshark uses this table to map ESS Security Category attributes to textual representations. The
[Word Count: 14]

values to put in this table are usually found in an XML SPIF, which is used for defining security
[Word Count: 19]

This table is a user table, as described in User Accessible Tables, with the following fields:
[Word Count: 16]

An Object Identifier representing the Category Tag Set.
[Word Count: 8]

The value (Label And Cert Value) representing the Category.
[Word Count: 9]

The textual representation for the value.
[Word Count: 6]

If your copy of Wireshark supports MaxMind’s MaxMindDB library, you can use their databases to
[Word Count: 15]

match IP addresses to countries, cites, autonomous system numbers, and other bits of information.
[Word Count: 14]

Some databases are available at no cost for registered users, while others require a licensing fee.
[Word Count: 16]

See the MaxMind web site for more information.
[Word Count: 8]

The configuration for the MaxMind database is a user table, as described in User Accessible Tables,
[Word Count: 16]

This specifies a directory containing MaxMind data files. Any files ending with .mmdb will be
[Word Count: 15]

By default Wireshark will always search for data files in /usr/share/GeoIP and /var/lib/GeoIP on
[Word Count: 14]

non-Windows platforms and in C:\ProgramData\GeoIP and C:\GeoIP on Windows. You can put any
[Word Count: 13]

additional search paths here, e.g. C:\Program Files\Wireshark\GeoIP might be a good choice on
[Word Count: 13]

While the default search paths are not listed in the user table, they are in the list
[Word Count: 17]

viewable by opening Help › About Wireshark and selecting the "Folders" tab.
[Word Count: 12]

Previous versions of Wireshark supported MaxMind’s original GeoIP Legacy database format. They
[Word Count: 12]

were configured similar to MaxMindDB files above, except GeoIP files must begin with Geo and end
[Word Count: 16]

with .dat. They are no longer supported and MaxMind stopped distributing GeoLite Legacy
[Word Count: 13]

Wireshark can decrypt WEP and WPA/WPA2/WPA3 in pre-shared (or personal) mode, as well as in
[Word Count: 15]

enterprise mode. Security improvements in more recent 802.11 releases require distinct session
[Word Count: 12]

keys, instead of being able to decipher all traffic to a given access point with a single known
[Word Count: 18]

You can add decryption keys using Wireshark’s IEEE 802.11 preferences. Up to 64 keys are
[Word Count: 15]

Go to Edit › Preferences › Protocols › IEEE 802.11, or, from the pop-up menu in the "Packet List" or
[Word Count: 20]

"Packet Details" pane from a frame that contains IEEE 802.11, Protocol Preferences › IEEE 802.11
[Word Count: 15]

wireless LAN. You should see a window that looks like this:
[Word Count: 11]

Figure 136. "IEEE 802.11 wireless LAN" preferences
[Word Count: 7]

Click on the "Edit…" button next to "Decryption Keys" to add keys. You should see a window that
[Word Count: 18]

When you click the + button to add a new key, there are five key types you can choose from: wep,
[Word Count: 21]

wpa-pwd, wpa-psk, tk, or msk. The correct key type(s) depend on the Cipher Suite and
[Word Count: 15]

Authentication and Key Management Suite (AKMS) used to encrypt the wireless traffic.
[Word Count: 12]

The key must be provided as a string of hexadecimal numbers, with or without colons, and will
[Word Count: 17]

be parsed as a WEP key. WEP keys can be 40-bit (5 bytes, or 10 hexadecimal characters), 104-bit,
[Word Count: 18]

The password and SSID are used to create a raw pre-shared WPA key. The password can be
[Word Count: 17]

between 8 and 63 characters, and the SSID can be up to 32 bytes. (Typically both are printable
[Word Count: 18]

ASCII, but that is not a hard limitation of the specification, only a recommendation.)
[Word Count: 14]

You can optionally omit the colon and SSID, and Wireshark will try to decrypt packets using the
[Word Count: 17]

last-seen SSID. This may not work for captures taken in busy environments, since the last-seen SSID
[Word Count: 16]

The WPA passphrase and SSID let you encode non-printable or otherwise
[Word Count: 11]

troublesome characters using URI-style percent escapes, e.g., %20 for a space. As a
[Word Count: 13]

result you have to escape the percent characters themselves using %25. You also
[Word Count: 13]

must escape colons in the passphrase or SSID themselves as %3a, in order to
[Word Count: 14]

distinguish them from a colon as a separator between the passphrase and SSID.
[Word Count: 13]

The WPA pass-phrase and SSID method is for WPA/WPA2-Personal only. It will
[Word Count: 12]

not work for WPA3-Personal, which uses SAE (Simultaneous Authentication of
[Word Count: 10]

Equals), nor for the Enterprise / 802.1X / EAP modes.
[Word Count: 10]

The key must be provided as a hexadecimal string, and is parsed as a PSK (Pre-Shared Key) or
[Word Count: 18]

PMK (Pairwise Master Key). For WPA/WPA2-Personal, the PSK and the PMK are identical, and
[Word Count: 14]

directly derived from the passphrase and SSID above. The keys can be 256 bits (32 bytes, 64 hex
[Word Count: 18]

characters) or 384 bits (48 bytes, 96 hex characters).
[Word Count: 9]

The key must be provided as a hexadecimal string, and is parsed as a PTK (Pairwise Transient
[Word Count: 17]

Key) or GTK (Group Temporal Key). The keys can be 16 or 32 bytes (128 or 256 bits), depending
[Word Count: 19]

on the cipher suite used. (5 and 13 byte WEP TKs are not yet supported.)
[Word Count: 15]

The key must be provided as a hexadecimal string, and is parsed as a MSK (Master Session Key).
[Word Count: 18]

This is used for FT-EAP (IEEE 802.11r Fast BSS Transition with EAP authentication). The key can
[Word Count: 16]

Figure 138. 802.11 Decryption Key Examples
[Word Count: 6]

Along with decryption keys there are other preference settings that affect decryption.
[Word Count: 12]

• Make sure Enable decryption is selected.
[Word Count: 7]

• You may have to toggle Assume Packets Have FCS and Ignore the Protection bit depending
[Word Count: 16]

on how your 802.11 driver delivers frames.
[Word Count: 7]

WPA and WPA2 use keys derived from an EAPOL handshake, which occurs when a machine joins a
[Word Count: 17]

Wi-Fi network, to encrypt traffic. Unless all four handshake packets are present for the session
[Word Count: 15]

you’re trying to decrypt, Wireshark won’t be able to decrypt the traffic. You can use the display
[Word Count: 17]

filter eapol to locate EAPOL packets in your capture.
[Word Count: 9]

In order to capture the handshake for a machine, you will need to force the machine to (re-)join the
[Word Count: 19]

network while the capture is in progress. One way to do this is to put the machine to sleep (for
[Word Count: 20]

smartphones and tablets, "turning off" the machine puts it to sleep) before you start the capture,
[Word Count: 16]

start the capture, and then wake the machine up. You will need to do this for all machines whose
[Word Count: 19]

If a TK is provided as a key, then the EAPOL 4-way handshake is not necessary, as the TK is what the
[Word Count: 22]

handshake derives. However, all available TKs will be tried agi
[Word Count: 10]

WPA and WPA2 use individual keys for each device. Wireshark is able to handle up to 256 active
[Word Count: 18]

associations, which should be enough in most circumstances. Nevertheless, if a capture has too
[Word Count: 14]

many devices and too many associations, then while the packet list may show all packets decoded
[Word Count: 16]

on the first pass, randomly accessing different packets in the packet details will result in some
[Word Count: 16]

packets failing to be properly deciphered.
[Word Count: 6]

Filtering out only the relevant packets (e.g. with "wlan.addr") and saving into a new file should get
[Word Count: 17]

decryption working in all cases, though it may require editing keys in the preferences or restarting
[Word Count: 16]

Wireshark in order to free used associations. For the same reason, it is possible to be able to decode
[Word Count: 19]

packets in a capture file without any EAPOL packets in it, as long as Wireshark did see the
[Word Count: 18]

handshake for this communication in another capture without being restarted or editing keys. This
[Word Count: 14]

can sometimes lead to exporting selected packets to a new file, opening that file and decoding
[Word Count: 16]

seeming to work, but then decoding suddenly fail on the new file after Wireshark is restarted or
[Word Count: 17]

keys are edited. If decoding suddenly stops working on a capture make sure the needed EAPOL
[Word Count: 16]

As long as you can somehow extract the PMK from either the client or the Radius Server and
[Word Count: 18]

configure the key (as PSK) all supported Wireshark versions will decode the traffic just fine up to
[Word Count: 17]

EAPoL rekey is often enabled for WPA/WPA2 enterprise and will change the used encryption key
[Word Count: 15]

similar to the procedure for the initial connect, but it can also be configured and used for pre-
[Word Count: 18]

Decrypting IEEE 802.11r Fast BSS Transition roaming requires capturing reassociation frames for
[Word Count: 12]

similar reasons, and is supported by recent Wireshark versions.
[Word Count: 9]

In WPA3, a different PMK is used for each connection in order to achieve forward secrecy.
[Word Count: 16]

Capturing the 4-way handshake and knowing the network password is not enough to decrypt
[Word Count: 14]

packets; you must obtain the PMK from either the client or access point (typically by enabling
[Word Count: 16]

logging in wpa_supplicant or hostapd with the -d -K flags) and use this as the decryption key in
[Word Count: 18]

Wireshark. Even then, the decryption will only work for packets between that client and access
[Word Count: 15]

point, not for all devices on that network.
[Word Count: 8]

The TKs are the actual transient keys used to encrypt packets, which are derived during the
[Word Count: 16]

handshake. If known, they can decrypt packets without having the handshake packets in a capture.
[Word Count: 15]

However, having TKs as encryption keys in the table will affect IEEE 802.11 dissector performance
[Word Count: 15]

as each encrypted packet will be tested against every TK until decryption is successful. If the table is
[Word Count: 18]

configured with many TKs, none of which match any encrypted frame in the capture, performance
[Word Count: 15]

Once a match is found, an association is formed similar to in the usual method and decryption of
[Word Count: 18]

other frames with the same key should be on par with normal decryption flow. Thus, if most frames
[Word Count: 18]

in the capture match TKs (or other keys), and only a limited number of TKs are configured, the
[Word Count: 18]

Wireshark can decrypt Encrypted Payloads of IKEv2 (Internet Key Exchange version 2) packets if
[Word Count: 14]

necessary information is provided. Note that you can decrypt only IKEv2 packets with this feature.
[Word Count: 15]

If you want to decrypt IKEv1 packets or ESP packets, use Log Filename setting under ISAKMP
[Word Count: 16]

protocol preference or settings under ESP protocol preference respectively.
[Word Count: 9]

This is handled by a user table, as described in User Accessible Tables, with the following fields:
[Word Count: 17]

Initiator’s SPI of the IKE_SA. This field takes hexadecimal string without “0x” prefix and the
[Word Count: 15]

length must be 16 hex chars (represents 8 octets).
[Word Count: 9]

Responder’s SPI of the IKE_SA. This field takes hexadecimal string without “0x” prefix and the
[Word Count: 15]

length must be 16 hex chars (represents 8 octets).
[Word Count: 9]

Key used to encrypt/decrypt IKEv2 packets from initiator to responder. This field takes
[Word Count: 13]

hexadecimal string without “0x” prefix and its length must meet the requirement of the
[Word Count: 14]

Key used to encrypt/decrypt IKEv2 packets from responder to initiator. This field takes
[Word Count: 13]

hexadecimal string without “0x” prefix and its length must meet the requirement of the
[Word Count: 14]

Key used to calculate Integrity Checksum Data for IKEv2 packets from responder to initiator.
[Word Count: 14]

This field takes hexadecimal string without “0x” prefix and its length must meet the requirement
[Word Count: 15]

Key used to calculate Integrity Checksum Data for IKEv2 packets from initiator to responder.
[Word Count: 14]

This field takes hexadecimal string without “0x” prefix and its length must meet the requirement
[Word Count: 15]

Many protocols that use ASN.1 use Object Identifiers (OIDs) to uniquely identify certain pieces of
[Word Count: 15]

information. In many cases, they are used in an extension mechanism so that new object identifiers
[Word Count: 16]

(and associated values) may be defined without needing to change the base standard.
[Word Count: 13]

While Wireshark has knowledge about many of the OIDs and the syntax of their associated values,
[Word Count: 16]

the extensibility means that other values may be encountered.
[Word Count: 9]

Wireshark uses this table to allow the user to define the name and syntax of Object Identifiers that
[Word Count: 18]

Wireshark does not know about (for example, a privately defined X.400 extension). It also allows
[Word Count: 15]

the user to override the name and syntax of Object Identifiers that Wireshark does know about
[Word Count: 16]

(e.g., changing the name “id-at-countryName” to just “c”).
[Word Count: 8]

This table is a user table, as described in User Accessible Tables, with the following fields:
[Word Count: 16]

The string representation of the Object Identifier e.g., “2.5.4.6”.
[Word Count: 9]

The name that should be displayed by Wireshark when the Object Identifier is dissected e.g.,
[Word Count: 15]

The syntax of the value associated with the Object Identifier. This must be one of the syntaxes
[Word Count: 17]

that Wireshark already knows about (e.g., “PrintableString”).
[Word Count: 7]

Wireshark uses this table to map a presentation context identifier to a given object identifier when
[Word Count: 16]

the capture does not contain a PRES package with a presentation context definition list for the
[Word Count: 16]

This table is a user table, as described in User Accessible Tables, with the following fields:
[Word Count: 16]

An Integer representing the presentation context identifier for which this association is valid.
[Word Count: 13]

The object identifier representing the abstract syntax name, which defines the protocol that is
[Word Count: 14]

Wireshark uses this table to map specific protocols to a certain DPC/SSN combination for SCCP.
[Word Count: 15]

This table is a user table, as described in User Accessible Tables, with the following fields:
[Word Count: 16]

An Integer representing the network indicator for which this association is valid.
[Word Count: 12]

A range of integers representing the dpcs for which this association is valid.
[Word Count: 13]

A range of integers representing the ssns for which this association is valid.
[Word Count: 13]

The protocol that is carried over this association
[Word Count: 8]

If your copy of Wireshark supports libSMI, you can specify a list of MIB and PIB modules here. The
[Word Count: 19]

COPS and SNMP dissectors can use them to resolve OIDs.
[Word Count: 10]

If your copy of Wireshark supports libSMI, you can specify one or more paths to MIB and PIB
[Word Count: 18]

A module directory, e.g., /usr/local/snmp/mibs. Wireshark automatically uses the standard SMI
[Word Count: 11]

path for your system, so you usually don’t have to add anything here.
[Word Count: 13]

Wireshark uses this table to map specific-trap values to user defined descriptions in a Trap PDU.
[Word Count: 16]

The description is shown in the packet details specific-trap element.
[Word Count: 10]

This table is a user table, as described in User Accessible Tables, with the following fields:
[Word Count: 16]

The object identifier representing the object generating the trap.
[Word Count: 9]

An Integer representing the specific-trap code.
[Word Count: 6]

The description to show in the packet details.
[Word Count: 8]

Wireshark uses this table to verify authentication and to decrypt encrypted SNMPv3 packets.
[Word Count: 13]

This table is a user table, as described in User Accessible Tables, with the following fields:
[Word Count: 16]

If given this entry will be used only for packets whose engine id is this. This field takes a
[Word Count: 19]

hexadecimal string in the form 0102030405.
[Word Count: 6]

This is the userName. When a single user has more than one password for different SNMP-
[Word Count: 16]

engines the first entry to match both is taken, if you need a catch all engine-id (empty) that entry
[Word Count: 19]

Which auth model to use (either “MD5”, “SHA1”, "SHA2-224", "SHA2-256", "SHA2-384" or "SHA2-
[Word Count: 13]

The authentication password. Use \xDD for unprintable characters. A hexadecimal password
[Word Count: 11]

must be entered as a sequence of \xDD characters. For example, the hex password 010203040506
[Word Count: 15]

must be entered as \x01\x02\x03\x04\x05\x06. The \ character must be treated as an unprintable
[Word Count: 14]

character, i.e., it must be entered as \x5C or \x5c.
[Word Count: 10]

Which encryption algorithm to use (either “DES”, “AES”, "AES192" or "AES256").
[Word Count: 11]

The privacy password. Use \xDD for unprintable characters. A hexadecimal password must be
[Word Count: 13]

entered as a sequence of \xDD characters. For example, the hex password 010203040506 must be
[Word Count: 15]

entered as \x01\x02\x03\x04\x05\x06. The \ character must be treated as an unprintable character,
[Word Count: 13]

i.e., it must be entered as \x5C or \x5c.
[Word Count: 9]

Which method to use to expand the key when the generated key provides too few bytes for the
[Word Count: 18]

selected encryption method (either based on "draft-reeder-snmpv3-usm-3desede-00" or as
[Word Count: 9]

The Tektronix K12xx/15 rf5 file format uses helper files (*.stk) to identify the various protocols that
[Word Count: 16]

are used by a certain interface. Wireshark doesn’t read these stk files, it uses a table that helps it
[Word Count: 19]

identify which lowest layer protocol to use.
[Word Count: 7]

Stk file to protocol matching is handled by a user table, as described in User Accessible Tables, with
[Word Count: 18]

A partial match for an stk filename, the first match wins, so if you have a specific case and a
[Word Count: 20]

general one the specific one must appear first in the list.
[Word Count: 11]

This is the name of the encapsulating protocol (the lowest layer in the packet data) it can be
[Word Count: 18]

either just the name of the protocol (e.g., mtp2, eth_withoutfcs, sscf-nni ) or the name of the
[Word Count: 17]

encapsulation protocol and the “application” protocol over it separated by a colon (e.g.,
[Word Count: 13]

sscop:sscf-nni, sscop:alcap, sscop:nbap, …)
[Word Count: 4]

When a pcap file uses one of the user DLTs (147 to 162) Wireshark uses this table to know which
[Word Count: 20]

This table is a user table, as described in User Accessible Tables, with the following fields:
[Word Count: 16]

This is the name of the payload dissector (the lowest layer in the packet data). (e.g., “eth_withfcs,
[Word Count: 17]

"eth_withoutfcs”, and "eth_maybefcs" respectively for Ethernet frames that do, do not, or might
[Word Count: 13]

possibly include the FCS at the end, “ip” for trying IPv4 then IPv6)
[Word Count: 13]

If there is a header (before the payload) this tells which size this header is. A value of 0 disables
[Word Count: 20]

The name of the header dissector to be used (uses “data” as default).
[Word Count: 13]

If there is a trailer (after the payload) this tells which size this trailer is. A value of 0 disables the
[Word Count: 21]

The name of the trailer dissector to be used (uses “data” as default).
[Word Count: 13]

The binary wire format of Protocol Buffers (Protobuf) messages are not self-described protocol. For
[Word Count: 14]

example, the varint wire type in protobuf packet may be converted to int32, int64, uint32, uint64,
[Word Count: 16]

sint32, sint64, bool or enum field types of protocol buffers language. Wireshark should be
[Word Count: 14]

configured with Protocol Buffers language files (*.proto) to enable proper dissection of protobuf
[Word Count: 13]

data (which may be payload of gRPC) based on the message, enum and field definitions.
[Word Count: 15]

You can specify protobuf search paths at the Protobuf protocol preferences. For example, if you
[Word Count: 15]

defined a proto file with path d:/my_proto_files/helloworld.proto and the helloworld.proto
[Word Count: 10]

contains a line of import "google/protobuf/any.proto"; because the any type of official protobuf
[Word Count: 13]

library 
is 
used. 
And 
the 
real 
path 
of 
any.proto 
is 
d:/protobuf-
[Word Count: 11]

3.4.1/include/google/protobuf/any.proto. You should add the d:/protobuf-3.4.1/include/ and
[Word Count: 7]

d:/my_proto_files paths into protobuf search paths.
[Word Count: 6]

The configuration for the protobuf search paths is a user table, as described in User Accessible
[Word Count: 16]

This specifies a directory containing protobuf source files. For example, d:/protobuf-
[Word Count: 11]

3.4.1/include/ 
and 
d:/my_proto_files 
in 
Windows, 
or 
/usr/include/ 
and
[Word Count: 8]

/home/alice/my_proto_files in Linux/UNIX.
[Word Count: 3]

If this option is enabled, Wireshark will load all *.proto files in this directory and its
[Word Count: 16]

subdirectories when Wireshark startup or protobuf search paths preferences changed. Note that
[Word Count: 12]

the source directories that configured to protobuf official or third libraries path (like
[Word Count: 13]

d:/protobuf-3.4.1/include/) should not be set to load all files, that may cause unnecessary
[Word Count: 13]

If the payload of UDP on certain ports is Protobuf encoding, Wireshark use this table to know which
[Word Count: 18]

Protobuf message type should be used to parsing the data on the specified UDP port(s).
[Word Count: 15]

The configuration for UDP Port(s) to Protobuf message type maps is a user table, as described in
[Word Count: 17]

User Accessible Tables, with the following fields:
[Word Count: 7]

The range of UDP ports. The format may be "8000" or "8000,8008-8088,9080".
[Word Count: 12]

The Protobuf message type as which the data on the specified udp port(s) should be parsed. The
[Word Count: 17]

message type is allowed to be empty, that means let Protobuf to dissect the data on specified UDP
[Word Count: 18]

ports as normal wire type without precise definitions.
[Word Count: 8]

Tips: You can create your own dissector to call Protobuf dissector. If your dissector is written in C
[Word Count: 18]

language, you can pass the message type to Protobuf dissector by data parameter of
[Word Count: 14]

call_dissector_with_data() function. If your dissector is written in Lua, you can pass the message
[Word Count: 14]

type 
to 
Protobuf 
dissector 
by 
pinfo.private["pb_msg_type"]. 
The 
format 
of 
data 
and
[Word Count: 11]

the helloworld is package name, HelloRequest is message type.
[Word Count: 9]

What is MATE? Well, to keep it very short, with MATE you can create user configurable extension(s)
[Word Count: 17]

MATE’s goal is to enable users to filter frames based on information extracted from related frames
[Word Count: 16]

or information on how frames relate to each other. MATE was written to help troubleshooting
[Word Count: 15]

gateways and other systems where a "use" involves more protocols. However, MATE can be used as
[Word Count: 16]

well to analyze other issues regarding an interaction between packets like response times,
[Word Count: 13]

incompleteness of transactions, presence/absence of certain attributes in a group of Protocol Data
[Word Count: 13]

MATE is a Wireshark plugin that allows the user to specify how different frames are related to each
[Word Count: 18]

other. To do so, MATE extracts data from the frames' tree and then, using that information, tries to
[Word Count: 18]

group the frames based on how MATE is configured. Once the PDUs are related, MATE will create a
[Word Count: 18]

"protocol" tree with fields the user can filter with. The fields will be almost the same for all the
[Word Count: 19]

related frames, so one can filter a complete session spanning several frames containing more
[Word Count: 14]

protocols based on an attribute appearing in some related frame. Other than that MATE allows to
[Word Count: 16]

filter frames based on response times, number of PDUs in a group and a lot more.
[Word Count: 16]

• Filter all packets of a call using various protocols knowing just the calling number. (MATE’s
[Word Count: 16]

• Filter all packets of all calls using various protocols based on the release cause of one of its
[Word Count: 19]

• Extrapolate slow transactions from very "dense" captures. (finding requests that timeout)
[Word Count: 12]

• Find incomplete transactions (no responses)
[Word Count: 6]

• Follow requests through more gateways/proxies.
[Word Count: 6]

• Run Wireshark and check if the plugin is installed (MATE should appear in Help→About
[Word Count: 15]

• Get a configuration file e.g., tcp.mate (see Mate/Examples for more) and place it somewhere on
[Word Count: 16]

• Go to Edit→Preferences…→Protocols→MATE and set the Configuration Filename to the file you
[Word Count: 13]

• Load a corresponding capture file (e.g., http.cap) and see if MATE has added some new display
[Word Count: 17]

filter fields, something like: mate tcp_pdu:1→tcp_ses:1 or, at prompt: path_to/wireshark -o
[Word Count: 11]

If everything went well, your packet details might look something like this:
[Word Count: 12]

Figure 139. Packet Details - MATE TCP Session (tcp.mate)
[Word Count: 9]

MATE creates a filterable tree based on information contained in frames that share some
[Word Count: 14]

relationship with information obtained from other frames. The way these relationships are made is
[Word Count: 14]

described in a configuration file. The configuration file tells MATE what makes a PDU and how to
[Word Count: 17]

MATE analyzes each frame to extract relevant information from the "protocol" tree of that frame.
[Word Count: 15]

The extracted information is contained in MATE PDUs; these contain a list of relevant attributes
[Word Count: 15]

taken from the tree. From now on, I will use the term "PDU" to refer to the objects created by MATE
[Word Count: 21]

containing the relevant information extracted from the frame; I’ll use "frame" to refer to the "raw"
[Word Count: 16]

information extracted by the various dissectors that pre-analyzed the frame.
[Word Count: 10]

For every PDU, MATE checks if it belongs to an existing "Group of PDUs" (GOP). If it does, it assigns
[Word Count: 20]

the PDU to that GOP and moves any new relevant attributes to the GOP’s attribute list. How and
[Word Count: 18]

when do PDUs belong to GOPs is described in the configuration file as well.
[Word Count: 14]

Every time a GOP is assigned a new PDU, MATE will check if it matches the conditions to make it
[Word Count: 20]

belong to a "Group of Groups" (GOG). Naturally the conditions that make a GOP belong to a GOG are
[Word Count: 19]

taken from the configuration file as well.
[Word Count: 7]

Once MATE is done analyzing the frame it will be able to create a "protocol" tree for each frame
[Word Count: 19]

based on the PDUs, the GOPs they belong to and naturally any GOGs the former belongs to.
[Word Count: 17]

How to tell MATE what to extract, how to group it and then how to relate those groups is made
[Word Count: 20]

Information in MATE is contained in Attribute Value Pairs (AVPs). AVPs are made of two strings: the
[Word Count: 17]

name and the value. AVPs are used in the configuration and there they have an operator as well.
[Word Count: 18]

There are various ways AVPs can be matched against each other using those operators.
[Word Count: 14]

AVPs are grouped into AVP Lists (AVPLs). PDUs, GOPs and GOGs have an AVPL each. Their AVPLs
[Word Count: 17]

will be matched in various ways against others coming from the configuration file.
[Word Count: 13]

MATE will be instructed how to extract AVPs from frames in order to create a PDU with an AVPL. It
[Word Count: 20]

will be instructed as well, how to match that AVPL against the AVPLs of other similar PDUs in order
[Word Count: 19]

to relate them. In MATE the relationship between PDUs is a GOP, it has an AVPL as well. MATE will
[Word Count: 20]

be configured with other AVPLs to operate against the GOP’s AVPL to relate GOPs together into
[Word Count: 16]

A good understanding on how AVPs and AVPLs work is fundamental to understand how MATE
[Word Count: 15]

MATE was originally written by Luis Ontanon, a Telecommunications systems troubleshooter, as a
[Word Count: 13]

way to save time filtering out the packets of a single call from huge capture files using just the
[Word Count: 19]

calling number. Later he used the time he had saved to make it flexible enough to work with
[Word Count: 18]

protocols other than the ones he was directly involved with.
[Word Count: 10]

Information used by MATE to relate different frames is contained in Attribute Value Pairs (AVPs).
[Word Count: 15]

AVPs are made of two strings - the name and the value. When AVPs are used in the configuration,
[Word Count: 19]

an operator is defined as well. There are various ways AVPs can be matched against each other
[Word Count: 17]

avp_name="avp's value"
  another_name= "1234 is the value"
[Word Count: 7]

The name is a string used to refer to a "type" of an AVP. Two AVPs won’t match unless their names
[Word Count: 21]

The name must start with a lowercase letter (a-z) and can contain only alphanumeric characters (a-
[Word Count: 16]

zA-Z0-9) and the special characters "_", "-", and ".". The name ends with an operator.
[Word Count: 15]

You should not use uppercase characters in names, or names that start with “.” or “_”. Capitalized
[Word Count: 17]

names are reserved for configuration parameters (we’ll call them keywords); nothing forbids you
[Word Count: 13]

from using capitalized strings for other things as well but it probably would be confusing. I’ll avoid
[Word Count: 17]

using capitalized words for anything but the keywords in this document, the reference manual, the
[Word Count: 15]

examples and the base library. Names that start with a “.” would be very confusing as well because
[Word Count: 18]

in the old grammar, AVPL transforms use names starting with a “.” to indicate they belong to the
[Word Count: 18]

The value is a string that is either set in the configuration (for configuration AVPs) or by Wireshark
[Word Count: 18]

while extracting interesting fields from a frame’s tree. The values extracted from fields use the
[Word Count: 15]

same representation as they do in filter strings except that no quotes are used.
[Word Count: 14]

The value will be dealt with as a string even if it is a number. If there are any spaces in the
[Word Count: 22]

value, the value must be between quotes "". Values that are also keywords such as True and False
[Word Count: 18]

should also be wrapped in quotes ("True", "False").
[Word Count: 8]

ip_addr=10.10.10.11
   tcp_port=1234
   binary_data=01:23:45:67:89:ab:cd:ef
   parameter12=0x23aa
   parameter_with_spaces="this value has spaces"
[Word Count: 8]

The way two AVPs with the same name might match is described by the operator. Remember two
[Word Count: 17]

AVPs won’t match unless their names are identical. In MATE, match operations are always made
[Word Count: 15]

between the AVPs extracted from frames (called data AVPs) and the configuration’s AVPs.
[Word Count: 13]

Currently defined MATE AVP match operators are:
[Word Count: 7]

• Equal = will match if the string given completely matches the data AVP’s value string
[Word Count: 16]

• Not Equal ! will match only if the given value string is not equal to the data AVP’s value string
[Word Count: 21]

• One Of {} will match if one of the possible strings listed is equal to the data AVP’s value string
[Word Count: 21]

• Starts With ^ will match if the string given matches the first characters of the data AVP’s value
[Word Count: 19]

• Ends With $ will match if the string given matches the last characters of the data AVP’s value
[Word Count: 19]

• Contains ~ will match if the string given matches any substring of the data AVP’s value string
[Word Count: 18]

• Lower Than < will match if the data AVP’s value string is semantically lower than the string
[Word Count: 18]

• Higher Than > will match if the data AVP’s value string is semantically higher than the string
[Word Count: 18]

• Exists ? (the ? can be omitted) will match as far as a data AVP of the given name exists
[Word Count: 21]

An AVPL is a set of diverse AVPs that can be matched against other AVPLs. Every PDU, GOP and GOG
[Word Count: 20]

has an AVPL that contains the information regarding it. The rules that MATE uses to group PDUs
[Word Count: 17]

There will never be two identical AVPs in a given AVPL. However, we can have more than one
[Word Count: 18]

AVP with the same name in an AVPL as long as their values are different.
[Word Count: 15]

( addr=10.20.30.40, addr=192.168.0.1, tcp_port=21, tcp_port=32534, user_cmd=PORT,
        data_port=12344, data_addr=192.168.0.1 )
  ( addr=10.20.30.40, addr=192.168.0.1, channel_id=22:23, message_type=Setup,
        calling_number=1244556673 )
  ( addr=10.20.30.40, addr=192.168.0.1, ses_id=01:23:45:67:89:ab:cd:ef )
  ( user_id=pippo, calling_number=1244556673, assigned_ip=10.23.22.123 )
[Word Count: 26]

• data AVPLs that contain information extracted from frames.
[Word Count: 9]

• configuration AVPLs that come from the configuration and are used to tell MATE how to relate
[Word Count: 17]

Data AVPLs can be operated against configuration AVPLs in various ways:
[Word Count: 11]

• Loose Match: Will match if at least one of the AVPs of each AVPL match. If it matches it will
[Word Count: 21]

return an AVPL containing all AVPs from the data AVPL that did match the configuration AVPs.
[Word Count: 16]

• "Every" Match: Will match if none of the AVPs of the configuration AVPL fails to match a present
[Word Count: 19]

AVP in the data AVPL, even if not all of the configuration AVPs have a match. If it matches it will
[Word Count: 21]

return an AVPL containing all AVPs from the data AVPL that did match one AVP in the
[Word Count: 17]

• Strict Match: Will match if and only if every one of the configuration AVPs have at least one
[Word Count: 19]

match in the data AVPL. If it matches it will return an AVPL containing the AVPs from the data
[Word Count: 19]

• There’s also a Merge operation that is to be performed between AVPLs where all the AVPs that
[Word Count: 18]

don’t exist in the data AVPL but exist in the configuration will be added to the data AVPL.
[Word Count: 18]

• Other than that, there are Transforms - a combination of a match AVPL and an AVPL to merge.
[Word Count: 19]

MATE’s analysis of a frame is performed in three phases:
[Word Count: 10]

• In the first phase, MATE attempts to extract a MATE PDU from the frame’s protocol tree. MATE
[Word Count: 18]

will create a PDU if MATE’s config has a Pdu declaration whose Proto is contained in the frame.
[Word Count: 18]

• In the second phase, if a PDU has been extracted from the frame, MATE will try to group it to
[Word Count: 21]

other PDUs into a GOP (Group of PDUs) by matching the key criteria given by a Gop declaration.
[Word Count: 18]

If there is no GOP yet with the key criteria for the PDU, MATE will try to create a new GOP for it
[Word Count: 23]

if it matches the Start criteria given in the Gop declaration.
[Word Count: 11]

• In the third phase, if there’s a GOP for the PDU, MATE will try to group this GOP with other GOPs
[Word Count: 22]

into a GOG (Group of Groups) using the criteria given by the Member criteria of a Gog
[Word Count: 17]

Figure 140. MATE Analysis (PDU→GOP→GOG) flowchart
[Word Count: 6]

The extraction and matching logic comes from MATE’s configuration; MATE’s configuration file is
[Word Count: 13]

specified by the mate.config preference. By default it is an empty string which means: do not
[Word Count: 16]

The config file tells MATE what to look for in frames; How to make PDUs out of it; How will PDUs be
[Word Count: 22]

related to other similar PDUs into GOPs; And how GOPs relate into GOGs.
[Word Count: 13]

The MATE configuration file is a list of declarations. There are 4 types of declarations: Transform,
[Word Count: 16]

Pdu, Gop, and Gog. A Transform block must be before any of the other block declarations that may
[Word Count: 18]

MATE will look in the tree of every frame to see if there is useful data to extract, and if there is, it
[Word Count: 23]

will create one or more PDU objects containing the useful information.
[Word Count: 11]

The first part of MATE’s analysis is the "PDU extraction".
[Word Count: 10]

MATE will make a PDU for each different proto field of Proto type present in the frame. MATE will
[Word Count: 19]

fetch from the field’s tree those fields that are defined in the PDU declaration block declaration
[Word Count: 16]

whose initial offset in the frame is within the boundaries of the current Proto and those of the
[Word Count: 18]

Pdu dns_pdu Proto dns Transport ip {
    Extract addr From ip.addr;
    Extract dns_id From dns.id;
    Extract dns_resp From dns.flags.response;
};
[Word Count: 20]

Figure 141. Wireshark window - fields for PDU extraction
[Word Count: 9]

Once MATE has found a Proto field for which to create a PDU from the frame it will move
[Word Count: 19]

backwards in the frame looking for the respective Transport fields. After that it will create AVPs
[Word Count: 16]

named as each of those given in the rest of the AVPL for every instance of the fields declared as its
[Word Count: 21]

Figure 142. Frame fields mapped to PDU attributes
[Word Count: 8]

Sometimes we need information from more than one Transport protocol. In that case MATE will
[Word Count: 15]

check the frame looking backwards to look for the various Transport protocols in the given stack.
[Word Count: 16]

MATE will choose only the closest transport boundary per "protocol" in the frame.
[Word Count: 13]

This way we’ll have all PDUs for every Proto that appears in a frame match its relative transports.
[Word Count: 18]

Pdu isup_pdu Proto isup Transport mtp3/ip {
    Extract addr From ip.addr;
[Word Count: 11]

Extract m3pc From mtp3.dpc;
    Extract m3pc From mtp3.opc;
[Word Count: 8]

Extract cic From isup.cic;
    Extract isup_msg From isup.message_type;
};
[Word Count: 9]

Figure 143. Frame containing multiple PDUs
[Word Count: 6]

This allows to assign the right Transport to the PDU avoiding duplicate transport protocol entries
[Word Count: 15]

(in case of tunneled ip over ip for example).
[Word Count: 9]

Pdu ftp_pdu Proto ftp Transport tcp/ip {
    Extract addr From ip.addr;
[Word Count: 11]

Extract port From tcp.port;
    Extract ftp_cmd From ftp.command;
};
[Word Count: 9]

Figure 144. Frame with encapsulated (tunneled) fields
[Word Count: 7]

Other than the mandatory Transport there is also an optional Payload statement, which works
[Word Count: 14]

pretty much as Transport but refers to elements after the Proto's range. It is useful in those cases
[Word Count: 18]

where the payload protocol might not appear in a PDU but nevertheless the PDU belongs to the
[Word Count: 17]

Pdu mmse_over_http_pdu Proto http Transport tcp/ip {
[Word Count: 7]

Extract addr From ip.addr;
    Extract port From tcp.port;
[Word Count: 8]

Extract content From http.content_type;
    Extract host From http.host;
    Extract http_rq From http.request;
    Extract method From http.request.method;
    Extract resp From http.response.code;
[Word Count: 20]

Extract msg_type From mmse.message_type;
    Extract notify_status From mmse.status;
    Extract send_status From mmse.response_status;
    Extract trx From mmse.transaction_id;
};
[Word Count: 17]

There might be cases in which we won’t want MATE to create a PDU unless some of its extracted
[Word Count: 19]

attributes meet or do not meet some criteria. For that we use the Criteria statements of the Pdu
[Word Count: 18]

Pdu isup_pdu Proto isup Transport mtp3/ip {
    ...
[Word Count: 8]

// MATE will create isup_pdu PDUs only when there is not a point code '1234'
    Criteria Reject Strict (m3pc=1234);
};
[Word Count: 20]

Pdu ftp_pdu Proto ftp Transport tcp/ip {
    ...
[Word Count: 8]

// MATE will create ftp_pdu PDUs only when they go to port 21 of our ftp_server
    Criteria Accept Strict (addr=10.10.10.10, port=21);
};
[Word Count: 22]

The Criteria statement is given an action (Accept or Reject), a match type (Strict, Loose or Every) and
[Word Count: 18]

an AVPL against which to match the currently extracted one.
[Word Count: 10]

Once the fields have been extracted into the PDU’s AVPL, MATE will apply any declared Transform
[Word Count: 16]

to it. The way transforms are applied and how they work is described later on. However, it’s useful
[Word Count: 18]

to know that once the AVPL for the PDU is created, it may be transformed before being analyzed.
[Word Count: 18]

That way we can massage the data to simplify the analysis.
[Word Count: 11]

Every successfully created PDU will add a MATE tree to the frame dissection. If the PDU is not
[Word Count: 18]

related to any GOP, the tree for the PDU will contain just the PDU’s info. If it is assigned to a GOP, the
[Word Count: 23]

tree will also contain the GOP items, and the same applies for the GOG level.
[Word Count: 15]

mate dns_pdu:1
    dns_pdu: 1
        dns_pdu time: 3.750000
        dns_pdu Attributes
            dns_resp: False
            dns_id: 0x8cac
            addr: 10.194.4.11
            addr: 10.194.24.35
[Word Count: 17]

The PDU’s tree contains some filterable fields
[Word Count: 7]

• mate.dns_pdu will contain the number of the "dns_pdu" PDU
[Word Count: 10]

• mate.dns_pdu.RelativeTime will contain the time passed since the beginning of the capture in
[Word Count: 14]

• the tree will contain the various attributes of the PDU as well, these will all be strings (to be
[Word Count: 20]

used in filters as "10.0.0.1", not as 10.0.0.1)
[Word Count: 8]

Once MATE has created the PDUs it passes to the PDU analysis phase. During the PDU analysis
[Word Count: 17]

phase MATE will try to group PDUs of the same type into 'Groups of PDUs' (aka GOPs) and copy
[Word Count: 19]

some AVPs from the PDU’s AVPL to the GOP’s AVPL.
[Word Count: 10]

Figure 146. Grouping PDUs (GOP) flowchart
[Word Count: 6]

Given a PDU, the first thing MATE will do is to check if there is any GOP declaration in the
[Word Count: 20]

configuration for the given PDU type. If so, it will use its Match AVPL to match it against the PDU’s
[Word Count: 20]

AVPL; if they don’t match, the analysis phase is done. If there is a match, the AVPL is the GOP’s
[Word Count: 20]

candidate key which will be used to search the index of GOPs for the GOP to which to assign the
[Word Count: 20]

current PDU. If there is no such GOP and this PDU does not match the Start criteria of a Gop
[Word Count: 20]

declaration for the PDU type, the PDU will remain unassigned and only the analysis phase will be
[Word Count: 17]

Gop ftp_ses On ftp_pdu Match (addr, addr, port, port) {...};
Gop dns_req On dns_pdu Match (addr, addr, dns_id) {...};
Gop isup_leg On isup_pdu Match (m3pc, m3pc, cic) {...};
[Word Count: 28]

If there was a match, the candidate key will be used to search the index of GOPs to see if there is
[Word Count: 22]

already a GOP matching the GOP’s key the same way. If there is such a match in the GOPs collection,
[Word Count: 20]

and the PDU doesn’t match the Start AVPL for its type, the PDU will be assigned to the matching
[Word Count: 19]

GOP. If it is a Start match, MATE will check whether or not that GOP has been already stopped. If the
[Word Count: 21]

GOP has been stopped, a new GOP will be created and will replace the old one in the index of GOPs.
[Word Count: 21]

Gop ftp_ses On ftp_pdu Match (addr, addr, port, port) {
[Word Count: 10]

Gop dns_req On dns_pdu Match (addr, addr, dns_id) {
    Start (dns_resp="True");
};
[Word Count: 12]

Gop isup_leg On isup_pdu Match (m3pc, m3pc, cic) {
    Start (isup_msg=1);
};
[Word Count: 12]

If no Start is given for a GOP, a PDU whose AVPL matches an existing GOP’s key will act as the start
[Word Count: 22]

Once we know a GOP exists and the PDU has been assigned to it, MATE will copy into the GOP’s
[Word Count: 20]

AVPL all the attributes matching the key plus any AVPs of the PDU’s AVPL matching the Extra AVPL.
[Word Count: 18]

Gop ftp_ses On ftp_pdu Match (addr, addr, port, port) {
    Start (ftp_cmd=USER);
    Extra (pasv_prt, pasv_addr);
};
[Word Count: 16]

Gop isup_leg On isup_pdu Match (m3pc, m3pc, cic) {
    Start (isup_msg=1);
    Extra (calling, called);
};
[Word Count: 15]

Once the PDU has been assigned to the GOP, MATE will check whether or not the PDU matches the
[Word Count: 19]

Stop, if it happens, MATE will mark the GOP as stopped. Even after stopped, a GOP may get assigned
[Word Count: 19]

new PDUs matching its key, unless such PDU matches Start. If it does, MATE will instead create a
[Word Count: 18]

Gop ftp_ses On ftp_pdu Match (addr, addr, port, port) {
    Start (ftp_cmd=USER);
    Stop (ftp_cmd=QUIT); // The response to the QUIT command will be assigned to the
same GOP
    Extra (pasv_prt, pasv_addr);
};
[Word Count: 32]

Gop dns_req On dns_pdu Match (addr, addr, dns_id) {
    Start (dns_resp="False");
[Word Count: 11]

Gop isup_leg On isup_pdu Match (m3pc, m3pc, cic) {
    Start (isup_msg=1); // IAM
    Stop (isup_msg=16); // RLC
    Extra (calling, called);
};
[Word Count: 21]

If no Stop criterium is stated for a given GOP, the GOP will be stopped as soon as it is created.
[Word Count: 21]

However, as with any other GOP, PDUs matching the GOP’s key will still be assigned to the GOP
[Word Count: 18]

unless they match a Start condition, in which case a new GOP using the same key will be created. To
[Word Count: 20]

group multiple PDUs that match the Start, add a bogus Stop such as
[Word Count: 13]

Gop frame_ses On frame_pdu Match (frame_time) {
    Start (frame_time);
    Stop (frame_time="FOO");
};
[Word Count: 12]

For every frame containing a PDU that belongs to a GOP, MATE will create a tree for that GOP.
[Word Count: 19]

The example below represents the tree created by the dns_pdu and dns_req examples.
[Word Count: 13]

...
MATE dns_pdu:6->dns_req:1
    dns_pdu: 6
        dns_pdu time: 2.103063
        dns_pdu time since beginning of Gop: 2.103063
        dns_pdu Attributes
            dns_resp: True
            dns_id: 0x8cac
            addr: 10.194.4.11
            addr: 10.194.24.35
    dns_req: 1
        GOP Key:  addr=10.194.4.11; addr=10.194.24.35; dns_id=0x8cac;
        dns_req Attributes
            dns_id: 0x8cac
            addr: 10.194.4.11
            addr: 10.194.24.35
        dns_req Times
            dns_req start time: 0.000000
            dns_req hold time: 2.103063
            dns_req duration: 2.103063
[Word Count: 53]

dns_req number of PDUs: 2
            Start PDU: in frame 1
            Stop PDU: in frame 6 (2.103063 : 2.103063)
[Word Count: 18]

Other than the PDU’s tree, this one contains information regarding the relationship between the
[Word Count: 14]

PDUs that belong to the GOP. That way we have:
[Word Count: 10]

• mate.dns_req which contains the id of this dns_req GOP. This will be present in frames that
[Word Count: 17]

• mate.dns_req.dns_id and mate.dns_req.addr which represent the values of the attributes copied
[Word Count: 12]

◦mate.dns_req.StartTime time (in seconds) passed since beginning of capture until GOP’s
[Word Count: 11]

◦mate.dns_req.Time time passed between the start PDU and the stop PDU assigned to this
[Word Count: 14]

GOP (only created if a Stop criterion has been declared for the GOP and a matching PDU has
[Word Count: 18]

◦mate.dns_req.Duration time passed between the start PDU and the last PDU assigned to this
[Word Count: 14]

• mate.dns_req.NumOfPdus the number of PDUs that belong to this GOP
[Word Count: 11]

◦mate.dns_req.Pdu a filterable list of frame numbers of the PDUs of this GOP
[Word Count: 13]

Note that there are two "timers" for a GOP:
[Word Count: 9]

• Time, which is defined only for GOPs that have been Stopped, and gives the time passed
[Word Count: 17]

• Duration, which is defined for every GOP regardless of its state, and give the time passed
[Word Count: 17]

between its Start PDU and the last PDU that was assigned to that GOP.
[Word Count: 14]

• we can filter for PDUs that belong to GOPs that have been Stopped with mate.xxx.Time
[Word Count: 16]

• we can filter for PDUs that belong to unstopped GOPs with mate.xxx && !mate.xxx.Time
[Word Count: 15]

• we can filter for PDUs that belong to stopped GOPs using mate.xxx.Duration
[Word Count: 13]

• we can filter for PDUs that belong to GOPs that have taken more (or less) time that 0.5s to
[Word Count: 20]

complete with mate.xxx.Time > 0.5 (you can try these also as color filters to find out when
[Word Count: 17]

When GOPs are created, or whenever their AVPL changes, GOPs are (re)analyzed to check if they
[Word Count: 16]

match an existent group of groups (GOG) or can create a new one. The GOP analysis is divided into
[Word Count: 19]

two phases. In the first phase, the still unassigned GOP is checked to verify whether it belongs to an
[Word Count: 19]

already existing GOG or may create a new one. The second phase eventually checks the GOG and
[Word Count: 17]

registers its keys in the index of GOGs.
[Word Count: 8]

Figure 147. Grouping GOPs (GOG) flowchart
[Word Count: 6]

There are several reasons for the author to believe that this feature needs to be reimplemented, so
[Word Count: 17]

probably there will be deep changes in the way this is done in the near future. This section of the
[Word Count: 20]

documentation reflects the version of MATE as of Wireshark 0.10.9; in future releases this will
[Word Count: 15]

The first thing we have to do configuring a GOG is to tell MATE that it exists.
[Word Count: 17]

Then we have to tell MATE what to look for a match in the candidate GOPs.
[Word Count: 16]

Gog http_use {
    Member http_ses (host);
    Member dns_req (host);
};
[Word Count: 10]

Most often, also other attributes than those used for matching would be interesting. In order to
[Word Count: 16]

copy from GOP to GOG other interesting attributes, we might use Extra like we do for GOPs.
[Word Count: 17]

Gog http_use {
    ...
    Extra (cookie);
};
[Word Count: 7]

mate http_pdu:4->http_req:2->http_use:1
    http_pdu: 4
        http_pdu time: 1.309847
        http_pdu time since beginning of Gop: 0.218930
        http_req: 2
            ... (the gop's tree for http_req: 2) ..
        http_use: 1
            http_use Attributes
                host: www.example.com
            http_use Times
                http_use start time: 0.000000
                http_use duration: 1.309847
            number of GOPs: 3
                dns_req: 1
                    ... (the gop's tree for dns_req: 1) ..
[Word Count: 53]

http_req: 1
                    ... (the gop's tree for http_req: 1) ..
                http_req of current frame: 2
[Word Count: 15]

◦mate.http_use.StartTime time (in seconds) passed since beginning of capture until GOG’s
[Word Count: 11]

◦mate.http_use.Duration time elapsed between the first frame of a GOG and the last one
[Word Count: 14]

• mate.http_use.NumOfGops the number of GOPs that belong to this GOG
[Word Count: 11]

• mate.http_use.GopStart the start frame of a GOP
[Word Count: 8]

• mate.http_use.GopStop the stop frame of a GOP
[Word Count: 8]

A Transform is a sequence of Match rules optionally completed with modification of the match
[Word Count: 15]

result by an additional AVPL. Such modification may be an Insert (merge) or a Replace. Transforms
[Word Count: 16]

can be used as helpers to manipulate an item’s AVPL before it is processed further. They come to be
[Word Count: 19]

AVPL Transforms are declared in the following way:
[Word Count: 8]

Transform name {
    Match [Strict|Every|Loose] match_avpl [Insert|Replace] modify_avpl;
    ...
};
[Word Count: 10]

The name is the handle to the AVPL transform. It is used to refer to the transform when invoking it
[Word Count: 20]

The Match declarations instruct MATE what and how to match against the data AVPL and how to
[Word Count: 17]

modify the data AVPL if the match succeeds. They will be executed in the order they appear in the
[Word Count: 19]

The optional match type qualifier (Strict, Every, or Loose) is used to choose the Match type; Strict is
[Word Count: 18]

The optional modification mode qualifier instructs MATE how the modify AVPL should be used:
[Word Count: 14]

• the default value Insert (which may be omitted) causes the modify_avpl to be merged to the
[Word Count: 17]

• Replace causes all the matching AVPs from the data AVPL to be replaced by the modify_avpl.
[Word Count: 17]

The modify_avpl may be an empty one; this comes useful in some cases for both Insert and Replace
[Word Count: 18]

Transform rm_client_from_http_resp1 {
    Match (http_rq); //first match wins so the request won't get the not_rq attribute
inserted
    Match Every (addr) Insert (not_rq); //this line won't be evaluated if the first
one matched so not_rq won't be inserted to requests
};
[Word Count: 40]

Transform rm_client_from_http_resp2 {
    Match (not_rq, client) Replace (); //replace "client and not_rq" with nothing
};
[Word Count: 15]

Transform insert_name_and {
    Match Strict (host=10.10.10.10, port=2345) Insert (name=JohnDoe);
};
[Word Count: 10]

adds name=JohnDoe to the data AVPL if it contains host=10.10.10.10 and port=2345
[Word Count: 12]

Transform insert_name_or {
    Match Loose (host=10.10.10.10, port=2345) Insert (name=JohnDoe);
};
[Word Count: 10]

adds name=JohnDoe to the data AVPL if it contains host=10.10.10.10 or port=2345
[Word Count: 12]

Transform replace_ip_address {
    Match (host=10.10.10.10) Replace (host=192.168.10.10);
};
[Word Count: 8]

replaces the original host=10.10.10.10 by host=192.168.10.10
[Word Count: 6]

Transform add_ip_address {
    Match (host=10.10.10.10) (host=192.168.10.10);
[Word Count: 6]

adds (inserts) host=192.168.10.10 to the AVPL, keeping the original host=10.10.10.10 in it too
[Word Count: 13]

Transform replace_may_be_surprising {
    Match Loose (a=aaaa, b=bbbb) Replace (c=cccc, d=dddd);
 };
[Word Count: 11]

• (a=aaaa, b=eeee) gets transformed to (b=eeee, c=cccc, d=dddd) because a=aaaa did match so it
[Word Count: 15]

got replaced while b=eeee did not match so it has been left intact,
[Word Count: 13]

• (a=aaaa, b=bbbb) gets transformed to (c=cccc, d=dddd) because both a=aaaa and b=bbbb did
[Word Count: 14]

Once declared, Transforms can be added to the declarations of PDUs, GOPs or GOGs. This is done by
[Word Count: 18]

adding the Transform name_list statement to the declaration:
[Word Count: 8]

Pdu my_proto_pdu Proto my_proto Transport ip {
    Extract addr From ip.addr;
    ...
    Transform my_pdu_transform[, other_pdu_transform[, yet_another_pdu_transform]];
};
[Word Count: 17]

• In case of PDU, the list of transforms is applied against the PDU’s AVPL after its creation.
[Word Count: 18]

• In case of GOP and GOG, the list of transforms is applied against their respective AVPLs when
[Word Count: 18]

they are created and every time they change.
[Word Count: 8]

Figure 148. Applying Transform flowchart
[Word Count: 5]

• A list of previously declared Transforms may be given to every Item (Pdu, Gop, or Gog), using
[Word Count: 18]

• Every time the AVPL of an item changes, it will be operated against all the Transforms on the
[Word Count: 19]

list given to that item. The Transforms on the list are applied left to right.
[Word Count: 15]

• Inside each of the Transforms, the item’s AVPL will be operated against the Transform’s Match
[Word Count: 16]

clauses starting from the topmost one, until all have been tried or until one of them succeeds.
[Word Count: 17]

MATE’s Transforms can be used for many different things, like:
[Word Count: 10]

Multiple Start/Stop conditions for a GOP
[Word Count: 6]

Using Transforms we can add more than one start or stop condition to a GOP.
[Word Count: 15]

Transform start_cond {
    Match (attr1=aaa,attr2=bbb) (msg_type=start);
    Match (attr3=www,attr2=bbb) (msg_type=start);
    Match (attr5^a) (msg_type=stop);
    Match (attr6$z) (msg_type=stop);
};
[Word Count: 16]

Pdu pdu ... {
    ...
    Transform start_cond;
}
[Word Count: 8]

Gop gop ... {
    Start (msg_type=start);
    Stop (msg_type=stop);
    ...
[Word Count: 9]

Marking GOPs and GOGs to filter them easily
[Word Count: 8]

Transform marks {
    Match (addr=10.10.10.10, user=john) (john_at_host);
    Match (addr=10.10.10.10, user=tom) (tom_at_host);
}
[Word Count: 12]

Gop my_gop ... {
    ...
    Transform marks;
}
[Word Count: 8]

After that we can use a display filter mate.my_gop.john_at_host or mate.my_gop.tom_at_host
[Word Count: 11]

Adding (Insert) direction knowledge to MATE
[Word Count: 6]

Transform direction_as_text {
    Match (src=192.168.0.2, dst=192.168.0.3) Insert (direction=from_2_to_3);
    Match (src=192.168.0.3, dst=192.168.0.2) Insert (direction=from_3_to_2);
};
[Word Count: 14]

Pdu my_pdu Proto my_proto Transport tcp/ip {
    Extract src From ip.src;
    Extract dst From ip.dst;
    Extract addr From ip.addr;
    Extract port From tcp.port;
    Extract start From tcp.flags.syn;
    Extract stop From tcp.flags.fin;
    Extract stop From tcp.flags.rst;
    Transform direction_as_text;
}
[Word Count: 38]

Gop my_gop On my_pdu Match (addr,addr,port,port) {
    ...
    Extra (direction);
}
[Word Count: 11]

The original example (below) would delete src and dst then add direction.
[Word Count: 12]

Match (src=192.168.0.2, dst=192.168.0.3) Replace (direction=from_2_to_3);
    Match (src=192.168.0.3, dst=192.168.0.2) Replace (direction=from_3_to_2);
};
[Word Count: 11]

NAT can create problems when tracing, but we can easily work around it by Transforming the
[Word Count: 16]

NATed IP address and the Ethernet address of the router into the non-NAT address:
[Word Count: 14]

Transform denat {
    Match (addr=192.168.0.5, ether=01:02:03:04:05:06) Replace (addr=123.45.67.89);
    Match (addr=192.168.0.6, ether=01:02:03:04:05:06) Replace (addr=123.45.67.90);
    Match (addr=192.168.0.7, ether=01:02:03:04:05:06) Replace (addr=123.45.67.91);
}
[Word Count: 19]

Pdu my_pdu Proto my_proto transport tcp/ip/eth {
    Extract ether From eth.addr;
    Extract addr From ip.addr;
    Extract port From tcp.port;
    Transform denat;
}
[Word Count: 22]

We’ll show a MATE configuration that first creates GOPs for every DNS and HTTP request, then it
[Word Count: 17]

ties the GOPs together in a GOG based on the host. Finally, we’ll separate into different GOGs
[Word Count: 17]

With this MATE configuration loaded we can:
[Word Count: 7]

• use mate.http_use.Duration > 5.5 to filter frames based on the time it takes to load a complete
[Word Count: 18]

page from the DNS request to resolve its name until the last image gets loaded.
[Word Count: 15]

• use mate.http_use.client == "10.10.10.20" && mate.http_use.host == "www.example.com" to
[Word Count: 10]

isolate DNS and HTTP packets related to a visit of a certain user.
[Word Count: 13]

• use mate.http_req.Duration > 1.5 to filter all the packets of HTTP requests that take more than
[Word Count: 17]

The complete config file is available on the Wireshark Wiki: https://wiki.wireshark.org/Mate/
[Word Count: 11]

Note: This example uses dns.qry.name which is defined since Wireshark version 0.10.9. Supposing
[Word Count: 13]

you have a MATE plugin already installed you can test it with the current Wireshark version.
[Word Count: 16]

First we’ll tell MATE how to create a GOP for each DNS request/response.
[Word Count: 13]

MATE needs to know what makes a DNS PDU. We describe it using a Pdu declaration:
[Word Count: 16]

Pdu dns_pdu Proto dns Transport ip {
    Extract addr From ip.addr;
    Extract dns_id From dns.id;
    Extract dns_resp From dns.flags.response;
};
[Word Count: 20]

Using Proto dns we tell MATE to create PDUs every time it finds dns. Using Transport ip we inform
[Word Count: 19]

MATE that some of the fields we are interested are in the ip part of the frame. Finally, we tell MATE
[Word Count: 21]

to import ip.addr as addr, dns.id as dns_id and dns.flags.response as dns_resp.
[Word Count: 12]

Once we’ve told MATE how to extract dns_pdus we’ll tell it how to match requests and responses
[Word Count: 17]

and group them into a GOP. For this we’ll use a Gop declaration to define the GOP, and then, Start
[Word Count: 20]

and Stop statements to tell it when the GOP starts and ends.
[Word Count: 12]

Gop dns_req On dns_pdu Match (addr,addr,dns_id) {
    Start (dns_resp="False");
    Stop (dns_resp="True");
};
[Word Count: 12]

Using the Gop declaration we tell MATE that the Name of the GOP is dns_req, that _dns_pdus_s can
[Word Count: 18]

become members of the GOP, and what is the key used to match the PDUs to the GOP.
[Word Count: 18]

The key for this GOP is "addr, addr, dns_id". That means that in order to belong to the same GOP,
[Word Count: 20]

dns_pdus have to have both addresses and the request id identical. We then instruct MATE that a
[Word Count: 17]

dns_req starts whenever a dns_pdu matches "dns_resp="False"" and that it stops when another
[Word Count: 13]

At this point, if we open a capture file using this configuration, we are able to use a display filter
[Word Count: 20]

mate.dns_req.Time > 1 to see only the packets of DNS requests that take more than one second to
[Word Count: 18]

We can use a display filter mate.dns_req && ! mate.dns_req.Time to find requests for which no
[Word Count: 16]

response was given. mate.xxx.Time is set only for GOPs that have being stopped.
[Word Count: 13]

This other example creates a GOP for every HTTP request.
[Word Count: 10]

Pdu http_pdu Proto http Transport tcp/ip {
    Extract addr From ip.addr;
    Extract port From tcp.port;
    Extract http_rq From http.request.method;
    Extract http_rs From http.response;
    DiscardPduData true;
};
[Word Count: 26]

Gop http_req On http_pdu Match (addr, addr, port, port) {
    Start (http_rq);
    Stop (http_rs);
};
[Word Count: 15]

So, if we open a capture using this configuration
[Word Count: 9]

• filtering with mate.http_req.Time > 1 will give all the requests where the response header
[Word Count: 15]

• filtering with mate.http_req.Duration > 1.5 will show those request that take more than 1.5
[Word Count: 15]

You have to know that mate.xxx.Time gives the time in seconds between the PDU matching the
[Word Count: 16]

GOP Start clause and the PDU matching the GOP Stop clause (yes, you can create timers using
[Word Count: 17]

this!). On the other hand, mate.xxx.Duration gives you the time passed between the GOP Start and
[Word Count: 16]

the last PDU assigned to that GOP regardless whether it is a Stop or not. After the GOP Stop, PDUs
[Word Count: 20]

matching the GOP’s Key will still be assigned to the same GOP as far as they don’t match the GOP
[Word Count: 20]

Start, in which case a new GOP with the same key will be created.
[Word Count: 14]

Getting DNS and HTTP together into a GOG
[Word Count: 8]

We’ll tie together to a single GOG all the HTTP packets belonging to requests and responses to a
[Word Count: 18]

certain host and the DNS request and response used to resolve its domain name using the Pdu and
[Word Count: 18]

Gop definitions of the previous examples
[Word Count: 6]

To be able to group DNS and HTTP requests together, we need to import into the PDUs and GOPs
[Word Count: 19]

some part of information that both those protocols share. Once the PDUs and GOPs have been
[Word Count: 16]

defined, we can use Extract (for PDUs) and Extract (for GOPs) statements to tell MATE what other
[Word Count: 17]

protocol fields are to be added to PDU’s and GOP’s AVPLs. We add the following statements to the
[Word Count: 18]

Extract host From http.host; // to Pdu http_pdu as the last Extract in the list
    Extra (host); // to Gop http_req after the Stop
[Word Count: 24]

Extract host From dns.qry.name; // to Pdu dns_pdu as the last Extract in the list
    Extra (host); // to Gop dns_req after the Stop
[Word Count: 24]

Here we’ve told MATE to import http.host into http_pdu and dns.qry.name into dns_pdu as host. We
[Word Count: 16]

also have to tell MATE to copy the host attribute from the PDUs to the GOPs - we do this using Extra.
[Word Count: 22]

Once we have all the data we need in PDUs and GOPs, we tell MATE what makes different GOPs
[Word Count: 19]

Gog http_use {
    Member http_req (host);
    Member dns_req (host);
    Expiration 0.75;
};
[Word Count: 12]

Using the Gog declaration, we tell MATE to define a GOG type named http_use whose expiration is
[Word Count: 17]

0.75 seconds after all the GOPs that belong to it had been stopped. After that time, an eventual new
[Word Count: 19]

GOP with the same key match will create a new GOG instead of been added to the previous GOG.
[Word Count: 19]

Using the Member statements, we tell MATE that http_req*s with the same *host belong to the
[Word Count: 16]

So far we have instructed MATE to group every packet related to sessions towards a certain host. At
[Word Count: 18]

this point if we open a capture file and:
[Word Count: 9]

• a display filter mate.http_use.Duration > 5 will show only those requests that have taken more
[Word Count: 16]

than 5 seconds to complete starting from the DNS request and ending with the last packet of the
[Word Count: 18]

• a display filter mate.http_use.host == "www.w3c.org" will show all the packets (both DNS and
[Word Count: 15]

HTTP) related to the requests directed to www.w3c.org
[Word Count: 8]

This configuration works fine if used for captures taken at the client’s side but deeper in the
[Word Count: 17]

network we’d got a real mess. Requests from many users get mixed together into http_uses. GOGs
[Word Count: 16]

are created and stopped almost randomly (depending on the timing in which GOPs start and stop).
[Word Count: 16]

How do we get requests from individual users separated from each other?
[Word Count: 12]

MATE has a tool that can be used to resolve this kind of grouping issues. This tool are the
[Word Count: 19]

Transforms. Once defined, they can be applied against PDUs, GOPs and GOGs and they might
[Word Count: 15]

replace or insert more attributes based on what’s there. We’ll use them to create an attribute
[Word Count: 16]

named client, using which we’ll separate different requests.
[Word Count: 8]

For DNS we need the ip.src of the request moved into the GOP only from the DNS request.
[Word Count: 18]

So we first tell MATE to import ip.src as client:
[Word Count: 10]

Next, we tell MATE to replace ( dns_resp="True", client ) with just dns_resp="True" in the PDU.
[Word Count: 16]

That way, we’ll keep the attribute client only in the DNS request PDUs (i.e., packets coming from the
[Word Count: 18]

client).To do so, we have to add a Transform declaration (in this case, with just one clause) before
[Word Count: 18]

Transform rm_client_from_dns_resp {
    Match (dns_resp="True", client) Replace (dns_resp="True");
};
[Word Count: 9]

Next, we invoke the transform by adding the following line after the Extract list of the dns_pdu
[Word Count: 17]

HTTP is a little trickier. We have to remove the attribute carrying ip.src from both the response and
[Word Count: 18]

the "continuations" of the response, but as there is nothing to filter on for the continuations, we
[Word Count: 17]

have to add a fake attribute first. And then we have to remove client when the fake attribute
[Word Count: 18]

appears. This is possible due to the fact that the Match clauses in the Transform are executed one by
[Word Count: 19]

one until one of them succeeds. First, we declare another two Transforms:
[Word Count: 12]

Transform rm_client_from_http_resp1 {
    Match (http_rq); //first match wins so the request won't get the not_rq attribute
inserted
    Match Every (addr) Insert (not_rq); //this line won't be evaluated if the first
one matched so not_rq won't be inserted to requests
};
[Word Count: 40]

Transform rm_client_from_http_resp2 {
    Match (not_rq, client) Replace (); //replace "client and not_rq" with nothing
(will happen only in the response and eventual parts of it)
};
[Word Count: 26]

Next, we add another Extract statement to the http_pdu declaration, and apply both Transforms
[Word Count: 14]

Extract client From ip.src;
    Transform rm_client_from_http_resp1, rm_client_from_http_resp2;
[Word Count: 7]

In MATE, all the Transform_s listed for an item will be evaluated, while inside a single _Transform, the
[Word Count: 18]

evaluation will stop at the first successful Match clause. That’s why we first just match http_rq to get
[Word Count: 18]

out of the first sequence before adding the not_rq attribute. Then we apply the second Transform
[Word Count: 16]

which removes both not_rq and client if both are there. Yes, _Transform_s are cumbersome, but
[Word Count: 15]

Once we got all what we need in the PDUs, we have to tell MATE to copy the attribute client from
[Word Count: 21]

the PDUs to the respective GOPs, by adding client to Extra lists of both Gop declarations:
[Word Count: 16]

On top of that, we need to modify the old declarations of GOP key to new ones that include both
[Word Count: 20]

client and host. So we change the Gog Member declarations the following way:
[Word Count: 13]

Member http_req (host, client);
    Member dns_req (host, client);
[Word Count: 8]

Now we got it, every "usage" gets its own GOG.
[Word Count: 10]

The following is a collection of various configuration examples for MATE. Many of them are useless
[Word Count: 16]

because the "conversations" facility does a better job. Anyway they are meant to help users
[Word Count: 15]

The following example creates a GOP out of every TCP session.
[Word Count: 11]

Transform add_tcp_stop {
    Match (tcp_flags_reset="True") Insert (tcp_stop="True");
    Match (tcp_flags_fin="True") Insert (tcp_stop="True");
};
[Word Count: 12]

Pdu tcp_pdu Proto tcp Transport ip {
    Extract addr From ip.addr;
    Extract port From tcp.port;
    Extract tcp_start From tcp.flags.syn;
    Extract tcp_flags_reset From tcp.flags.reset;
    Extract tcp_flags_fin From tcp.flags.fin;
    Transform add_tcp_stop;
};
[Word Count: 30]

Gop tcp_ses On tcp_pdu Match (addr, addr, port, port) {
    Start (tcp_start="True");
[Word Count: 12]

This probably would do fine in 99.9% of the cases but 10.0.0.1:20→10.0.0.2:22 and
[Word Count: 13]

10.0.0.1:22→10.0.0.2:20 would both fall into the same gop if they happen to overlap in time.
[Word Count: 15]

• filtering with mate.tcp_ses.Time > 1 will give all the sessions that last more than one second
[Word Count: 17]

• filtering with mate.tcp_ses.NumOfPdus < 5 will show all tcp sessions that have less than 5
[Word Count: 16]

• filtering with mate.tcp_ses.Id == 3 will show all the packets for the third tcp session MATE has
[Word Count: 18]

This configuration allows to tie a complete passive FTP session (including the data transfer) in a
[Word Count: 16]

Pdu ftp_pdu Proto ftp Transport tcp/ip {
    Extract ftp_addr From ip.addr;
    Extract ftp_port From tcp.port;
    Extract ftp_resp From ftp.response.code;
    Extract ftp_req From ftp.request.command;
    Extract server_addr From ftp.passive.ip;
    Extract server_port From ftp.passive.port;
[Word Count: 31]

Pdu ftp_data_pdu Proto ftp-data Transport tcp/ip{
    Extract server_addr From ip.src;
    Extract server_port From tcp.srcport;
[Word Count: 14]

Gop ftp_data On ftp_data_pdu Match (server_addr, server_port) {
    Start (server_addr);
};
[Word Count: 11]

Gop ftp_ctl On ftp_pdu Match (ftp_addr, ftp_addr, ftp_port, ftp_port) {
    Start (ftp_resp=220);
    Stop (ftp_resp=221);
    Extra (server_addr, server_port);
};
[Word Count: 18]

Gog ftp_ses {
    Member ftp_ctl (ftp_addr, ftp_addr, ftp_port, ftp_port);
    Member ftp_data (server_addr, server_port);
};
[Word Count: 14]

Note: not having anything to distinguish between ftp-data packets makes this config to create one
[Word Count: 15]

GOP for every ftp-data packet instead of each transfer. Pre-started GOPs would avoid this.
[Word Count: 14]

using RADIUS to filter SMTP traffic of a specific user
[Word Count: 10]

Spying on people, in addition to being immoral, is illegal in many countries. This is an example
[Word Count: 17]

meant to explain how to do it not an invitation to do so. It’s up to the police to do this kind of job
[Word Count: 24]

Pdu radius_pdu On radius Transport udp/ip {
    Extract addr From ip.addr;
    Extract port From udp.port;
    Extract radius_id From radius.id;
    Extract radius_code From radius.code;
    Extract user_ip From radius.framed_addr;
    Extract username From radius.username;
}
[Word Count: 32]

Gop radius_req On radius_pdu (radius_id, addr, addr, port, port) {
    Start (radius_code {1|4|7} );
    Stop (radius_code {2|3|5|8|9} );
    Extra (user_ip, username);
}
[Word Count: 22]

// we define the smtp traffic we want to filter
Pdu user_smtp Proto smtp Transport tcp/ip {
    Extract user_ip From ip.addr;
    Extract smtp_port From tcp.port;
    Extract tcp_start From tcp.flags.syn;
    Extract tcp_stop From tcp.flags.reset;
}
[Word Count: 34]

Gop user_smtp_ses On user_smtp (user_ip, user_ip, smtp_port!25) {
    Start (tcp_start=1);
    Stop (tcp_stop=1);
}
[Word Count: 13]

// with the following group of groups we'll group together the radius and the smtp
[Word Count: 15]

// we set a long expiration to avoid the session expire on long pauses.
Gog user_mail {
    Expiration 1800;
    Member radius_req (user_ip);
    Member user_smtp_ses (user_ip);
    Extra (username);
}
[Word Count: 28]

Filtering the capture file with mate.user_mail.username == "theuser" will filter the RADIUS
[Word Count: 12]

This configuration will create a GOG out of every call.
[Word Count: 10]

Pdu q931 Proto q931 Transport ip {
    Extract addr From ip.addr;
    Extract call_ref From q931.call_ref;
    Extract q931_msg From q931.message_type;
    Extract calling From q931.calling_party_number.digits;
    Extract called From q931.called_party_number.digits;
    Extract guid From h225.guid;
    Extract q931_cause From q931.cause_value;
};
[Word Count: 36]

Gop q931_leg On q931 Match (addr, addr, call_ref) {
    Start (q931_msg=5);
    Stop (q931_msg=90);
    Extra (calling, called, guid, q931_cause);
};
[Word Count: 19]

Pdu ras Proto h225.RasMessage Transport ip {
    Extract addr From ip.addr;
    Extract ras_sn From h225.requestSeqNum;
    Extract ras_msg From h225.RasMessage;
    Extract guid From h225.guid;
};
[Word Count: 24]

Gop ras_req On ras Match (addr, addr, ras_sn) {
    Start (ras_msg {0|3|6|9|12|15|18|21|26|30} );
    Stop (ras_msg {1|2|4|5|7|8|10|11|13|14|16|17|19|20|22|24|27|28|29|31});
    Extra (guid);
};
[Word Count: 19]

Gog call {
    Member ras_req (guid);
    Member q931_leg (guid);
    Extra (called,calling,q931_cause);
};
[Word Count: 12]

• filter all signalling for a specific caller: mate.call.caller == "123456789"
[Word Count: 11]

• filter all signalling for calls with a specific release cause: mate.call.q931_cause == 31
[Word Count: 14]

• filter all signalling for very short calls: mate.q931_leg.Time < 5
[Word Count: 11]

With this example, all the components of an MMS send or receive will be tied into a single GOG.
[Word Count: 19]

Note that this example uses the Payload clause because MMS delivery uses MMSE over either HTTP
[Word Count: 16]

or WSP. As it is not possible to relate the retrieve request to a response by the means of MMSE only
[Word Count: 21]

(the request is just an HTTP GET without any MMSE), a GOP is made of HTTP PDUs but MMSE data
[Word Count: 20]

## WARNING: this example has been blindly translated from the "old" MATE syntax
## and it has been verified that Wireshark accepts it. However, it has not been
## tested against any capture file due to lack of the latter.
[Word Count: 40]

Transform rm_client_from_http_resp1 {
    Match (http_rq);
    Match Every (addr) Insert (not_rq);
};
[Word Count: 11]

Transform rm_client_from_http_resp2 {
    Match (not_rq,ue) Replace ();
};
[Word Count: 8]

Pdu mmse_over_http_pdu Proto http Transport tcp/ip {
    Payload mmse;
    Extract addr From ip.addr;
    Extract port From tcp.port;
    Extract http_rq From http.request;
    Extract content From http.content_type;
    Extract resp From http.response.code;
    Extract method From http.request.method;
    Extract host From http.host;
    Extract content From http.content_type;
[Word Count: 41]

Extract trx From mmse.transaction_id;
    Extract msg_type From mmse.message_type;
    Extract notify_status From mmse.status;
    Extract send_status From mmse.response_status;
    Transform rm_client_from_http_resp1, rm_client_from_http_resp2;
};
[Word Count: 20]

Gop mmse_over_http On mmse_over_http_pdu Match (addr, addr, port, port) {
    Start (http_rq);
    Stop (http_rs);
    Extra (host, ue, resp, notify_status, send_status, trx);
};
[Word Count: 22]

Transform mms_start {
    Match Loose() Insert (mms_start);
};
[Word Count: 8]

Pdu mmse_over_wsp_pdu Proto wsp Transport ip {
    Payload mmse;
    Extract trx From mmse.transaction_id;
    Extract msg_type From mmse.message_type;
    Extract notify_status From mmse.status;
    Extract send_status From mmse.response_status;
    Transform mms_start;
};
[Word Count: 28]

Gop mmse_over_wsp On mmse_over_wsp_pdu Match (trx) {
    Start (mms_start);
    Stop (never);
    Extra (ue, notify_status, send_status);
};
[Word Count: 16]

Gog mms {
    Member mmse_over_http (trx);
    Member mmse_over_wsp (trx);
    Extra (ue, notify_status, send_status, resp, host, trx);
    Expiration 60.0;
};
[Word Count: 19]

The MATE library (will) contains GOP definitions for several protocols. Library protocols are
[Word Count: 13]

included in your MATE config using: _Action=Include; Lib=proto_name;_.
[Word Count: 8]

For Every protocol with a library entry, we’ll find defined what from the PDU is needed to create a
[Word Count: 19]

GOP for that protocol, eventually any criteria and the very essential GOP definition (i.e., Gop, Start
[Word Count: 16]

It seems that this code is written in the old syntax of MATE. So far it has not been
[Word Count: 19]

transcribed into the new format. It may still form the basis to recreate these in the
[Word Count: 16]

It will create a GOP for every TCP session. If it is used it should be the last one in the list. And every
[Word Count: 24]

other proto on top of TCP should be declared with LastPdu=TRUE; so that a TCP PDU is not created
[Word Count: 19]

Transform add_tcp_stop {
    Match (tcp_flags_reset="True") Insert (tcp_stop="True");
    Match (tcp_flags_fin="True") Insert (tcp_stop="True");
};
[Word Count: 12]

Pdu tcp_pdu Proto tcp Transport ip {
    Extract addr From ip.addr;
    Extract port From tcp.port;
    Extract tcp_start From tcp.flags.syn;
    Extract tcp_flags_reset From tcp.flags.reset;
    Extract tcp_flags_fin From tcp.flags.fin;
    Transform add_tcp_stop;
};
[Word Count: 30]

Gop tcp_ses On tcp_pdu Match (addr, addr, port, port) {
    Start (tcp_start="True");
    Stop (tcp_stop="True");
};
[Word Count: 15]

will create a GOP containing every request and its response (eventually retransmissions too).
[Word Count: 13]

Action=PduDef; Name=dns_pdu; Proto=dns; Transport=udp/ip; addr=ip.addr; port=udp.port;
dns_id=dns.id; dns_rsp=dns.flags.response;
[Word Count: 8]

Action=GopDef; Name=dns_req; On=dns_pdu; addr; addr; port!53; dns_id;
Action=GopStart; For=dns_req; dns_rsp=0;
[Word Count: 10]

Action=PduDef; Name=radius_pdu; Proto=radius; Transport=udp/ip; addr=ip.addr;
port=udp.port; radius_id=radius.id; radius_code=radius.code;
[Word Count: 8]

Action=GopDef; Name=radius_req; On=radius_pdu; radius_id; addr; addr; port; port;
Action=GopStart; For=radius_req; radius_code|1|4|7;
Action=GopStop; For=radius_req; radius_code|2|3|5|8|9;
[Word Count: 14]

Action=PduDef; Name=rtsp_pdu; Proto=rtsp; Transport=tcp/ip; addr=ip.addr;
port=tcp.port; rtsp_method=rtsp.method;
Action=PduExtra; For=rtsp_pdu; rtsp_ses=rtsp.session; rtsp_url=rtsp.url;
[Word Count: 11]

Action=GopDef; Name=rtsp_ses; On=rtsp_pdu; addr; addr; port; port;
Action=GopStart; For=rtsp_ses; rtsp_method=DESCRIBE;
Action=GopStop; For=rtsp_ses; rtsp_method=TEARDOWN;
Action=GopExtra; For=rtsp_ses; rtsp_ses; rtsp_url;
[Word Count: 17]

Most protocol definitions here will create one GOP for every Call Leg unless stated.
[Word Count: 14]

Action=PduDef; Name=isup_pdu; Proto=isup; Transport=mtp3; mtp3pc=mtp3.dpc;
mtp3pc=mtp3.opc; cic=isup.cic; isup_msg=isup.message_type;
[Word Count: 8]

Action=GopDef; Name=isup_leg; On=isup_pdu; ShowPduTree=TRUE; mtp3pc; mtp3pc; cic;
Action=GopStart; For=isup_leg; isup_msg=1;
Action=GopStop; For=isup_leg; isup_msg=16;
[Word Count: 13]

Action=PduDef; Name=q931_pdu; Proto=q931; Stop=TRUE; Transport=tcp/ip; addr=ip.addr;
call_ref=q931.call_ref; q931_msg=q931.message_type;
[Word Count: 8]

Action=GopDef; Name=q931_leg; On=q931_pdu; addr; addr; call_ref;
Action=GopStart; For=q931_leg; q931_msg=5;
Action=GopStop; For=q931_leg; q931_msg=90;
[Word Count: 12]

Action=PduDef; Name=ras_pdu; Proto=h225.RasMessage; Transport=udp/ip; addr=ip.addr;
ras_sn=h225.RequestSeqNum; ras_msg=h225.RasMessage;
Action=PduExtra; For=ras_pdu; guid=h225.guid;
[Word Count: 10]

Action=GopDef; Name=ras_leg; On=ras_pdu; addr; addr; ras_sn;
Action=GopStart; For=ras_leg; ras_msg|0|3|6|9|12|15|18|21|26|30;
Action=GopStop; For=ras_leg;
ras_msg|1|2|4|5|7|8|10|11|13|14|16|17|19|20|22|24|27|28|29|31;
Action=GopExtra; For=ras_leg; guid;
[Word Count: 15]

Action=PduDef; Proto=sip_pdu; Transport=tcp/ip; addr=ip.addr; port=tcp.port;
sip_method=sip.Method; sip_callid=sip.Call-ID; calling=sdp.owner.username;
[Word Count: 8]

Action=GopDef; Name=sip_leg; On=sip_pdu; addr; addr; port; port;
Action=GopStart; For=sip; sip_method=INVITE;
Action=GopStop; For=sip; sip_method=BYE;
[Word Count: 13]

Will create a GOP out of every transaction.
[Word Count: 8]

To "tie" them to your call’s GoG use: Action=GogKey; Name=your_call; On=mgc_tr; addr!mgc_addr;
[Word Count: 12]

Action=PduDef; Name=mgc_pdu; Proto=megaco; Transport=ip; addr=ip.addr;
megaco_ctx=megaco.context; megaco_trx=megaco.transid; megaco_msg=megaco.transaction;
term=megaco.termid;
[Word Count: 9]

Action=GopDef; Name=mgc_tr; On=mgc_pdu; addr; addr; megaco_trx;
Action=GopStart; For=mgc_tr; megaco_msg|Request|Notify;
Action=GopStop; For=mgc_tr; megaco_msg=Reply;
Action=GopExtra; For=mgc_tr; term^DS1; megaco_ctx!Choose one;
[Word Count: 17]

MATE uses AVPs for almost everything: to keep the data it has extracted from the frames' trees as
[Word Count: 18]

well as to keep the elements of the configuration.
[Word Count: 9]

These "pairs" (actually tuples) are made of a name, a value and, in case of configuration AVPs, an
[Word Count: 18]

operator. Names and values are strings. AVPs with operators other than '=' are used only in the
[Word Count: 17]

configuration and are used for matching AVPs of PDUs, GOPs and GOGs in the analysis phase.
[Word Count: 16]

The name is a string used to refer to a type of AVP. Two attributes won’t match unless their names
[Word Count: 20]

are identical. Capitalized names are reserved for keywords (you can use them for your elements if
[Word Count: 16]

you want but I think it’s not the case). MATE attribute names can be used in Wireshark’s display
[Word Count: 18]

filters the same way like names of protocol fields provided by dissectors, but they are not just
[Word Count: 17]

references to (or aliases of) protocol fields.
[Word Count: 7]

The value is a string. It is either set in the configuration (for configuration AVPs) or by MATE while
[Word Count: 19]

extracting interesting fields from a dissection tree and/or manipulating them later. The values
[Word Count: 13]

extracted from fields use the same representation as they do in filter strings.
[Word Count: 13]

Currently only match operators are defined (there are plans to (re)add transform attributes but
[Word Count: 14]

some internal issues have to be solved before that). The match operations are always performed
[Word Count: 15]

between two operands: the value of an AVP stated in the configuration and the value of an AVP (or
[Word Count: 19]

several AVPs with the same name) extracted from packet data (called "data AVPs"). It is not possible
[Word Count: 17]

• Equal = test for equality, that is: either the value strings are identical or the match will fail.
[Word Count: 19]

• Not Equal ! will match only if the value strings aren’t equal.
[Word Count: 13]

• One Of {} will match if one of the value strings listed is equal to the data AVP’s string. Items
[Word Count: 21]

inside the list’s curly braces are separated with the | character.
[Word Count: 11]

• Starts With ^ will match if the configuration value string matches the first characters of the data
[Word Count: 18]

• Ends With $ will match if the configuration value string matches the last characters of the data
[Word Count: 18]

• Contains ~ will match if the configuration value string matches a substring of the characters of
[Word Count: 17]

• Lower Than < will match if the data AVP’s value string is semantically lower than the
[Word Count: 17]

• Higher Than > will match if the data AVP’s value string is semantically higher than the
[Word Count: 17]

• Exists ? (can be omitted) will match if the AVP name matches, regardless what the value string
[Word Count: 18]

This operator tests whether the values of the operator and the operand AVP are equal.
[Word Count: 15]

This operator matches if the value strings of two AVPs are not equal.
[Word Count: 13]

The "one of" operator matches if the data AVP value is equal to one of the values listed in the "one
[Word Count: 21]

The "starts with" operator matches if the first characters of the data AVP value are identical to the
[Word Count: 18]

The ends with operator will match if the last bytes of the data AVP value are equal to the
[Word Count: 19]

attrib=abc…wxyz does not match attrib$abc
[Word Count: 5]

The "contains" operator will match if the data AVP value contains a string identical to the
[Word Count: 16]

The "lower than" operator will match if the data AVP value is semantically lower than the
[Word Count: 16]

but beware: attrib=10 does not match attrib<9
[Word Count: 7]

It should check whether the values are numbers and compare them numerically
[Word Count: 12]

The "higher than" operator will match if the data AVP value is semantically higher than the
[Word Count: 16]

but beware: attrib=9 does not match attrib>10
[Word Count: 7]

It should check whether the values are numbers and compare them numerically
[Word Count: 12]

The exists operator will always match as far as the two operands have the same name.
[Word Count: 16]

attrib=abc matches attrib (this is just an alternative notation of the previous example)
[Word Count: 13]

obviously attrib=abc does not match other_attrib?
[Word Count: 6]

PDUs, GOPs and GOGs use an AVPL to contain the tracing information. An AVPL is an unsorted set
[Word Count: 18]

of AVPs that can be matched against other AVPLs.
[Word Count: 9]

There are three types of match operations that can be performed between AVPLs. The
[Word Count: 14]

PDU’s/GOP’s/GOG’s AVPL will be always one of the operands; the AVPL operator (match type) and
[Word Count: 15]

the second operand AVPL will always come from the configuration. Note that a diverse AVP match
[Word Count: 16]

operator may be specified for each AVP in the configuration AVPL.
[Word Count: 11]

An AVPL match operation returns a result AVPL. In Transforms, the result AVPL may be replaced by
[Word Count: 17]

another AVPL. The replacement means that the existing data AVPs are dropped and the
[Word Count: 14]

replacement AVPL from the configuration is Merged to the data AVPL of the PDU/GOP/GOG.
[Word Count: 14]

• Loose Match: Will match if at least one of the AVPs of the two operand AVPLs match. If it
[Word Count: 20]

matches, it returns a result AVPL containing all AVPs from the data AVPL that did match the
[Word Count: 17]

• "Every" Match: Will match if none of the AVPs of the configuration AVPL fails to match an AVP
[Word Count: 19]

in the data AVPL, even if not all of the configuration AVPs have a match. If it matches, it returns
[Word Count: 20]

a result AVPL containing all AVPs from the data AVPL that did match an AVP in the
[Word Count: 17]

• Strict Match: Will match if and only if each of the AVPs in the configuration AVPL has at least
[Word Count: 20]

one match in the data AVPL. If it matches, it returns a result AVPL containing those AVPs from
[Word Count: 18]

A loose match between AVPLs succeeds if at least one of the data AVPs matches at least one of the
[Word Count: 20]

configuration AVPs. Its result AVPL contains all the data AVPs that matched.
[Word Count: 12]

Loose matches are used in Extra operations against the PDU's AVPL to merge the result into GOP's
[Word Count: 17]

AVPL, and against GOP's AVPL to merge the result into GOG's AVPL. They may also be used in
[Word Count: 18]

NOTE
As of current (2.0.1), Loose Match does not work as described here, see issue 12184.
[Word Count: 16]

Only use in Transforms and Criteria is effectively affected by the bug.
[Word Count: 12]

(attr_a=aaa, attr_b=bbb, attr_c=xxx) Match Loose (attr_a?, attr_c?) =⇒ (attr_a=aaa, attr_c=xxx)
[Word Count: 10]

(attr_a=aaa, attr_b=bbb, attr_c=xxx) Match Loose (attr_a?, attr_c=ccc) =⇒ (attr_a=aaa)
[Word Count: 9]

(attr_a=aaa, attr_b=bbb, attr_c=xxx) Match Loose (attr_a=xxx; attr_c=ccc) =⇒ No Match!
[Word Count: 10]

An "every" match between AVPLs succeeds if none of the configuration’s AVPs that have a
[Word Count: 15]

counterpart in the data AVPL fails to match. Its result AVPL contains all the data AVPs that matched.
[Word Count: 18]

These may only be used in Criteria and Transforms.
[Word Count: 9]

NOTE
As of current (2.0.1), Loose Match does not work as described here, see issue 12184.
[Word Count: 16]

(attr_a=aaa, attr_b=bbb, attr_c=xxx) Match Every (attr_a?, attr_c?) =⇒ (attr_a=aaa, attr_c=xxx)
[Word Count: 10]

(attr_a=aaa, attr_b=bbb, attr_c=xxx) Match Every (attr_a?, attr_c?, attr_d=ddd) =⇒ (attr_a=aaa,
[Word Count: 10]

(attr_a=aaa, attr_b=bbb, attr_c=xxx) Match Every (attr_a?, attr_c=ccc) =⇒ No Match!
[Word Count: 10]

(attr_a=aaa; attr_b=bbb; attr_c=xxx) Match Every (attr_a=xxx, attr_c=ccc) =⇒ No Match!
[Word Count: 10]

A Strict match between AVPLs succeeds if and only if every AVP in the configuration AVPL has at
[Word Count: 18]

least one counterpart in the data AVPL and none of the AVP matches fails. The result AVPL contains
[Word Count: 18]

These are used between GOP keys (key AVPLs) and PDU AVPLs. They may also be used in Criteria
[Word Count: 18]

(attr_a=aaa, attr_b=bbb, attr_c=xxx) Match Strict (attr_a?, attr_c=xxx) =⇒ (attr_a=aaa, attr_c=xxx)
[Word Count: 10]

(attr_a=aaa, attr_b=bbb, attr_c=xxx, attr_c=yyy) Match Strict (attr_a?, attr_c?) =⇒ (attr_a=aaa,
[Word Count: 10]

(attr_a=aaa, attr_b=bbb, attr_c=xxx) Match Strict (attr_a?, attr_c=ccc) =⇒ No Match!
[Word Count: 10]

(attr_a=aaa, attr_b=bbb, attr_c=xxx) Match Strict (attr_a?, attr_c?, attr_d?) =⇒ No Match!
[Word Count: 11]

An AVPL may be merged into another one. That would add to the latter every AVP from the former
[Word Count: 19]

• between the result of a key match and the GOP’s or GOG’s AVPL,
[Word Count: 14]

• between the result of an Extra match and the GOP’s or GOG’s AVPL,
[Word Count: 14]

• between the result of a Transform match and PDU’s/GOP’s AVPL. If the operation specified by
[Word Count: 16]

the Match clause is Replace, the result AVPL of the match is removed from the item’s AVPL
[Word Count: 17]

before the modify_avpl is merged into it.
[Word Count: 7]

(attr_a=aaa, attr_b=bbb) "merge" (attr_a=aaa, attr_c=xxx) former becomes (attr_a=aaa, attr_b=bbb,
[Word Count: 9]

Can’t have multiple "attr_a" with same value "aaa"
[Word Count: 8]

(attr_a=aaa, attr_b=bbb) "merge" (attr_a=aaa, attr_a=xxx) former becomes (attr_a=aaa, attr_a=xxx,
[Word Count: 9]

Multiple "attr_a" with different values "aaa" and "xxx"
[Word Count: 8]

(attr_a=aaa, attr_b=bbb) "merge" (attr_c=xxx, attr_d=ddd) former becomes (attr_a=aaa, attr_b=bbb,
[Word Count: 9]

All AVP names are unique so resulting AVPL contains all AVPs from both AVPLs
[Word Count: 14]

The following configuration AVPLs deal with PDU creation and data extraction.
[Word Count: 11]

In each frame of the capture, MATE will look for source proto_name's PDUs in the order in which
[Word Count: 18]

the declarations appear in its configuration and will create PDUs of every type it can from that
[Word Count: 17]

frame, unless specifically instructed that some PDU type is the last one to be looked for in the
[Word Count: 18]

frame. If told so for a given type, MATE will extract all PDUs of that type and the previously
[Word Count: 19]

declared types it finds in the frame but not those declared later.
[Word Count: 12]

The complete declaration of a Pdu looks as below; the mandatory order of the diverse clauses is as
[Word Count: 18]

Pdu name Proto proto_name Transport {proto1[/proto2/proto3[/...]|mate}; {
    Payload proto; //optional, no default value
    Extract attribute From proto.field ; //may occur multiple times, at least once
    Transform transform1[, transform2[, ...]]; //optional
    Criteria {Accept|Reject} {Strict|Every|Loose} match_avpl; //optional
    DropUnassigned {TRUE|FALSE}; //optional, default=FALSE
    DiscardPduData {TRUE|FALSE}; //optional, default=FALSE
    LastPdu {TRUE|FALSE}; //optional, default=FALSE
};
[Word Count: 48]

The name is a mandatory attribute of a Pdu declaration. It is chosen arbitrarily, except that each
[Word Count: 17]

name may only be used once in MATE’s configuration, regardless the class of an item it is used for.
[Word Count: 19]

The name is used to distinguish between different types of PDUs, GOPs, and GOGs. The name is also
[Word Count: 18]

used as part of the filterable fields' names related to this type of PDU which MATE creates.
[Word Count: 17]

However, several Pdu declarations may share the same name. In such case, all of them are created
[Word Count: 17]

from each source PDU matching their Proto, Transport, and Payload clauses, while the bodies of
[Word Count: 15]

their declarations may be totally different from each other. Together with the Accept (or Reject)
[Word Count: 15]

clauses, this feature is useful when it is necessary to build the PDU’s AVPL from different sets of
[Word Count: 18]

source fields depending on contents (or mere presence) of other source fields.
[Word Count: 12]

Every instance of the protocol proto_name PDU in a frame will generate one PDU with the AVPs
[Word Count: 17]

extracted from fields that are in the proto_name's range and/or the ranges of underlying protocols
[Word Count: 15]

specified by the Transport list. It is a mandatory attribute of a Pdu declaration. The proto_name is
[Word Count: 17]

the name of the protocol as used in Wireshark display filter.
[Word Count: 11]

The PDU’s Proto, and its Transport list of protocols separated by / tell MATE which fields of a frame
[Word Count: 19]

can get into the PDU’s AVPL. In order that MATE would extract an attribute from a frame’s protocol
[Word Count: 18]

tree, the area representing the field in the hex display of the frame must be within the area of
[Word Count: 19]

either the Proto or its relative Transports. Transports are chosen moving backwards from the
[Word Count: 14]

protocol area, in the order they are given.
[Word Count: 8]

Proto http Transport tcp/ip does what you’d expect it to - it selects the nearest tcp range that
[Word Count: 18]

precedes the current http range, and the nearest ip range that precedes that tcp range. If there is
[Word Count: 18]

another ip range before the nearest one (e.g., in case of IP tunneling), that one is not going to be
[Word Count: 20]

selected. Transport tcp/ip/ip that "logically" should select the encapsulating IP header too doesn’t
[Word Count: 13]

Once we’ve selected the Proto and Transport ranges, MATE will fetch those protocol fields
[Word Count: 14]

belonging to them whose extraction is declared using the Extract clauses for the PDU type. The
[Word Count: 16]

Transport list is also mandatory, if you actually don’t want to use any transport protocol, use
[Word Count: 16]

Transport mate. (This didn’t work until 0.10.9).
[Word Count: 7]

Other than the PDU’s Proto and its Transport protocols, there is also a Payload attribute to tell MATE
[Word Count: 18]

from which ranges of Proto's payload to extract fields of a frame into the PDU. In order to extract an
[Word Count: 20]

attribute from a frame’s tree the highlighted area of the field in the hex display must be within the
[Word Count: 19]

area of the Proto's relative payload(s). Payloads are chosen moving forward from the protocol area,
[Word Count: 15]

in the order they are given. Proto http Transport tcp/ip Payload mmse will select the first mmse
[Word Count: 17]

range after the current http range. Once we’ve selected the Payload ranges, MATE will fetch those
[Word Count: 16]

protocol fields belonging to them whose extraction is declared using the Extract clauses for the PDU
[Word Count: 16]

Each Extract clause tells MATE which protocol field value to extract as an AVP value and what
[Word Count: 17]

string to use as the AVP name. The protocol fields are referred to using the names used in
[Word Count: 18]

Wireshark display filters. If there is more than one such protocol field in the frame, each instance
[Word Count: 17]

that fulfills the criteria stated above is extracted into its own AVP. The AVP names may be chosen
[Word Count: 18]

arbitrarily, but to be able to match values originally coming from different PDUs (e.g., hostname
[Word Count: 15]

from DNS query and a hostname from HTTP GET request) later in the analysis, identical AVP names
[Word Count: 17]

must be assigned to them and the dissectors must provide the field values in identical format
[Word Count: 16]

The Transform clause specifies a list of previously declared Transforms to be performed on the
[Word Count: 15]

PDU’s AVPL after all protocol fields have been extracted to it. The list is always executed completely,
[Word Count: 17]

left to right. On the contrary, the list of Match clauses inside each individual Transform is executed
[Word Count: 17]

This clause tells MATE whether to use the PDU for analysis. It specifies a match AVPL, an AVPL
[Word Count: 18]

Match type (Strict, Every, or Loose) and the action to be performed (Accept or Reject) if the match
[Word Count: 18]

succeeds. Once every attribute has been extracted and eventual transform list has been executed,
[Word Count: 14]

and if the Criteria clause is present, the PDU’s AVPL is matched against the match AVPL; if the
[Word Count: 18]

match succeeds, the action specified is executed, i.e., the PDU is accepted or rejected. The default
[Word Count: 16]

behaviors used if the respective keywords are omitted are Strict and Accept. Accordingly, if the
[Word Count: 15]

clause is omitted, all PDUs are accepted.
[Word Count: 7]

If set to TRUE, MATE will destroy the PDU if it cannot assign it to a GOP. If set to FALSE (the default if
[Word Count: 24]

If set to TRUE, MATE will delete the PDU’s AVPL once it has analyzed it and eventually extracted
[Word Count: 18]

some AVPs from it into the GOP’s AVPL. This is useful to save memory (of which MATE uses a lot). If
[Word Count: 21]

set to FALSE (the default if not given), MATE will keep the PDU attributes.
[Word Count: 14]

If set to FALSE (the default if not given), MATE will continue to look for PDUs of other types in the
[Word Count: 21]

frame. If set to TRUE, it will not try to create PDUs of other types from the current frame, yet it will
[Word Count: 22]

Declares a Gop type and its candidate key.
[Word Count: 8]

Gop name On pduname Match key {
    Start match_avpl; // optional
    Stop match_avpl; // optional
    Extra match_avpl; // optional
    Transform transform_list; // optional
    Expiration time; // optional
    IdleTimeout time; // optional
    Lifetime time; // optional
    DropUnassigned [TRUE|FALSE]; //optional
    ShowTree [NoTree|PduTree|FrameTree|BasicTree]; //optional
    ShowTimes [TRUE|FALSE]; //optional, default TRUE
};
[Word Count: 47]

The name is a mandatory attribute of a Gop declaration. It is chosen arbitrarily, except that each
[Word Count: 17]

name may only be used once in MATE’s configuration, regardless the class of an item it is used for.
[Word Count: 19]

The name is used to distinguish between different types of PDUs, GOPs, and GOGs. The name is also
[Word Count: 18]

used as part of the filterable fields' names related to this type of GOP which MATE creates.
[Word Count: 17]

The name of PDUs which this type of GOP is supposed to be grouping. It is mandatory.
[Word Count: 17]

Defines what AVPs form up the key part of the GOP’s AVPL (the GOP’s key AVPL or simply the GOP’s
[Word Count: 20]

key). All PDUs matching the key AVPL of an active GOP are assigned to that GOP; a PDU which
[Word Count: 19]

contains the AVPs whose attribute names are listed in the GOP’s key AVPL, but they do not strictly
[Word Count: 18]

match any active GOP’s key AVPL, will create a new GOP (unless a Start clause is given). When a
[Word Count: 19]

GOP is created, the elements of its key AVPL are copied from the creating PDU.
[Word Count: 15]

If given, it tells MATE what match_avpl must a PDU’s AVPL match, in addition to matching the GOP’s
[Word Count: 18]

key, in order to start a GOP. If not given, any PDU whose AVPL matches the GOP’s key AVPL will act
[Word Count: 21]

as a start for a GOP. The PDU’s AVPs matching the match_avpl are not automatically copied into the
[Word Count: 18]

If given, it tells MATE what match_avpl must a PDU’s AVPL match, in addition to matching the GOP’s
[Word Count: 18]

key, in order to stop a GOP. If omitted, the GOP is "auto-stopped" - that is, the GOP is marked as
[Word Count: 21]

stopped as soon as it is created. The PDU’s AVPs matching the match_avpl are not automatically
[Word Count: 16]

If given, tells MATE which AVPs from the PDU’s AVPL are to be copied into the GOP’s AVPL in
[Word Count: 19]

The Transform clause specifies a list of previously declared Transforms to be performed on the
[Word Count: 15]

GOP’s AVPL after the AVPs from each new PDU, specified by the key AVPL and the Extra clause’s
[Word Count: 18]

match_avpl, have been merged into it. The list is always executed completely, left to right. On the
[Word Count: 17]

contrary, the list of Match clauses inside each individual Transform is executed only until the first
[Word Count: 16]

A (floating) number of seconds after a GOP is Stop ped during which further PDUs matching the
[Word Count: 17]

Stop ped GOP’s key but not the Start condition will still be assigned to that GOP. The default value of
[Word Count: 20]

zero has an actual meaning of infinity, as it disables this timer, so all PDUs matching the Stop ped
[Word Count: 19]

GOP’s key will be assigned to that GOP unless they match the Start condition.
[Word Count: 14]

A (floating) number of seconds elapsed from the last PDU assigned to the GOP after which the GOP
[Word Count: 18]

will be considered released. The default value of zero has an actual meaning of infinity, as it
[Word Count: 17]

disables this timer, so the GOP won’t be released even if no PDUs arrive - unless the Lifetime timer
[Word Count: 19]

A (floating) of seconds after the GOP Start after which the GOP will be considered released
[Word Count: 16]

regardless anything else. The default value of zero has an actual meaning of infinity.
[Word Count: 14]

Whether or not a GOP that has not being assigned to any GOG should be discarded. If TRUE, the
[Word Count: 19]

GOP is discarded right after creation. If FALSE, the default, the unassigned GOP is kept. Setting it to
[Word Count: 18]

TRUE helps save memory and speed up filtering.
[Word Count: 8]

Controls the display of PDUs subtree of the GOP:
[Word Count: 9]

• NoTree: completely suppresses showing the tree
[Word Count: 7]

• PduTree: the tree is shown and shows the PDUs by PDU Id
[Word Count: 13]

• FrameTree: the tree is shown and shows the PDUs by the frame number in which they are
[Word Count: 18]

Whether or not to show the times subtree of the GOP. If TRUE, the default, the subtree with the
[Word Count: 19]

timers is added to the GOP’s tree. If FALSE, the subtree is suppressed.
[Word Count: 13]

Declares a Gog type and its candidate key.
[Word Count: 8]

Gog name {
    Member gopname (key); // mandatory, at least one
    Extra match_avpl; // optional
    Transform transform_list; // optional
    Expiration time; // optional, default 2.0
    GopTree [NoTree|PduTree|FrameTree|BasicTree]; // optional
    ShowTimes [TRUE|FALSE]; // optional, default TRUE
[Word Count: 35]

The name is a mandatory attribute of a Gog declaration. It is chosen arbitrarily, except that each
[Word Count: 17]

name may only be used once in MATE’s configuration, regardless the class of an item it is used for.
[Word Count: 19]

The name is used to distinguish between different types of PDUs, GOPs, and GOGs. The name is also
[Word Count: 18]

used as part of the filterable fields' names related to this type of GOG which MATE creates.
[Word Count: 17]

Defines the key AVPL for the GOG individually for each GOP type gopname. All gopname type GOPs
[Word Count: 17]

whose key AVPL matches the corresponding key AVPL of an active GOG are assigned to that GOG; a
[Word Count: 18]

GOP which contains the AVPs whose attribute names are listed in the GOG’s corresponding key
[Word Count: 15]

AVPL, but they do not strictly match any active GOG’s key AVPL, will create a new GOG. When a
[Word Count: 19]

GOG is created, the elements of its key AVPL are copied from the creating GOP.
[Word Count: 15]

Although the key AVPLs are specified separately for each of the Member gopnames, in most cases
[Word Count: 16]

they are identical, as the very purpose of a GOG is to group together GOPs made of PDUs of
[Word Count: 19]

If given, tells MATE which AVPs from any of the GOP’s AVPL are to be copied into the GOG’s AVPL in
[Word Count: 21]

A (floating) number of seconds after all the GOPs assigned to a GOG have been released during
[Word Count: 17]

which new GOPs matching any of the session keys should still be assigned to the existing GOG
[Word Count: 17]

instead of creating a new one. Its value can range from 0.0 to infinite. Defaults to 2.0 seconds.
[Word Count: 18]

The Transform clause specifies a list of previously declared Transforms to be performed on the
[Word Count: 15]

GOG’s AVPL after the AVPs from each new GOP, specified by the key AVPL and the Extra clause’s
[Word Count: 18]

match_avpl, have been merged into it. The list is always executed completely, left to right. On the
[Word Count: 17]

contrary, the list of Match clauses inside each individual Transform is executed only until the first
[Word Count: 16]

Controls the display of GOPs subtree of the GOG:
[Word Count: 9]

• NoTree: completely suppresses showing the tree
[Word Count: 7]

Whether or not to show the times subtree of the GOG. If TRUE, the default, the subtree with the
[Word Count: 19]

timers is added to the GOG’s tree. If FALSE, the subtree is suppressed.
[Word Count: 13]

A Transform is a sequence of Match rules optionally followed by an instruction how to modify the
[Word Count: 17]

match result using an additional AVPL. Such modification may be an Insert (merge) or a Replace.
[Word Count: 16]

Transform name {
    Match [Strict|Every|Loose] match_avpl [[Insert|Replace] modify_avpl] ; // may
occur multiple times, at least once
};
[Word Count: 18]

For examples of Transforms, check the Manual page.
[Word Count: 8]

The list of Match rules inside a Transform is processed top to bottom; the processing ends as soon
[Word Count: 18]

as either a Match rule succeeds or all have been tried in vain.
[Word Count: 13]

Transforms can be used as helpers to manipulate an item’s AVPL before the item is processed
[Word Count: 16]

further. An item declaration may contain a Transform clause indicating a list of previously declared
[Word Count: 15]

Transforms. Regardless whether the individual transforms succeed or fail, the list is always
[Word Count: 13]

executed completely and in the order given, i.e., left to right.
[Word Count: 11]

In MATE configuration file, a Transform must be declared before declaring any item which uses it.
[Word Count: 16]

NOTE
The Settings parameters have been moved to other configuration parameters or
[Word Count: 12]

deprecated. Leave for now until rest of document is updated for current syntax.
[Word Count: 13]

The Settings config element is used to pass to MATE various operational parameters. the possible
[Word Count: 15]

How long in seconds after all the GOPs assigned to a GOG have been released new GOPs matching
[Word Count: 18]

any of the session keys should create a new GOG instead of being assigned to the previous one. Its
[Word Count: 19]

value can range from 0.0 to infinite. Defaults to 2.0 seconds.
[Word Count: 11]

Whether or not the AVPL of every PDU should be deleted after it was being processed (saves
[Word Count: 17]

memory). It can be either TRUE or FALSE. Defaults to TRUE. Setting it to FALSE can save you from a
[Word Count: 20]

Whether PDUs should be deleted if they are not assigned to any GOP. It can be either TRUE or
[Word Count: 19]

FALSE. Defaults to FALSE. Set it to TRUE to save memory if unassigned PDUs are useless.
[Word Count: 16]

Whether GOPs should be deleted if they are not assigned to any session. It can be either TRUE or
[Word Count: 19]

FALSE. Defaults to FALSE. Setting it to TRUE saves memory.
[Word Count: 10]

The following settings are used to debug MATE and its configuration. All levels are integers ranging
[Word Count: 16]

from 0 (print only errors) to 9 (flood me with junk), defaulting to 0.
[Word Count: 14]

Debug {
    Filename "path/name"; //optional, no default value
    Level [0-9]; //optional, generic debug level
    Pdu Level [0-9]; //optional, specific debug level for Pdu handling
    Gop Level [0-9]; //optional, specific debug level for Gop handling
    Gog Level [0-9]; //optional, specific debug level for Gog handling
};
[Word Count: 45]

The {{{path/name}}} is a full path to the file to which debug output is to be written. Non-existent file
[Word Count: 19]

will be created, existing file will be overwritten at each opening of a capture file. If the statement is
[Word Count: 19]

missing, debug messages are written to console, which means they are invisible on Windows.
[Word Count: 14]

Sets the level of debugging for generic debug messages. It is an integer ranging from 0 (print only
[Word Count: 18]

Sets the level of debugging for messages regarding PDU creation. It is an integer ranging from 0
[Word Count: 17]

(print only errors) to 9 (flood me with junk).
[Word Count: 9]

Sets the level of debugging for messages regarding PDU analysis (that is how do they fit into ?GOPs).
[Word Count: 18]

It is an integer ranging from 0 (print only errors) to 9 (flood me with junk).
[Word Count: 16]

Sets the level of debugging for messages regarding GOP analysis (that is how do they fit into ?GOGs).
[Word Count: 18]

It is an integer ranging from 0 (print only errors) to 9 (flood me with junk).
[Word Count: 16]

Action=Settings; SessionExpiration=3.5; DiscardPduData=FALSE;
[Word Count: 3]

Will include a file to the configuration.
[Word Count: 7]

Action=Include; {Filename=filename;|Lib=libname;}
[Word Count: 2]

The filename of the file to include. If it does not begin with '/' it will look for the file in the current
[Word Count: 23]

The name of the lib config to include. will look for libname.mate in wiresharks_dir/matelib.
[Word Count: 14]

This will include the file called "rtsp.mate" into the current config.
[Word Count: 11]

Wireshark provides you with additional information generated out of the plain packet data or it
[Word Count: 15]

may need to indicate dissection problems. Messages generated by Wireshark are usually placed in
[Word Count: 14]

These messages might appear in the packet list.
[Word Count: 8]

Malformed packet means that the protocol dissector can’t dissect the contents of the packet any
[Word Count: 15]

• Wrong dissector: Wireshark erroneously has chosen the wrong protocol dissector for this
[Word Count: 13]

packet. This will happen e.g., if you are using a protocol not on its well known TCP or UDP port.
[Word Count: 20]

You may try Analyze|Decode As to circumvent this problem.
[Word Count: 9]

• Packet not reassembled: The packet is longer than a single frame and it is not reassembled, see
[Word Count: 18]

• Packet is malformed: The packet is actually wrong (malformed), meaning that a part of the
[Word Count: 16]

packet is just not as expected (not following the protocol specifications).
[Word Count: 11]

• Dissector is buggy: The corresponding protocol dissector is simply buggy or still incomplete.
[Word Count: 14]

Any of the above is possible. You’ll have to look into the specific situation to determine the reason.
[Word Count: 18]

You could disable the dissector by disabling the protocol on the Analyze menu and check how
[Word Count: 16]

Wireshark displays the packet then. You could (if it’s TCP) enable reassembly for TCP and the
[Word Count: 16]

specific dissector (if possible) in the Edit|Preferences menu. You could check the packet contents
[Word Count: 14]

yourself by reading the packet bytes and comparing it to the protocol specification. This could
[Word Count: 15]

reveal a dissector bug. Or you could find out that the packet is indeed wrong.
[Word Count: 15]

The packet size was limited during capture, see “Limit each packet to n bytes” at the The “Capture
[Word Count: 18]

Options” Dialog Box. While dissecting, the current protocol dissector was simply running out of
[Word Count: 14]

packet bytes and had to give up. There’s nothing else you can do now, except to repeat the whole
[Word Count: 19]

capture process again with a higher (or no) packet size limitation.
[Word Count: 11]

These messages might appear in the packet details.
[Word Count: 8]

The current packet is the request of a detected request/response pair. You can directly jump to the
[Word Count: 17]

corresponding response packet by double-clicking on the message.
[Word Count: 8]

Same as “Response in frame: 123” above, but the other way round.
[Word Count: 12]

The time between the request and the response packets.
[Word Count: 9]

The session control protocol (SDP, H225, etc.) message which signaled the creation of this session.
[Word Count: 15]

You can directly jump to the corresponding packet by double-clicking on this message.
[Word Count: 13]

To understand which information will remain available after the captured packets are saved to a
[Word Count: 15]

capture file, it’s helpful to know a bit about the capture file contents.
[Word Count: 13]

Wireshark uses the pcapng file format as the default format to save captured packets. It is very
[Word Count: 17]

flexible but other tools may not support it.
[Word Count: 8]

Wireshark also supports the libpcap file format. This is a much simpler format and is well
[Word Count: 16]

established. However, it has some drawbacks: it’s not extensible and lacks some information that
[Word Count: 14]

would be really helpful (e.g., being able to add a comment to a packet such as “the problems start
[Word Count: 19]

In addition to the libpcap format, Wireshark supports several different capture file formats.
[Word Count: 13]

However, the problems described above also applies for these formats.
[Word Count: 10]

At the start of each libpcap capture file some basic information is stored like a magic number to
[Word Count: 18]

identify the libpcap file format. The most interesting information of this file start is the link layer
[Word Count: 17]

The following data is saved for each packet:
[Word Count: 8]

• The timestamp with millisecond resolution
[Word Count: 6]

• The packet length as it was “on the wire”
[Word Count: 10]

• The packet length as it’s saved in the file
[Word Count: 10]

A detailed description of the libpcap file format can be found at https://wiki.wireshark.org/
[Word Count: 13]

You should also know the things that are not saved in capture files:
[Word Count: 13]

• Current selections (selected packet, …)
[Word Count: 6]

• Name resolution information. See Name Resolution for details
[Word Count: 9]

Pcapng files can optionally save name resolution information. Libpcap files can’t. Other file
[Word Count: 13]

• The number of packets dropped while capturing
[Word Count: 8]

• Packet marks set with “Edit/Mark Packet”
[Word Count: 7]

• Time references set with “Edit/Time Reference”
[Word Count: 7]

To match the different policies for Unix-like systems and Windows, and different policies used on
[Word Count: 15]

different Unix-like systems, the folders containing configuration files and plugins are different on
[Word Count: 13]

different platforms. We indicate the location of the top-level folders under which configuration files
[Word Count: 14]

and plugins are stored here, giving them placeholder names independent of their actual location,
[Word Count: 14]

and use those names later when giving the location of the folders for configuration files and
[Word Count: 16]

TIP
A list of the folders Wireshark actually uses can be found under the Folders tab in the
[Word Count: 18]

dialog box shown when you select About Wireshark from the Help menu.
[Word Count: 12]

%APPDATA% 
is 
the 
personal 
application 
data 
folder, 
e.g.: 
C:\Users\
[Word Count: 9]

username\AppData\Roaming\Wireshark (details can be found at: Windows profiles).
[Word Count: 8]

WIRESHARK is the Wireshark program folder, e.g.: C:\Program Files\Wireshark.
[Word Count: 9]

$XDG_CONFIG_HOME is the folder for user-specific configuration files. It’s usually $HOME/.config,
[Word Count: 11]

where $HOME is the user’s home folder, which is usually something such as /home/username, or
[Word Count: 15]

If you are using macOS and you are running a copy of Wireshark installed as an application bundle,
[Word Count: 18]

APPDIR is the top-level directory of the Wireshark application bundle, which will typically be
[Word Count: 14]

/Applications/Wireshark.app. Otherwise, INSTALLDIR is the top-level directory under which reside
[Word Count: 10]

the subdirectories in which components of Wireshark are installed. This will typically be /usr if
[Word Count: 15]

Wireshark is bundled with the system (for example, provided as a package with a Linux
[Word Count: 15]

distribution) and /usr/local if, for example, you’ve built Wireshark from source and installed it.
[Word Count: 14]

Wireshark uses a number of configuration files while it is running. Some of these reside in the
[Word Count: 17]

personal configuration folder and are used to maintain information between runs of Wireshark,
[Word Count: 13]

while some of them are maintained in system areas.
[Word Count: 9]

The content format of the configuration files is the same on all platforms.
[Word Count: 13]

• The personal configuration folder for Wireshark is the Wireshark sub-folder of that folder, i.e.,
[Word Count: 15]

• The global configuration folder for Wireshark is the Wireshark program folder and is also used
[Word Count: 16]

• The personal configuration folder is $XDG_CONFIG_HOME/wireshark. For backwards
[Word Count: 9]

compatibility with Wireshark before 2.2, if $XDG_CONFIG_HOME/wireshark does not exist and
[Word Count: 11]

$HOME/.wireshark is present, then the latter will be used.
[Word Count: 9]

• If you are using macOS and you are running a copy of Wireshark installed as an application
[Word Count: 18]

bundle, 
the 
global 
configuration 
folder 
is 
APPDIR/Contents/Resources/share/wireshark.
[Word Count: 7]

Otherwise, the global configuration folder is INSTALLDIR/share/wireshark.
[Word Count: 7]

• The /etc folder is the system configuration folder. The folder actually used on your system may
[Word Count: 17]

vary, maybe something like: /usr/local/etc.
[Word Count: 5]

preferences
Settings from the Preferences dialog box.
[Word Count: 7]

This file contains all the capture filters that you have defined and saved. It consists of one or
[Word Count: 18]

more lines, where each line has the following format:
[Word Count: 9]

At program start, if there is a cfilters file in the personal configuration folder, it is read. If there
[Word Count: 19]

isn’t a cfilters file in the personal configuration folder, then, if there is a cfilters file in the global
[Word Count: 19]

When you press the Save button in the “Capture Filters” dialog box, all the current capture
[Word Count: 16]

filters are written to the personal capture filters file.
[Word Count: 9]

This file contains all the color filters that you have defined and saved. It consists of one or more
[Word Count: 19]

lines, where each line has the following format:
[Word Count: 8]

@<filter name>@<filter string>@[<bg RGB(16-bit)>][<fg RGB(16-bit)>]
[Word Count: 5]

At program start, if there is a colorfilters file in the personal configuration folder, it is read. If
[Word Count: 18]

there isn’t a colorfilters file in the personal configuration folder, then, if there is a colorfilters file
[Word Count: 17]

in the global configuration folder, it is read.
[Word Count: 8]

When you press the Save button in the “Coloring Rules” dialog box, all the current color filters
[Word Count: 17]

are written to the personal color filters file.
[Word Count: 8]

This file contains all the display filter buttons that you have defined and saved. It consists of one
[Word Count: 18]

or more lines, where each line has the following format:
[Word Count: 10]

"TRUE/FALSE","<button label>","<filter string>","<comment string>"
[Word Count: 4]

where the first field is TRUE if the button is enabled (shown).
[Word Count: 12]

At program start, if there is a dfilter_buttons file in the personal configuration folder, it is read. If
[Word Count: 18]

there isn’t a dfilter_buttons file in the personal configuration folder, then, if there is a
[Word Count: 15]

dfilter_buttons file in the global configuration folder, it is read.
[Word Count: 10]

When you save any changes to the filter buttons, all the current display filter buttons are written
[Word Count: 17]

to the personal display filter buttons file.
[Word Count: 7]

This file contains all the display filters that you have defined and saved. It consists of one or
[Word Count: 18]

more lines, where each line has the following format:
[Word Count: 9]

At program start, if there is a dfilters file in the personal configuration folder, it is read. If there
[Word Count: 19]

isn’t a dfilters file in the personal configuration folder, then, if there is a dfilters file in the global
[Word Count: 19]

When you press the Save button in the “Display Filters” dialog box, all the current display filters
[Word Count: 17]

are written to the personal display filters file.
[Word Count: 8]

Each line in this file specifies a disabled protocol name. The following are some examples:
[Word Count: 15]

At program start, if there is a disabled_protos file in the global configuration folder, it is read
[Word Count: 17]

first. Then, if there is a disabled_protos file in the personal configuration folder, that is read; if
[Word Count: 17]

there is an entry for a protocol set in both files, the setting in the personal disabled protocols file
[Word Count: 19]

overrides the setting in the global disabled protocols file.
[Word Count: 9]

When you press the Save button in the “Enabled Protocols” dialog box, the current set of
[Word Count: 16]

disabled protocols is written to the personal disabled protocols file.
[Word Count: 10]

This file contains all the display filter macros that you have defined and saved. It consists of one
[Word Count: 18]

or more lines, where each line has the following format:
[Word Count: 10]

At program start, if there is a dmacros file in the personal configuration folder, it is read. If there
[Word Count: 19]

isn’t a dmacros file in the personal configuration folder, then, if there is a dmacros file in the
[Word Count: 18]

global configuration folder, it is read.
[Word Count: 6]

In versions of Wireshark prior to 4.4, the display filter macros were stored in a dfilter_macros
[Word Count: 16]

file with a somewhat different format, a UAT. At program start if the dmacros file is not found a
[Word Count: 19]

dfilter_macros file is looked for in the personal and global configuration folders and converted to
[Word Count: 15]

When you press the Save button in the "Display Filter Macros" dialog box, all the current display
[Word Count: 17]

filter macros are written to the personal display filter macros file.
[Word Count: 11]

More information about Display Filter Macros is available in Defining And Saving Filter Macros
[Word Count: 14]

When Wireshark is trying to translate a hardware MAC or EUI-64 address to a name, it consults
[Word Count: 17]

the ethers file in the personal configuration folder first. If the address is not found in that file,
[Word Count: 18]

Wireshark consults the ethers file in the system configuration folder.
[Word Count: 10]

This file has a similar format to the /etc/ethers file on some UNIX-like systems. Each line in these
[Word Count: 18]

files consists of one hardware address and name separated by whitespace (tabs or spaces). The
[Word Count: 15]

hardware addresses are expressed as pairs of hexadecimal digits separated by colons (:), dashes
[Word Count: 14]

(-), or periods(.), with the same separator used in the entire address. A # can be used to indicate a
[Word Count: 20]

comment that extends to the rest of the line. NIS lookups, as in some UNIX-like systems, are not
[Word Count: 18]

supported. Both 6 byte MAC and 8 byte EUI-64 addresses are supported. The following are some
[Word Count: 16]

ff-ff-ff-ff-ff-ff    Broadcast
c0-00-ff-ff-ff-ff    TR_broadcast
00.2b.08.93.4b.a1    Freds_machine
00:00:00:00:00:00:00:00    zb_zero_broadcast
[Word Count: 8]

The settings from this file are read in at program start, and reloaded when opening a new
[Word Count: 17]

capture file or changing the configuration profile, and never written by Wireshark.
[Word Count: 12]

Wireshark uses the entries in the hosts files to translate IPv4 and IPv6 addresses into names.
[Word Count: 16]

At program start, if there is a hosts file in the global configuration folder, it is read first. Then, if
[Word Count: 20]

there is a hosts file in the personal configuration folder, that is read; if there is an entry for a
[Word Count: 20]

given IP address in both files, the setting in the personal hosts file overrides the entry in the
[Word Count: 18]

This file has the same format as the usual /etc/hosts file on Unix systems.
[Word Count: 14]

# Comments must be prepended by the # sign!
192.168.0.1 homeserver
[Word Count: 11]

The settings from this file are read in at program start, and reloaded when opening a new
[Word Count: 17]

capture file or changing the configuration profile, and never written by Wireshark.
[Word Count: 12]

When Wireshark is trying to translate an IPX network number to a name, it consults the ipxnets
[Word Count: 17]

file in the personal configuration folder first. If the address is not found in that file, Wireshark
[Word Count: 17]

consults the ipxnets file in the system configuration folder.
[Word Count: 9]

C0.A8.2C.00      HR
c0-a8-1c-00      CEO
00:00:BE:EF      IT_Server1
110f             FileServer3
[Word Count: 8]

The settings from this file are read in when an IPX network number is to be translated to a
[Word Count: 19]

At program start, if there is a manuf file in the global configuration folder, it is read first. Then, if
[Word Count: 20]

there is a manuf file in the personal configuration folder, that is read; if there is an entry for a
[Word Count: 20]

given address prefix in both files, the setting in the personal file overrides the entry in the global
[Word Count: 18]

The entries in this file are used to translate MAC address prefixes into short and long
[Word Count: 16]

manufacturer names. Each line consists of a MAC address prefix followed by an abbreviated
[Word Count: 14]

manufacturer name and the full manufacturer name. Prefixes 24 bits long by default and may
[Word Count: 15]

be followed by an optional length. Note that this is not the same format as the ethers file, which
[Word Count: 19]

00:00:01        Xerox   Xerox Corporation
00:50:C2:00:30:00/36      Microsof        Microsoft
[Word Count: 7]

In earlier versions of Wireshark, official information from the IEEE Registration Authority was
[Word Count: 13]

distributed in this format as the manuf file in the global configuration folder. In current versions
[Word Count: 16]

of Wireshark, this information is compiled into the program to speed startup, but if a file is
[Word Count: 17]

present in the global configuration folder it is still read, and can be used to supplement or
[Word Count: 17]

replace the official data just as the personal file does. The compiled-in information can be
[Word Count: 15]

written out in this format as a report with tshark -G manuf.
[Word Count: 12]

The settings from this file are read in at program start, and reloaded when opening a new
[Word Count: 17]

capture file or changing the configuration profile, and never written by Wireshark.
[Word Count: 12]

This file contains your Wireshark preferences, including defaults for capturing and displaying
[Word Count: 12]

packets. It is a simple text file containing statements of the form:
[Word Count: 12]

At program start, if there is a preferences file in the global configuration folder, it is read first.
[Word Count: 18]

Then, if there is a preferences file in the personal configuration folder, that is read; if there is a
[Word Count: 19]

preference set in both files, the setting in the personal preferences file overrides the setting in
[Word Count: 16]

If you press the Save button in the “Preferences” dialog box, all the current settings are written
[Word Count: 17]

This file contains GUI settings that are specific to the current profile, such as column widths and
[Word Count: 17]

toolbar visibility. It is a simple text file containing statements of the form:
[Word Count: 13]

It is read at program start and written when preferences are saved and at program exit. It is also
[Word Count: 19]

written and read whenever you switch to a different profile.
[Word Count: 10]

This file contains common GUI settings, such as recently opened capture files, recently used
[Word Count: 14]

filters, and window geometries. It is a simple text file containing statements of the form:
[Word Count: 15]

It is read at program start and written when preferences are saved and at program exit.
[Word Count: 16]

Wireshark uses the services files to translate port numbers into names.
[Word Count: 11]

At program start, if there is a services file in the global configuration folder, it is read first. Then,
[Word Count: 19]

if there is a services file in the personal configuration folder, that is read; if there is an entry for
[Word Count: 20]

a given port number in both files, the setting in the personal services file overrides the entry in
[Word Count: 18]

the global services file. The format is that of the standard services(5) file on UNIX-compatible
[Word Count: 15]

mydns       5045/udp     # My own Domain Name Server
mydns       5045/tcp     # My own Domain Name Server
[Word Count: 16]

In earlier versions of Wireshark, official information from the IANA Service Name and
[Word Count: 13]

Transport Protocol Port Number Registry was distributed in this format as the services file in the
[Word Count: 16]

global configuration folder. In current versions of Wireshark, this information is compiled into
[Word Count: 13]

the program to speed startup, but if a file is present in the global configuration folder it is still
[Word Count: 19]

read, and can be used to supplement or replace the official data just as the personal file does.
[Word Count: 18]

The compiled-in information can be written out in this format as a report with tshark -G
[Word Count: 16]

The settings from this file are read in at program start, and reloaded when opening a new
[Word Count: 17]

capture file or changing the configuration profile, and never written by Wireshark.
[Word Count: 12]

Wireshark uses the ss7pcs file to translate SS7 point codes to node names.
[Word Count: 13]

At program start, if there is a ss7pcs file in the personal configuration folder, it is read.
[Word Count: 17]

Each line in this file consists of one network indicator followed by a dash followed by a point
[Word Count: 18]

code in decimal and a node name separated by whitespace or tab.
[Word Count: 12]

The settings from this file are read in at program start, and reloaded when opening a new
[Word Count: 17]

capture file opens or changing the configuration profile, and never written by Wireshark.
[Word Count: 13]

Wireshark uses the subnets file to translate an IPv4 address into a subnet name. If no exact
[Word Count: 17]

match from a hosts file or from DNS is found, Wireshark will attempt a partial match for the
[Word Count: 18]

At program start, if there is a subnets file in the personal configuration folder, it is read first.
[Word Count: 18]

Then, if there is a subnets file in the global configuration folder, that is read; if there is a
[Word Count: 19]

preference set in both files, the setting in the global preferences file overrides the setting in the
[Word Count: 17]

Each line in one of these files consists of an IPv4 address, a subnet mask length separated only
[Word Count: 18]

by a “/” and a name separated by whitespace. While the address must be a full IPv4 address, any
[Word Count: 19]

values beyond the mask length are subsequently ignored.
[Word Count: 8]

# Comments must be prepended by the # sign!
192.168.0.0/24 ws_test_network
[Word Count: 11]

A partially matched name will be printed as “subnet-name.remaining-address”. For example,
[Word Count: 11]

“192.168.0.1” under the subnet above would be printed as “ws_test_network.1”; if the mask
[Word Count: 13]

length above had been 16 rather than 24, the printed address would be “ws_test_network.0.1”.
[Word Count: 14]

The settings from this file are read in at program start, and reloaded when opening a new
[Word Count: 17]

capture file or changing the configuration profile, and never written by Wireshark.
[Word Count: 12]

The subnets file also changes the behavior of the Endpoints and Conversations Statistics dialogs
[Word Count: 14]

for the IPv4 protocol when the IPv4 user preference Aggregate subnets in Statistics Dialogs is
[Word Count: 15]

enabled. In this case, when an IPv4 address matches a subnet, the statistics dialog will show this
[Word Count: 17]

Wireshark uses the vlans file to translate VLAN tag IDs into names.
[Word Count: 12]

If there is a vlans file in the currently active profile folder, it is used. Otherwise, the vlans file in
[Word Count: 20]

the personal configuration folder is used.
[Word Count: 6]

Each line in this file consists of one VLAN tag ID and a describing name separated by whitespace
[Word Count: 18]

123     Server-LAN
2049    HR-Client-LAN
[Word Count: 4]

The settings from this file are read in when a VLAN ID is to be translated to a name, and never
[Word Count: 21]

At program start, if there is a wka file in the global configuration folder, it is read.
[Word Count: 17]

The entries in this file are used to translate MAC addresses and MAC address prefixes into
[Word Count: 16]

names. The format is that of the manuf file. This file is distributed with Wireshark, and contains
[Word Count: 17]

data assembled from various non IEEE but respected sources.
[Word Count: 9]

The settings from this file are read in at program start, and reloaded when opening a new
[Word Count: 17]

capture file or changing the configuration profile, and never written by Wireshark.
[Word Count: 12]

Wireshark supports plugins for various purposes. Plugins can either be scripts written in Lua or
[Word Count: 15]

code written in C or C++ and compiled to machine code.
[Word Count: 11]

Wireshark looks for plugins in both a personal plugin folder and a global plugin folder. Lua plugins
[Word Count: 17]

are stored in the plugin folders; compiled plugins are stored in subfolders of the plugin folders,
[Word Count: 16]

with the subfolder name being the Wireshark minor version number (X.Y). There is another
[Word Count: 14]

hierarchical level for each Wireshark plugin type (libwireshark, libwiretap and codecs). So for
[Word Count: 13]

example the location for a libwireshark plugin foo.so (foo.dll on Windows) would be
[Word Count: 13]

PLUGINDIR/X.Y/epan (libwireshark used to be called libepan; the other folder names are codecs and
[Word Count: 14]

• The personal plugin folder is %APPDATA%\Wireshark\plugins.
[Word Count: 7]

• The global plugin folder is WIRESHARK\plugins.
[Word Count: 7]

• The personal plugin folder is ~/.local/lib/wireshark/plugins.
[Word Count: 7]

To provide better support for binary plugins this folder changed in Wireshark 2.5. It
[Word Count: 14]

is recommended to use the new folder but for lua scripts only you may continue to
[Word Count: 16]

use $XDG_CONFIG_HOME/wireshark/plugins for backward-compatibility. This is
[Word Count: 6]

useful to have older versions of Wireshark installed side-by-side. In case of
[Word Count: 12]

duplicate file names between old and new the new folder wins.
[Word Count: 11]

• If you are running on macOS and Wireshark is installed as an application bundle, the global
[Word Count: 17]

plugin 
folder 
is 
%APPDIR%/Contents/PlugIns/wireshark, 
otherwise 
it’s
[Word Count: 6]

Here you will find some details about the folders used in Wireshark on different Windows versions.
[Word Count: 16]

As already mentioned, you can find the currently used folders in the “About Wireshark” dialog.
[Word Count: 15]

Windows uses some special directories to store user configuration files which define the “user
[Word Count: 14]

profile”. This can be confusing, as the default directory location changed from Windows version to
[Word Count: 15]

version and might also be different for English and internationalized versions of Windows.
[Word Count: 13]

NOTE
If you’ve upgraded to a new Windows version, your profile might be kept in the
[Word Count: 16]

former location. The defaults mentioned here might not apply.
[Word Count: 9]

The following guides you to the right place where to look for Wireshark’s profile data.
[Word Count: 15]

Windows 10, Windows 8.1, Windows 8, Windows 7, Windows Vista, and associated server
[Word Count: 13]

C:\Users\username\AppData\Roaming\Wireshark.
[Word Count: 1]

C:\Documents and Settings\username\Application Data. “Documents and Settings” and
[Word Count: 8]

“Application Data” might be internationalized.
[Word Count: 5]

Some larger Windows environments use roaming profiles. If this is the case the configurations of
[Word Count: 15]

all programs you use won’t be saved on your local hard drive. They will be stored on the domain
[Word Count: 19]

Your settings will travel with you from computer to computer with one exception. The “Local
[Word Count: 15]

Settings” folder in your profile data (typically something like: C:\Documents and Settings\
[Word Count: 12]

username\Local Settings) will not be transferred to the domain server. This is the default for
[Word Count: 15]

Wireshark uses the folder which is set by the TMPDIR or TEMP environment variable. This variable
[Word Count: 16]

Windows 10, Windows 8.1, Windows 8, Windows 7, Windows Vista, and associated server
[Word Count: 13]

C:\Documents and Settings\username\Local Settings\Temp
[Word Count: 4]

[1] No longer supported by Wireshark. For historical reference only.
[Word Count: 10]

Appendix C: Protocols and Protocol Fields
[Word Count: 6]

Wireshark distinguishes between protocols (e.g., tcp) and protocol fields (e.g., tcp.port).
[Word Count: 11]

A comprehensive list of all protocols and protocol fields can be found in the “Display Filter
[Word Count: 16]

Reference” at https://www.wireshark.org/docs/dfref/
[Word Count: 3]

Wireshark comes with an array of command line tools which can be helpful for packet analysis.
[Word Count: 16]

Some of these tools are described in this chapter. You can find more information about all of
[Word Count: 17]

Wireshark’s command line tools on the web site.
[Word Count: 8]

TShark is a terminal oriented version of Wireshark designed for capturing and displaying packets
[Word Count: 14]

when an interactive user interface isn’t necessary or available. It supports the same options as
[Word Count: 15]

wireshark. For more information on tshark consult your local manual page (man tshark) or the
[Word Count: 15]

TShark (Wireshark) 4.5.0 (v4.5.0rc0-1147-g31b31e100870)
Dump and analyze network traffic.
See https://www.wireshark.org for more information.
[Word Count: 14]

Capture display:
  --update-interval        interval between updates with new packets, in milliseconds
(def: 100ms)
[Word Count: 13]

Diagnostic output:
  --log-level <level>      sets the active log level ("critical", "warning", etc.)
  --log-fatal <level>      sets level to abort the program ("critical" or "warning")
  --log-domains <[!]list>  comma-separated list of the active log domains
  --log-fatal-domains <list>
                           list of domains that cause the program to abort
  --log-debug <[!]list>    list of domains with "debug" level
  --log-noisy <[!]list>    list of domains with "noisy" level
  --log-file <path>        file to output messages to (in addition to stderr)
[Word Count: 70]

Miscellaneous:
  -h, --help               display this help and exit
  -v, --version            display version info and exit
  -o <name>:<value> ...    override preference setting
  -K <keytab>              keytab file to use for kerberos decryption
  -G [report]              dump one of several available reports and exit
                           default report="fields"
                           use "-G help" for more help
[Word Count: 48]

Dumpcap can benefit from an enabled BPF JIT compiler if available.
[Word Count: 11]

You might want to enable it by executing:
 "echo 1 > /proc/sys/net/core/bpf_jit_enable"
Note that this can make your system less secure!
[Word Count: 21]

tcpdump: Capturing with “tcpdump” for viewing with
Wireshark
[Word Count: 8]

It’s often more useful to capture packets using tcpdump rather than wireshark. For example, you
[Word Count: 15]

might want to do a remote capture and either don’t have GUI access or don’t have Wireshark
[Word Count: 17]

Older versions of tcpdump truncate packets to 68 or 96 bytes. If this is the case, use -s to capture full-
[Word Count: 21]

$ tcpdump -i <interface> -s 65535 -w <file>
[Word Count: 8]

You will have to specify the correct interface and the name of a file to save into. In addition, you will
[Word Count: 21]

have to terminate the capture with ^C when you believe you have captured enough packets.
[Word Count: 15]

tcpdump is not part of the Wireshark distribution. You can get it from https://www.tcpdump.org/ or
[Word Count: 15]

as a standard package in most Linux distributions. For more information on tcpdump consult your
[Word Count: 15]

local manual page (man tcpdump) or the online version.
[Word Count: 9]

dumpcap: Capturing with “dumpcap” for viewing with
Wireshark
[Word Count: 8]

Dumpcap is a network traffic dump tool. It captures packet data from a live network and writes the
[Word Count: 18]

packets to a file. Dumpcap’s native capture file format is pcapng, which is also the format used by
[Word Count: 18]

By default, Dumpcap uses the pcap library to capture traffic from the first available network
[Word Count: 15]

interface and writes the received raw packet data, along with the packets’ time stamps into a
[Word Count: 16]

pcapng file. The capture filter syntax follows the rules of the pcap library. For more information on
[Word Count: 17]

dumpcap consult your local manual page (man dumpcap) or the online version.
[Word Count: 12]

Dumpcap (Wireshark) 4.5.0 (v4.5.0rc0-1205-gef12db5df104)
Capture network packets and dump them into a pcapng or pcap file.
See https://www.wireshark.org for more information.
[Word Count: 21]

interval:NUM - switch to next file when the time is
                                          an exact multiple of NUM secs
                          printname:FILE - print filename to FILE when written
                                           (can use 'stdout' or 'stderr')
  -n                       use pcapng format instead of pcap (default)
  -P                       use libpcap format instead of pcapng
  --capture-comment <comment>
                           add a capture comment to the output file
                           (only for pcapng)
  --temp-dir <directory>   write temporary files to this directory
                           (default: /tmp)
[Word Count: 67]

Diagnostic output:
  --log-level <level>      sets the active log level ("critical", "warning", etc.)
  --log-fatal <level>      sets level to abort the program ("critical" or "warning")
  --log-domains <[!]list>  comma-separated list of the active log domains
  --log-fatal-domains <list>
                           list of domains that cause the program to abort
  --log-debug <[!]list>    list of domains with "debug" level
  --log-noisy <[!]list>    list of domains with "noisy" level
  --log-file <path>        file to output messages to (in addition to stderr)
[Word Count: 70]

Miscellaneous:
  -N <packet_limit>        maximum number of packets buffered within dumpcap
  -C <byte_limit>          maximum number of bytes used for buffering packets
                           within dumpcap
  -t                       use a separate thread per interface
  -q                       don't report packet capture counts
  --application-flavor <flavor>
                           set the application flavor
  -v, --version            print version information and exit
  -h, --help               display this help and exit
[Word Count: 55]

Dumpcap can benefit from an enabled BPF JIT compiler if available.
You might want to enable it by executing:
 "echo 1 > /proc/sys/net/core/bpf_jit_enable"
Note that this can make your system less secure!
[Word Count: 32]

Example: dumpcap -i eth0 -a duration:60 -w output.pcapng
"Capture packets from interface eth0 until 60s passed into output.pcapng"
[Word Count: 18]

Use Ctrl-C to stop capturing at any time.
[Word Count: 8]

capinfos: Print information about capture files
[Word Count: 6]

capinfos can print information about capture files including the file type, number of packets, date
[Word Count: 15]

and time information, and file hashes. Information can be printed in human and machine readable
[Word Count: 15]

formats. For more information on capinfos consult your local manual page (man capinfos) or the
[Word Count: 15]

Help information available from capinfos
[Word Count: 5]

Capinfos (Wireshark) 4.5.0 (v4.5.0rc0-48-g7b7ca8210417)
Print various information (infos) about capture files.
See https://www.wireshark.org for more information.
[Word Count: 16]

General infos:
  -t display the capture file type
  -E display the capture file encapsulation
  -I display the capture file interface information
  -F display additional capture file information
  -H display the SHA256 and SHA1 hashes of the file
  -k display the capture comment
  -p display individual packet comments
[Word Count: 47]

Size infos:
  -c display the number of packets
  -s display the size of the file (in bytes)
  -d display the total length of all packets (in bytes)
  -l display the packet size limit (snapshot length)
[Word Count: 35]

Time infos:
  -u display the capture duration (in seconds)
  -a display the timestamp of the earliest packet
  -e display the timestamp of the latest packet
  -o display the capture file chronological status (True/False)
  -S display earliest and latest packet timestamps as seconds
[Word Count: 42]

Statistic infos:
  -y display average data rate (in bytes/sec)
  -i display average data rate (in bits/sec)
  -z display average packet size (in bytes)
  -x display average packet rate (in packets/sec)
[Word Count: 30]

Metadata infos:
  -n display number of resolved IPv4 and IPv6 addresses
  -D display number of decryption secrets
[Word Count: 17]

Output format:
  -L generate long report (default)
  -T generate table report
  -M display machine-readable values in long reports
[Word Count: 18]

Table report options:
  -R generate header record (default)
  -r do not generate header record
[Word Count: 14]

-B separate infos with TAB character (default)
  -m separate infos with comma (,) character
  -b separate infos with SPACE character
[Word Count: 20]

-N do not quote infos (default)
  -q quote infos with single quotes (')
  -Q quote infos with double quotes (")
[Word Count: 20]

Miscellaneous:
  -h, --help               display this help and exit
  -v, --version            display version info and exit
  -C cancel processing if file open fails (default is to continue)
  -A generate all infos (default)
  -K disable displaying the capture comment
  -P disable displaying individual packet comments
[Word Count: 43]

Options are processed from left to right order with later options superseding
or adding to earlier options.
[Word Count: 17]

If no options are given the default is to display all infos in long report
output format.
[Word Count: 17]

rawshark: Dump and analyze network traffic.
[Word Count: 6]

Rawshark reads a stream of packets from a file or pipe, and prints a line describing its output,
[Word Count: 18]

followed by a set of matching fields for each packet on stdout. For more information on rawshark
[Word Count: 17]

consult your local manual page (man rawshark) or the online version.
[Word Count: 11]

Help information available from rawshark
[Word Count: 5]

Rawshark (Wireshark) 4.5.0 (v4.5.0rc0-48-g7b7ca8210417)
Dump and analyze network traffic.
See https://www.wireshark.org for more information.
[Word Count: 14]

Input file:
  -r <infile>, --read-file <infile>
                            set the pipe or file name to read from
[Word Count: 15]

Output:
  -l                       flush output after each packet
  -S                       format string for fields
                           (%D - name, %S - stringval, %N numval)
  -t (a|ad|adoy|d|dd|e|r|u|ud|udoy)[.[N]]|.[N]
                           output format of time stamps (def: r: rel. to first)
  -u s|hms                 output format of seconds (def: s: seconds)
[Word Count: 41]

Diagnostic output:
  --log-level <level>      sets the active log level ("critical", "warning", etc.)
  --log-fatal <level>      sets level to abort the program ("critical" or "warning")
  --log-domains <[!]list>  comma-separated list of the active log domains
  --log-fatal-domains <list>
                           list of domains that cause the program to abort
  --log-debug <[!]list>    list of domains with "debug" level
  --log-noisy <[!]list>    list of domains with "noisy" level
  --log-file <path>        file to output messages to (in addition to stderr)
[Word Count: 70]

-h, --help               display this help and exit
  -v, --version            display version info and exit
  -o <name>:<value> ...    override preference setting
  -K <keytab>              keytab file to use for kerberos decryption
[Word Count: 29]

editcap is a general-purpose utility for modifying capture files. Its main function is to remove
[Word Count: 15]

packets from capture files, but it can also be used to convert capture files from one format to
[Word Count: 18]

another, as well as to print information about capture files. For more information on editcap
[Word Count: 15]

consult your local manual page (man editcap) or the online version.
[Word Count: 11]

Editcap (Wireshark) 4.5.0 (v4.5.0rc0-48-g7b7ca8210417)
Edit and/or translate the format of capture files.
See https://www.wireshark.org for more information.
[Word Count: 17]

Usage: editcap [options] ... <infile> <outfile> [ <packet#>[-<packet#>] ... ]
[Word Count: 10]

<infile> and <outfile> must both be present; use '-' for stdin or stdout.
A single packet or a range of packets can be selected.
[Word Count: 24]

Packet selection:
  -r                     keep the selected packets; default is to delete them.
  -A <start time>        only read packets whose timestamp is after (or equal
                         to) the given time.
  -B <stop time>         only read packets whose timestamp is before the
                         given time.
                         Time format for -A/-B options is
                         YYYY-MM-DDThh:mm:ss[.nnnnnnnnn][Z|+-hh:mm]
                         Unix epoch timestamps are also supported.
[Word Count: 54]

Specifically the -r, -t or -S options will very likely NOT have the
           desired effect if combined with the -d, -D or -w.
  --skip-radiotap-header skip radiotap header when checking for packet duplicates.
                         Useful when processing packets captured by multiple radios
                         on the same channel in the vicinity of each other.
  --set-unused           set unused byts to zero in sll link addr.
[Word Count: 60]

Miscellaneous:
  -h, --help             display this help and exit.
  -V                     verbose output.
                         If -V is used with any of the 'Duplicate Packet
                         Removal' options (-d, -D or -w) then Packet lengths
                         and MD5 hashes are printed to standard-error.
  -v, --version          print version information and exit.
[Word Count: 44]

Capture file types available from editcap -F
[Word Count: 7]

editcap: The available capture file types for the "-F" flag are:
    pcap - Wireshark/tcpdump/... - pcap
[Word Count: 16]

Encapsulation types available from editcap -T
[Word Count: 6]

editcap: The available encapsulation types for the "-T" flag are:
    alp - ATSC Link-Layer Protocol (A/330) packets
    ap1394 - Apple IP-over-IEEE 1394
    arcnet - ARCNET
    arcnet_linux - Linux ARCNET
    ascend - Lucent/Ascend access equipment
[Word Count: 34]

mergecap: Merging multiple capture files into one
[Word Count: 7]

Mergecap is a program that combines multiple saved capture files into a single output file specified
[Word Count: 16]

by the -w argument. Mergecap can read libpcap capture files, including those of tcpdump. In
[Word Count: 15]

addition, Mergecap can read capture files from snoop (including Shomiti) and atmsnoop,
[Word Count: 12]

LanAlyzer, Sniffer (compressed or uncompressed), Microsoft Network Monitor, AIX’s iptrace,
[Word Count: 10]

NetXray, Sniffer Pro, RADCOM’s WAN/LAN analyzer, Lucent/Ascend router debug output, HP-UX’s
[Word Count: 11]

nettl, and the dump output from Toshiba’s ISDN routers. There is no need to tell Mergecap what
[Word Count: 17]

type of file you are reading; it will determine the file type by itself. Mergecap is also capable of
[Word Count: 19]

reading any of these file formats if they are compressed using gzip. Mergecap recognizes this
[Word Count: 15]

directly from the file; the “.gz” extension is not required for this purpose.
[Word Count: 13]

By default, Mergecap writes all of the packets in the input capture files to a pcapng file. The -F flag
[Word Count: 20]

can be used to specify the capture file’s output format ; it can write the file in libpcap format
[Word Count: 19]

(standard libpcap format, a modified format used by some patched versions of libpcap, the format
[Word Count: 15]

used by Red Hat Linux 6.1, or the format used by SuSE Linux 6.3), snoop format, uncompressed
[Word Count: 17]

Sniffer format, Microsoft Network Monitor 1.x format, and the format used by Windows-based
[Word Count: 13]

Packets from the input files are merged in chronological order based on each frame’s timestamp,
[Word Count: 15]

unless the -a flag is specified. Mergecap assumes that frames within a single capture file are
[Word Count: 16]

already stored in chronological order. When the -a flag is specified, packets are copied directly
[Word Count: 15]

from each input file to the output file, independent of each frame’s timestamp.
[Word Count: 13]

If the -s flag is used to specify a snapshot length, frames in the input file with more captured data
[Word Count: 20]

than the specified snapshot length will have only the amount of data specified by the snapshot
[Word Count: 16]

length written to the output file. This may be useful if the program that is to read the output file
[Word Count: 20]

cannot handle packets larger than a certain size (for example, the versions of snoop in Solaris 2.5.1
[Word Count: 17]

and Solaris 2.6 appear to reject Ethernet frames larger than the standard Ethernet MTU, making
[Word Count: 15]

them incapable of handling gigabit Ethernet captures if jumbo frames were used).
[Word Count: 12]

If the -T flag is used to specify an encapsulation type, the encapsulation type of the output capture
[Word Count: 18]

file will be forced to the specified type, rather than being the type appropriate to the encapsulation
[Word Count: 17]

type of the input capture file. Note that this merely forces the encapsulation type of the output file
[Word Count: 18]

to be the specified type; the packet headers of the packets will not be translated from the
[Word Count: 17]

encapsulation type of the input capture file to the specified encapsulation type (for example, it will
[Word Count: 16]

not translate an Ethernet capture to an FDDI capture if an Ethernet capture is read and -T fddi is
[Word Count: 19]

For more information on mergecap consult your local manual page (man mergecap) or the online
[Word Count: 15]

Help information available from mergecap
[Word Count: 5]

Mergecap (Wireshark) 4.5.0 (v4.5.0rc0-48-g7b7ca8210417)
Merge two or more capture files into one.
See https://www.wireshark.org for more information.
[Word Count: 17]

Usage: mergecap [options] -w <outfile>|- <infile> [<infile> ...]
[Word Count: 8]

Miscellaneous:
  -h, --help        display this help and exit.
  -V                verbose output.
  -v, --version     print version information and exit.
[Word Count: 18]

A simple example merging dhcp-capture.pcapng and imap-1.pcapng into outfile.pcapng is shown
[Word Count: 11]

$ mergecap -w outfile.pcapng dhcp-capture.pcapng imap-1.pcapng
[Word Count: 6]

text2pcap: Converting ASCII hexdumps to network
captures
[Word Count: 7]

There may be some occasions when you wish to convert a hex dump of some network traffic into a
[Word Count: 19]

text2pcap is a program that reads in an ASCII hex dump and writes the data described into any
[Word Count: 18]

capture file format supported by libwiretap. text2pcap can read hexdumps with multiple packets in
[Word Count: 14]

them, and build a capture file of multiple packets. text2pcap is also capable of generating dummy
[Word Count: 16]

Ethernet, IP, UDP, TCP or SCTP headers, in order to build fully processable packet dumps from
[Word Count: 16]

hexdumps of application-level data only.
[Word Count: 5]

text2pcap understands a hexdump of the form generated by od -A x -t x1. In other words, each
[Word Count: 18]

byte is individually displayed and surrounded with a space. Each line begins with an offset
[Word Count: 15]

describing the position in the packet, each new packet starts with an offset of 0 and there is a space
[Word Count: 20]

separating the offset from the following bytes. The offset is a hex number (can also be octal - see -o),
[Word Count: 20]

of more than two hex digits. Here is a sample dump that text2pcap can recognize:
[Word Count: 15]

000000 00 e0 1e a7 05 6f 00 10 ........
000008 5a a0 b9 12 08 00 46 00 ........
000010 03 68 00 00 00 00 0a 2e ........
000018 ee 33 0f 19 08 7f 0f 19 ........
000020 03 80 94 04 00 00 10 01 ........
000028 16 a2 0a 00 03 50 00 0c ........
000030 01 01 0f 19 03 80 11 01 ........
[Word Count: 70]

There is no limit on the width or number of bytes per line. Also the text dump at the end of the line
[Word Count: 23]

is ignored. Bytes/hex numbers can be uppercase or lowercase. Any text before the offset is ignored,
[Word Count: 16]

including email forwarding characters “>”. Any lines of text between the bytestring lines is ignored.
[Word Count: 15]

The offsets are used to track the bytes, so offsets must be correct. Any line which has only bytes
[Word Count: 19]

without a leading offset is ignored. An offset is recognized as being a hex number longer than two
[Word Count: 18]

characters. Any text after the bytes is ignored (e.g., the character dump). Any hex numbers in this
[Word Count: 17]

text are also ignored. An offset of zero is indicative of starting a new packet, so a single text file with
[Word Count: 21]

a series of hexdumps can be converted into a packet capture with multiple packets. Packets may be
[Word Count: 17]

preceded by a timestamp. These are interpreted according to the format given on the command
[Word Count: 15]

line. If not, the first packet is timestamped with the current time the conversion takes place.
[Word Count: 16]

Multiple packets are written with timestamps differing by one microsecond each. In general, short
[Word Count: 14]

of these restrictions, text2pcap is pretty liberal about reading in hexdumps and has been tested with
[Word Count: 16]

a variety of mangled outputs (including being forwarded through email multiple times, with
[Word Count: 13]

There are a couple of other special features to note. Any line where the first non-whitespace
[Word Count: 16]

character is “#” will be ignored as a comment. Any line beginning with #TEXT2PCAP is a directive
[Word Count: 17]

and options can be inserted after this command to be processed by text2pcap. Currently there are
[Word Count: 16]

no directives implemented; in the future, these may be used to give more fine-grained control on
[Word Count: 16]

the dump and the way it should be processed e.g., timestamps, encapsulation type etc.
[Word Count: 14]

text2pcap also allows the user to read in dumps of application-level data, by inserting dummy L2,
[Word Count: 16]

L3 and L4 headers before each packet. Possibilities include inserting headers such as Ethernet,
[Word Count: 14]

Ethernet + IP, Ethernet + IP + UDP, or TCP, or SCTP before each packet. This allows Wireshark or any
[Word Count: 20]

other full-packet decoder to handle these dumps.
[Word Count: 7]

For more information on text2pcap consult your local manual page (man text2pcap) or the online
[Word Count: 15]

Help information available from text2pcap
[Word Count: 5]

Text2pcap (Wireshark) 4.5.0 (v4.5.0rc0-48-g7b7ca8210417)
Generate a capture file from an ASCII hexdump of packets.
See https://www.wireshark.org for more information.
[Word Count: 19]

Usage: text2pcap [options] <infile> <outfile>
[Word Count: 5]

where  <infile> specifies input  filename (use - for standard input)
      <outfile> specifies output filename (use - for standard output)
[Word Count: 19]

Input:
  -o hex|oct|dec|none    parse offsets as (h)ex, (o)ctal, (d)ecimal, or (n)one;
                         default is hex.
  -t <timefmt>           treat the text before the packet as a date/time code;
                         <timefmt> is a format string supported by strptime,
                         with an optional %f descriptor for fractional seconds.
                         Example: The time "10:15:14.5476" has the format code
                         "%H:%M:%S.%f"
                         The special format string ISO supports ISO-8601 times.
                         NOTE: Date/time fields from the current date/time are
                         used as the default for unspecified fields.
[Word Count: 74]

Prepend dummy header:
  -e <ethertype>         prepend dummy Ethernet II header with specified EtherType
                         (in HEX).
                         Example: -e 0x806 to specify an ARP packet.
  -i <proto>             prepend dummy IP header with specified IP protocol
                         (in DECIMAL).
                         Automatically prepends Ethernet header as well if
                         link-layer type is Ethernet.
[Word Count: 46]

Diagnostic output:
  --log-level <level>      sets the active log level ("critical", "warning", etc.)
  --log-fatal <level>      sets level to abort the program ("critical" or "warning")
  --log-domains <[!]list>  comma-separated list of the active log domains
  --log-fatal-domains <list>
                           list of domains that cause the program to abort
  --log-debug <[!]list>    list of domains with "debug" level
  --log-noisy <[!]list>    list of domains with "noisy" level
  --log-file <path>        file to output messages to (in addition to stderr)
[Word Count: 70]

Miscellaneous:
  -h, --help             display this help and exit
  -v, --version          print version information and exit
  -q                     don't report processed packet counts
[Word Count: 21]

reordercap lets you reorder a capture file according to the packets timestamp. For more information
[Word Count: 15]

on reordercap consult your local manual page (man reordercap) or the online version.
[Word Count: 13]

Help information available from reordercap
[Word Count: 5]

Reordercap (Wireshark) 4.5.0 (v4.5.0rc0-48-g7b7ca8210417)
Reorder timestamps of input file frames into output file.
See https://www.wireshark.org for more information.
[Word Count: 18]

Usage: reordercap [options] <infile> <outfile>
[Word Count: 5]

Options:
  -n                don't write to output file if the input file is ordered.
  -h, --help        display this help and exit.
  -v, --version     print version information and exit.
[Word Count: 27]

As with the original license and documentation distributed with Wireshark, this document is
[Word Count: 13]

covered by the GNU General Public License (GNU GPL).
[Word Count: 9]

If you haven’t read the GPL before, please do so. It explains all the things that you are allowed to do
[Word Count: 21]

GNU GENERAL PUBLIC LICENSE
               Version 2, June 1991
[Word Count: 8]

Copyright (C) 1989, 1991 Free Software Foundation, Inc.
     51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.
[Word Count: 36]

The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.)  You can apply it to
your programs, too.
[Word Count: 94]

When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.
[Word Count: 78]

To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.
[Word Count: 45]

For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.
[Word Count: 53]

We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.
[Word Count: 29]

Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.
[Word Count: 64]

Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.
[Word Count: 56]

The precise terms and conditions for copying, distribution and
modification follow.
[Word Count: 11]

GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
[Word Count: 12]

0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".
[Word Count: 100]

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.
[Word Count: 65]

1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.
[Word Count: 72]

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.
[Word Count: 27]

2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:
[Word Count: 48]

a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.
[Word Count: 23]

b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.
[Word Count: 47]

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.
[Word Count: 43]

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.
[Word Count: 44]

3. You may copy and distribute the Program (or a work based on it,
[Word Count: 14]

under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:
[Word Count: 27]

a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,
[Word Count: 32]

b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,
[Word Count: 61]

c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)
[Word Count: 48]

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.
[Word Count: 54]

4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.
[Word Count: 68]

5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
[Word Count: 34]

prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.
[Word Count: 52]

6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.
[Word Count: 66]

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.
[Word Count: 37]

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.
[Word Count: 21]

8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
[Word Count: 22]

original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.
[Word Count: 50]

9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.
[Word Count: 43]

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.
[Word Count: 75]

10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.
[Word Count: 80]

11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.
[Word Count: 96]

How to Apply These Terms to Your New Programs
[Word Count: 9]

If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.
[Word Count: 41]

To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.
[Word Count: 51]

<one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>
[Word Count: 21]

This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.
[Word Count: 41]

This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
[Word Count: 38]

You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
[Word Count: 34]

Also add information on how to contact you by electronic and paper mail.
[Word Count: 13]

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:
[Word Count: 20]

Gnomovision version 69, Copyright (C) year  name of author
    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.
[Word Count: 39]

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.
[Word Count: 46]

You should also get your employer (if you work as a programmer) or your
[Word Count: 14]

school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:
[Word Count: 20]

Yoyodyne, Inc., hereby disclaims all copyright interest in the program
  `Gnomovision' (which makes passes at compilers) written by James Hacker.
[Word Count: 20]

<signature of Ty Coon>, 1 April 1989
  Ty Coon, President of Vice
[Word Count: 12]

This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Library General
Public License instead of this License.
[Word Count: 53]

Total Paragraphs: 5436