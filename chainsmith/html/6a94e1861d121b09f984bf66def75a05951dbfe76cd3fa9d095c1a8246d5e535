<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<script type="text/javascript">var BOOTSTRAP_VERSION ="lumen";
	var BOOTSTRAP_JS_HEAD =1;
	var BOOTSTRAP_CDN_ENABLE =0; var BOOTSTRAP_NAVBAR_TYPE =0; var BOOTSTRAP_LOGO_OPTION =0; var BOOTSTRAP_NAVBAR =1; var BootstrapInputFix =true;var BootstrapNavbarLineHeightFix =true;var BOOTSTRAP_EDT= 0; </script>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<title>Virus Bulletin :: VB2014 paper: Unveiling the kernel: rootkit discovery using selective automated kernel memory differencing</title>
<meta name="description" content="The very nature of rootkits makes them hard to classify (and in some cases even detect) using automated malware analysis techniques. Kernel memory modifications can indicate that samples are trying to conceal information or hijack execution paths, thus exhibiting malicious behaviour. In an environment with a large throughput of analysis jobs, the need arises for an efficient and accurate way to identify such complex threats. In their VB2014 paper, Ahmed Zaki and Benjamin Humphrey present a system for identifying rootkit samples that is based on automated analysis - but instead of monitoring modifications to the whole memory, the system captures changes to data structures and memory regions that are known to have been targeted by rootkits in the past." />
<meta name="generator" content="concrete5 - 5.6.3.5" />
<script type="text/javascript">
var CCM_DISPATCHER_FILENAME = '/index.php';var CCM_CID = 1571;var CCM_EDIT_MODE = false;var CCM_ARRANGE_MODE = false;var CCM_IMAGE_PATH = "/concrete/images";
var CCM_TOOLS_PATH = "/index.php/tools/required";
var CCM_BASE_URL = "https://www.virusbulletin.com";
var CCM_REL = "";

</script>
<link rel="shortcut icon" href="/files/8914/5459/9485/VBIcon.png" type="image/x-icon" />
<link rel="icon" href="/files/8914/5459/9485/VBIcon.png" type="image/x-icon" />
<link rel="stylesheet" type="text/css" href="/concrete/css/ccm.base.css" />
<script type="text/javascript" src="/concrete/js/jquery.js"></script>
<script type="text/javascript" src="/concrete/js/ccm.base.js"></script>
<script type="text/javascript">
var COOKIES_ALLOWED=false;
</script>
<link rel="stylesheet" type="text/css" href="/packages/free_cookies_disclosure/css/cookies_disclosure.css" />
<!--[if lte IE 8]><link rel="stylesheet" type="text/css" href="/packages/free_cookies_disclosure/css/cookies_disclosure_ie.css" /><![endif]-->
<script type="text/javascript">
var COOKIES_DISCLOSURE_HIDE_INTERVAL=10;
</script>
<script type="text/javascript" src="/packages/free_cookies_disclosure/js/disclosure_hide.js"></script>
<link rel="stylesheet" type="text/css" href="/packages/bootstrap/css/lumen/bootstrap.css" />
<link rel="stylesheet" type="text/css" href="/packages/bootstrap/css/lumen/bootstrap-overwrites.css" />
<link rel="stylesheet" type="text/css" href="/packages/bootstrap/css/members.css" />
<script type="text/javascript" src="/packages/bootstrap/js/common/prettify.js"></script>
<script type="text/javascript" src="/packages/bootstrap/js/common/jquery.easing.1.3.js"></script>
<script type="text/javascript" src="/packages/bootstrap/js/common/bootstrap.min.js"></script>
<link rel="stylesheet" type="text/css" href="/libraries/css/jquery.fancybox.css" />
<script type="text/javascript" src="/libraries/js/jquery.fancybox.pack.js"></script>
<link rel="stylesheet" media="screen" type="text/css" href="/files/cache/css/bootstrap/typography.css" />
<script type="text/javascript" src="/index.php/tools/packages/free_cookies_disclosure/disclosure_i18n_js"></script>
<script type="text/javascript" src="/packages/free_cookies_disclosure/js/disclosure_ajax_form.js"></script>
<link rel="stylesheet" type="text/css" href="/concrete/blocks/page_list/view.css" />
<link rel="stylesheet" type="text/css" href="/packages/remo_expand/blocks/remo_expand/templates/vbexpand/view.css" />
<script type="text/javascript" src="/packages/remo_expand/js/jquery.color.js"></script>
<script type="text/javascript" src="/packages/remo_expand/js/jquery.ba-hashchange.js"></script>
<script type="text/javascript" src="/packages/remo_expand/js/remo.expand.js"></script>
<link rel="stylesheet" type="text/css" href="/packages/bootstrap/blocks/search/templates/VB_global_search/view.css" />
<link rel="stylesheet" type="text/css" href="/packages/travisn_spacer/css/ccm.tnspacer.css" />

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">

<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/run_prettify.js" integrity="sha256-1SFdTXlsw0RkQ+iO0E91LDshGiIbPiTYqJto0px4wds=" crossorigin="anonymous"></script>
<!--[if gte IE 9]>
<script src="/packages/bootstrap/js/common/modernizr.js"></script>
<![endif]-->

<!--[if lt IE 9]>	
	
	<script src="/packages/bootstrap/js/common/html5shiv.js"></script>
	<script src="/packages/bootstrap/js/common/respond.min.js"></script>
	
<![endif]-->
</head>
<body data-spy="scroll" data-target=".bs-sidebar">

<div class="navbar  navbar-fixed-top navbar-default  bs-docs-nav">
<div class="navbar-inner">
<div class="container"><div class="row"><div class="col-sm-4 col-md-4 logo-position-1 col-logo">
<div class="navbar-header">
<button type="button" class="navbar-toggle btn_navbar_custom">
<span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</button><div class="mobile-clearfix"></div><div class="navbar-brand navbar-brand-area"><a href="/"><img border="0" class="ccm-image-block" alt="" src="/files/4614/4535/7515/logo-big.png" width="339" height="92" /></a></div> </div>
</div><div class="col-sm-8 col-md-8 logo-position-1 col-nav"> <div class="nav-collapse collapse nav_collapse_custom navbar-collapse"> <div style="clear:both"></div>
<div class="vb-global-search-div">
<form action="/index.php/global-search-results/" method="get">
<fieldset>
<input name="search_paths[]" type="hidden" value="" />
<input name="query" type="text" class="vb-global-search" placeholder="Search site..." />
<input name="submit" type="submit" value="Search!" style="display:none" />
</fieldset>
</form>
</div>
<div class="tnSpacer" style="height:48px"></div>
<ul class="nav nav-pills"><li class=" nav-first nav-item-6299"><a href="/newsletter/" target="_self" class=" nav-first nav-item-6299 ">Newsletter</a></li><li class=" nav-item-260"><a href="/conference/" target="_self" class=" nav-item-260 ">VB Conference</a></li><li class=" nav-item-166"><a href="/testing/" target="_self" class=" nav-item-166 ">VB Testing</a></li><li class=" nav-path-selected active nav-item-160"><a href="/virusbulletin/" target="_self" class=" nav-path-selected active nav-item-160 ">Bulletin</a></li><li class=" nav-last nav-item-130"><a href="/blog/" target="_self" class=" nav-last nav-item-130 ">Blog</a></li></ul> </div>
</div>
</div><div class="clearfix"></div>
</div>
</div>
</div>
<div class="navbar-top-fixed-space "><div class="clearfix"></div></div>

<div class="container m-top-20">
<div class="row">
<div class="col-md-9 col-sm-9 col-lg-9">
<div class="titlepage" xmlns=""><div><div><h1 class="title" xmlns="http://www.w3.org/1999/xhtml"><a id="vb201501-unveiling-kernel"></a>VB2014 paper: Unveiling the kernel: rootkit discovery using selective automated kernel memory differencing</h1></div><div><p class="pubdate" xmlns="http://www.w3.org/1999/xhtml">2015-01-06</p></div><div><div class="authorgroup" xmlns="http://www.w3.org/1999/xhtml"><div class="author titlepage"><h3 class="author"><span class="firstname">Ahmed</span> <span class="surname">Zaki</span></h3><span class="orgname">Sophos</span>, <span class="orgdiv">UK</span></div><div class="author titlepage"><h3 class="author"><span class="firstname">Benjamin</span> <span class="surname">Humphrey</span></h3><span class="orgname">Sophos</span>, <span class="orgdiv">UK</span></div><b class="editedby">Editor: </b><span class="editor"><span class="firstname">Martijn</span> <span class="surname">Grooten</span></span></div></div><div><div class="abstract" xmlns="http://www.w3.org/1999/xhtml"><p class="title"><b>Abstract</b></p><p>The very nature of rootkits makes them hard to classify (and in some cases even detect) using automated malware analysis techniques. Kernel memory modifications can indicate that samples are trying to conceal information or hijack execution paths, thus exhibiting malicious behaviour. In an environment with a large throughput of analysis jobs, the need arises for an efficient and accurate way to identify such complex threats. In their VB2014 paper, Ahmed Zaki and Benjamin Humphrey present a system for identifying rootkit samples that is based on automated analysis - but instead of monitoring modifications to the whole memory, the system captures changes to data structures and memory regions that are known to have been targeted by rootkits in the past. </p></div></div><div><p class="copyright" xmlns="http://www.w3.org/1999/xhtml"><i>Copyright &copy; 2014 Virus Bulletin</i></p></div></div><hr /></div>
<div class="ccm-remo-expand">
<div id="ccm-remo-expand-title-2143" class="ccm-remo-expand-title ccm-remo-expand-closed" data-expander-speed="200">Table of contents</div><div id="ccm-remo-expand-content-2143" class="ccm-remo-expand-content"><div class="toc"><dl><dt><span class="sect1"><a href="#id3982360">Abstract</a></span></dt><dt><span class="sect1"><a href="#id3141120">1. Introduction</a></span></dt><dt><span class="sect1"><a href="#id3057773">2. System specifications</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id4181697">2.1 Usage of the Sophos AV Engine</a></span></dt><dt><span class="sect2"><a href="#id4578516">2.2 A processing module</a></span></dt><dt><span class="sect2"><a href="#id4598585">2.3 A driver analysis package</a></span></dt><dt><span class="sect2"><a href="#id4335388">2.4 The signatures</a></span></dt><dt><span class="sect2"><a href="#id4112761">2.5 The report</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id2229284">3. Results</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id3247998">3.1 Known malicious rootkits</a></span></dt><dt><span class="sect2"><a href="#id4629683">3.2 Building a malware index using kernel memory differencing</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id2988290">4. CONCLUSION</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id2676424">4.1 Future work</a></span></dt></dl></dd></dl></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a class="chapter" id="id3982360"></a>Abstract</h2></div></div></div><p>As an increasing number of automated malware analysis systems become mainstream, the emphasis on the relevance of the data extracted from the analysis task increases. Conceptually, automated malware analysis systems provide information about a sample and also identify modifications to a computer system induced by the sample. Traditionally, the focus of such analysis systems has primarily been on monitoring process, disk and network-level behaviour with varying levels of granularity. While providing a varied set of information, these systems offer limited ability to identify and classify rootkits. The very nature of rootkits makes them hard to classify (and in some cases even detect) using these scanning techniques. Kernel memory modifications can indicate that samples are trying to conceal information or hijack execution paths, thus exhibiting malicious behaviour. In an environment with a large throughput of analysis jobs, the need arises for an efficient and accurate way to identify such complex threats that could otherwise be misclassified or pass unnoticed. We present a system for identifying rootkit samples that is based on automated analysis. In this system we recognize the performance and memory constraints of a high-throughput environment; instead of monitoring modifications to the whole memory, we capture changes to data structures and memory regions that, on a <span class="emphasis"><em>Microsoft Windows</em></span> operating system, are known to have been targeted by rootkits in the past. We explain the reasons behind the design decisions and how they have reflected on identifying different classes of rootkits. In our research, we also explore the effectiveness of using this model as a standalone component to identify malicious behaviour. In order to do this, we run a large set of known clean versus malicious files to identify traits that could be indicative of malicious activity.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a class="chapter" id="id3141120"></a>1. Introduction</h2></div></div></div><p>The volume of malware is increasing exponentially. The number of samples seen by anti-virus vendors each day now exceeds the personnel resources available to analyse and classify them. In order to reduce the workload, automated analysis systems are used to identify, classify and cluster samples based on their malicious behaviour. Using static (examining file attributes) and dynamic (behavioural) techniques, these systems examine each sample, and usually make a reasoned assumption about its maliciousness. </p><p>Kernel-mode rootkits pose a particular problem when it comes to automated analysis. A rootkit is &lsquo;malicious software that allows an unauthorized user to maintain access to a computer by concealing programs and processes, files, or data from the operating system&rsquo; [<span class="citation"><a href="#citation.1">1</a></span>]. Kernel-mode rootkits are a sub-class of rootkits that introduce changes in the kernel memory of an operating system to conceal or manipulate information provided by the kernel itself. Examples of kernel-mode rootkits include Necurs <em class="citetitle"><a href="#citation.2">2</a></em>, TDL [<span class="citation"><a href="#citation.3">3</a></span>] and Turla [<span class="citation"><a href="#citation.4">4</a></span>]. A rootkit&rsquo;s ability to hide in the operating system increases the likelihood that automated analysis systems will fail to produce any intelligible data. Tools such as <span class="emphasis"><em>GMER</em></span> [<span class="citation"><a href="#citation.5">5</a></span>] can be used to detect rootkit activity, but scan times can be long and the tools can be cumbersome to automate. In an environment where the throughput of samples is in the tens of thousands, speed of analysis is certainly an issue. </p><p>To create an automated analysis system that can detect kernel mode rootkits, it is necessary to create a reliable method of identifying rootkit-like behaviour that is efficient and fast to keep analysis times to a minimum. We propose a system that fulfils these criteria, based on the <span class="emphasis"><em>Cuckoo Sandbox </em></span>[<span class="citation"><a href="#citation.6">6</a></span>] modified to use the <span class="emphasis"><em>Sophos</em></span> AV engine. Using the engine, selected areas of the kernel are extracted and saved to create &lsquo;Before&rsquo; and &lsquo;After&rsquo; snapshots to identify the changes made to the kernel. By examining these changes it is possible to identify rootkit activity. </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a class="chapter" id="id3057773"></a>2. System specifications</h2></div></div></div><p>We use a <span class="emphasis"><em>Windows 7 </em></span>SP1 x86 virtual machine in a <span class="emphasis"><em>VirtualBox</em></span> virtualization environment, version 4.3.10. The kernel memory differencing is implemented as part of a <span class="emphasis"><em>Cuckoo Sandbox </em></span>installed on <span class="emphasis"><em>Ubuntu</em></span> OS version 12.04.</p><p>The guest virtual machine has the <span class="emphasis"><em>Sophos</em></span> anti-virus engine installed by default. Detections are reported as part of the analysis information and sent to the host component. Once a sample executes, a kernel memory scan is started by the analyser inside the guest machine. In addition to scanning for known malware traits in kernel memory, the scan dumps specific kernel structure information to disk in JSON format. (More on this data is explained in Section 2.1.) This data is saved to the server module with other standard behavioural analysis information as part of each analysis. </p><p>In order to capture kernel memory changes made by the sample, we need a baseline snapshot of the kernel data before execution of the sample (the baseline data). The baseline data is associated with a virtual machine snapshot. Each snapshot has a unique identifier and baseline data. The baseline data is generated by performing a dummy analysis with no files submitted. The results of the analysis are tagged as baseline data, and comparisons are made with data obtained from subsequent analysis tasks. </p><p><span class="emphasis"><em><span class="bold"><strong>Cuckoo</strong></span></em></span></p><p>We utilize the<span class="emphasis"><em> Cuckoo Sandbox</em></span> as a base framework for automating sample analysis. <span class="emphasis"><em>Cuckoo Sandbox </em></span>is an open-source malware analysis system [<span class="citation"><a href="#citation.6">6</a></span>]. It supports running different types of files using different virtualization technologies.</p><p><span class="emphasis"><em>Cuckoo Sandbox</em></span>&rsquo;s modularity makes it ideal for our purposes. It can be split into a host-side management component and a guest side component running in a virtual machine (VM). The host-side component is responsible for the core execution of the analysis task: starting a VM, preparing an analysis task for execution (packaging the guest-side components that run inside the VM to collect analysis information), collecting the raw data resulting from the analysis, processing it, and finally running a set of signatures and reports to present the results. The guest side component runs selected modules packaged by the host-side component and returns the results to it [<span class="citation"><a href="#citation.6">6</a></span>].</p><p><span class="bold"><strong>Cluster requirements</strong></span></p><p>In building an efficient automated analysis system capable of processing high sample volumes, both time and stability are key requirements. We did not want the time taken to complete a job to extend beyond four minutes. This time interval captures the total time from the sample submission to the report generation. By adhering to this requirement we could be confident that our system would work efficiently in a cluster environment. </p><p>We can split the overall task into three main time frames: </p><div class="orderedlist"><ol type="1"><li><p>Preparation and initialization &ndash; starting the VM and sending the sample to the VM for execution and analysis.</p></li><li><p>Analysis &ndash; running the sample in the VM, returning the raw data for processing, and powering off the VM.</p></li><li><p>Processing and reporting &ndash; kernel memory data differencing and executing the signatures against the processed results.</p></li></ol></div><p>Using generic anti-rootkit tools inside the VM was not feasible due to the time it takes to complete a scan (minutes with some tools), the inconsistent formats of the log files produced by the various scanners, and the footprint some of them have on the kernel memory, which taints the collected information. A tool like <span class="emphasis"><em>GMER</em></span> [<span class="citation"><a href="#citation.5">5</a></span>], for example, could take more than two minutes to perform an exhaustive scan. </p><p>We measured the time taken for the kernel memory data to be produced with our additions, and it added 10&ndash;15 seconds to the standard analysis time. The default time taken from the point the VM stops until the report is produced can be between 20 and 80 seconds. The time is dependent on the amount of processing performed on the raw results retrieved from the job, the number and performance of the signatures that are run on the results, and the type of report to be produced. On evaluating our signatures and the differencing mechanism, we found that the added time is between one and two seconds. </p><p>Given the minimal amount of time added, we decided to maximize utility. We used a default analysis timeout of 120 seconds and set our kernel memory scan to start after 105 seconds. By using those intervals we allowed more time for the sample to run and make changes to kernel memory and disk so that the changes would be picked up during the scan. We are aware that this setting could be costly in a cluster environment, since many samples do not execute in automated systems and thus we would be wasting the 120 seconds. The timeout and scan start settings can be altered to reduce the delay before the scan. The benefit for us was that the feature did not add a significant time delay in producing the necessary information. </p><p>The overall analysis task time from sample submission to report generation using <span class="emphasis"><em>VirtualBox</em></span> on a standalone machine took between three and four minutes. This included the initialization, analysis and reporting time. This length of time is acceptable in a cluster environment. </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a class="chapter" id="id4181697"></a>2.1 Usage of the Sophos AV Engine</h3></div></div></div><p>The requirements for the kernel examination component of this system are:</p><div class="itemizedlist"><ul type="disc"><li><p>A presence in the kernel.</p></li><li><p>The ability to dump areas of kernel memory selected at runtime.</p></li><li><p>The ability to write dumped memory to a JSON file.</p></li></ul></div><p>The decision to use the <span class="emphasis"><em>Sophos</em></span> AV engine to gather the required data was based on it meeting the above requirements. The <span class="emphasis"><em>Sophos</em></span> AV engine is already capable of dumping and scanning kernel memory, negating the need to design and implement new software to do so. Since we were already using the <span class="emphasis"><em>Sophos</em></span> AV engine to scan for malicious traits during analysis, we decided to leverage its presence to gather the desired information.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a class="chapter" id="id4168768"></a>Selecting the areas of the kernel to examine</h4></div></div></div><p>To select which areas of the kernel to examine, it is necessary to understand what effect kernel-mode rootkits have on the kernel. For a kernel-mode rootkit to have a presence in the kernel it must load a driver. The driver will then modify various functions or pointers to hide malicious activity from the user, other programs, and sometimes from itself.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a class="chapter" id="id4621649"></a>Drivers</h4></div></div></div><p>A driver object represents an individual driver in the system [<span class="citation"><a href="#citation.7">7</a></span>]. The DRIVER_OBJECT structure contains information about a driver including its name, initialization routine, unload routine, a pointer to the loaded driver image, a pointer to its device object, and its MajorFunction dispatch table. </p><p>When a rootkit loads its driver, a DRIVER_OBJECT structure is created for it. The DriverStart field points to the loaded image of the rootkit driver. When the initialization routine is executed, as well as creating its own driver object, a rootkit driver can modify the driver objects of other drivers. </p><p>To track changes, driver objects and device objects are enumerated, and data from each is extracted and dumped. For speed and memory efficiency, only specific fields from the structures are dumped. </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a class="chapter" id="id3590513"></a>Modules</h4></div></div></div><p>A kernel module is a loaded image file that resides in kernel address space. The address space typically comprises drivers and the <span class="emphasis"><em>Windows</em></span> kernel. Currently, the information dumped to the JSON file is minimal, consisting of the module name, image base and module size. By comparing before and after snapshots of the module list, it is possible to tell which modules have been added (indicating the possible presence of a new driver), and which modules have been changed. Changes to the image base or size of a module suggest that the module has been replaced, thus indicating the presence of a rootkit. </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a class="chapter" id="id4504576"></a>System Service Dispatch Table (SSDT)</h4></div></div></div><p>The System Service Dispatch Table (SSDT) is an array of function pointers that resides in kernel address space. The entries in the array reference core functions exported by the <span class="emphasis"><em>Windows</em></span> kernel (e.g. ntoskrnl). These functions provide an interface for user-mode programs to perform tasks such as opening a file or querying a directory. By modifying the address of a function pointer or the code that an entry points to, rootkits can hook a function and control the data that is passed to and from it.</p><p>To detect changes to the SSDT, the entire table is dumped. The addresses in the table are checked (during processing) against the ones saved in the baseline snapshot to detect any hooks. Typically, when the code of a function is hooked, an assembly language &lsquo;jmp&rsquo; instruction is written to the beginning of the function which jumps to hook the code. To detect such code hooks, the first eight bytes of each function are also dumped, to enable the processing module to compare them against the baseline snapshot.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a class="chapter" id="id4740629"></a>Interrupt Descriptor Table (IDT)</h4></div></div></div><p>The IDT is a processor-specific array that has 256 entries. Each entry (an interrupt vector) in the array contains information about its corresponding interrupt handler. Interrupts are operating system conditions that divert the processor to code from the normal flow of execution of a program [<span class="citation"><a href="#citation.8">8</a></span>]. These interrupts are called (using the INT x assembly language instruction) by both hardware and software. As defined by <span class="emphasis"><em>Intel</em></span>, the first 32 entries are reserved for exceptions [<span class="citation"><a href="#citation.8">8</a></span>] (i.e. INT 0 - Division by 0), and the rest are &lsquo;user&rsquo; defined. The <span class="emphasis"><em>Windows</em></span> operating system and various core system drivers also install interrupts, but there remain spare entries that rootkit developers can use to their advantage. </p><p>The entire IDT for each processor is dumped to the JSON log to enable us to find new IDT additions and hooks. </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a class="chapter" id="id2957825"></a>Callbacks</h4></div></div></div><p>A callback is a function that is executed on completion of a specific event. The <span class="emphasis"><em>Windows</em></span> operating system provides routines that allow driver writers to register callbacks on a number of events that rootkit writers can exploit. The routines that are of most interest are:</p><div class="itemizedlist"><ul type="disc"><li><p>CreateProcessNotify &ndash; triggered when a new process is created</p></li><li><p>LoadImageNotify &ndash; triggered when a new image is loaded</p></li><li><p>CreateThreadNotify &ndash; triggered when a new thread is created</p></li><li><p>CmRegister &ndash; triggered when an operation is performed on the registry.</p></li></ul></div><p>A rootkit registering any of these callbacks will be able to hide processes, images, threads or registry entries upon creation. </p><p>The callbacks of each type are enumerated and added to the JSON log. </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a class="chapter" id="id2186315"></a>Disk information</h4></div></div></div><p>Rootkits reside in kernel address space, but bootkits begin outside the operating system. Their execution begins in either a modified Master Boot Record (MBR) or a modified Volume Boot Record (VBR). A common task of a bootkit is to load a driver, typically from hidden storage at the end of the disk, which may proceed to hide the modified MBR/VBR. As the bootkit executes before the operating system is fully started, it can bypass detection by security software. </p><p>To detect the presence of a bootkit, checksums of the MBR and VBRs for all partitions are written to the JSON log. In addition to the initial boot code, the MBR also contains the disk&rsquo;s partition table [<span class="citation"><a href="#citation.9">9</a></span>]. The entire partition table is also dumped and written to the JSON log so that changes in partition location/size (also indicative of a hidden file system) can be detected. </p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a class="chapter" id="id4578516"></a>2.2 A processing module</h3></div></div></div><p><span class="emphasis"><em>Cuckoo</em></span>&rsquo;s processing modules are Python scripts that analyse the raw data from the guest-side component of the sandbox and append the result to a global data structure [<span class="citation"><a href="#citation.6">6</a></span>]. To identify changes in the kernel data we had to add a custom processing module that would compare the data received from the analysis to the baseline data associated with the guest machine. Since new analysis tasks are started from the same snapshot, we do not encounter noise caused by ASLR in kernel memory space. </p><p>After differencing both data structures and identifying any new changes, the processing module produces two dictionary objects. One object encompasses all the changes identified (the diff object), while the second object includes all the information retrieved from the analysis task (the task object). Both objects are then appended to the global container which holds information produced by other processing modules. The task object will include information about driver objects, modules, kernel callbacks, the system service dispatch table, the interrupt descriptor table and hashing of the master boot record, along with information about each partition defined in the partition table. </p><p>The diff object will show whether information has been changed, added or deleted. The comparison mechanism is agnostic to the number or name of the data; it assumes both objects are JSON formatted. Post comparison, noise is cancelled from the diff object. We identified noise heuristically and used a list approach to identify driver objects and modules that we do not include in the diff output. We decided to exclude noise coming from the following modules, since it was almost always due to paging in: </p><div class="itemizedlist"><ul type="disc"><li><p>\windows\system32\autochk.exe </p></li><li><p>\systemroot\system32\drivers\kmixer.sys</p></li><li><p>\systemroot\system32\drivers\spsys.sys</p></li><li><p>\systemroot\system32\drivers\asyncmac.sys</p></li><li><p>\windows\system32\devobj.dll</p></li><li><p>\windows\system32\setupapi.dll</p></li></ul></div><p>Some drivers will experience the creation of devices once the execution starts, while others will change DEVICE_OBJECT addresses. The device object attached to \Driver\usbhub named &lsquo;\Device\_HID00000000&rsquo; gets a different address each time the job starts. The same problem occurs for \Driver\mouclass, which is the class driver for all mouse devices. Namely, a &lsquo;\Device\PointerClass&rsquo; DEVICE_OBJECT gets a different address. This different DEVICE_OBJECT gets attached to the list of devices of \Driver\mouhid and \Driver\hidusb. </p><p>We also found less common cases of \Driver\swenum and \Driver\asyncmac having devices attached to them, so we also filtered noise coming from them. </p><p>The drivers from which noise was filtered were: </p><div class="itemizedlist"><ul type="disc"><li><p>\Driver\mouhid</p></li><li><p>\Driver\usbhub</p></li><li><p>\Driver\mouclass</p></li><li><p>\Driver\hidusb</p></li><li><p>\Driver\umbus</p></li><li><p>\Driver\asyncmac</p></li></ul></div><p>There was noise introduced in the SSDT information returned due to paging of certain portions of the ntoskrnl.exe. We excluded all changes introduced due to paging out, and tagged data that had been paged in.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a class="chapter" id="id4598585"></a>2.3 A driver analysis package</h3></div></div></div><p><span class="emphasis"><em>Cuckoo</em></span> uses separate packages to instruct the analyser inside the guest machine to conduct the analysis procedure [<span class="citation"><a href="#citation.6">6</a></span>]. By default, <span class="emphasis"><em>Cuckoo</em></span> provides packages to handle running dynamic link libraries (DLL), PDF, VBS and DOC files, among other packages. <span class="emphasis"><em>Cuckoo Sandbox</em></span> is unable to process driver files for analysis by default. Since kernel-level malicious alteration is normally introduced by a malicious kernel module, we wanted the ability to run driver files alone to capture their pure behaviour. </p><p>The driver analysis package (sys package) gets invoked if the analyser identifies that the file is of native type. Since our guest machine is 32-bit, we restricted the analysis package to 32-bit driver files. </p><p>The sys package will invoke Sc.exe, which is provided in the <span class="emphasis"><em>Windows</em></span> Resource Kit to register the service. This is done by running the command: </p><pre class="programlisting">sc create newservicebinPath=&lt;C:\path_to_file.sys&gt; type=kernel start=auto error=normal </pre><p>The default parameters used to create the service are:</p><div class="itemizedlist"><ul type="disc"><li><p>Servicename=newservice</p></li><li><p>Type=kernel</p></li><li><p>Start=auto</p></li><li><p>Error=normal </p></li></ul></div><p>Each parameter can be changed by the user when a sample is submitted for analysis. </p><p>&lsquo;Sc create&rsquo; is the equivalent of calling the CreateService Win32 API. </p><p>The sys package supports two ways to execute the driver file. The default method uses the NtLoadDriver Windows API. The other method for execution is using sc.exe by running the command: </p><pre class="programlisting">sc start newservice</pre><p>This is equivalent to calling the StartService Win32 API. </p><p>Using sc.exe, which is a command-line interface to the service control manager, takes care of the prep work necessary to register a service in the service control manager database. </p><p>&lsquo;sc create&rsquo; creates the service registry key under HKLM\System\CurrentControlSet\services, which both NtLoadDriver and &lsquo;sc start&rsquo; use to start the service. The sys package also provides an option to try both methods (sc.exe and NtLoadDriver) to check which one succeeds. </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a class="chapter" id="id4335388"></a>2.4 The signatures</h3></div></div></div><p><span class="emphasis"><em>Cuckoo</em></span> provides an easy way to interpret the results of an analysis by matching the results via signatures. The signatures will look for predefined patterns in the results and flag them if they are present [<span class="citation"><a href="#citation.6">6</a></span>]. Each signature has an attribute called &lsquo;severity&rsquo; that is used to define how malicious a signature is. This allows a user to write purely informative signatures in addition to ones that indicate malicious behaviour. (We explain more about the values we assigned to each signature to build a malicious index in section 3.2.) </p><p>We have written a set of signatures in order to identify certain modifications to the kernel data retrieved from an analysis task. <a href="#table.1">Table 1</a> shows the signatures and their definitions. </p><div class="table"><a id="table.1"></a><table border="1" summary="Signatures and definitions."><colgroup><col /><col /></colgroup><thead><tr><th align="center">Signature name</th><th align="center">Definition</th></tr></thead><tbody><tr><td>generic_new_driver</td><td>Flags driver objects that have been created in the analysis job.</td></tr><tr><td>generic_modified_driver</td><td>Flags changes to already existing driver objects. </td></tr><tr><td>generic_deleted_driver</td><td>Flags driver objects that have been deleted during an analysis job. </td></tr><tr><td>generic_new_module</td><td>Flags new modules created during an analysis job. </td></tr><tr><td>generic_deleted_module</td><td>Identifies modules that were present before the analysis job took place, but which aren&rsquo;t present anymore. </td></tr><tr><td>generic_modified_module</td><td>Identifies changes to properties such as size or address of a module. </td></tr><tr><td>generic_ssdt_hook</td><td>Identifies changes to the system service dispatch table. Namely, changes in the address of any of the system calls (and flags them). </td></tr><tr><td>generic_idt_hook</td><td>Identifies changes to the interrupt descriptor table of any processor. </td></tr><tr><td>generic_new_callback</td><td>Identifies new driver-supplied callbacks. We check: &bull; LoadImageNotify <span class="othercredit"><span class="surname">&bull; CreateThreadNotify </span></span><span class="othercredit"><span class="surname">&bull; CreateProcessNotify</span></span><span class="othercredit"><span class="surname">&bull; CmRegister (registry callbacks) </span></span></td></tr><tr><td>generic_modified_callback</td><td>Identifies changes to the table holding driver-supplied callbacks. </td></tr><tr><td>generic_attached_device</td><td>Identifies new devices added to driver objects. </td></tr><tr><td>generic_modified_mbr</td><td>Identifies if the SHA1 checksum of the MBR has changed during the analysis. </td></tr><tr><td>generic_modified_vbr</td><td>Identifies if the SHA1 checksum of the VBR has changed during the analysis</td></tr><tr><td>generic_modified_eod_size</td><td>Identifies if the size of the unformatted region beyond the file system at the end of disk has changed during the analysis. </td></tr></tbody></table><p class="title"><b>Table&nbsp;1.&nbsp;Signatures and definitions.</b></p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a class="chapter" id="id4112761"></a>2.5 The report</h3></div></div></div><p>We built a template in the Django framework used by <span class="emphasis"><em>Cuckoo</em></span> to show all the information we gathered from an analysis task. The report is split into seven tabs, with each tab showing the information specific to a certain category in the results data container. </p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a class="chapter" id="id3074198"></a>Kernel memory changes</h4></div></div></div><p>This category shows the changes to the kernel introduced during the analysis. For example, in <a href="#figure.1">Figure 1</a> we can see that a new device was attached to \Filesystem\FltMgr and \Filesystem\RAW. Also, the MBR SHA1 has been changed.</p><div class="figure"><a id="figure.1"></a><div class="mediaobject"><img alt="A new device attached to \Filesystem\FltMgr and \Filesystem\RAW." src="/uploads/images/figures/2015/01/Zaki-Humphrey-1.jpg" /></div><p class="title"><b>Figure&nbsp;1.&nbsp;A new device attached to \Filesystem\FltMgr and \Filesystem\RAW.</b></p></div><p>(Click <a href="/uploads/images/figures/2015/01/Zaki-Humphrey-1-large.jpg" target="_top">here</a> to view a larger version of Figure 1.)</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a class="chapter" id="id2188363"></a>Drivers</h4></div></div></div><p>This section shows a breakdown of all the driver objects found in kernel memory after running the sample. The breakdown also shows the I/O request packet handlers for each object. </p><div class="figure"><a id="figure.2"></a><div class="mediaobject"><img alt="Drivers." src="/uploads/images/figures/2015/01/Zaki-Humphrey-2.jpg" /></div><p class="title"><b>Figure&nbsp;2.&nbsp;Drivers.</b></p></div><p>(Click <a href="/uploads/images/figures/2015/01/Zaki-Humphrey-2-large.jpg" target="_top">here</a> to view a larger version of Figure 2.)</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a class="chapter" id="id3629287"></a>Modules</h4></div></div></div><p>This section shows all modules found on the system by enumerating the linked list of modules starting with ntoskrnl.exe. For each module we get the name, address and size.</p><div class="figure"><a id="figure.3"></a><div class="mediaobject"><img alt="Modules." src="/uploads/images/figures/2015/01/Zaki-Humphrey-3.jpg" /></div><p class="title"><b>Figure&nbsp;3.&nbsp;Modules.</b></p></div><p>(Click <a href="/uploads/images/figures/2015/01/Zaki-Humphrey-3-large.jpg" target="_top">here</a> to view a larger version of Figure 3.)</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a class="chapter" id="id3467581"></a>SSDT</h4></div></div></div><p>This section shows the entries in the system service dispatch table. For each system call we get its address and starting bytes. This shows if any inline hooks are added to the system calls.</p><div class="figure"><a id="figure.4"></a><div class="mediaobject"><img alt="SSDT." src="/uploads/images/figures/2015/01/Zaki-Humphrey-4.jpg" /></div><p class="title"><b>Figure&nbsp;4.&nbsp;SSDT.</b></p></div><p>(Click <a href="/uploads/images/figures/2015/01/Zaki-Humphrey-4-large.jpg" target="_top">here</a> to view a larger version of Figure 4.)</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a class="chapter" id="id4937261"></a>Callbacks</h4></div></div></div><p>These sections show any callbacks installed by any drivers. For each callback we list its type, the driver path that installed it, the address and SHA1 of the driver.</p><div class="figure"><a id="figure.5"></a><div class="mediaobject"><img alt="Callbacks." src="/uploads/images/figures/2015/01/Zaki-Humphrey-5.jpg" /></div><p class="title"><b>Figure&nbsp;5.&nbsp;Callbacks.</b></p></div><p>(Click <a href="/uploads/images/figures/2015/01/Zaki-Humphrey-5-large.jpg" target="_top">here</a> to view a larger version of Figure 5.)</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a class="chapter" id="id3626558"></a>MBR</h4></div></div></div><p>This section contains information available in the MBR and its SHA1. In addition to listing each partition&rsquo;s detailed information by parsing the partition table entries, we also list the SHA1 of the VBR that this partition points to and the address of the last sector of the formatted file system and the last sector of disk. </p><div class="figure"><a id="figure.6"></a><div class="mediaobject"><img alt="MBR." src="/uploads/images/figures/2015/01/Zaki-Humphrey-6.jpg" /></div><p class="title"><b>Figure&nbsp;6.&nbsp;MBR.</b></p></div><p>(Click <a href="/uploads/images/figures/2015/01/Zaki-Humphrey-6-large.jpg" target="_top">here</a> to view a larger version of Figure 6.)</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a class="chapter" id="id4858571"></a>IDT</h4></div></div></div><p>This section shows the descriptors in the interrupt descriptor table. For each descriptor we show its type and address.</p><div class="figure"><a id="figure.7"></a><div class="mediaobject"><img alt="IDT." src="/uploads/images/figures/2015/01/Zaki-Humphrey-7.jpg" /></div><p class="title"><b>Figure&nbsp;7.&nbsp;IDT.</b></p></div><p>(Click <a href="/uploads/images/figures/2015/01/Zaki-Humphrey-7-large.jpg" target="_top">here</a> to view a larger version of Figure 7.)</p></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a class="chapter" id="id2229284"></a>3. Results</h2></div></div></div><p><span class="bold"><strong>Approach</strong></span></p><p>To assess the effectiveness of the system we tested three groups of samples. First, we picked a group of rootkits that were thoroughly documented and compared the results obtained from running the samples in our systems versus the behaviour documented by researchers. We also ran a set of known malicious driver files and a set of known clean driver files to analyse the results. Finally, we ran a set of known malicious standard executables and analysed the results obtained from them.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a class="chapter" id="id3247998"></a>3.1 Known malicious rootkits</h3></div></div></div><p>We picked a group of four well documented and researched rootkit samples to assess against our system. In cases where the report or blog article about the sample contained SHAs, we used those, otherwise we selected SHAs which we had previously analysed.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a class="chapter" id="id2721422"></a>TDL</h4></div></div></div><p>TDL has many variants. We tested a variant that employs an MBR infection technique to load its malicious driver. TDL4 is discussed thoroughly in [<span class="citation"><a href="#citation.10">10</a></span>], [<span class="citation"><a href="#citation.11">11</a></span>]. According to [<span class="citation"><a href="#citation.10">10</a></span>], on an x86 system, the kernel-mode drivers are tasked with maintaining the hidden file system to store the bootkit components, injecting the payload into system processes, and performing self-defence. The dropper tries to employ the print spooler provider load method to load its driver in kernel memory. The sample we looked at employed direct writes to disk by getting a handle to PhysicalDrive0 using NtCreateFile, and then used a sequence of DeviceIOControls to write to the disk, as explained in [<span class="citation"><a href="#citation.11">11</a></span>]. </p><p>The SHA of the sample we analysed was c46ac210e06aad56dda12df3c0ccebb45108a745. <a href="#figure.8">Figure 8</a> and <a href="#figure.9">Figure 9</a> show the changes introduced in the kernel. </p><pre class="programlisting">\Filesystem\RAW
{u&rsquo;devicename&rsquo;:u&rsquo;(unnamed)&rsquo;,
u&rsquo;devobj_extension&rsquo;:
  {u&rsquo;deviceobject&rsquo;: u&rsquo;0x8482c030&rsquo;},
u&rsquo;driverobject&rsquo;: u&rsquo;0x83e1f1b8&rsquo;,
u&rsquo;deviceobject&rsquo;: u&rsquo;0x8482c030&rsquo;,
u&rsquo;attacheddevice&rsquo;:
    {u&rsquo;devicename&rsquo;: u&rsquo;(unnamed)&rsquo;,
    u&rsquo;devobj_extension&rsquo;: 
      {u&rsquo;attachedtoname&rsquo;: u&rsquo;(unnamed)&rsquo;,
      u&rsquo;attachedtoobject&rsquo;: u&rsquo;0x8482c030&rsquo;, 
      u&rsquo;deviceobject&rsquo;: u&rsquo;0x84895710&rsquo;}, 
    u&rsquo;driverobject&rsquo;: u&rsquo;0x84a41c40&rsquo;, 
    u&rsquo;deviceobject&rsquo;: u&rsquo;0x84895710&rsquo;,
    u&rsquo;drivername&rsquo;: u&rsquo;\\FileSystem\\FltMgr&rsquo;, 
    u&rsquo;type&rsquo;: u&rsquo;FILE_DEVICE_DISK_FILE_SYSTEM&rsquo;},
u&rsquo;drivername&rsquo;: u&rsquo;\\FileSystem\\RAW&rsquo;, 
u&rsquo;type&rsquo;: u&rsquo;FILE_DEVICE_DISK_FILE_SYSTEM&rsquo;}}]}

\Filesystem\FltMgr
{u&rsquo;devicename&rsquo;: u&rsquo;(unnamed)&rsquo;, 
u&rsquo;devobj_extension&rsquo;: 
    {u&rsquo;attachedtoname&rsquo;: u&rsquo;(unnamed)&rsquo;,
    u&rsquo;attachedtoobject&rsquo;: u&rsquo;0x8482c030&rsquo;, 
    u&rsquo;deviceobject&rsquo;: u&rsquo;0x84895710&rsquo;}, 
u&rsquo;driverobject&rsquo;: u&rsquo;0x84a41c40&rsquo;,
u&rsquo;deviceobject&rsquo;: u&rsquo;0x84895710&rsquo;,
u&rsquo;drivername&rsquo;: u&rsquo;\\FileSystem\\FltMgr&rsquo;, 
u&rsquo;type&rsquo;: u&rsquo;FILE_DEVICE_DISK_FILE_SYSTEM&rsquo;}}]}
</pre><div class="figure"><a id="figure.8"></a><div class="mediaobject"><img alt="Changes introduced in the kernel." src="/uploads/images/figures/2015/01/Zaki-Humphrey-8.jpg" /></div><p class="title"><b>Figure&nbsp;8.&nbsp;Changes introduced in the kernel.</b></p></div><p>(Click <a href="/uploads/images/figures/2015/01/Zaki-Humphrey-8-large.jpg" target="_top">here</a> to view a larger version of Figure 8.)</p><div class="figure"><a id="figure.9"></a><div class="mediaobject"><img alt="Kernel memory changes." src="/uploads/images/figures/2015/01/Zaki-Humphrey-9.jpg" /></div><p class="title"><b>Figure&nbsp;9.&nbsp;Kernel memory changes.</b></p></div><p>(Click <a href="/uploads/images/figures/2015/01/Zaki-Humphrey-9-large.jpg" target="_top">here</a> to view a larger version of Figure 9.)</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a class="chapter" id="id4851226"></a>TDL</h4></div></div></div><p>What we observe from the changes to the driver objects are the changes seen in the DEVICE_OBJECTs relating to two drivers: \FileSystem\FltMgr and \FileSystem\RAW. If we examine the changes above, we see that a single device has been created and attached to the device pointed to by \Filesystem\RAW. That same device is now pointed to by \FileSystem\FltMgr. The DEVICE_OBJECT is represented as the one at address 0x84895710. </p><p>Another change is in the MBR SHA which indicates that the sample has written the malicious MBR to disk: </p><pre class="programlisting">[{u&rsquo;Original&rsquo;:u&rsquo;4b1713e6d41c71667f2af1681fad8be1e101163f&rsquo;}, 
{u&rsquo;Changed&rsquo;: u&rsquo;a192e0fa1db37219932b17ecdd23ad59e5c57ef0&rsquo;}]
</pre><p>Finally, there are changes in the SSDT that are the result of paging in parts of the kernel. These are marked as paged in during processing of the raw results. While they might not necessarily be system calls made by the sample, they could lie within a page that was paged in and thus show up in the differencing (see <a href="#table.2">Table 2</a>).</p><div class="table"><a id="table.2"></a><table border="1" summary="Changes in the SSDT that are marked as paged in during
          processing of the raw results."><colgroup><col /><col /></colgroup><tbody><tr><td>NtDeletePrivateNamespace</td><td>{u&rsquo;startbytes&rsquo;: {u&rsquo;Added&rsquo;: u&rsquo;8bff558bec83ec10&rsquo;, u&rsquo;PagedIn&rsquo;: 1}}</td></tr><tr><td>NtQueryInformationJobObject</td><td>{u&rsquo;startbytes&rsquo;: {u&rsquo;Added&rsquo;: u&rsquo;6890010068d051&rsquo;, u&rsquo;PagedIn&rsquo;: 1}}</td></tr><tr><td>NtSaveKey</td><td>{u&rsquo;startbytes&rsquo;: {u&rsquo;Added&rsquo;: u&rsquo;8bff558bec83e4f8&rsquo;, u&rsquo;PagedIn&rsquo;: 1}}</td></tr><tr><td>NtGetNextThread</td><td>{u&rsquo;startbytes&rsquo;: {u&rsquo;Added&rsquo;: u&rsquo;6868010068180f&rsquo;, u&rsquo;PagedIn&rsquo;: 1}}</td></tr><tr><td>NtPulseEvent</td><td>{u&rsquo;startbytes&rsquo;: {u&rsquo;Added&rsquo;: u&rsquo;6a1468a8e6982e8&rsquo;, u&rsquo;PagedIn&rsquo;: 1}}</td></tr></tbody></table><p class="title"><b>Table&nbsp;2.&nbsp;Changes in the SSDT that are marked as paged in during processing of the raw results.</b></p></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a class="chapter" id="id2445290"></a>Gapz</h4></div></div></div><p>Gapz is a bootkit that is famous for its sophistication. It was thoroughly analysed in [<span class="citation"><a href="#citation.12">12</a></span>]. Gapz comes as two different variants: an MBR infector and a VBR infector. The MBR infecting version of the bootkit hijacks the boot process to hook the int 13 handler. The VBR-infecting variant only alters a DWORD: the &lsquo;hidden_sectors&rsquo; value in the BIOS Parameter block of the VBR, which will instruct the VBR code to transfer control to a malicious loader instead of the standard IPL. The kernel-mode changes include writing blocks of its malicious kernel module to kernel memory in addition to hooks to IRP_MJ_INTERNAL_DEVICE_CONTROL and IRP_MJ_DEVICE_CONTROL handlers of the disk miniport driver. Both variants employ the same kernel-mode component. </p><p>The SHA of the VBR infector we used was 1f206ea64fb3ccbe0cd7ff7972bef2592bb30c84. As documented in [<span class="citation"><a href="#citation.12">12</a></span>], this sample injects the shellcode responsible for writing to disk into explorer.exe. The sample gets a handle to the volume and to the disk by calling NtCreateFile on GLOBALROOT\ArcName\multi(0)disk(0)rdisk(0)partition(1) and PhysicalDrive0, respectively. As with TDL, it issues a series of DeviceIOControls to write to them. </p><p>As can be seen in <a href="#figure.10">Figure 10</a> and <a href="#figure.11">Figure 11</a>, the differencing identified a change in the VBR for partition 0. </p><pre class="programlisting">{u&rsquo;vbrsha1sum&rsquo;: [{u&rsquo;Original&rsquo;: u&rsquo;7a781423dbb768786a81633441f8d533594583f5&rsquo;},
{u&rsquo;Changed&rsquo;: u&rsquo;64f08b44562578234af25a1cfef84d2bccf1a5&rsquo;}]}
</pre><div class="figure"><a id="figure.10"></a><div class="mediaobject"><img alt="A change in VBR is noted." src="/uploads/images/figures/2015/01/Zaki-Humphrey-10.jpg" /></div><p class="title"><b>Figure&nbsp;10.&nbsp;A change in VBR is noted.</b></p></div><div class="figure"><a id="figure.11"></a><div class="mediaobject"><img alt="A change in the VBR for partition 0 is identified." src="/uploads/images/figures/2015/01/Zaki-Humphrey-11.jpg" /></div><p class="title"><b>Figure&nbsp;11.&nbsp;A change in the VBR for partition 0 is identified.</b></p></div><p>(Click <a href="/uploads/images/figures/2015/01/Zaki-Humphrey-11-large.jpg" target="_top">here</a> to view a larger version of Figure 11.)</p><div class="figure"><a id="figure.12"></a><div class="mediaobject"><img alt="MBR." src="/uploads/images/figures/2015/01/Zaki-Humphrey-12.jpg" /></div><p class="title"><b>Figure&nbsp;12.&nbsp;MBR.</b></p></div><p>(Click <a href="/uploads/images/figures/2015/01/Zaki-Humphrey-12-large.jpg" target="_top">here</a> to view a larger version of Figure 12.)</p><p>We can also see changes in the SSDT that are showing as paged in calls (see <a href="#table.3">Table 3</a>). </p><div class="table"><a id="table.3"></a><table border="1" summary="Changes in the SSDT that are showing as paged in
          calls."><colgroup><col /><col /></colgroup><tbody><tr><td>NtDeletePrivateNamespace</td><td>{u&rsquo;startbytes&rsquo;: {u&rsquo;Added&rsquo;: u&rsquo;8bff558bec83ec10&rsquo;, u&rsquo;PagedIn&rsquo;: 1}}</td></tr><tr><td>NtSaveKey</td><td>{u&rsquo;startbytes&rsquo;: {u&rsquo;Added&rsquo;: u&rsquo;8bff558bec83e4f8&rsquo;, u&rsquo;PagedIn&rsquo;: 1}}</td></tr><tr><td>NtPulseEvent</td><td>{u&rsquo;startbytes&rsquo;: {u&rsquo;Added&rsquo;: u&rsquo;6a1468a8e6982e8&rsquo;, u&rsquo;PagedIn&rsquo;: 1}}</td></tr></tbody></table><p class="title"><b>Table&nbsp;3.&nbsp;Changes in the SSDT that are showing as paged in calls.</b></p></div><p>In our standard system set-up we did not capture the changes introduced in kernel memory during our standard test. We caught the write to the VBR, which is sufficient indication of malicious behaviour. The reason we could not see the kernel memory changes is because the dropper requests a reboot in order to kick off the VBR/MBR loading of its kernel-mode component. </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a class="chapter" id="id3646012"></a>Turla (a.k.a. Uroburous, Snake)</h4></div></div></div><p>In March 2014, German security firm<span class="emphasis"><em> G Data </em></span>released a red paper which contained an analysis of the Uroburous rootkit [<span class="citation"><a href="#citation.13">13</a></span>]. Shortly afterwards, <span class="emphasis"><em>BAE Systems </em></span>also released a comprehensive white paper on the rootkit [<span class="citation"><a href="#citation.4">4</a></span>]. The <span class="emphasis"><em>G Data</em></span> paper indicated that the rootkit may have been involved in a Russian cyber attack against the US. Due to tensions between Russia and Ukraine at the time, multiple news companies covered the story, including the <span class="emphasis"><em>New York Times</em></span> [<span class="citation"><a href="#citation.14">14</a></span>].</p><p>As described in [<span class="citation"><a href="#citation.4">4</a></span>] and [<span class="citation"><a href="#citation.13">13</a></span>], the rootkit comprises a driver and a virtual file system that is contained in a file on the disk. The rootkit creates an entry in the Interrupt Descriptor Table (IDT). The code for several functions in the SSDT is then hooked with an INT instruction (see [<span class="citation"><a href="#citation.8">8</a></span>] for details) that triggers the malicious software interrupt. A parameter is passed to the interrupt, identifying from which function it was called. This is used to look up a function in a custom dispatch table which executes the appropriate code for the hook. </p><p>From running an analysis on sample 39e492e839ad47ab6b58608f0f6b7290b52122eb, we get the results shown in <a href="#figure.13">Figure 13</a>. The results tell us that SSDT functions have been hooked, and that the IDT has been modified, which is consistent with the behaviour of Turla. </p><div class="figure"><a id="figure.13"></a><div class="mediaobject"><img alt="Results of sample analysis." src="/uploads/images/figures/2015/01/Zaki-Humphrey-13.jpg" /></div><p class="title"><b>Figure&nbsp;13.&nbsp;Results of sample analysis.</b></p></div><p>Upon closer inspection of the SSDT (see <a href="#figure.14">Figure 14</a>), we can see that a number of functions have been modified. Functions like NtQuerySystemInformation and NtReadFile are often targeted by rootkits. </p><div class="figure"><a id="figure.14"></a><div class="mediaobject"><img alt="A number of functions have been modified." src="/uploads/images/figures/2015/01/Zaki-Humphrey-14.jpg" /></div><p class="title"><b>Figure&nbsp;14.&nbsp;A number of functions have been modified.</b></p></div><p>(Click <a href="/uploads/images/figures/2015/01/Zaki-Humphrey-14-large.jpg" target="_top">here</a> to view a larger version of Figure 14.)</p><p>The diff is showing that there is a difference in the first eight bytes of each function. Closer examination of the NtCreateThread start bytes reveals that it is only the first five bytes that have changed. </p><pre class="programlisting">{u&rsquo;startbytes&rsquo;: [{u&rsquo;Original&rsquo;: u&rsquo;682403006820b4&rsquo;}, {u&rsquo;Changed&rsquo;: u&rsquo;6a08cdc3906820b4&rsquo;}]}</pre><p>On translating the modified bytes into assembly language we get:</p><pre class="programlisting">6A08  push byte +0x8
CDC3  nt 0xc3
90    nop
</pre><p>Looking up the IDT entry at index 0xc3 on the IDT tab (see <a href="#figure.15">Figure 15</a>), we see that the code for the interrupt is located at 0x8495a2b0. Cross referencing this address with the IDT entry in the kernel diff (<a href="#figure.16">Figure 16</a>), we see that 0xc3 is the newly added IDT entry.</p><div class="figure"><a id="figure.15"></a><div class="mediaobject"><img alt="Looking up the IDT entry at index 0xc3 on the IDT tab." src="/uploads/images/figures/2015/01/Zaki-Humphrey-15.jpg" /></div><p class="title"><b>Figure&nbsp;15.&nbsp;Looking up the IDT entry at index 0xc3 on the IDT tab.</b></p></div><div class="figure"><a id="figure.16"></a><div class="mediaobject"><img alt="Cross referencing 0x8495a2b0 with the IDT entry in the kernel diff." src="/uploads/images/figures/2015/01/Zaki-Humphrey-16.jpg" /></div><p class="title"><b>Figure&nbsp;16.&nbsp;Cross referencing 0x8495a2b0 with the IDT entry in the kernel diff.</b></p></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a class="chapter" id="id3270773"></a>Necurs</h4></div></div></div><p>The Necurs rootkit was first discovered in May 2011[<span class="citation"><a href="#citation.15">15</a></span>] , but became well established in 2012. It was one of the first widespread rootkits to target x64 systems. It was originally packaged with fake anti-virus malware, but recently it has been used with the infamous Gameover Zeus variant [<span class="citation"><a href="#citation.16">16</a></span>]. Although it has been around for a while, the rootkit is as prevalent as ever. </p><p>Necurs is the name for the kernel-mode part of the rootkit. It consists of a driver file which, when installed on a system, works alongside other malware to hide its presence and make it difficult to remove. The way this is achieved differs depending on the processor architecture and operating system of the host computer. As our analysis system is only running on x86 <span class="emphasis"><em>Windows 7</em></span>, we will only discuss the effects of the rootkit on this particular set-up. </p><p>When Necurs is installed on <span class="emphasis"><em>Windows 7</em></span>, a service is created and the malicious driver is loaded. The driver hides the service and the driver file on disk by installing a file system filter driver. It also installs a LoadImageNotify callback to control which programs can be loaded. </p><p>By looking at the signatures (<a href="#figure.17">Figure 17</a> and <a href="#figure.18">Figure 18</a>) after running a Necurs sample (412769f14bbc629a16208cda5fd6dc25e5f8e8bb), we see that a number of kernel modifications have occurred. These indicate that a new driver and a new callback have been installed. </p><div class="figure"><a id="figure.17"></a><div class="mediaobject"><img alt="Signatures after running a Necurs sample." src="/uploads/images/figures/2015/01/Zaki-Humphrey-17.jpg" /></div><p class="title"><b>Figure&nbsp;17.&nbsp;Signatures after running a Necurs sample.</b></p></div><div class="figure"><a id="figure.18"></a><div class="mediaobject"><img alt="Signatures after running a Necurs sample." src="/uploads/images/figures/2015/01/Zaki-Humphrey-18.jpg" /></div><p class="title"><b>Figure&nbsp;18.&nbsp;Signatures after running a Necurs sample.</b></p></div><p>Closer examination of the driver object (<a href="#figure.19">Figure 19</a>) shows a name but no path. This means that our system could not access the driver. The most likely reason for this is that the driver is hidden. Something is hiding it from the file system, yet the driver object exists in memory. While this is not necessarily a malicious trait, it is certainly suspicious, and is worth investigating further.</p><div class="figure"><a id="figure.19"></a><div class="mediaobject"><img alt="Closer examination of the driver object." src="/uploads/images/figures/2015/01/Zaki-Humphrey-19.jpg" /></div><p class="title"><b>Figure&nbsp;19.&nbsp;Closer examination of the driver object.</b></p></div><p>The next point of interest is the addition of device objects. By looking at the kernel diff (<a href="#figure.20">Figure 20</a>) we see that a device has been added to /FileSystem/FtlMgr, which is the file system filter manager. This is definitely of interest. Examination of the added data shows that the driver object related to the added device belongs to the newly added driver. </p><div class="figure"><a id="figure.20"></a><div class="mediaobject"><img alt="A device has been added to /FileSystem/FtlMgr." src="/uploads/images/figures/2015/01/Zaki-Humphrey-20.jpg" /></div><p class="title"><b>Figure&nbsp;20.&nbsp;A device has been added to /FileSystem/FtlMgr. </b></p></div><p>Similarly, examining the callback that has been added (<a href="#figure.21">Figure 21</a>) also reveals that the code for the callback is contained in the newly added driver. </p><div class="figure"><a id="figure.21"></a><div class="mediaobject"><img alt="Examining the callback." src="/uploads/images/figures/2015/01/Zaki-Humphrey-21.jpg" /></div><p class="title"><b>Figure&nbsp;21.&nbsp;Examining the callback.</b></p></div><p>(Click <a href="/uploads/images/figures/2015/01/Zaki-Humphrey-21-large.jpg" target="_top">here</a> to view a larger version of Figure 21.)</p><p>To summarize, the scan has revealed: </p><div class="itemizedlist"><ul type="disc"><li><p>A new driver that is hidden</p></li><li><p>A file system filter</p></li><li><p>A LoadImageNotify callback</p></li></ul></div><p>This collection of traits is indicative of rootkit-like behaviour, and is consistent with the behaviour of the Necurs rootkit.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a class="chapter" id="id4629683"></a>3.2 Building a malware index using kernel memory differencing</h3></div></div></div><p>To assess whether kernel memory differencing can be used to build a metric to decide if a sample is malicious, we performed two experiments. In the first experiment, we ran a group of malicious and clean 32-bit driver files and observed the changes in the kernel introduced by running the drivers. In the second experiment we ran a set of malicious standard executable files to find out what proportion of them introduced kernel memory changes.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a class="chapter" id="id3878689"></a>Running a set of driver files</h4></div></div></div><p>We observed from our first experiment that not all successfully loaded drivers produced kernel memory data. From the set of successfully loaded malicious drivers, 82.3% produced kernel memory data that could be used later for differencing. From the clean set, 51.2% returned kernel memory data. </p><p>The reasons for failure were shared by clean and malicious drivers. A common reason was insufficient time for the log to be generated. Because the scan starts 105 seconds into the 120 seconds available for the analysis, and can take between 10 and 15 seconds, we sometimes miss the log by a second or two. Since the agent terminates before the machine shuts down fully, this is time taken from the 120 seconds. There is a trade-off between speed of analysis and data gathered. Our testing produced enough successful replication from malicious files for an automated analysis system. </p><div class="mediaobject"><img src="/uploads/images/figures/2015/01/Zaki-Humphrey-1.jpg" /></div><p>From a set of malicious driver files: </p><p>Total drivers successfully loaded: 1,854 </p><p>Total tasks with kernel data retrieved: 1,525 </p><div class="informaltable"><table border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th align="center">Signature</th><th align="center">Number of hits</th><th align="center">Percentage</th></tr></thead><tbody><tr><td>generic_new_driver</td><td>1524</td><td>99.9</td></tr><tr><td>generic_modified_driver</td><td>1171</td><td>76.8</td></tr><tr><td>generic_deleted_driver</td><td>0</td><td>0</td></tr><tr><td>generic_new_module</td><td>1523</td><td>99.8</td></tr><tr><td>generic_modified_module</td><td>0</td><td>0</td></tr><tr><td>generic_ssdt_hook</td><td>30</td><td>1.96</td></tr><tr><td>generic_idt_hook</td><td>0</td><td>0</td></tr><tr><td>generic_new_callback</td><td>1332</td><td>87.3</td></tr><tr><td>generic_modified_callback</td><td>0</td><td>0</td></tr><tr><td>generic_attached_device</td><td>1149</td><td>75.3</td></tr><tr><td>generic_new_device_links</td><td>1441</td><td>94.5</td></tr><tr><td>generic_modified_mbr</td><td>0</td><td>0</td></tr><tr><td>generic_modified_vbr</td><td>0</td><td>0</td></tr><tr><td>generic_modified_eod_size</td><td>0</td><td>0</td></tr></tbody></table></div><p>We expect that a successfully loaded driver would create a driver object and a new module. All of the malicious drivers created a new driver object on loading, except for one. This driver installed &lsquo;CreateProcessNotify&rsquo; and &lsquo;LoadImageNotify&rsquo; callbacks pointing to an &lsquo;unknown/module&rsquo;, and installed inline hooks at &lsquo;NTEnumerateKey&rsquo; and &lsquo;NtFlushInstructionCache&rsquo;. This is indicative of highly suspicious behaviour. </p><div class="figure"><a id="figure.22"></a><div class="mediaobject"><img alt="The driver installed &lsquo;CreateProcessNotify&rsquo; and &lsquo;LoadImageNotify&rsquo; callbacks." src="/uploads/images/figures/2015/01/Zaki-Humphrey-22.jpg" /></div><p class="title"><b>Figure&nbsp;22.&nbsp;The driver installed &lsquo;CreateProcessNotify&rsquo; and &lsquo;LoadImageNotify&rsquo; callbacks.</b></p></div><p>(Click <a href="/uploads/images/figures/2015/01/Zaki-Humphrey-22-large.jpg" target="_top">here</a> to view a larger version of Figure 22.)</p><div class="figure"><a class="chapter" id="id2639212"></a><div class="mediaobject"><img alt="Callbacks pointing to an &lsquo;unknown/module&rsquo;." src="/uploads/images/figures/2015/01/Zaki-Humphrey-23.jpg" /></div><p class="title"><b>Figure&nbsp;23.&nbsp;Callbacks pointing to an &lsquo;unknown/module&rsquo;.</b></p></div><p>(Click <a href="/uploads/images/figures/2015/01/Zaki-Humphrey-23-large.jpg" target="_top">here</a> to view a larger version of Figure 23.)</p><p>Another interesting find was a sample that created a new driver object upon loading, but which did not show a newly added module in the differencing data. Looking at the job we find that the sample installs an SSDT hook by altering the VA of the service function &lsquo;NtMapViewOfSection&rsquo;. Again, this is highly suspicious behaviour. </p><div class="figure"><a id="figure.24"></a><div class="mediaobject"><img alt="The sample installs an SSDT hook by altering the VA of the service function &lsquo;NtMapViewOfSection&rsquo;." src="/uploads/images/figures/2015/01/Zaki-Humphrey-24.jpg" /></div><p class="title"><b>Figure&nbsp;24.&nbsp;The sample installs an SSDT hook by altering the VA of the service function &lsquo;NtMapViewOfSection&rsquo;.</b></p></div><p>(Click <a href="/uploads/images/figures/2015/01/Zaki-Humphrey-24-large.jpg" target="_top">here</a> to view a larger version of Figure 24.)</p><p>From a set of running clean driver files: </p><p>Total drivers successfully loaded: 1,053 </p><p>Total tasks with kernel data retrieved: 5,40 </p><div class="informaltable"><table border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th align="center">Signature</th><th align="center">Number of hits</th><th align="center">Percentage</th></tr></thead><tbody><tr><td>generic_new_driver</td><td>539</td><td>99.8</td></tr><tr><td>generic_modified_driver</td><td>98</td><td>18.15</td></tr><tr><td>generic_deleted_driver</td><td>0</td><td>0</td></tr><tr><td>generic_new_module</td><td>539</td><td>99.8</td></tr><tr><td>generic_deleted_module</td><td>0</td><td>0</td></tr><tr><td>generic_modified_module</td><td>0</td><td>0</td></tr><tr><td>generic_ssdt_hook</td><td>15</td><td>2.77</td></tr><tr><td>generic_idt_hook</td><td>1</td><td>0.18</td></tr><tr><td>generic_new_callback</td><td>45</td><td>8.33</td></tr><tr><td>generic_modified_callback</td><td>0</td><td>0</td></tr><tr><td>generic_attached_device</td><td>74</td><td>13.70</td></tr><tr><td>generic_new_device_links</td><td>472</td><td>87.40</td></tr><tr><td>generic_modified_mbr</td><td>0</td><td>0</td></tr><tr><td>generic_modified_vbr</td><td>0</td><td>0</td></tr><tr><td>generic_modified_eod_size</td><td>0</td><td>0</td></tr></tbody></table></div><div class="mediaobject"><img src="/uploads/images/figures/2015/01/Zaki-Humphrey-2.jpg" /></div><p>These results show that the number of hits on newly created drivers corresponds to the hits on the new module. This makes sense, since a successfully loaded driver would also have added a module. An interesting finding was that on the <span class="emphasis"><em>Windows 7</em></span> machine, the percentage of samples that installed SSDT hooks was higher. Delving into those clean samples showed that they were either security software drivers that installed hooks in the SSDT or ones used for general system administration. For example, in <a href="#figure.25">Figure 25</a> we can see the SSDT hooks installed by regmon.sys from<span class="emphasis"><em> Microworld Technologies Inc.</em></span></p><div class="figure"><a id="figure.25"></a><div class="mediaobject"><img alt="SSDT hooks installed by regmon.sys from Microworld Technologies Inc." src="/uploads/images/figures/2015/01/Zaki-Humphrey-25.jpg" /></div><p class="title"><b>Figure&nbsp;25.&nbsp;SSDT hooks installed by regmon.sys from Microworld Technologies Inc.</b></p></div><p>(Click <a href="/uploads/images/figures/2015/01/Zaki-Humphrey-25-large.jpg" target="_top">here</a> to view a larger version of Figure 25.)</p><p>Another interesting sample was a clean driver that installed an IDT hook. Checking the results for that job shows that the driver also hooks NtOpenKey and NtCreateKey. Furthermore, it modifies the disk driver object by hooking an IRP, namely IRP_MJ_POWER. While it looks suspicious, this is actually a driver from <span class="emphasis"><em>Aladdin Knowledge Systems</em></span> called &lsquo;aksfridge.sys&rsquo; of ancillary function driver type. We are still investigating the function of this driver. </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a class="chapter" id="id4168540"></a>PE results</h4></div></div></div><p>We collected a set of malicious PE files (detected by a static detection) and ran them for analysis to see whether our system can identify rootkit behaviour from executables. </p><p>First, we observed that the percentage of jobs that produced kernel memory data was much higher than any of the driver replication sets. This is positive news for us, since PE files constitute a large proportion of malicious files. </p><div class="mediaobject"><img src="/uploads/images/figures/2015/01/Zaki-Humphrey-3.jpg" /></div><p>Number of malicious PEs: 319 </p><p>Number of malicious PEs with kernel memory log: 303 </p><div class="informaltable"><table border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th align="center">Signature </th><th align="center">Number of hits</th><th align="center">Percentage</th></tr></thead><tbody><tr><td>generic_new_driver</td><td>12</td><td>3.9</td></tr><tr><td>generic_modified_driver</td><td>14</td><td>4.6</td></tr><tr><td>generic_deleted_driver</td><td>0</td><td>0</td></tr><tr><td>generic_new_module</td><td>12</td><td>3.9</td></tr><tr><td>generic_deleted_module</td><td>0</td><td>0</td></tr><tr><td>generic_modified_module</td><td>0</td><td>0</td></tr><tr><td>generic_ssdt_hook</td><td>7</td><td>2.3</td></tr><tr><td>generic_idt_hook</td><td>1</td><td>0.3</td></tr><tr><td>generic_new_callback</td><td>0</td><td>0</td></tr><tr><td>generic_modified_callback</td><td>0</td><td>0</td></tr><tr><td>generic_attached_device</td><td>2</td><td>0.7</td></tr><tr><td>generic_modified_mbr</td><td>0</td><td>0</td></tr><tr><td>generic_modified_vbr</td><td>0</td><td>0</td></tr><tr><td>generic_modified_eod_size</td><td>0</td><td>0</td></tr></tbody></table></div><div class="mediaobject"><img src="/uploads/images/figures/2015/01/Zaki-Humphrey-4.jpg" /></div><p>It is clear that the number of malicious PEs that induced rootkit like behaviour was not large. We can still infer useful information by delving into the samples that triggered some of those signatures. </p><p>We can see an example of a sample that created two new driver objects in addition to installing an SSDT hook (<a href="#figure.26">Figure 26</a> and <a href="#figure.27">Figure 27</a>). This sample is detected as Troj/NtRootK-DJ. The sample drops two driver files in %SYSTEM32%\drivers\. We could see the two objects for the two drivers created in addition to the SSDT hook installed below in the kernel memory differencing. By comparing the VAs, we see that the SSDT hook lies in the second driver. </p><div class="figure"><a id="figure.26"></a><div class="mediaobject"><img alt="Two driver files are dropped in %SYSTEM32%\drivers\." src="/uploads/images/figures/2015/01/Zaki-Humphrey-26.jpg" /></div><p class="title"><b>Figure&nbsp;26.&nbsp;Two driver files are dropped in %SYSTEM32%\drivers\.</b></p></div><p>(Click <a href="/uploads/images/figures/2015/01/Zaki-Humphrey-26-large.jpg" target="_top">here</a> to view a larger version of Figure 26.)</p><div class="figure"><a id="figure.27"></a><div class="mediaobject"><img alt="The SSDT hook lies in the second driver." src="/uploads/images/figures/2015/01/Zaki-Humphrey-27.jpg" /></div><p class="title"><b>Figure&nbsp;27.&nbsp;The SSDT hook lies in the second driver.</b></p></div><p>(Click <a href="/uploads/images/figures/2015/01/Zaki-Humphrey-27-large.jpg" target="_top">here</a> to view a larger version of Figure 27.)</p><p><a href="#figure.28">Figure 28</a> is a screen capture of the kernel memory differencing produced by a sample of Mal/DownLdr-BZ. The sample drops a malicious driver file in several locations. The dropped driver file is detected as Mal/Rootkit-X. We can see that in the kernel memory differencing there is a newly attached device object to the PnP Manager driver. This device object is of type FILE_DEVICE_CONTROLLER. This could indicate that the sample is trying to hide the existence of malicious files. The type of the device in addition to the location to which it is attached is sufficiently interesting to warrant further investigation.</p><div class="figure"><a id="figure.28"></a><div class="mediaobject"><img alt="Kernel memory differencing produced by a sample of Mal/DownLdr-BZ." src="/uploads/images/figures/2015/01/Zaki-Humphrey-28.jpg" /></div><p class="title"><b>Figure&nbsp;28.&nbsp;Kernel memory differencing produced by a sample of Mal/DownLdr-BZ.</b></p></div><p>(Click <a href="/uploads/images/figures/2015/01/Zaki-Humphrey-28-large.jpg" target="_top">here</a> to view a larger version of Figure 28.)</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a class="chapter" id="id2511679"></a>Ranking severity</h4></div></div></div><p>Combining the data for all the malicious files versus all the clean files, we get a clearer picture of the high-contributing signatures. It is important to note that our set of malicious files is larger than the set of the clean files. </p><p>Total number of malicious files with kernel data: 1,828 </p><p>Total number of clean files with kernel data: 540 </p><div class="informaltable"><table border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th align="center">Signature</th><th align="center">Malicious</th><th align="center">Clean</th><th align="center">Total hits</th></tr></thead><tbody><tr><td>generic_new_driver</td><td>1536</td><td>539</td><td>2075</td></tr><tr><td>generic_modified_driver</td><td>1185</td><td>98</td><td>1283</td></tr><tr><td>generic_deleted_driver</td><td>0</td><td>0</td><td>0</td></tr><tr><td>generic_new_module</td><td>1535</td><td>539</td><td>2074</td></tr><tr><td>generic_deleted_module</td><td>0</td><td>0</td><td>0</td></tr><tr><td>generic_modified_module</td><td>0</td><td>0</td><td>0</td></tr><tr><td>generic_ssdt_hook</td><td>37</td><td>15</td><td>52</td></tr><tr><td>generic_idt_hook</td><td>1</td><td>1</td><td>2</td></tr><tr><td>generic_new_callback</td><td>1332</td><td>45</td><td>1377</td></tr><tr><td>generic_modified_callback</td><td>0</td><td>0</td><td>0</td></tr><tr><td>generic_attached_device</td><td>1151</td><td>74</td><td>1225</td></tr><tr><td>generic_modified_mbr</td><td>0</td><td>0</td><td>0</td></tr><tr><td>generic_modified_vbr</td><td>0</td><td>0</td><td>0</td></tr><tr><td>generic_modified_eod_size</td><td>0</td><td>0</td><td>0</td></tr></tbody></table></div><div class="mediaobject"><img src="/uploads/images/figures/2015/01/Zaki-Humphrey-5.jpg" /></div><p>Combining the results above with our experience in analysing rootkits, we assigned maliciousness indexes to each signature following the <span class="emphasis"><em>Cuckoo</em></span> signatures severity style. In <span class="emphasis"><em>Cuckoo</em></span>, a signature&rsquo;s severity field indicates its maliciousness. For example, a signature that triggers to highlight an action that is usually performed by clean software will have the lowest severity value of &lsquo;1&rsquo;. An action frequently performed by clean software will trigger a signature of a higher severity value, &lsquo;2&rsquo;. Actions that are largely only exhibited by malicious software will trigger a signature that has the highest severity value of &lsquo;3.&rsquo; </p><p>Our previous assumption that modifying the IDT or the SSDT should mainly be performed by malicious drivers proved to be incorrect. It transpires that the registration of a new callback is more suspicious than, for example, an SSDT hook. We showed earlier how a clean driver installed an IDT hook in addition to hooking the IRP table of the disk driver. An expected finding for us was the low severity of generic_new_driver and generic_new_module, since this is behaviour that can be induced by both clean and malicious files. Generic_ssdt_hook was also relatively low, but we attribute that to the high number of clean software security drivers in our clean set. Most of these will add SSDT hooks for monitoring purposes. We decided to make the severity of this signature medium. Generic_modified_driver, generic_new_callback and generic_attached_device provided most results from this experiment. We can assign a medium severity to those, since they are more likely to be performed by malicious files. For the rest of the samples where we did not get any hits, we assigned a severity based on past experience and our understanding of how malicious rootkits operate. </p><p>It became obvious from the results that no single signature from those that fired is a clear indication of maliciousness. Some were weighted when it came to malicious behaviour, but none were sufficiently high on their own. Some signatures failed to trigger so we had to resort to our experienced opinion to assign a severity level. <a href="#table.4">Table 4</a> is a breakdown of the severity levels we assigned to indicate maliciousness. </p><div class="table"><a id="table.4"></a><table border="1" summary="Breakdown of the severity levels we assigned to indicate
          maliciousness. "><colgroup><col /><col /></colgroup><thead><tr><th align="center">Signature name</th><th align="center">Severity</th></tr></thead><tbody><tr><td>generic_new_driver</td><td>1</td></tr><tr><td>generic_modified_driver</td><td>2</td></tr><tr><td>generic_deleted_driver</td><td>1</td></tr><tr><td>generic_new_module</td><td>1</td></tr><tr><td>generic_deleted_module</td><td>1</td></tr><tr><td>generic_modified_module</td><td>2</td></tr><tr><td>generic_ssdt_hook</td><td>2</td></tr><tr><td>generic_idt_hook</td><td>2</td></tr><tr><td>generic_new_callback</td><td>2</td></tr><tr><td>generic_modified_callback</td><td>3</td></tr><tr><td>generic_attached_device</td><td>2</td></tr><tr><td>generic_modified_mbr</td><td>3</td></tr><tr><td>generic_modified_vbr</td><td>3</td></tr><tr><td>generic_modified_eod_size</td><td>3</td></tr></tbody></table><p class="title"><b>Table&nbsp;4.&nbsp;Breakdown of the severity levels we assigned to indicate maliciousness. </b></p></div></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a class="chapter" id="id2988290"></a>4. CONCLUSION</h2></div></div></div><p>We have presented an automated analysis system that performs kernel memory differencing, focusing on identifying rootkit-like behaviour. After testing this system against some prevalent rootkits and a set of clean and malicious drivers we can draw several conclusions. </p><p>Primarily, we proved that the system successfully revealed rootkit manipulations in the cases of the prevalent rootkits tested. Although the system did not capture all the changes documented by other researchers, we believe that in a high throughput cluster environment, the amount of information provided will suffice to indicate maliciousness. Analysts using the system can then perform extensive research on the sample. Since the signatures can also match on specific data, this system will provide the opportunity to cluster samples based on induced kernel changes. For example, the system allows clustering of samples that add devices to \Filesystem\FltMgr or hook IRPs of the disk miniport driver. The signatures can even validate IRPs outside drivers by checking the size and address of ntoskrnl. Correlating changes in the kernel and validating them can be done on static snapshot data, which ensures authenticity, unlike trying to query volatile information on a live system. </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a class="chapter" id="id2676424"></a>4.1 Future work</h3></div></div></div><p>Although we are getting good results, work remains to be done before the system is complete. First and foremost, the system must reliably be able to replicate every file that it receives. </p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a class="chapter" id="id2876899"></a>Exploring other areas of the kernel</h4></div></div></div><p>It is still worth exploring the possibility of examining other areas of kernel memory. For instance, checking the functions exported by ntoskrnl for hooks (TDSS hooks IofCallDriver, which is a function exported by the kernel). As part of our future work we intend to improve the identification of modifications to modules. We currently only present the image base, size and name of a module. Additionally, research will be done into comparing individual kernel objects, to see if any useful information can be obtained as long as the analysis processing time is not increased too much.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a class="chapter" id="id4382369"></a>Adding features</h4></div></div></div><p>An obvious enhancement to the system would be the ability to handle 64-bit files. At the moment the system does not have this functionality, but with common rootkits [<span class="citation"><a href="#citation.2">2</a></span>] now infecting x64 systems, this would be a worthwhile improvement. </p><p>Straying from the kernel, investigation will be conducted into the ability to detect user-mode rootkits building on the system we have already. Families like Beta Bot [<span class="citation"><a href="#citation.17">17</a></span>] utilize user-mode API hooking and other rootkit techniques in order to remain on system. This would be useful information to get from an automated analysis. </p><p>Finally, the reporting needs improvement in order to show where the same device is being attached to several driver objects. With more data being produced through the kernel memory scan like objects, ntoskrnl exports, we also intend to give more focus to devices. </p><p>Overall, we believe that such an automated system will provide greater visibility into the state and prevalence of rootkits in the wild. It will enhance the tracking of families and the identification of rootkit behaviour whether by clean or malicious files. It functions as a system that could flag malicious behaviour and also as an enabler to flag samples that could prove to be worthy of further investigation. </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a class="chapter" id="id3360382"></a>Improvements to sample clustering</h4></div></div></div><p>Sample clustering is not just a problem for rootkits, but for all malware, with numerous papers being penned on the subject. Identifying common behaviours and traits in large sample sets is a problem every anti-virus vendor faces. The system presented in this paper is not intended to solve sample clustering problems. However, we believe that it can serve as a platform for identifying behaviour exhibited by samples in ways that other systems cannot. For example, many rootkits will typically install a service and load a driver. This information alone cannot be relied on for clustering purposes. Our system exposes information per service and/or driver loaded, such as device names and types, that can be used to cluster samples. While the usual static and dynamic analysis methods provide a lot of data that can be used to cluster samples, the ability to access, dump, and diff areas of kernel memory gives a whole new dimension to the dataset. </p><p>Using the data exported by our system (as described in Section 2.1), it is possible to write signatures (as described in Section 2.4) which can be used to identify common traits. Clustering samples that, for example, commonly hook the same APIs, or insert devices into the device stack of the same drivers is a good way to group rootkits into the respective families. </p><p>As the next stage of this project we would like to expose the signature output to be utilized by our existing sample clustering system to increase the accuracy of clustering rootkit samples. </p><div class="bibliography"><div class="titlepage"><div><div><h5 class="title"><a class="chapter" id="id4667421"></a>Bibliography</h5></div></div></div><div class="bibliomixed"><a id="citation.1"></a><p class="bibliomixed">[1] Rootkit. Dictionary.com. <span class="bibliosource"><a href="http://dictionary.reference.com/browse/rootkit" target="_blank">http://dictionary.reference.com/browse/rootkit</a></span>.</p></div><div class="bibliomixed"><a id="citation.2"></a><p class="bibliomixed">[2] Ferrie, P. The curse of Necurs &ndash; Part 1. Virus Bulletin, April 2014, p.4. <span class="bibliosource"><a href="/uploads/pdf/magazine/2014/201404.pdf" target="_blank">http://www.virusbtn.com/pdf/magazine/2014/201404.pdf</a></span>.</p></div><div class="bibliomixed"><a id="citation.3"></a><p class="bibliomixed">[3] DrWeb. BackDoor.Tdss.565 and its modifications (aka TDL3). <span class="bibliosource"><a href="http://www.drweb.com/static/BackDoor.Tdss.565_(aka TDL3)_en.pdf" target="_blank">http://www.drweb.com/static/BackDoor.Tdss.565_%28aka%20TDL3%29_en.pdf</a></span>.</p></div><div class="bibliomixed"><a id="citation.4"></a><p class="bibliomixed">[4] BAE Systems. Snake campaign and cyber espionage toolkit. 2014. <span class="bibliosource"><a href="http://info.baesystemsdetica.com/rs/baesystems/images/snake_whitepaper.pdf" target="_blank">http://info.baesystemsdetica.com/rs/baesystems/images/snake_whitepaper.pdf</a></span>.</p></div><div class="bibliomixed"><a id="citation.5"></a><p class="bibliomixed">[5] Gmer.net. <span class="bibliosource"><a href="http://www.gmer.net/" target="_blank">http://www.gmer.net/</a></span>.</p></div><div class="bibliomixed"><a id="citation.6"></a><p class="bibliomixed">[6] Cuckoo Sandbox. <span class="bibliosource"><a href="http://docs.cuckoosandbox.org/en/latest/" target="_blank">http://docs.cuckoosandbox.org/en/latest/</a></span>.</p></div><div class="bibliomixed"><a id="citation.7"></a><p class="bibliomixed">[7] Russinovich, M. E.; Solomon, D. A.; Ionescu, A. Windows Internals, Fifth Edition. 2009.</p></div><div class="bibliomixed"><a id="citation.8"></a><p class="bibliomixed">[8] Intel 64 and IA-32 Architectures Software Developer Manuals. <span class="bibliosource"><a href="https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-manual-325462.pdf" target="_blank">http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-manual-325462.pdf</a></span>.</p></div><div class="bibliomixed"><a id="citation.9"></a><p class="bibliomixed">[9] OSDev.org. Partition Table. <span class="bibliosource"><a href="http://wiki.osdev.org/Partition_Table" target="_blank">http://wiki.osdev.org/Partition_Table</a></span>.</p></div><div class="bibliomixed"><a id="citation.10"></a><p class="bibliomixed">[10] Rodionov, E.; Matrosov, A. The Evolution of TDL: Conquering x64. <span class="bibliosource"><a href="https://www.eset.com/us/resources/white-papers/The_Evolution_of_TDL.pdf" target="_blank">http://www.eset.com/us/resources/white-papers/The_Evolution_of_TDL.pdf</a></span>.</p></div><div class="bibliomixed"><a id="citation.11"></a><p class="bibliomixed">[11] Johnson, J. Alureon: The First ITW 64-Bit Windows Rootkit. Virus Bulletin. 2010. <span class="bibliosource"><a href="/uploads/pdf/conference_slides/2010/Johnson-VB2010.pdf" target="_blank">https://www.virusbtn.com/pdf/conference_slides/2010/Johnson-VB2010.pdf</a></span>.</p></div><div class="bibliomixed"><a id="citation.12"></a><p class="bibliomixed">[12] Rodionov, E.; Matrosov, A. Mind the Gapz. <span class="bibliosource"><a href="http://www.welivesecurity.com/wp-content/uploads/2013/04/gapz-bootkit-whitepaper.pdf" target="_blank">http://www.welivesecurity.com/wp-content/uploads/2013/04/gapz-bootkit-whitepaper.pdf</a></span>. </p></div><div class="bibliomixed"><a id="citation.13"></a><p class="bibliomixed">[13] G Data SecurityLabs. Uroburos Highly complex espionage software with Russian roots. 2014. <span class="bibliosource"><a href="https://public.gdatasoftware.com/Web/Content/INT/Blog/2014/02_2014/documents/GData_Uroburos_RedPaper_EN_v1.pdf" target="_blank">https://public.gdatasoftware.com/Web/Content/INT/Blog/2014/02_2014/documents/GData_Uroburos_RedPaper_EN_v1.pdf</a></span>. </p></div><div class="bibliomixed"><a id="citation.14"></a><p class="bibliomixed">[14] New York Times. Suspicion Falls on Russia as &lsquo;Snake&rsquo; Cyberattacks Target Ukraine&rsquo;s Government. 2014. <span class="bibliosource"><a href="https://www.nytimes.com/2014/03/09/world/europe/suspicion-falls-on-russia-as-snake-cyberattacks-target-ukraines-government.html" target="_blank">http://www.nytimes.com/2014/03/09/world/europe/suspicion-falls-on-russia-as-snake-cyberattacks-target-ukraines-government.html</a></span>.</p></div><div class="bibliomixed"><a id="citation.15"></a><p class="bibliomixed">[15] malware-lu. Necurs Quick Analysis. 2012. <span class="bibliosource"><a href="https://code.google.com/p/malware-lu/wiki/en_necurs_analysis" target="_blank">https://code.google.com/p/malware-lu/wiki/en_necurs_analysis</a></span>.</p></div><div class="bibliomixed"><a id="citation.16"></a><p class="bibliomixed">[16] Wyke, J. Notorious &ldquo;Gameover&rdquo; malware gets itself a kernel-mode rootkit... NakedSecurity. February 2014. <span class="bibliosource"><a href="https://nakedsecurity.sophos.com/2014/02/27/notorious-gameover-malware-gets-itself-a-kernel-mode-rootkit/" target="_blank">http://nakedsecurity.sophos.com/2014/02/27/notorious-gameover-malware-gets-itself-a-kernel-mode-rootkit/</a></span>.</p></div><div class="bibliomixed"><a id="citation.17"></a><p class="bibliomixed">[17] MacDermid, K. Beta Bot &ndash; A Code Review. Arbour Networks. June 2013. <span class="bibliosource"><a href="http://www.arbornetworks.com/asert/2013/11/beta-bot-a-code-review/" target="_blank">http://www.arbornetworks.com/asert/2013/11/beta-bot-a-code-review/</a></span>.</p></div><div class="bibliomixed"><a id="citation.18"></a><p class="bibliomixed">[18] Monthly Malware Statistics, May 2011. Securelist. 2011. <span class="bibliosource"><a href="https://www.securelist.com/en/analysis/204792214/Monthly_Malware_Statistics_May_2011" target="_blank">http://www.securelist.com/en/analysis/204792214/Monthly_Malware_Statistics_May_2011</a></span>.</p></div><div class="bibliomixed"><a id="citation.19"></a><p class="bibliomixed">[19] Zaki, A. Guntior bootkit up to new tricks. Naked Security. June 2013. <span class="bibliosource"><a href="https://nakedsecurity.sophos.com/2013/06/12/guntior-bootkit-up-to-new-tricks/" target="_blank">http://nakedsecurity.sophos.com/2013/06/12/guntior-bootkit-up-to-new-tricks/</a></span>.</p></div></div></div></div></div> </div>
<div class="col-md-3 col-sm-3 col-lg-3">
<p><a href="/uploads/pdf/conference/vb2014/VB2014-ZakiHumphrey.pdf" target="_blank"><img class="ccm-image-block responsive" alt="" src="/uploads/images/buttons/pdf-download-button.jpg" onmouseover="this.src = '/uploads/images/buttons/pdf-download-button-hover.jpg'" onmouseout="this.src = '/uploads/images/buttons/pdf-download-button.jpg'" border="0" height="45" width="262"></a></p>
<div id="NDPHPBlock13359" class="NDPHPBlock">
<div style="width: 100%;"><div style='float: left; width: 20%; margin-left: auto; margin-right: auto; text-align: center;'><center><a target='_blank' title='Tweet this!' href="https://twitter.com/share?text=VB2014 paper: Unveiling the kernel: rootkit discovery using selective automated kernel memory differencing&url=https://www.virusbulletin.com/virusbulletin/2015/01/paper-unveiling-kernel-rootkit-discovery-using-selective-automated-kernel-memory-differencing"><img src='/uploads/images/buttons/twitter.png' alt='twitter.png' width='45' height='45' class='responsive' /></a></center></div><div style='float: left; width: 20%; margin-left: auto; margin-right: auto; text-align: center;'><center><a target='_blank' title='Share on Facebook' href='https://www.facebook.com/sharer.php?u=https://www.virusbulletin.com/virusbulletin/2015/01/paper-unveiling-kernel-rootkit-discovery-using-selective-automated-kernel-memory-differencing'><img src='/uploads/images/buttons/fb.png' alt='fb.png' width='45' height='45' class='responsive' /></a></center></div><div style='float: left; width: 20%; margin-left: auto; margin-right: auto; text-align: center;'><center><a target='_blank' title='Share on LinkedIn' href="https://www.linkedin.com/shareArticle?mini=true&url=https://www.virusbulletin.com/virusbulletin/2015/01/paper-unveiling-kernel-rootkit-discovery-using-selective-automated-kernel-memory-differencing&title=VB2014 paper: Unveiling the kernel: rootkit discovery using selective automated kernel memory differencing"><img src='/uploads/images/buttons/linkedin.png' alt='linkedin.png' width='45' height='45' class='responsive' /></a></center></div><div style='float: left; width: 20%; margin-left: auto; margin-right: auto; text-align: center;'><center><a target='_blank' title='Share on Hacker News' href="https://news.ycombinator.com/submitlink?u=https://www.virusbulletin.com/virusbulletin/2015/01/paper-unveiling-kernel-rootkit-discovery-using-selective-automated-kernel-memory-differencing&t=VB2014 paper: Unveiling the kernel: rootkit discovery using selective automated kernel memory differencing"><img src='/uploads/images/buttons/hackernews.png' alt='hackernews.png' width='45' height='45' class='responsive' /></a></center></div><div style='float: left; width: 20%; margin-left: auto; margin-right: auto; text-align: center;'><center><a target='_blank' title='reddit this!' href="https://www.reddit.com/submit?url=https://www.virusbulletin.com/virusbulletin/2015/01/paper-unveiling-kernel-rootkit-discovery-using-selective-automated-kernel-memory-differencing"><img src='/uploads/images/buttons/reddit.png' alt='reddit.png' width='45' height='45' class='responsive' /></a></center></div></div></div><p></p>
<h2>Latest articles:</h2>
<div class="ccm-page-list">
<h3 class="ccm-page-list-title">
<a href="/virusbulletin/2022/04/cryptojacking-fly-teamtnt-using-nvidia-drivers-mine-cryptocurrency/" target="_self">Cryptojacking on the fly: TeamTNT using NVIDIA drivers to mine cryptocurrency</a>
</h3>
<div class="ccm-page-list-description">
TeamTNT is known for attacking insecure and vulnerable Kubernetes deployments in order to infiltrate organizations&rsquo; dedicated environments and transform them into attack launchpads. In this article Aditya Sood presents a new module introduced by&hellip; </div>
<h3 class="ccm-page-list-title">
<a href="/virusbulletin/2021/12/collector-stealer-russian-origin-credential-and-information-extractor/" target="_self">Collector-stealer: a Russian origin credential and information extractor</a>
</h3>
<div class="ccm-page-list-description">
Collector-stealer, a piece of malware of Russian origin, is heavily used on the Internet to exfiltrate sensitive data from end-user systems and store it in its C&amp;C panels. In this article, researchers Aditya K Sood and Rohit Chaturvedi present a 360&hellip; </div>
<h3 class="ccm-page-list-title">
<a href="/virusbulletin/2021/06/fighting-fire-fire/" target="_self">Fighting Fire with Fire</a>
</h3>
<div class="ccm-page-list-description">
In 1989, Joe Wells encountered his first virus: Jerusalem. He disassembled the virus, and from that moment onward, was intrigued by the properties of these small pieces of self-replicating code. Joe Wells was an expert on computer viruses, was partly&hellip; </div>
<h3 class="ccm-page-list-title">
<a href="/virusbulletin/2021/04/run-your-malicious-vba-macros-anywhere/" target="_self">Run your malicious VBA macros anywhere!</a>
</h3>
<div class="ccm-page-list-description">
Kurt Natvig wanted to understand whether it&rsquo;s possible to recompile VBA macros to another language, which could then easily be &lsquo;run&rsquo; on any gateway, thus revealing a sample&rsquo;s true nature in a safe manner. In this article he explains how he recompiled&hellip; </div>
<h3 class="ccm-page-list-title">
<a href="/virusbulletin/2021/04/dissecting-design-and-vulnerabilities-azorultccpanels/" target="_self">Dissecting the design and vulnerabilities in AZORult&nbsp;C&amp;C&nbsp;panels</a>
</h3>
<div class="ccm-page-list-description">
Aditya K Sood looks at the command-and-control (C&amp;C) design of the AZORult malware, discussing his team's findings related to the C&amp;C design and some security issues they identified during the research. </div>
</div>
<p><br /><a class="btn btn-block btn-warning" href="/virusbulletin/archive">Bulletin Archive</a></p> </div>
</div>
</div>

<footer class="bs-footer" role="contentinfo">
<div class="container">
<div class="bs-social">
<div class="row ">
<div class="col-md-3">
<p><a title="About Us" href="/about-vb/about-us/">About us</a></p>
<p><a title="Contact Us" href="/about-vb/contact-us/">Contact us</a></p>
<p><a title="Advisory Board" href="/about-vb/advisory-board/">Advisory board</a></p>
<p><a title="Press" href="/about-vb/press/">Press information</a></p>
<p><a title="Security Events Calendar" href="/resources/calendar/">Security events calendar</a></p>
<p><a title="Newsletter" href="/newsletter/">Virus Bulletin newsletter</a></p> </div>
<div class="col-md-3">
<p><a title="VB Testing" href="/testing/">Testing</a></p>
<p><a title="VB100" href="/testing/vb1001/">VB100</a></p>
<p><a title="VBSpam" href="/testing/vbspam/">VBSpam</a></p>
<p><a title="VBWeb" href="/testing/vbweb/">VBWeb</a></p>
<p><a title="Consultancy Services" href="/testing/consultancy-services/">Consultancy services</a></p>
<p><a title="The Spammers' Compendium" href="/resources/spammerscompendium/">Spammers' Compendium</a></p> </div>
<div class="col-md-3">
<p><a title="VB2021 localhost" href="/conference/vb2021/">VB2021 localhost</a></p>
<p><a title="VB2020 localhost" href="/conference/vb2020/">VB2020 localhost</a></p>
<p><a title="VB2019" href="/conference/vb2019/">VB2019 (London)</a></p>
<p><a title="VB2018" href="/conference/vb2018">VB2018 (Montreal)</a></p>
<p><a title="VB2017" href="/conference/vb2017">VB2017 (Madrid)</a></p>
<p><a title="Conference Archive" href="/conference/vb-conference-archive/">Older conferences</a></p> </div>
<div class="col-md-3">
<div class="row">
<table style="float: right;" border="0">
<tbody>
<tr>
<td align="center"><a href="/rss" target="_blank"><img title="Get our blog updates" src="/uploads/images/buttons/rss-square-gray.png" alt="rss.png" width="35" height="35" /></a></td>
<td></td>
<td align="center"><a href="https://twitter.com/virusbtn" target="_blank"><img class="bhtmbxoyxwpzahwcvxnw" title="Visit us on Twitter" src="/uploads/images/buttons/twitter-square-gray.png" alt="twitter.png" width="35" height="35" /></a></td>
<td></td>
<td align="center"><a href="https://www.linkedin.com/company/virus-bulletin" target="_blank"><img class="bhtmbxoyxwpzahwcvxnw" title="Visit us on LinkedIn" src="/uploads/images/buttons/linkedin-square-gray.png" alt="linkedin.png" width="35" height="35" /></a></td>
<td></td>
<td align="center"><a href="https://www.facebook.com/virusbulletin" target="_blank"><img title="Visit us on Facebook" src="/uploads/images/buttons/fb-square-gray.png" alt="twitter.png" width="35" height="35" /></a></td>
<td></td>
<td align="center"><a href="https://www.youtube.com/user/virusbtn" target="_blank"><img title="Visit us on Youtube" src="/uploads/images/buttons/youtube-square-gray.png" alt="youtube.png" width="35" height="35" /></a></td>
</tr>
</tbody>
</table>
</div> </div>
</div>
<div class="row ">
<div class="col-md-12">
</div>
</div>
</div>
</div>
</footer>

<footer class="bs-footer2" role="contentinfo">
<div class="container">
<div class="bs-social2">
<div class="row ">
<div class="col-md-3">
</div>
<div class="col-md-3">
</div>
<div class="col-md-3">
</div>
<div class="col-md-3">
</div>
</div>
<div class="row ">
<div class="col-md-12">
<p style="text-align: left;">1989-2022 Virus Bulletin.<a title="Privacy Policy" href="/about-vb/privacy-policy/">Privacy policy</a><a title="Cookies" href="/about-vb/privacy-policy/cookies/">Cookies</a><a title="Terms and Conditions" href="/about-vb/terms-and-conditions/">Terms and Conditions</a></p> </div>
</div>
</div>
</div>
</footer>

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-21876594-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-21876594-2', { 'anonymize_ip': true });
</script><script type="text/javascript" src="/libraries/js/fancybox.load.js"></script>
<script type="text/javascript" src="/packages/bootstrap/js/common/app.js"></script>
<div id="ccm-cookiesDisclosure" class="disclosure-bottom">
<div class="disclosure-container">
<div class="disclosure-content">
<p> We have placed cookies on your device in order to improve the functionality of this site, as outlined in our <a href="/about-vb/privacy-policy/cookies" target="_blank">cookies policy</a>. However, you may delete and block all cookies from this site and your use of the site will be unaffected. By continuing to browse this site, you are agreeing to Virus Bulletin's use of data as outlined in our <a href="/about-vb/privacy-policy/" target="_blank">privacy policy</a>.</p>
</div>
<div class="disclosure-form">
<form action="/index.php/cookies_disclosure/" method="POST">
<input type="hidden" name="allowCookies" value="1" />
<div class="button">
<input class="btn btn-info btn-sm" type="submit" name="submit" value="I understand. Don't show this message again!" />
</div>
</form>
</div>
<div class="ccm-spacer">&nbsp;</div>
</div>
</div>
</body>
</html>